/*! 
axisj - v1.1.0 - 2016-03-07 
*/
/*! 
axisj - v1.1.0 - 2016-03-07 
*/

if(!window.AXConfig){
/**
 * AXISJ UI 등에 기본값으로 사용되는 설정 변수
 * @namespace {Object} AXConfig
 * @example
 ```json
 AXConfig.weekDays = [{label:""},..];
 AXConfig.AXReq.contentType = "";
 // 처럼 기본값을 수정할 수 있습니다.
 // .net 에서 webMethod를 이용하여 개발할 때는 다음의 설정을 권장합니다.
 AXConfig.AXReq.okCode = "00";
 AXConfig.AXReq.contentType = "application/json; charset=utf-8";
 AXConfig.AXReq.dataSendMethod = "json";
 AXConfig.AXReq.resultFormatter = function () {
	return this.d.object();
 };
 ```
 */
	var AXConfig = {
/**
 * calendar weekDays label
 * @memberof AXConfig
 * @example
 ```json
 weekDays: [
	 { label: "일" },
	 { label: "월" },
	 { label: "화" },
	 { label: "수" },
	 { label: "목" },
	 { label: "금" },
	 { label: "토" }
 ]
 ```
 */
		weekDays: [
			{ label: "일" },
			{ label: "월" },
			{ label: "화" },
			{ label: "수" },
			{ label: "목" },
			{ label: "금" },
			{ label: "토" }
		],
/**
 * AXReq default config
 * @memberof AXConfig
 * @example
 ```json
 AXReq: {
	async: true, // AJAX 비동기 처리 여부
	okCode: "ok", // 통신 성공 코드
	responseType: "", // AJAX responseType
	dataType: "", // AJAX return Data type
	contentType: "application/x-www-form-urlencoded; charset=UTF-8", // AJAX contentType
	dataSendMethod: "parameter", // AJAX parameter send type
	crossDomain: false,
	resultFormatter: function () { // onsucc formatter
		return this;
	}
}
 ```
 */
		AXReq: {
			async: true, // AJAX 비동기 처리 여부
			okCode: "ok", // 통신 성공 코드
			responseType: "", // AJAX responseType
			dataType: "", // AJAX return Data type
			contentType: "application/x-www-form-urlencoded; charset=UTF-8", // AJAX contentType
			dataSendMethod: "parameter", // AJAX parameter send type
			crossDomain: false,
			resultFormatter: function () { // onsucc formatter
				return this;
			}
		},
/**
 * AXGrid default config
 * @memberof AXConfig
 * @example
 ```json
 AXGrid: {
	passiveMode: false,
	passiveRemoveHide: false,
	fitToWidthRightMargin: 10,
	fitToWidth: false,
	pageSize: 10,
	pageHeight: 400,
	keyResult: "result",
	keyList: "list",
	emptyListMSG: "empty of list",
	listCountMSG: "<b>{listCount}</b> count(s)",
	pageCountMSG: "page(s)"
}
 ```
 */
		AXGrid: {
			passiveMode: false,
			passiveRemoveHide: false,
			fitToWidthRightMargin: 11,
			fitToWidth: false,
			pageSize: 10,
			pageHeight: 400,
			headTdHeight: 30,
			keyResult: "result",
			keyList: "list",
			emptyListMSG: "empty of list",
			listCountMSG: "<b>{listCount}</b> count(s)",
			pageCountMSG: "page(s)"
		},
/**
 * AXTree default config
 * @memberof AXConfig
 * @example
 ```json
 AXTree: {
	fitToWidthRightMargin: 10,
	fitToWidth: false,
	pageSize: 10,
	pageHeight: 400,
	keyResult: "result",
	keyTree: "tree",
	keyList: "list",
	emptyListMSG: "목록이 없습니다.",
	persist: true,
    cookiePrefix: "axtree-",
    cookieExpiredays: 7
}
 ```
 */
		AXTree: {
			fitToWidthRightMargin: 10,
			fitToWidth: false,
			pageSize: 10,
			pageHeight: 400,
			keyResult: "result",
			keyTree: "tree",
			keyList: "list",
			emptyListMSG: "목록이 없습니다.",
			persistExpanded: false,
			persistSelected: false,
			cookiePrefix: "axtree-",
			cookieExpiredays: 7
		},
/**
 * AXProgress default config
 * @memberof AXConfig
 * @example
 ```json
 AXProgress: {
	cancelMsg: "프로세스를 취소 하시겠습니까?"
}
 ```
 */
		AXProgress: {
			cancelMsg: "프로세스를 취소 하시겠습니까?"
		},
/**
 * AXUpload5 default config
 * @memberof AXConfig
 * @example
 ```json
 AXUpload5: {
	buttonTxt: "Upload files",
	deleteConfirm: "정말 삭제하시겠습니까?",
	uploadSelectTxt: "업로드 하실 파일을 선택해주세요.",
	dropZoneTxt: "업로드할 파일을 여기에 놓습니다."
}
 ```
 */
		AXUpload5: {
			buttonTxt: "Upload files",
			deleteConfirm: "정말 삭제하시겠습니까?",
			uploadSelectTxt: "업로드 하실 파일을 선택해주세요.",
			dropZoneTxt: "업로드할 파일을 여기에 놓습니다."
		},
/**
 * AXModal default config
 * @memberof AXConfig
 * @example
 ```json
 AXModal: {
	contentDivClass: "bodyHeightDiv"
}
 ```
 */
		AXModal: {
			contentDivClass: "bodyHeightDiv",
			pars: ""
		},
/**
 * AXInput default config
 * @memberof AXConfig
 * @example
 * ```json
 * AXInput: {
 * 	errorPrintType: "toast",
 * 	selectorOptionEmpty: "목록이 없습니다.",
 * 	yearText:"{year}년",
 * 	monthText:"{month}월",
 * 	confirmText:"확인",
 * 	keyOptions:"options",
 * 	keyOptionValue:"optionValue",
 * 	keyOptionText:"optionText"
 * }
 * ```
 */
		AXInput: {
			errorPrintType: "toast",
			selectorOptionEmpty: "목록이 없습니다.",
			yearText:"{year}년",
			monthText:"{month}월",
			confirmText:"확인",
			keyOptions:"options",
			keyOptionValue:"optionValue",
			keyOptionText:"optionText"
		},
/**
 * AXSelect default config
 * @memberof AXConfig
 * @example
 * ```json
 * AXSelect: {
 *  keyOptions:"options",
 *  keyOptionValue:"optionValue",
 *  keyOptionText:"optionText"
 * }
 * ```
 */
		AXSelect: {
			keyOptions:"options",
			keyOptionValue:"optionValue",
			keyOptionText:"optionText"
		},
/**
 * AXContextMenu default config
 * @memberof AXConfig
 * @example
 ```json
 AXContextMenu: {
	title:"선택하세요"
}
 ```
 */
		AXContextMenu: {
			title:"선택하세요"
		},
/**
 * mobile default config : 모바일 UI 반응너비
 * @memberof AXConfig
 * @example
 ```json
 mobile: {
	responsiveWidth: 0
}
 ```
 */
		mobile: {
			responsiveWidth: 0
		},
/**
 * AXEditor default config
 * @memberof AXConfig
 * @example
 ```json
 AXEditor: {
	editor_frameSrc : "/_AXJ/lib/AXEditor.html",
	iconDirectory : "/ui/icons/"
}
 ```
 */
		AXEditor: {
			editor_frameSrc : "/_AXJ/lib/AXEditor.html",
			iconDirectory : "/ui/icons/"
		},
/**
 * AXTab default config
 * @memberof AXConfig
 * @example
 ```json
 AXTab: {
	closable : false
 }
 ```
 */
		AXTab: {
			closable : false
		},
	/**
	 * AXValidator default config
	 * @memberof AXConfig
	 * @example
	 * ```json
	 * AXValidator: {
	 *	validateErrMessage: {
	 *		required: "[{label}](은)는 필수입력 사항입니다.",
	 *		requiredstring: "반드시 {required}(으)로 입력하셔야 하는 사항입니다.",
	 *		match: "[{label}](은)는 입력된 내용이 일치하지 않습니다.",
	 *		invalid: "[{label}](은)는 입력된 내용이 올바르지 않습니다.",
	 *		min: "[{label}](은)는 {min} 이상의 값을 입력해주세요.",
	 *		max: "[{label}](은)는 {max} 이하의 값을 입력해주세요.",
	 *		minbyte: "[{label}]의 입력된 내용의 길이가 {minbyte}Byte 이상이어야 합니다.",
	 *		maxbyte: "[{label}]의 입력된 내용의 길이가 {maxbyte}Byte를 초과할 수 없습니다.",
	 *		minlength: "[{label}]의 입력된 내용의 length가 {minlength} 이상이어야 합니다.",
	 *		maxlength: "[{label}]의 입력된 내용의 length가 {maxlength}을 초과할 수 없습니다.",
	 *
	 *		number: "숫자로만 입력하셔야 합니다.",
	 *		email: "이메일 형식이 올바르지 않습니다.",
	 *		hangul: "한글로만 입력하셔야 합니다.",
	 *		engonly: "영문으로만 입력하셔야 합니다.",
	 *		residentno: "주민등록번호 형식이 올바르지 않습니다.",
	 *		foreignerno: "외국인등록번호 형식이 올바르지 않습니다.",
	 *		bizno: "사업자등록번호 형식이 올바르지 않습니다.",
	 *		phone: "전화번호 형식이 올바르지 않습니다.",
	 *		isdate: "날짜 형식이 올바르지 않습니다.",
	 *		zip: "우편번호 형식이 올바르지 않습니다.",
	 *		money: "화폐형식으로만 입력하셔야 합니다.",
	 *		earlierThan: "[{label}] 보다 빠른 날짜를 입력해야 합니다.",
	 *		laterThan: "[{label}] 보다 느린 날짜를 입력해야 합니다.",
	 *
	 *		exception: "not found errmessage"
	 *	}
	 *}
	 * ```
 	 */
		AXValidator: {
			validateErrMessage: {
				/* for element */
				required: "[{label}](은)는 필수입력 사항입니다.",
				requiredstring: "반드시 {required}(으)로 입력하셔야 하는 사항입니다.",
				match: "[{label}](은)는 입력된 내용이 일치하지 않습니다.",
				invalid: "[{label}](은)는 입력된 내용이 올바르지 않습니다.",
				min: "[{label}](은)는 {min} 이상의 값을 입력해주세요.",
				max: "[{label}](은)는 {max} 이하의 값을 입력해주세요.",
				minbyte: "[{label}]의 입력된 내용의 길이가 {minbyte}Byte 이상이어야 합니다.",
				maxbyte: "[{label}]의 입력된 내용의 길이가 {maxbyte}Byte를 초과할 수 없습니다.",
				minlength: "[{label}]의 입력된 내용의 length가 {minlength} 이상이어야 합니다.",
				maxlength: "[{label}]의 입력된 내용의 length가 {maxlength}을 초과할 수 없습니다.",

				/* for format */
				number: "숫자로만 입력하셔야 합니다.",
				email: "이메일 형식이 올바르지 않습니다.",
				hangul: "한글로만 입력하셔야 합니다.",
				engonly: "영문으로만 입력하셔야 합니다.",
				residentno: "주민등록번호 형식이 올바르지 않습니다.",
				foreignerno: "외국인등록번호 형식이 올바르지 않습니다.",
				bizno: "사업자등록번호 형식이 올바르지 않습니다.",
				phone: "전화번호 형식이 올바르지 않습니다.",
				isdate: "날짜 형식이 올바르지 않습니다.",
				zip: "우편번호 형식이 올바르지 않습니다.",
				money: "화폐형식으로만 입력하셔야 합니다.",
				earlierThan: "[{label}] 보다 빠른 날짜를 입력해야 합니다.",
				laterThan: "[{label}] 보다 느린 날짜를 입력해야 합니다.",

				exception: "not found errmessage"
			}
		}
	};
}
/* ---------------------------- */
var axf = AXUtil = {
    async: true,
    ajaxOkCode: "ok",
    ajaxResponseType: "",
    ajaxDataType: "",
    gridPassiveMode: false,
    gridPassiveRemoveHide: false,
    gridFitToWidthRightMargin: 10,

    uniqueSeq: 0,

    /**
     * 현재페이지에서 고유한 순번을 반환합니다.
     * @method axf.getUniqueId
     * @returns {Number} uniqueSeq
     * @example
     * ```js
     * trace( axf.getUniqueId() );
     * ```
     */
    getUniqueId: function () { return (axf.uniqueSeq += 1); },

    /**
     * document.getElementById(id) 와 같습니다. 아이디가 같은 엘리먼트를 반환합니다.
     * @method axf.getId
     * @param {String} id
     * @returns {HtmlElement}
     * @example
     * ```js
     * if(axf.getId("myele_id")){
	 *    $("#myele_id").css({...});
	 * }
     * ```
     */
    getId: function (id) { return document.getElementById(id); },

    /**
     * @method axf.each
     * @param {Array|Object} obj
     * @param {Function} callback
     * @description Array 또는 Object의 아이템만큰 callback 함수를 call합니다.
     * @example
     * ```js
     * var new_array = [];
     * axf.each([0, 1, 2], function(){
	 * 	new_array.push(this*2);
	 * });
     * var new_object = {};
     * axf.each({a:1, b:2, c:3}, function(k, v){
	 * 	new_object[k] = v*2;
	 * });
     * ```
     */
    each: function (obj, callback) {
        if (obj) {
            var name, i = 0, length = obj.length,
                isObj = length === undefined || Object.isFunction(obj);
            if (isObj) {
                for (name in obj) {
                    if (callback.call(obj[name], name, obj[name]) === false) {
                        break;
                    }
                }
            }
            else {
                for (; i < length;) {
                    if (callback.call(obj[i], i, obj[i++]) === false) {
                        break;
                    }
                }
            }
        }
    },
    /**
     * 브라우저의 이름과 버전 모바일여부
     *
     * @member {Object} axf.browser
     * @example
     * ```js
     *{
     *	name: {String} - bowserName (ie|chrome|webkit|oprea),
     *	version: {Number} - browserVersion,
     *	mobile: {Boolean}
     *}
     * ```
     */
    browser: (function () {
        var ua = navigator.userAgent.toLowerCase();
        var mobile = (ua.search(/mobile/g) != -1);
        if (ua.search(/iphone/g) != -1) {
            return {name: "iphone", version: 0, mobile: true}
        }
        else if (ua.search(/ipad/g) != -1) {
            return {name: "ipad", version: 0, mobile: true}
        }
        else if (ua.search(/android/g) != -1) {
            var match = /(android)[ \/]([\w.]+)/.exec(ua) || [];
            var browserVersion = (match[2] || "0");
            return {name: "android", version: browserVersion, mobile: mobile}
        }
        else {
            var match = /(msie) ([\w.]+)/.exec(ua) ||
                /(trident)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
                /(opera|opr)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
                /(chrome)[ \/]([\w.]+)/.exec(ua) ||
                /(webkit)[ \/]([\w.]+)/.exec(ua) ||
                ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
                [];

            var browser = (match[1] || "");
            var browserVersion = (match[2] || "0");

            var browserName = {
                "msie": "ie",
                "trident": "ie",
                "opr": "opera"
            };
            if (browser in browserName) browser = browserName[browser];

            return {
                name: browser,
                version: browserVersion,
                mobile: mobile
            }
        }
    })(),
    /**
     * 호환성보기 여부
     * @member {String} axf.docTD
     * @example
     * ```js
     * axf.docTD = (Q|S)
     * ```
     */
    docTD: (function () {
        if (!document.compatMode || document.compatMode == 'BackCompat') return "Q";
        else return "S";
    })(),
    /**
     * @method axf.timekey
     * @returns {String} timeKey
     * @description 밀리세컨드까지 조합한 문자열을 반환합니다.
     * @example
     * ```js
     * trace(axf.timeKey()); // A004222760
     * ```
     */
    timekey: function () {
        var d = new Date();
        return ("A" + d.getHours().setDigit(2) + d.getMinutes().setDigit(2) + d.getSeconds().setDigit(2) + d.getMilliseconds());
    },
    /**
     * @method axf.overwriteObject
     * @param {Object} tg - 덮어쓰기 대상 오브젝트
     * @param {Object} obj - 덮어쓰기 할 오브젝트
     * @param {Boolean} [rewirte=false] - 덮어쓰기 모드
     * @returns {Object} 덮어쓰기된 tg
     * @description 덮어쓰기 대상 오브젝트에 덮어쓰기 할 오브젝트를 덮어쓰기 합니다.
     * @example
     * ```js
     * axf.overwriteObject({a:1}, {b:1});
     * // {a:1, b:1}
     * axf.overwriteObject({a:1}, {a:2}, true);
     * // {a:2}
     * // rewirte : false 이면 {a:1} 로 유지 됩니다. 대상오브젝트에 키가 없는 경우에만 덮어쓰기 합니다.
     * ```
     */
    overwriteObject: function (tg, obj, rewrite) {
        if (rewrite == undefined) rewrite = true;
        //trace(tg[k]);
        if (obj) AXUtil.each(obj, function (k, v) {
            if (rewrite) {
                tg[k] = v;
            }
            else {
                //trace(tg[k]);
                if (tg[k] == undefined) tg[k] = v;
            }
        });
        return tg;
    },
    /**
     * @method axf.copyObject
     * @param {Object} obj - 복제할 오브젝트
     * @returns {Object} 복제된 오브젝트
     * @description 오브젝트를 복제하여 새로운 참조를 리턴합니다.
     * @example
     * ```js
     * axf.copyObject({a:1});
     * // 내부코드가 Object.toJSON(obj).object(); 이므로 상황에 맞게 사용해야 합니다.
     * ```
     */
    copyObject: function (obj) {
        //return Object.clone(obj);
        return Object.toJSON(obj).object();
    },
    consonantKR: function (cword) {
        var cons = [
            {c: "ㄱ", re: "[가-깋]"}, {c: "ㄲ", re: "[까-낗]"}, {c: "ㄴ", re: "[나-닣]"}, {c: "ㄷ", re: "[다-딯]"}, {c: "ㄸ", re: "[따-띻]"}, {c: "ㄹ", re: "[라-맇]"},
            {c: "ㅁ", re: "[마-밓]"}, {c: "ㅂ", re: "[바-빟]"}, {c: "ㅃ", re: "[빠-삫]"}, {c: "ㅅ", re: "[사-싷]"}, {c: "ㅆ", re: "[싸-앃]"}, {c: "ㅇ", re: "[아-잏]"}, {c: "ㅈ", re: "[자-짛]"},
            {c: "ㅉ", re: "[짜-찧]"}, {c: "ㅊ", re: "[차-칳]"}, {c: "ㅋ", re: "[카-킿]"}, {c: "ㅌ", re: "[타-팋]"}, {c: "ㅍ", re: "[파-핗]"}, {c: "ㅎ", re: "[하-힣]"},
            {c: "(", re: "\\("}, {c: ")", re: "\\)"}, {c: "[", re: "\\["}, {c: "]", re: "\\]"}
        ];
        var rword = "";
        var cwords = cword.split("");
        for (var i = 0, l = cwords.length; i < l; i++) {
            var fos = cons.searchObject(function () {
                return this.item.c == cwords[i];
            });
            var fo = fos.first();
            if (fo) rword += fo.re;
            else rword += cwords[i];
        }
        return rword;
    },
    /**
     * @method axf.setCookie
     * @param {String} name
     * @param {String} value
     * @param {Number} [expiredays]
     * @param {Object} options
     * @description 쿠키에 값을 지정합니다.
     * @example
     * ```js
     * axf.setCookie("myname", "tomas", 10, {
	 *     path  : "/",             // {String} [현재 페이지의 path]
	 *     domain: "www.axisj.com", // {String} [현재 사이트의 domain]
	 *     secure: true             // {Boolean} [false]
	 * });
     * ```
     */
    setCookie: function (name, value, expiredays, options) {
        var expireDate;
        if (typeof expiredays === "number") {
            expireDate = new Date();
            expireDate.setDate(expireDate.getDate() + expiredays);
        }

        options = options || {};

        return (document.cookie = [
            encodeURIComponent(name), '=', String(value),
            expireDate ? "; expires=" + expireDate.toUTCString() : "", // use expires attribute, max-age is not supported by IE
            options.path ? "; path=" + options.path : "",
            options.domain ? "; domain=" + options.domain : "",
            options.secure ? "; secure" : ""
        ].join(""));
    },
    /**
     * @method axf.getCookie
     * @param {String} name
     * @description 쿠키에서 값을 읽어들입니다
     * @example
     * ```js
     * trace( axf.getCookie("myname") );
     * // tomas
     * ```
     */
    getCookie: function (name) {
        var nameOfCookie = name + "=";
        var x = 0;
        while (x <= document.cookie.length) {
            var y = (x + nameOfCookie.length);
            if (document.cookie.substring(x, y) == nameOfCookie) {
                if ((endOfCookie = document.cookie.indexOf(";", y)) == -1) endOfCookie = document.cookie.length;
                return decodeURIComponent(document.cookie.substring(y, endOfCookie));
            }
            x = document.cookie.indexOf(" ", x) + 1;
            if (x == 0) break;
        }
        return "";
    },
    JSONFilter: /^\/\*-secure-([\s\S]*)\*\/\s*$/,
    /**
     * @method axf.dayLen
     * @param {Number} year
     * @param {Number} month
     * @returns {Number} end of daynum
     * @description 지정한 년도와 월의 날자수를 반환합니다.
     * @example
     * ```js
     * trace( axf.dayLen(2013, 1) );
     * // 28
     * // 주의 Data.getMonth() 의 반환값을 그대로 사용 하므로 1월은 0 으로 전달 해야 합니다. 0~11 까지의 값을 사용할 수 있습니다.
     * ```
     */
    dayLen: function (y, m) {
        if ([3, 5, 8, 10].has(function () { return this.item == m; })) {
            return 30;
        }
        else if (m == 1) {
            return (((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0)) ? 29 : 28;
        }
        else {
            return 31;
        }
    },
    /**
     * @method  axf.clientHeight
     * @returns {Number} clientHeight
     * @description 브라우저 clientHeight 반환합니다. window 창 높이와 같습니다.
     * @example
     * ```js
     * axf.clientHeight();
     * ```
     */
    clientHeight: function () { return (AXUtil.docTD == "Q") ? document.body.clientHeight : document.documentElement.clientHeight; },
    /**
     * @method  axf.scrollHeight
     * @returns {Number} scrollHeight
     * @description HTML scrollHeight 반환합니다.
     * @example
     * ```js
     * axf.scrollHeight();
     * ```
     */
    scrollHeight: function () { return (AXUtil.docTD == "Q") ? document.body.scrollHeight : document.documentElement.scrollHeight; },
    /**
     * @method  axf.clientWidth
     * @returns {Number} clientWidth
     * @description 브라우저 clientWidth 반환합니다. window 창 너비와 같습니다.
     * @example
     * ```js
     * axf.clientWidth();
     * ```
     */
    clientWidth: function () { return (AXUtil.docTD == "Q") ? document.body.clientWidth : document.documentElement.clientWidth; },
    /**
     * @method  axf.scrollWidth
     * @returns {Number} scrollWidth
     * @description HTML scrollWidth 반환합니다.
     * @example
     * ```js
     * axf.scrollWidth();
     * ```
     */
    scrollWidth: function () { return (AXUtil.docTD == "Q") ? document.body.scrollWidth : document.documentElement.scrollWidth; },
    scrollTop: function () {
        return (document.documentElement && document.documentElement.scrollTop) ||
            document.body.scrollTop;
    },
    scrollLeft: function () {
        return (document.documentElement && document.documentElement.scrollLeft) ||
            document.body.scrollLeft;
    },
    /**
     * @member {Object} axf.Event
     * @description Event.keyCode 모음 ref => https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode
     * @example
     * ```js
     *Event: {
	 *    KEY_BACKSPACE: 8,
	 *    KEY_TAB      : 9,
	 *    KEY_RETURN   : 13,
	 *    KEY_SHIFT    : 16,
	 *    KEY_CONTROL  : 17,
	 *    KEY_ALT      : 18,
	 *    KEY_ESC      : 27,
	 *    KEY_SPACE    : 32,
	 *    KEY_PAGEUP   : 33,
	 *    KEY_PAGEDOWN : 34,
	 *    KEY_END      : 35,
	 *    KEY_HOME     : 36,
	 *    KEY_LEFT     : 37,
	 *    KEY_UP       : 38,
	 *    KEY_RIGHT    : 39,
	 *    KEY_DOWN     : 40,
	 *    KEY_INSERT   : 45,
	 *    KEY_DELETE   : 46,
	 *    KEY_WINDOW   : 91,
	 *    KEY_EQUAL    : 187,
	 *    KEY_MINUS    : 189,
	 *    KEY_PERIOD   : 190,
	 *    NUMPAD_EQUAL   : 12,
	 *    NUMPAD_MULTIPLY: 106,
	 *    NUMPAD_ADD     : 107,
	 *    NUMPAD_SUBTRACT: 109,
	 *    NUMPAD_DECIMAL : 110,
	 *    NUMPAD_DIVIDE  : 111,
	 *    NUMPAD_COMMA   : 194,
	 *    cache: {}
	 *}
     * ```
     */
    Event: {
        KEY_BACKSPACE: 8,
        KEY_TAB: 9,
        KEY_RETURN: 13,
        KEY_SHIFT: 16,
        KEY_CONTROL: 17,
        KEY_ALT: 18,
        KEY_ESC: 27,
        KEY_SPACE: 32,
        KEY_PAGEUP: 33,
        KEY_PAGEDOWN: 34,
        KEY_END: 35,
        KEY_HOME: 36,
        KEY_LEFT: 37,
        KEY_UP: 38,
        KEY_RIGHT: 39,
        KEY_DOWN: 40,
        KEY_INSERT: 45,
        KEY_DELETE: 46,
        KEY_WINDOW: 91,
        KEY_EQUAL: 187,
        KEY_MINUS: 189,
        KEY_PERIOD: 190,
        NUMPAD_EQUAL: 12,
        NUMPAD_MULTIPLY: 106,
        NUMPAD_ADD: 107,
        NUMPAD_SUBTRACT: 109,
        NUMPAD_DECIMAL: 110,
        NUMPAD_DIVIDE: 111,
        NUMPAD_COMMA: 194,
        cache: {}
    },
    /**
     * @method axf.console
     * @param {String|Object|Array} obj
     * @description 브라우저 console 에 메세지를 출력하여 줍니다. trace 와 같습니다.
     * @example
     * ```js
     * axf.console("AXISJ");
     * // AXISJ
     *
     * axf.console(1234);
     * // 1234
     *
     * var myObj = {name:"AXISJ", url:"http://www.axisj.com"};
     * axf.console(myObj);
     * // {"name":"AXISJ", "url":"http://www.axisj.com"}
     * ```
     */
    console: function (obj) {
        var po = "";
        if (arguments.length > 1) {
            for (i = 0; i < arguments.length; i++) {
                var obji = arguments[i];
                var objStr = "";
                var type = (typeof obji).toLowerCase();
                if (type == "undefined" || type == "function") {
                    objStr = type;
                }
                else if (type == "boolean" || type == "number" || type == "string") {
                    objStr = obji;
                }
                else if (type == "object") {
                    objStr = Object.toJSON(obji);
                }
                if (po != "") po += ", ";
                po += "arg[" + i + "] : " + objStr;
            }
        }
        else {
            var type = (typeof obj).toLowerCase();
            if (type == "undefined" || type == "function") {
                po = type;
            }
            else if (type == "boolean" || type == "number" || type == "string") {
                po = obj;
            }
            else if (type == "object") {
                po = Object.toJSON(obj);
            }
        }

        if (axf.mobileConsole) {
            axf.mobileConsole.prepend("<div>" + po + "</div>");
        }
        else {
            if (window.console == undefined) {
            }
            else {
                try {
                    console.log(po);
                    //+ ":" + axf.console.caller.name
                } catch (e) {
                    alert(e);
                }
            }
        }
    },
    /**
     * @method  axf.alert
     * @param {String|Object|Array} obj
     * @description window.alert 를 확장하여 JSObject 구조를 출력 합니다.
     * @example
     * ```js
     * axf.alert("AXISJ");
     * // AXISJ
     *
     * axf.alert(1234);
     * // 1234
     *
     * var myObj = {name:"AXISJ", url:"http://www.axisj.com"};
     * axf.alert(myObj);
     * // {"name":"AXISJ", "url":"http://www.axisj.com"}
     * ```
     */
    alert: function (obj) {
        var po = "";
        if (arguments.length > 1) {
            for (i = 0; i < arguments.length; i++) {
                var obji = arguments[i];
                var objStr = "";
                var type = (typeof obji).toLowerCase();
                if (type == "undefined" || type == "function") {
                    objStr = type;
                }
                else if (type == "boolean" || type == "number" || type == "string") {
                    objStr = obji;
                }
                else if (type == "object") {
                    objStr = Object.toJSON(obji);
                }
                if (po != "") po += ", ";
                po += "arguments[" + i + "] : " + objStr;
            }
        }
        else {
            var type = (typeof obj).toLowerCase();
            if (type == "undefined" || type == "function") {
                po = type;
            }
            else if (type == "boolean" || type == "number" || type == "string") {
                po = obj;
            }
            else if (type == "object") {
                po = Object.toJSON(obj);
            }
        }
        alert(po);
    },
    /**
     * @method  axf.confirm
     * @param {String|Object|Array} obj
     * @description window.confirm 를 확장하여 JSObject 구조를 출력 합니다.
     * @example
     * ```js
     * axf.confirm("AXISJ");
     * // AXISJ
     *
     * axf.confirm(1234);
     * // 1234
     *
     * var myObj = {name:"AXISJ", url:"http://www.axisj.com"};
     * axf.confirm(myObj);
     * // {"name":"AXISJ", "url":"http://www.axisj.com"}
     * ```
     */
    confirm: function (obj) {
        var po = "";
        var type = (typeof obj).toLowerCase();
        if (type == "undefined" || type == "function") {
            po = type;
        }
        else if (type == "boolean" || type == "number" || type == "string") {
            po = obj;
        }
        else if (type == "object") {
            po = Object.toJSON(obj);
        }
        var result = confirm(po);
        return result;
    },
    importJS: function (src) {
        var scriptElement = document.createElement("script");
        scriptElement.setAttribute("src", src);
        scriptElement.setAttribute("type", "text/javascript");
        document.getElementsByTagName("head")[0].appendChild(scriptElement);
    },
    bindPlaceholder: function () {

    },
    /**
     * @method axf.isEmpty
     * @param {obj} obj
     * @returns {Boolean}
     * @description 대상 개체가 undefined, null, "" 인지 체크 합니다.
     * @example
     * ```js
     * trace( axf.isEmpty("AXISJ") );
     * // false
     * trace( axf.isEmpty("") );
     * // true
     * trace( axf.isEmpty(undefined) );
     * // true
     * ```
     */
    isEmpty: function (obj) {
        return (obj === "" || obj === null || obj === undefined);
    },
    /**
     * @method axf.getUrlInfo
     * @returns {Object} urlInfo
     * @description 브라우저 각종 속성을 반환합니다.
     * @example
     * ```js
     * trace( axf.getUrlInfo() );
     * {
	 * 	"url":"http://127.0.0.1:2013/samples/AXcore/test.html",
	 * 	"param":"",
	 * 	"anchorData":"127.0.0.1:2013/samples/AXcore/test.html",
	 * 	"urlParam":"http://127.0.0.1:2013/samples/AXcore/test.html",
	 * 	"referUrl":"",
	 * 	"pathName":"/samples/AXcore/test.html",
	 * 	"protocol":"http:",
	 * 	"hostName":"127.0.0.1"
	 * }
     * ```
     */
    getUrlInfo: function () {
        var url, url_param, param, referUrl, pathName, AXparam, pageProtocol, pageHostName;
        url_param = window.location.href;
        param = window.location.search;
        referUrl = document.referrer;
        pathName = window.location.pathname;
        url = url_param.replace(param, '');
        param = param.replace(/^\?/, '');
        pageProtocol = window.location.protocol;
        pageHostName = window.location.hostname;
        AXparam = url_param.replace(pageProtocol + "//", "");
        AXparam = (param) ? AXparam.replace(pageHostName + pathName + "?" + param, "") : AXparam.replace(pageHostName + pathName, "");
        return {
            url: url,
            param: param,
            anchorData: AXparam,
            urlParam: url_param,
            referUrl: referUrl,
            pathName: pathName,
            protocol: pageProtocol,
            hostName: pageHostName
        };
    },
    /**
     * @method axf.encParam
     * @param {String} str - parameter
     * @returns {String} parameter
     * @description 파라미터에 value를 URLEncode해 줍니다.
     * @example
     * ```js
     * axf.encParam("name=장기영&sex=남");
     * //"name=%EC%9E%A5%EA%B8%B0%EC%98%81&sex=%EB%82%A8"
     * ```
     */
    encParam: function (str) {
        var re = new RegExp("[^&?]*?=[^&?]*", "ig");
        var pars = [];
        var arr;
        while ((arr = re.exec(str)) != null) {
            var strContent = arr.toString();
            var dotIndex = strContent.indexOf("=");
            pars.push(strContent.substring(0, dotIndex) + "=" + strContent.substring(dotIndex + 1).enc());
        }
        return pars.join("&");
    },
    readyMobileConsole: function () {
        AXUtil.mobileConsole = axdom("<div class=\"AXMobileConsole\"></div>");
        axdom(document.body).append(AXUtil.mobileConsole);
    },
    parsingTable: function (elemObj, returnType) {
        var head = {}, body = [];
        elemObj.find("thead tr td").each(function () {
            var elem = axdom(this);
            var attrs = {
                key: elem.attr("name"),
                label: (elem.html() || ""),
                width: (elem.attr("width") || "*"),
                align: (elem.attr("align") || "")
            };
            head[attrs.key] = attrs;
        });

        elemObj.find("tbody tr").each(function () {
            var item = {};
            axdom(this).find("td").each(function () {
                var elem = axdom(this);
                item[elem.attr("name")] = elem.html();
            });
            body.push(item);
        });
        return {
            head: head, body: body
        };
    },
    /**
     * @member {type} axf.mousewheelevt
     * @description 브라우저에 따른 마우스 휠 이벤트이름
     */
    mousewheelevt: ((/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel"),

    //todo : event bubble catch
    /**
     * 타겟엘리먼트의 부모 엘리멘트에서 원하는 조건의 엘리먼트를 얻습니다.
     * @method axf.get_event_target
     * @param {Element} target - target element
     * @param {Object} cond - 원하는 element를 찾을 조건
     * @returns {Element}
     * @example
     * ```js
     * console.log(axf.get_event_target(e.target, {tagname:"a", clazz:"findclass", etc:"attribute"}));
     * ```
     */
    get_event_target: function (target, cond) {
        var _target = target;
        if (_target) {
            while ((function () {
                var result = true;
                if (Object.isFunction(cond)) {
                    result = cond(_target);
                }
                else if (Object.isObject(cond)) {
                    for (var k in cond) {
                        if (k === "tagname") {
                            if (_target.tagName.lcase() != cond[k]) {
                                result = false;
                                break;
                            }
                        }
                        else if (k === "clazz") {
                            var klasss = _target.className.split(/ /g);
                            var hasClass = false;
                            for (var a = 0; a < klasss.length; a++) {
                                if (klasss[a] == cond[k]) {
                                    hasClass = true;
                                    break;
                                }
                            }
                            result = hasClass;
                        }
                        else { // 그외 속성값들.
                            if (_target.getAttribute) {
                                if (_target.getAttribute(k) != cond[k]) {
                                    result = false;
                                    break;
                                }
                            }
                            else {
                                result = false;
                                break;
                            }
                        }
                    }
                }
                return !result;
            })())
            {
                if (_target.parentNode) {
                    _target = _target.parentNode;
                }
                else {
                    _target = false;
                    break;
                }
            }
        }
        return _target;
    }
};
var axdom;
if (window.jQuery) axdom = jQuery;
if (window.axdomConverter) axdom = axdomConverter;

// extend implement block

/**
 * AXISJ Class 지원 오브젝트
 * @namespace {Object} Class
 */
var Class = (function () {
    function subclass() { }

    /**
     * @method Class.create
     * @param {Object} [superClass] - 부모 클래스 오브젝트
     * @param {Object} Class Body
     * @description 클래스를 만들어 줍니다.
     * @example
     * ```js
     * var AXJ = Class.create({
 *	initialize: function () {
 *		this.config = {
 *			debugMode: false,
 *			hashSpliter: "_",
 *			href: "href=\"javascript:;\""
 *		};
 *	},
 *	init: function () {
 *		trace(Object.toJSON(this.config));
 *	}
 * });
     * ```
     */
    function create() {
        var parent = null, properties = AX_A(arguments);
        if (Object.isFunction(properties[0])) parent = properties.shift();
        function klass() { this.initialize.apply(this, arguments); }

        Object.extend(klass, Class.Methods);
        klass.superclass = parent;
        klass.subclasses = [];
        if (parent) {
            subclass.prototype = parent.prototype;
            klass.prototype = new subclass;
            parent.subclasses.push(klass);
        }
        for (var i = 0; i < properties.length; i++) klass.addMethods(properties[i]);
        if (!klass.prototype.initialize) klass.prototype.initialize = Prototype.emptyFunction;
        klass.prototype.constructor = klass;
        return klass;
    }

    function addMethods(source) {
        var ancestor = this.superclass && this.superclass.prototype;
        var properties = Object.keys(source);
        if (!Object.keys({toString: true}).length) {
            if (source.toString != Object.prototype.toString) properties.push("toString");
            if (source.valueOf != Object.prototype.valueOf) properties.push("valueOf");
        }
        for (var i = 0, length = properties.length; i < length; i++) {
            var property = properties[i], value = source[property];
            if (ancestor && Object.isFunction(value) && value.argumentNames().first() == "AXJ_super") {
                var method = value;
                value = (function (m) { return function () { return ancestor[m].apply(this, arguments); }; })(property).wrap(method);
                value.valueOf = method.valueOf.bind(method);
                value.toString = method.toString.bind(method);
            }
            this.prototype[property] = value;
        }
        return this;
    }

    return {create: create, Methods: {addMethods: addMethods}};
})();

/**
 * Object.prototype
 * @namespace {Object} Object
 */
    // Object extend
(function () {
    var _toString = Object.prototype.toString;
    //function extend(destination, source) { for (var property in source) destination[property] = source[property]; return destination; }

    /**
     * @method Object.extend
     * @param {Object} [target]
     * @param {Object} extend object
     * @param {Boolean} [overwrite=false] - 덮어쓰기 여부
     * @returns {Object} extended object
     * @description 오브젝트를 확장합니다. 타겟 오브젝트에 확장오브젝트의 키를 추가하거나 덮어쓰기 합니다.
     * @example
     * ```js
     * Object.extend({a:1}, {a:2});
     * // Object {a: 1}
     * Object.extend({a:1}, {b:2});
     * // Object {a: 1, b: 2}
     * Object.extend({a:1}, {a:2}, true);
     * // Object {a: 2}
     * ```
     */
    function extend() {
        var target = arguments[0] || {}, items = arguments[1], overwrite = arguments[2] || false;
        if (typeof target !== "object" && typeof target !== "function") {
            target = {};
        }
        if (typeof items === "string") {
            target = items;
        }
        else {
            if (overwrite === true) {
                for (var k in items) target[k] = items[k];
            }
            else if (overwrite === false) {
                for (var k in items) {
                    if (typeof target[k] === "undefined") target[k] = items[k];
                }
            }
        }
        return target;
    }

    function inspect(obj) {
        try {
            if (isUndefined(obj)) return 'undefined';
            if (obj === null) return 'null';
            return obj.inspect ? obj.inspect() : String(obj);
        } catch (e) {
            if (e instanceof RangeError) return '...';
            throw e;
        }
    }

    /**
     * @method Object.toJSON
     * @param {Object} object
     * @param {Boolean} [qoute=true] - 따옴표 표시 여부
     * @returns {String} JSON String
     * @description Object JSON String 으로 반환합니다. Function은 제외합니다.
     * @example
     * ```js
     * Object.toJSON({a:1, b:2});
     * // "{"a":1, "b":2}"
     * Object.toJSON({a:1, b:2}, false);
     * // "{a:1, b:2}"
     * ```
     */

    var toJSON = (function () {
        var r = /["]/g, f;
        return f = function (vContent, isqoute) {
            var result, i, j;
            switch (result = typeof vContent) {
                case'string':
                    return '"' + vContent.replace(r, '\\"') + '"';
                case'number':
                    return vContent;
                case'boolean':
                    return vContent.toString();
                case'undefined':
                    return 'undefined';
                case'function':
                    return '""';
                case'object':
                    if(_toString.call(vContent) == "[object Number]"){
                        return vContent;
                    }
                    if(_toString.call(vContent) == "[object String]"){
                        return '"' + vContent.replace(r, '\\"') + '"';
                    }
                    if (!vContent) return 'null';
                    result = '';
                    if (vContent.splice) {
                        for (i = 0, j = vContent.length; i < j; i++) result += ',' + f(vContent[i]);
                        return '[' + result.substr(1) + ']';
                    }
                    else {
                        for (i in vContent) if (vContent.hasOwnProperty(i) && vContent[i] !== undefined && typeof vContent[i] != 'function') result += ',"' + i + '":' + f(vContent[i]);
                        return '{' + result.substr(1) + '}';
                    }
            }
        };
    })();

    /*
     function toJSON(vContent, qoute) {
     var type = typeof object;
     var isqoute = qoute;
     if (isqoute == undefined) isqoute = true;
     switch (type) {
     case 'undefined': return "undefined";
     //case 'function': return "\"" + object.toString().replace(/\"/g, "\\\"") + "\"";
     case 'function': return;
     case 'unknown': return "unknown";
     case 'boolean': return object.toString();
     case 'number': return object.toString();
     case 'string': return object.axtoJSON(true);
     }
     if (object === null) return 'null';
     if (object.axtoJSON) return object.axtoJSON(isqoute);
     if (isElement(object)) return;
     var results = [];
     for (var property in object) {
     if (object.hasOwnProperty(property)) {
     var value = toJSON(object[property], isqoute);
     if (!isUndefined(value)) results.push(property.axtoJSON(isqoute) + ':' + value);
     }
     }
     return '{' + results.join(', ') + '}';
     }
     */

    /**
     * 오브젝트의 새로운 참조를 생성합니다.
     * @method Object.toJSONfn
     * @param {Object} object
     * @param {Boolean} [qoute=true] - 따옴표 표시 여부
     * @returns {String} JSON String
     */
    function toJSONfn(object, qoute) {
        var type = typeof object;
        var isqoute = qoute;
        if (isqoute == undefined) isqoute = true;
        switch (type) {
            case 'undefined':
                return "undefined";
            case 'function':
                try {
                    return toJSONfn(object(), isqoute);
                } catch (e) {
                    return;
                }
            case 'unknown':
                return "unknown";
            case 'boolean':
                return object.toString();
            case 'number':
                return object.toString();
            case 'string':
                return object.axtoJSON(true);
        }
        if (object === null) return 'null';
        if (object.axtoJSON) return object.axtoJSON(isqoute);
        if (isElement(object)) return;
        var results = [];
        for (var property in object) {
            if (object.hasOwnProperty(property)) {
                var value = toJSONfn(object[property], isqoute);
                if (!isUndefined(value)) results.push(property.axtoJSON(isqoute) + ':' + value);
            }
        }
        return '{' + results.join(', ') + '}';
    }

    function toJSONforMobile(object) {
        var type = typeof object;
        switch (type) {
            case 'undefined':
            case 'function':
                return;
            case 'unknown':
                return;
            case 'boolean':
                return "\"" + object.toString() + "\"";
            case 'number':
                return "\"" + object.toString() + "\"";
            case 'string':
                return object.axtoJSON(true);
        }
        if (object === null) return 'null';
        if (object.toJSONforMobile) return object.toJSONforMobile(true);
        if (isElement(object)) return;
        var results = [];
        for (var property in object) {
            if (object.hasOwnProperty(property)) {
                var value = axtoJSON(object[property]);
                if (!isUndefined(value)) results.push(property.axtoJSON(true) + ':' + value);
            }
        }
        return '{' + results.join(', ') + '}';
    }

    /**
     * 오브젝트의 key를 배열로 반환합니다.
     * @method Object.keys
     * @param {Object} object
     * @returns {Array}
     */
    function keys(obj) {
        var results = [];
        for (var property in obj) results.push(property);
        return results;
    }

    /**
     * 오브젝트의 value를 배열로 반환합니다.
     * @method Object.values
     * @param {Object} object
     * @returns {Array}
     */
    function values(obj) {
        var results = [];
        for (var property in obj) results.push(obj[property]);
        return results;
    }

    /**
     * 오브젝트의 새로운 참조를 생성합니다.
     * @method Object.clone
     * @param {Object} object
     * @returns {Object}
     */
    function clone(obj) { return extend({}, obj); }

    /**
     * 오브젝트가 HTML 엘리먼트여부인지 판단합니다.
     * @method Object.isElement
     * @param {Object} object
     * @returns {Boolean}
     */
    function isElement(obj) { return !!(obj && obj.nodeType == 1); }

    /**
     * 오브젝트가 Object인지 판단합니다.
     * @method Object.isObject
     * @param {Object} object
     * @returns {Boolean}
     */
    function isObject(obj) { return _toString.call(obj) == "[object Object]"; }

    /**
     * 오브젝트가 Array인지 판단합니다.
     * @method Object.isArray
     * @param {Object} object
     * @returns {Boolean}
     */
    function isArray(obj) { return _toString.call(obj) == "[object Array]"; }

    /**
     * 오브젝트가 Hash인지 판단합니다.
     * @method Object.isHash
     * @param {Object} object
     * @returns {Boolean}
     */
    function isHash(obj) { return obj instanceof Hash; }

    /**
     * 오브젝트가 Function인지 판단합니다.
     * @method Object.isFunction
     * @param {Object} object
     * @returns {Boolean}
     */
    function isFunction(obj) { return typeof obj === "function"; }

    /**
     * 오브젝트가 String인지 판단합니다.
     * @method Object.isString
     * @param {Object} object
     * @returns {Boolean}
     */
    function isString(obj) { return _toString.call(obj) == "[object String]"; }

    /**
     * 오브젝트가 Number인지 판단합니다.
     * @method Object.isNumber
     * @param {Object} object
     * @returns {Boolean}
     */
    function isNumber(obj) { return _toString.call(obj) == "[object Number]"; }

    /**
     * 오브젝트가 undefined인지 판단합니다.
     * @method Object.isUndefined
     * @param {Object} object
     * @returns {Boolean}
     */
    function isUndefined(obj) { return typeof obj === "undefined"; }

    extend(Object, {
        extend: extend,
        inspect: inspect,
        toJSON: toJSON,
        toJSONfn: toJSONfn,
        toJSONforMobile: toJSONforMobile,
        keys: keys,
        values: values,
        clone: clone,
        isElement: isElement,
        isObject: isObject,
        isArray: isArray,
        isHash: isHash,
        isFunction: isFunction,
        isString: isString,
        isNumber: isNumber,
        isUndefined: isUndefined
    });
})();

/**
 * Function.prototype
 * @namespace {Function} Function
 */
Object.extend(Function.prototype, (function () {
    var slice = Array.prototype.slice;

    function update(array, args) {
        var arrayLength = array.length, length = args.length;
        while (length--) array[arrayLength + length] = args[length];
        return array;
    }

    function merge(array, args) {
        array = slice.call(array, 0);
        return update(array, args);
    }

    /**
     * @method Function.argumentNames
     * @returns {Array} arguments
     * @description 함수의 아규먼트를 배열로 반환합니다.
     * @example
     * ```js
     * var myFn = function(a, b, c){
	 *     return a;
	 * };
     *
     * trace(myFn.argumentNames());
     * //  ["a", "b", "c"]
     * // prototypejs 를 참조하여 제작되었습니다.
     * ```
     */
    function argumentNames() {
        var names = this.toString().match(/^[\s\(]*function[^(]*\(([^)]*)\)/)[1].replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g, '').replace(/\s+/g, '').split(',');
        return names.length == 1 && !names[0] ? [] : names;
    }

    /**
     * @method Function.bind
     * @param {Object} bindTarget
     * @param {Object} [Argument]
     * @description 함수의 위치를 bind 대상에 연결하여 줍니다.
     * @example
     * ```js
     * var AlertClass = Class.create({
	 *     initialize: function(msg) {
	 *        this.msg = msg;
	 *    },
	 *    handleClick: function(event) {
	 *        alert(this.msg);
	 *    }
	 * });
     * var myalert = new AlertClass("AXJ Clicked");
     *
     * $("#link1").click(myalert.handleClick);
     * //undefined
     * $("#link2").click(myalert.handleClick.bind(myalert));
     * //AXJ Clicked
     *
     * // ---------------------
     * var AlertClass = Class.create({
	 *    initialize: function(msg) {
	 *        this.msg = msg;
	 *    },
	 *    handleClick: function(a, b, c, event) {
	 *        trace({a:a, b:b, c:c, event:event.type});
	 *        // {"a":"A", "b":"X", "c":"J", "event":"click"}
	 *        alert(this.msg);
	 *    }
	 * });
     * var myalert = new AlertClass("AXJ Clicked");
     *
     * $("#link1").click(myalert.handleClick);
     * $("#link2").click(myalert.handleClick.bind(myalert, "A", "X", "J"));
     * ```
     */
    function bind(context) {
        if (arguments.length < 2 && Object.isUndefined(arguments[0])) return this;
        var __method = this, args = slice.call(arguments, 1);
        return function () {
            var a = merge(args, arguments);
            return __method.apply(context, a);
        }
    }

    function curry() {
        if (!arguments.length) return this;
        var __method = this, args = slice.call(arguments, 0);
        return function () {
            var a = merge(args, arguments);
            return __method.apply(this, a);
        }
    }

    /**
     * @method Function.delay
     * @param {Number} timeout - second
     * @description 함수의 실행을 지정된 시간 후에 실행되게 합니다.
     * @example
     * ```js
     * var showMsg = function(a, b){
	 *     alert(a+"/"+b);
	 * };
     * showMsg.delay(2, "AX", "ISJ");
     * // 2초 후에 alert 구문이 실행됩니다.
     * // 내부네서 this.apply 를 호출합니다. 간단한 함수 호출에는 사용을 권장하지만 복잡한 형태의 함수 구현에는 권장하지 않습니다.
     * ```
     */
    function delay(timeout) {
        var __method = this, args = slice.call(arguments, 1);
        timeout = timeout * 1000;
        return window.setTimeout(function () { return __method.apply(__method, args); }, timeout);
    }

    function defer() {
        var args = update([0.01], arguments);
        return this.delay.apply(this, args);
    }

    function wrap(wrapper) {
        var __method = this;
        return function () {
            var a = update([__method.bind(this)], arguments);
            return wrapper.apply(this, a);
        }
    }

    function methodize() {
        if (this._methodized) return this._methodized;
        var __method = this;
        return this._methodized = function () {
            var a = update([this], arguments);
            return __method.apply(null, a);
        };
    }

    function addPrototype(fns) {
        var name, i = 0, length = fns.length, isObj = length === undefined || Object.isFunction(fns);
        if (isObj) {
            for (name in fns) {
                this.prototype[name] = fns[name];
            }
        }
    }

    return {argumentNames: argumentNames, bind: bind, curry: curry, delay: delay, defer: defer, wrap: wrap, methodize: methodize, addPrototype: addPrototype}
})());

/**
 * String.prototype
 * @namespace {String} String
 */
Object.extend(String.prototype, (function () {
    function password() { return Math.tan(45).toString().substr(7)}

    /**
     * 문자열 시작부터 지정한 글자수 만큼 반환합니다.
     * @method String.left
     * @param {Number} strLen
     * @returns {String}
     * @example
     * ```js
     * "AXJ_String".left(3); -> "AXJ"
     * toast.push('left(3) : ' + "AXJ_String".left(3));
     * ```
     */
    function left(strLen) { return this.toString().substr(0, strLen); }

    /**
     * 문자열 끝부터 지정한 글자수 만큼 반환합니다.
     * @method String.right
     * @param {Number} strLen
     * @returns {String}
     * @example
     * ```js
     * "AXJ_String".right(3); -> "ing"
     * toast.push('right(3) : '+$('#AXJrightTest').val().left(3));
     * ```
     */
    function right(strLen) { return this.substring(this.length - strLen, this.length); }

    /**
     * URLencode된 문자열을 디코드 합니다.
     * @method String.dec
     * @returns {String}
     * @example
     * ```js
     * "AXJ_String%2C%EC%97%91%EC%8B%9C%EC%8A%A4%EC%A0%9C%EC%9D%B4".dec(); -> "AXJ_String,엑시스제이"
     * ```
     */
    function dec() {
        var decodeURI;
        try {
            decodeURI = decodeURIComponent(this);
        }
        catch (e) {
            decodeURI = unescape(this);
        }
        return decodeURI;
        /*
         var decodeURI;
         try{decodeURI = decodeURIComponent(this.replace(/\+/g, " "));}catch(e){var decodeURI = this;}
         return (this) ? (decodeURI) : this;
         */
    }

    /**
     * URLencode된 문자열로 인코드 합니다.
     * @method String.enc
     * @returns {String}
     * @example
     * ```js
     * "AXJ_String,엑시스제이".enc(); -> "AXJ_String%2C%EC%97%91%EC%8B%9C%EC%8A%A4%EC%A0%9C%EC%9D%B4"
     * ```
     */
    function enc() { return (this) ? encodeURIComponent(this) : this; }

    /**
     * JSONString이면 Object로 변환합니다.
     * @method String.object
     * @returns {Object}
     * @example
     * ```js
     * var myObj = "{a:1, b:2, name:'AXJ'}".object();
     * trace(myObj);
     * // {"a":1, "b":2, "name":"AXJ"}
     *
     * var myObjError = "{1, b:2, name:'AXJ'}".object();
     * trace(myObjError);
     * // {"error":"syntaxerr", "result":"syntaxerr", "msg":"JSON syntax error.{1, b:2, name:'AXJ'}", "body":"{1, b:2, name:'AXJ'}"}
     * ```
     */
    function object() {
        try {
            var res = this.evalJSON();
        } catch (e) {
            res = {error: "syntaxerr", result: "syntaxerr", msg: "to object error, " + e.print() + ", " + this};
            try {
                mask.close();
            } catch (e) {
            }
        }
        return res;
    }

    /**
     * 콤마가 포함된 문자열을 Array로 변환합니다.
     * @method String.array
     * @returns {Array}
     * @example
     * ```js
     * var myObj = "a,b,c".array();
     * trace(myObj);
     * // ["a", "b", "c"]
     * ```
     */
    function array() {
        try {
            var res = this.split(/,/g);
        } catch (e) {
            res = {error: "syntaxerr", result: "syntaxerr", msg: "to object error, " + e.print() + ", " + this};
        }
        return res;
    }

    /**
     * 문자열을 date 형식에 맞추어 날짜 포멧으로 리턴합니다.
     * @method String.date
     * @param {String} [separator=-] 날짜구분자
     * @returns {Date}
     * @example
     * ```js
     * trace("20121119".date());
     * // "2012-11-19T03:00:00Z"
     *
     * trace("2012-11-19".date());
     * // "2012-11-19T03:00:00Z"
     *
     * trace("2012/11/19".date("/"));
     * // "2012-11-19T03:00:00Z"
     * ```
     */
    function toDate(separator, defaultDate) {
        function local_date(yy, mm, dd, hh, mi, ss) {
            var utc_d, local_d;
            local_d = new Date();
            if (typeof hh === "undefined") hh = 23;
            if (typeof mi === "undefined") mi = 59;
            utc_d = new Date(Date.UTC(yy, mm, dd || 1, hh, mi, ss || 0));

            if (mm == 0 && dd == 1 && utc_d.getUTCHours() + (utc_d.getTimezoneOffset() / 60) < 0) {
                utc_d.setUTCHours(0);
            }
            else {
                utc_d.setUTCHours(utc_d.getUTCHours() + (utc_d.getTimezoneOffset() / 60));
            }
            return utc_d;
        }

        if (this.length == 0) {
            return defaultDate || new Date();
        }
        else if (this.length > 15) {
            var yy, mm, dd, hh, mi,
                aDateTime = this.split(/ /g), aTimes, aTime,
                aDate = aDateTime[0].split(separator || "-"),
                utc_d, local_d;

            yy = aDate[0];
            mm = parseFloat(aDate[1]);
            dd = parseFloat(aDate[2]);
            aTime = aDateTime[1] || "09:00";
            aTimes = aTime.left(5).split(":");
            hh = parseFloat(aTimes[0]);
            mi = parseFloat(aTimes[1]);
            if (aTime.right(2) === "AM" || aTime.right(2) === "PM") hh += 12;
            return local_date(yy, mm - 1, dd, hh, mi);
        }
        else if (this.length == 14) {
            var va = this.replace(/\D/g, "");
            return local_date(va.substr(0, 4), va.substr(4, 2).number() - 1, va.substr(6, 2).number(), va.substr(8, 2).number(), va.substr(10, 2).number(), va.substr(12, 2).number());
        }
        else if (this.length > 7) {
            var va = this.replace(/\D/g, "");
            return local_date(va.substr(0, 4), va.substr(4, 2).number() - 1, va.substr(6, 2).number());
        }
        else if (this.length > 4) {
            var va = this.replace(/\D/g, "");
            return local_date(va.substr(0, 4), va.substr(4, 2).number() - 1, 1);
        }
        else if (this.length > 2) {
            var va = this.replace(/\D/g, "");
            return local_date(va.substr(0, 4), va.substr(4, 2).number() - 1, 1);
        }
        else {
            return defaultDate || new Date();
        }
    }

    /**
     * 문자열을 Number로 변환해 줍니다.
     * @method String.number
     * @returns {Number}
     * @example
     * ```js
     * var str = "1234";
     * trace(typeof str);
     * // string
     *
     * str = str.number();
     * trace(typeof str);
     * // number
     *
     * "1,234".number(); -> 1234
     * "1,234.1".number(); -> 1234.1
     * ```
     */
    function toNum() {
        var pair = this.replace(/,/g, "").split(".");
        var isMinus = false;
        if (parseFloat(pair[0]) < 0) isMinus = true;
        if (pair[0] == "-0") isMinus = true;
        var returnValue = 0.0;
        pair[0] = pair[0].replace(/[-|+]?[\D]/gi, "");
        if (pair[1]) {
            pair[1] = pair[1].replace(/\D/gi, "");
            returnValue = parseFloat(pair[0] + "." + pair[1]) || 0;
        }
        else {
            returnValue = parseFloat(pair[0]) || 0;
        }
        return (isMinus) ? -returnValue : returnValue;
    }

    function parseF() { return parseFloat(this); }

    /**
     * 문자열의 앞뒤 공백을 제거하여 줍니다.
     * @method String.trim
     * @returns {String}
     * @example
     * ```js
     * " AXJ ".trim(); ->  "AXJ"
     * ```
     */
    function strip() { return this.replace(/^\s+/, '').replace(/\s+$/, ''); }

    /**
     * 문자열에서 HTML 태그를 제거하여 반환합니다.
     * @method String.delHtml
     * @returns {String}
     * @example
     * ```js
     * "<div>AXJ</div>".delHtml(); ->  "AXJ"
     * ```
     */
    function stripTags() { return this.replace(/<\w+(\s+("[^"]*"|'[^']*'|[^>])+)?>|<\/\w+>/gi, ''); }

    /**
     * 문자열에서 Script 태그를 제거하여 반환합니다.
     * @method String.delScript
     * @returns {String}
     * @example
     * ```js
     * "<script src="scriptname"></script>AXJ".delScript(); ->  "AXJ"
     * ```
     */
    function stripScript() {
        //스크립트 제거
        var cStr;
        var RegExpJS = new RegExp("<[ ]*script[^>]*>[^<]*</[ ]*script[^>]*>", "gi");
        cStr = this.replace(RegExpJS, "");

        cStr = cStr.replace(/[\s]*onclick[^=]*=/gi, " xonclick=");
        cStr = cStr.replace(/[\s]*onmouserover[^=]*=/gi, " xonmouseover=");
        cStr = cStr.replace(/[\s]*onmouseout[^=]*=/gi, " xonmouseout=");
        cStr = cStr.replace(/[\s]*onchange[^=]*=/gi, " xonchange=");
        cStr = cStr.replace(/[\s]*onblur[^=]*=/gi, " xonblur=");
        cStr = cStr.replace(/[\s]*onerror[^=]*=/gi, " xonerror=");
        cStr = cStr.replace(/[\s]*onload[^=]*=/gi, " xonload=");
        cStr = cStr.replace(/[\s]*href[^=]*=[\s]*["']?javascript/gi, " href=\"xjavascript");

        return cStr;
    }

    /**
     * 문자열을 반복하여 반환합니다.
     * @method String.times
     * @param {Number} count
     * @returns {String}
     * @example
     * ```js
     * "AXJ".times(3); ->  "AXJAXJAXJ"
     * ```
     */
    function times(count) { return count < 1 ? '' : new Array(count + 1).join(this); }

    function inspect(useDoubleQuotes) {
        var escapedString = this.replace(
            /[\x00-\x1f\\]/g,
            function (character) {
                try {
                    if (character in String.specialChar) return String.specialChar[character];
                } catch (e) {
                }
                if (character.charCodeAt() == 13) return "\\r";
                if (character.charCodeAt() == 10) return "\\n";
                return '\\u00' + character.charCodeAt()
            }
        );
        if (useDoubleQuotes) return '"' + escapedString.replace(/"/g, '\\"') + '"';
        return "" + escapedString.replace(/'/g, '\\\'') + "";
    }

    function axtoJSON(TF) {
        return this.inspect(TF || false);
    }

    function blank() { return /^\s*$/.test(this); }

    function isJSON() {
        var str = this;
        if (str.isBlank()) return false;
        str = this.replace(/\\./g, '@').replace(/"[^"\\\n\r]*"/g, '');
        return (/^[,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]*$/).test(str);
    } //"
    function unfilterJSON(filter) { return this.replace(filter || AXUtil.JSONFilter, '$1'); }

    function evalJSON(sanitize) {
        var json = this.unfilterJSON();
        try {
            var _evl = eval;
            if (!sanitize || json.isJSON()) return _evl("(" + json + ")");
            else return {error: "syntaxerr", result: "syntaxerr", msg: "JSON syntax error. fail to convert Object\n" + this};
            _evl = null;
        } catch (e) {
            return {
                error: e,
                result: "syntaxerr",
                msg: e,
                body: this
            };
        }
    }

    /**
     * queryString 형식의 문자열을 json object로 변환하여 줍니다.
     * @method String.queryToObject
     * @param {String} [separator=&]
     * @returns {Object}
     * @example
     * ```js
     * var myObject = "a=1&b=1".queryToObject();
     * trace(myObject);
     * // {"a":"1", "b":"1"}
     * ```
     */
    function queryToObject(separator) {
        var match = this.trim().match(/([^?#]*)(#.*)?$/);
        if (!match) return {};
        var rs = match[1].split(separator || '&');
        var returnObj = {};
        var i = 0;
        while (i < rs.length) {
            var pair = rs[i].split("=");
            var k = pair[0], v = pair[1];
            if (returnObj[k] != undefined) {
                if (!Object.isArray(returnObj[k])) returnObj[k] = [returnObj[k]];
                returnObj[k].push(v);
            }
            else {
                returnObj[k] = v;
            }
            i++;
        }
        return returnObj;
    }

    /**
     * queryString 형식의 문자열을 json object로 변환하여 줍니다. (파라미터 값은 URLDecode 합니다.)
     * @method String.queryToObjectDec
     * @param {String} [separator=&]
     * @returns {Object}
     * @example
     * ```js
     * var myObject = "a=1&b=1".queryToObject();
     * trace(myObject);
     * // {"a":"1", "b":"1"}
     * ```
     */
    function queryToObjectDec(separator) {
        var match = this.trim().match(/([^?#]*)(#.*)?$/);
        if (!match) return {};
        var rs = match[1].split(separator || '&');
        var returnObj = {};
        var i = 0;
        while (i < rs.length) {
            var pair = rs[i].split("=");
            var k = pair[0], v = pair[1];
            if (returnObj[k] != undefined) {
                if (!Object.isArray(returnObj[k])) returnObj[k] = [returnObj[k]];
                returnObj[k].push(v.dec());
            }
            else {
                returnObj[k] = v.dec();
            }
            i++;
        }
        return returnObj;
    }

    /**
     * 줄넘김 문자열 '\n'을 &gt;br/> 태그로 변환하여 줍니다.
     * @method String.crlf
     * @param {Regexp} [replaceTarget=/\n/g]
     * @param {String} [replacer=&gt;br/>]
     * @returns {String}
     * @example
     * ```js
     * "123
     * 123".crlf(); ->  "123<br/>123"
     * ```
     */
    function crlf(replaceTarget, replacer) { return this.replace((replaceTarget || /\n/g), (replacer || "<br/>")); }

    /**
     * 줄넘김 문자열 '%0A'을 &gt;br/> 태그로 변환하여 줍니다.
     * @method String.ecrlf
     * @param {Regexp} [replaceTarget=/%0A/g]
     * @param {String} [replacer=&gt;br/>]
     * @returns {String}
     * @example
     * ```js
     * "123%0A123".crlf(); ->  "123<br/>123"
     * ```
     */
    function ecrlf(replaceTarget, replacer) { return this.replace((replaceTarget || /%0A/g), (replacer || "<br/>")); }

    /**
     * 문자열 자리수를 맞추어 줍니다.
     * @method String.setDigit
     * @param {Number} length
     * @param {String} [padder=0]
     * @returns {String}
     * @example
     * ```js
     * "A".setDigit(3); ->  "00A"
     * "A".setDigit(3, '!'); ->  "!!A"
     * ```
     */
    function formatDigit(length, padder) {
        var string = this;
        return (padder || '0').times(length - string.length) + string;
    }

    /**
     * 파일경로에서 파일명을 반환합니다.
     * @method String.getFileName
     * @returns {String}
     * @example
     * ```js
     *"C://Works/AXISJ_project/css/myfile.zip".getFileName(); ->  "myfile.zip"
     * ```
     */
    function getFileName() {
        var sToMatch = this;
        var reAt = /[\/\\]?([^\/\\]?\.?[^\/\\]+)$/;
        var reArr = sToMatch.match(reAt);
        return RegExp.$1;
    }

    /**
     * Mozila 브라우저 등에서 사용하는 색상정보 값을 표준색상코드로 변환합니다. 표준색상코드를 입력하여도 표준색상코드 값을 얻을 수 있습니다.
     * @method String.toColor
     * @param {String} [prefix]
     * @returns {String}
     * @example
     * ```js
     * "rgb(243, 243, 243)".toColor(); ->  "f3f3f3"
     * "rgb(243, 243, 243)".toColor('#'); ->  "#f3f3f3"
     * "#f3f3f3".toColor(); ->  "f3f3f3"
     * "f3f3f3".toColor(); ->  "f3f3f3"
     * "f3f3f3".toColor('#'); ->  "#f3f3f3"
     * ```
     */
    function toColor(sharp) {
        var colorValue = "";
        if (this.left(3) == "rgb") {
            var val = this;
            var reAt = /rgb\((.+)\)/;
            val.match(reAt);
            var vals = RegExp.$1.split(", ");
            for (var a = 0; a < vals.length; a++) {
                vals[a] = vals[a].number().setDigit(2, '0', 16);
            }
            colorValue = vals.join("");
        }
        else {
            colorValue = this.replace("#", "");
        }
        var preFix = (sharp) ? "#" : "";
        return preFix + colorValue;
    }

    /**
     * 숫자형 문자열에 콤마를 삽입하여 통화단위로 반환합니다.
     * @method String.money
     * @returns {String}
     * @example
     * ```js
     * "1000000".money()
     * // "1,000,000"
     * ```
     */
    function toMoney() { return this.number().money(); }

    function toByte() { return this.number().byte(); }

    /**
     * 문자열을 소문자로 반환합니다.
     * @method String.lcase
     * @returns {String}
     * @example
     * ```js
     * "AXISJ".lcase() -> "axisj"
     * ```
     */
    function lcase() { return this.toLowerCase(); }

    /**
     * 문자열을 대문자로 반환합니다.
     * @method String.ucase
     * @returns {String}
     * @example
     * ```
     * "axisj".ucase() -> "AXISJ"
     * ```
     */
    function ucase() { return this.toUpperCase(); }

    /**
     * 문자열의 바이트 값을 계산하여 줍니다.
     * @method String.getByte
     * @returns {Number}
     * @example
     * ```
     * trace("장".getByte());
     * // 2
     * trace("a".getByte());
     * // 1
     * ```
     */
    function getByte() {
        var valueByte = this.length;
        for (i = 0, l = this.length; i < l; i++) if (this.charCodeAt(i) > 128) valueByte++;
        return valueByte;
    }

    /**
     * 문자열을 전화번호 형태로 반홥니다.
     * @method String.phone
     * @returns {String}
     * @example
     * ```js
     * trace("장".phone());
     * // 02
     * trace("a".phone());
     * // 02
     * trace("88819123".phone());
     * // 02-8881-9123
     * trace("01088819123".phone());
     * // 010-8881-9137
     * ```
     */
    function toPhoneString() {
        if (this == "") return this;
        var _this = this.replace(/\D+/g, "");
        var myLocalNums = "";
        var num1 = "", num2 = "";
        var localNum = "031/032/033/041/042/043/051/052/053/054/055/061/062/063/064/010/011/016/017/019/070/080/060";
        if (_this.left(2) == "02") {
            myLocalNums = "02";
        }
        else {
            var localNums = localNum.split(/\//g);
            var tempNum = _this.left(3);
            AXUtil.each(localNums, function () {
                if (this == tempNum) {
                    myLocalNums = this;
                    return false;
                }
            });
        }

        if (myLocalNums == "") {
            myLocalNums = "02";
            if (_this.length > 7) {
                num1 = _this.substr(0, 4);
                num2 = _this.substr(4);
            }
            else {
                num1 = _this.substr(0, 3);
                num2 = _this.substr(3);
            }
        }
        else {
            try {
                var snum = myLocalNums.length;
                if ((_this.length - snum) > 7) {
                    num1 = _this.substr(snum, 4);
                    num2 = _this.substr(snum + 4);
                }
                else {
                    num1 = _this.substr(snum, 3);
                    num2 = _this.substr(snum + 3);
                }
            } catch (e) {
                //trace(e);
            }
        }

        var returnString = myLocalNums;
        if (num1 != "") returnString += "-" + num1;
        if (num2 != "") returnString += "-" + num2;

        return returnString;

    }

    /**
     * anchor 데이터를 반환합니다.
     * @method String.getAnchorData
     * @returns {String}
     * @example
     * ```js
     * "http://jdoc.axisj.com/#{id:\"/API/Prototype/String/phone\"}".getAnchorData();
     * "{id:"/API/Prototype/String/phone"}"
     * ```
     */
    function getAnchorData() {
        var idx = this.indexOf("#", 0);
        if (idx < 0) return "";
        var cnt = this.length;
        var str = this.substring(idx + 1, cnt);
        return str;
    }

    function print() {
        return this;
    }

    return {
        ppassword: password,
        left: left,
        right: right,
        dec: dec,
        decode: dec,
        enc: enc,
        object: object,
        array: array,
        date: toDate,
        number: toNum,
        num: parseF,
        money: toMoney,
        byte: toByte,
        trim: strip,
        delHtml: stripTags,
        delScript: stripScript,
        removeScript: stripScript,
        times: times,
        inspect: inspect,
        axtoJSON: axtoJSON,
        isBlank: blank,
        isJSON: isJSON,
        unfilterJSON: unfilterJSON,
        evalJSON: evalJSON,
        queryToObject: queryToObject,
        queryToObjectDec: queryToObjectDec,
        crlf: crlf,
        ecrlf: ecrlf,
        setDigit: formatDigit,
        getFileName: getFileName,
        toColor: toColor,
        lcase: lcase,
        ucase: ucase,
        getByte: getByte,
        phone: toPhoneString,
        getAnchorData: getAnchorData,
        print: print
    }
})());

/**
 * Number.prototype
 * @namespace {Number} Number
 */
Object.extend(Number.prototype, (function () {
    /**
     * 숫자를 문자열로 변환하고 시작부터 지정한 글자수 만큼 반환합니다.
     * @method Number.left
     * @param {Number} strLen
     * @returns {String}
     * @example
     * ```js
     * (1234).left(3); -> "123"
     * ```
     */
    function left(strLen) { return this.toString().substr(0, strLen); }

    /**
     * 숫자를 문자열로 변환하고 마지막부터 지정한 글자수 만큼 반환합니다.
     * @method Number.right
     * @param {Number} strLen
     * @returns {String}
     * @example
     * ```js
     * 1234.right(3); -> 234
     * ```
     */
    function right(strLen) { return this.toString().substring(this.toString().length - strLen, this.toString().length); }

    /**
     * 통화표현 단위로 변환된 문자열을 반환합니다.
     * @method Number.money
     * @returns {String}
     * @example
     * ```js
     * trace((1234.9).money());
     * //1,234.9
     * trace((1234.1).money());
     * //1,234.1
     * trace((-1234.9).money());
     * //-1,234.9
     * trace((-1234.1).money());
     * //-1,234.1
     *
     * (12345678).money(); -> "12,345,678"
     * "12345678".money(); -> "12,345,678"
     * // String 에서도 money 메소드를 직접 사용 할 수 있습니다.
     * ```
     */
    function toMoney() {
        var txtNumber = '' + this;
        if (isNaN(txtNumber) || txtNumber == "") {
            return "";
        }
        else {
            var rxSplit = new RegExp('([0-9])([0-9][0-9][0-9][,.])');
            var arrNumber = txtNumber.split('.');
            arrNumber[0] += '.';
            do {
                arrNumber[0] = arrNumber[0].replace(rxSplit, '$1,$2');
            } while (rxSplit.test(arrNumber[0]));
            if (arrNumber.length > 1) {
                return arrNumber.join('');
            }
            else {
                return arrNumber[0].split('.')[0];
            }
        }
    }

    /**
     * 숫자값을 Byte로 인식하여 값에 크기에 따르 KB, MB, GB 의 형식으로 반환합니다.
     * @method Number.byte
     * @returns {String}
     * @example
     * ```js
     * trace((1234567890).byte());
     * // 1.1GB
     * trace((12345678).byte());
     * // 11.8MB
     * trace((123456).byte());
     * // 120.6KB
     * trace((123).byte());
     * // 0.1KB
     * ```
     */
    function toByte() {
        var n_unit = "KB";
        var myByte = this / 1024;
        if (myByte / 1024 > 1) {
            n_unit = "MB";
            myByte = myByte / 1024;
        }
        if (myByte / 1024 > 1) {
            n_unit = "GB";
            myByte = myByte / 1024;
        }
        return myByte.round(1) + n_unit;
    }

    /**
     * 자신을 반환합니다.
     * @method Number.number
     * @returns {Number}
     */
    function toNum() { return this; }

    /**
     * 원하는 횟수 만큼 자릿수 맞춤 문자열을 포함한 문자열을 반환합니다.
     * @method Number.setDigit
     * @param {Number} length - 자릿수
     * @param {String} padder - 자릿수 맞춤 문자열
     * @param {Number} radix - 진수
     * @returns {String}
     * @example
     * ```js
     * trace( (11).setDigit(3) );
     * //011
     * trace( (11).setDigit(3, '!') );
     * //!11
     * trace( (11).setDigit(3, 0, 16) );
     * //00b
     * trace( (25).setDigit(5, "X", 8) );
     * //XXX31
     * ```
     */
    function formatDigit(length, padder, radix) {
        var string = this.toString(radix || 10);
        return (padder || '0').times(length - string.length) + string;
    }

    /**
     * 인자값부터 원본까지 정수 단위로 이어진 배열을 리턴합니다.
     * @method Number.rangeFrom
     * @param {Number} start - 배열시작위치
     * @returns {Array}
     * @example
     * ```js
     * (3).rangeFrom(0);
     * [0, 1, 2, 3]
     * ```
     */
    function range(start) {
        var ra = [];
        for (var a = (start || 0); a < this + 1; a++) ra.push(a);
        return ra;
    }

    function axtoJSON() { return this; }

    /**
     * 절대값을 반환합니다.
     * @method Number.abs
     * @returns {Number}
     * @example
     * ```js
     * trace((1234).abs());
     * // 1234
     * trace((-1234).abs());
     * // 1234
     * trace((1234.123).abs());
     * // 1234.123
     * trace((-1234.123).abs());
     * // 1234.123
     * ```
     */
    function abs() { return Math.abs(this); }

    /**
     * 반올림 위치에서부터 반올림 한 값을 반환합니다.
     * @method Number.round
     * @param {Number} digit
     * @returns {Number}
     * @example
     * ```js
     * trace((1234.5678).round());
     * //1235
     * trace((1234.5678).round(1));
     * //1234.6
     * trace((1234.5678).round(2));
     * //1234.57
     * ```
     */
    function round(digit) {
        return (typeof digit == "undefined") ? Math.round(this) :
            (this.toString().search('e-')) ? this.toFixed(digit) : +(Math.round(this + "e+" + digit) + "e-" + digit);
    }

    /**
     * Math.ceil
     * @method Number.ceil
     * @returns {Number}
     */
    function ceil() { return Math.ceil(this); }

    /**
     * Math.floor
     * @method Number.floor
     * @returns {Number}
     */
    function floor() { return Math.floor(this); }

    /**
     * 숫자를 time값으로 이용하여 Date를 반환합니다.
     * @method Number.date
     * @returns {Date}
     * @example
     * ```js
     * var ndate = new Date();
     * ndate.getTime();
     * // 1417253161813
     * (1417253161813).date();
     * // Sat Nov 29 2014 18:26:01 GMT+0900 (KST)
     * ```
     */
    function date() { return new Date(this); }

    /**
     * 나누기 연산 결과를 반환합니다. divisor 가 0인 경우 연산 결과는 오류 없이 0을 반환합니다.
     * @method Number.div
     * @param {Number} divisor - 나눔수
     * @returns {Number}
     * @example
     * ```js
     * trace( (10).div(2); );
     * // 5
     * trace( (10).div(0); );
     * // 0
     * ```
     */
    function div(divisor) {
        if (divisor != 0) {
            return this / divisor;
        }
        else {
            return 0;
        }
    }

    function none() { return this; }

    function times(count) { return count < 1 ? '' : new Array(count + 1).join(this.toString()); }

    /**
     * 숫자를 문자로 변환후 String.phone를 실행합니다.
     * @method Number.phone
     * @returns {String}
     */
    function phone() {
        var txtNumber = '' + this;
        return txtNumber.phone();
    }

    return {
        left: left,
        right: right,
        abs: abs,
        round: round,
        ceil: ceil,
        floor: floor,
        money: toMoney,
        byte: toByte,
        num: toNum,
        number: toNum,
        setDigit: formatDigit,
        date: date,
        div: div,
        dec: none,
        enc: none,
        rangeFrom: range,
        axtoJSON: axtoJSON,
        times: times,
        phone: phone
    }
})());

/**
 * Date.prototype
 * @namespace {Date} Date
 */
Object.extend(Date.prototype, (function () {
    /**
     * @method Data.add
     * @param {Number} daunum
     * @param {String} [interval=d] - y|m|d
     * @returns {Date}
     * @description 원본날짜에서 인자만큼 더해진 날짜 데이터를 반환합니다.
     * @example
     * ```js
     * var myDate = new Date();
     * trace(myDate.add(1));
     * // 내일값이 나옵니다.
     *
     * trace("2013-05-05".date().add(3));
     * // "2013-05-08T03:00:00Z"
     * trace("2013-05-05".date().add(2, 'm'));
     * //  "2013-07-05T03:00:00Z"
     * trace("2013-05-05".date().add(2, 'y'));
     * //  "2015-05-05T03:00:00Z"
     * ```
     */
    function dateAdd(daynum, interval) {
        interval = interval || "d";
        var interval = interval.toLowerCase();
        var DyMilli = ((1000 * 60) * 60) * 24;
        var aDate = new Date(this.getUTCFullYear(), this.getMonth(), this.getDate(), 12);

        if (interval == "d") {
            //trace(aDate.getTime(), (daynum) , (DyMilli));
            aDate.setTime(aDate.getTime() + (daynum * DyMilli));
        }
        else if (interval == "m") {
            var yy = aDate.getFullYear();
            var mm = aDate.getMonth();
            var dd = aDate.getDate();
            /*if (mm == 0 && dd == 1) yy += 1;*/
            yy = yy + parseInt(daynum / 12);
            mm += daynum % 12;
            var mxdd = AXUtil.dayLen(yy, mm);
            if (mxdd < dd) dd = mxdd;
            aDate = new Date(yy, mm, dd, 12);
        }
        else if (interval == "y") {
            aDate.setTime(aDate.getTime() + ((daynum * 365) * DyMilli));
        }
        else {
            aDate.setTime(aDate.getTime() + (daynum * DyMilli));
        }
        return aDate;
    }

    /**
     * @method Data.diff
     * @param {Date|String} edDate
     * @param {String} [type=d] - y|m|d
     * @returns {Number}
     * @description 날짜와 날짜 사이의 날짜 수를 반환합니다.
     * @example
     * ```js
     * trace( "2013-05-05".date().diff("2013-05-08") );
     * // 3
     * trace( "2013-05-05".date().diff("2013-05-08".date()) );
     * // 3
     * ```
     */
    function dayDiff(edDate, tp) {
        var DyMilli = ((1000 * 60) * 60) * 24;
        //trace(this.print() +"/"+ edDate.print() + "//" + ((edDate.date() - this) / DyMilli) + "//" + ((edDate.date() - this) / DyMilli).floor());
        var y1 = this.getFullYear();
        var m1 = this.getMonth();
        var d1 = this.getDate();
        var hh1 = this.getHours();
        var mm1 = this.getMinutes();
        var dd1 = new Date(y1, m1, d1, hh1, mm1, this.getSeconds());

        var day2 = edDate.date();
        var y2 = day2.getFullYear();
        var m2 = day2.getMonth();
        var d2 = day2.getDate();
        var hh2 = day2.getHours();
        var mm2 = day2.getMinutes();
        var dd2 = new Date(y2, m2, d2, hh2, mm2, this.getSeconds());

        if (tp != undefined) {
            if (tp == "D") {
                DyMilli = ((1000 * 60) * 60) * 24;
                dd2 = new Date(y2, m2, d2, hh1, mm1, this.getSeconds());
            }
            else if (tp == "H") {
                DyMilli = ((1000 * 60) * 60);
            }
            else if (tp == "mm") {
                DyMilli = (1000 * 60);
            }
            else {
                DyMilli = ((1000 * 60) * 60) * 24;
                dd2 = new Date(y2, m2, d2, hh1, mm1, this.getSeconds());
            }
        }

        return ((dd2.getTime() - dd1.getTime()) / DyMilli).floor();

    }

    /**
     * @method  Date.print
     * @param {String} [format=yyyy-mm-dd]
     * @returns {type} name
     * @description yyyy:년도, mm:월, dd:일, hh:시, mi:분, ss:초, dw:요일 을 조합하여 format으로 지정하면 그에 맞는 날짜형식 문자열이 반환됩니다.
     * @example
     * ```js
     * "2013-05-05".date().print(); -> "2013-05-05"
     * "2013-05-05".date().print('yyyy년 mm월 dd일'); -> "2013년 05월 05일"
     * "2013-05-05".date().print('yyyy년 mm월 dd일 (dw)'); -> "2013년 05월 05일 (일)"
     * ```
     */
    function toString(format) {
        if (format == undefined) {
            var sSeper = "-";
            return this.getUTCFullYear() + sSeper + (this.getMonth() + 1).setDigit(2) + sSeper + this.getDate().setDigit(2);
        }
        else {
            var fStr = format;
            var nY, nM, nD, nH, nMM, nS, nDW;
            nY = this.getUTCFullYear();
            nM = (this.getMonth() + 1).setDigit(2);
            nD = this.getDate().setDigit(2);
            nH = this.getHours().setDigit(2);
            nMM = this.getMinutes().setDigit(2);
            nS = this.getSeconds().setDigit(2);
            nDW = this.getDay();

            var yre = /[^y]*(yyyy)[^y]*/gi;
            yre.exec(fStr);
            var regY = RegExp.$1;
            var mre = /[^m]*(mm)[^m]*/gi;
            mre.exec(fStr);
            var regM = RegExp.$1;
            var dre = /[^d]*(dd)[^d]*/gi;
            dre.exec(fStr);
            var regD = RegExp.$1;
            var hre = /[^h]*(hh)[^h]*/gi;
            hre.exec(fStr);
            var regH = RegExp.$1;
            var mire = /[^m]*(mi)[^i]*/gi;
            mire.exec(fStr);
            var regMI = RegExp.$1;
            var sre = /[^s]*(ss)[^s]*/gi;
            sre.exec(fStr);
            var regS = RegExp.$1;
            var dwre = /[^d]*(dw)[^w]*/gi;
            dwre.exec(fStr);
            var regDW = RegExp.$1;

            if (regY === "yyyy") {
                fStr = fStr.replace(regY, nY.right(regY.length));
            }
            if (regM === "mm") {
                if (regM.length == 1) nM = (this.getMonth() + 1);
                fStr = fStr.replace(regM, nM);
            }
            if (regD === "dd") {
                if (regD.length == 1) nD = this.getDate();
                fStr = fStr.replace(regD, nD);
            }
            if (regH === "hh") {
                fStr = fStr.replace(regH, nH);
            }
            if (regMI === "mi") {
                fStr = fStr.replace(regMI, nMM);
            }
            if (regS === "ss") {
                fStr = fStr.replace(regS, nS);
            }
            if (regDW == "dw") {
                fStr = fStr.replace(regDW, AXConfig.weekDays[nDW].label);
            }
            return fStr;
        }
    }

    /**
     * @method  Date.getTimeAgo
     * @returns {String}
     * @description 현재와 날짜 데이터 간의 간격을 문자열로 반환합니다.
     * @example
     * ```js
     * var pDate = new Date();
     * pDate.setTime(pDate.getTime()-1000*60);
     * trace( pDate.getTimeAgo() );
     * // 1분 전
     *
     * pDate.setTime(pDate.getTime()-1000*60*5);
     * trace( pDate.getTimeAgo() );
     * //  6분 전
     *
     * pDate.setTime(pDate.getTime()-1000*60*60);
     * trace( pDate.getTimeAgo() );
     * //  1시간 6분 전
     *
     * pDate.setTime(pDate.getTime()-1000*60*60*24);
     * trace( pDate.getTimeAgo() );
     * //  2013년 11월 19일 화
     * ```
     */
    function getTimeAgo() {

        var rtnStr = "";
        var nMinute = Math.abs((new Date()).diff(this, "mm"));

        var wknames = [];
        wknames.push("일", "월", "화", "수", "목", "금", "토");

        if (isNaN(nMinute)) {
            rtnStr = "알수없음";
        }
        else {
            if (parseInt(nMinute / 60 / 24) >= 1) {
                rtnStr = this.print("yyyy년 mm월 dd일") + " " + wknames[this.getDay()];
            }
            else {
                rtnStr = nMinute;

                if ((nMinute / 60) > 1) {
                    rtnStr = parseInt(nMinute / 60) + "시간 " + (nMinute % 60) + "분 전";
                }
                else {
                    rtnStr = nMinute + "분 전";
                }
            }
        }
        return rtnStr;
    }

    function date() { return this; }

    function axtoJSON() { return '"' + this.getUTCFullYear() + '-' + (this.getUTCMonth() + 1).setDigit(2) + '-' + this.getUTCDate().setDigit(2) + 'T' + this.getUTCHours().setDigit(2) + ':' + this.getUTCMinutes().setDigit(2) + ':' + this.getUTCSeconds().setDigit(2) + 'Z"'; }

    /**
     * @method  Date.axGetDay
     * @param {Number} [dayOfStart=0]
     * @returns {Number}
     * @description 요일의 시작인덱스를 변경한 요일인덱스를 반환합니다.
     */
    function axGetDay(dayOfStart) {
        if (dayOfStart == undefined) dayOfStart = 0;
        var myDay = this.getDay() - dayOfStart;
        if (myDay < 0) myDay = 7 + myDay;
        return myDay;
    }

    return {
        add: dateAdd,
        diff: dayDiff,
        print: toString,
        date: date,
        axtoJSON: axtoJSON,
        getTimeAgo: getTimeAgo,
        axGetDay: axGetDay
    }
})());

/**
 * Error.prototype
 * @namespace {Error} Error
 */
Object.extend(Error.prototype, (function () {
    /**
     * 에러넘버와 에러 객체를 리턴합니다.
     * @method Error.print
     * @returns {String}
     */
    function print() {
        return (this.number & 0xFFFF) + " : " + this;
    }

    return {
        print: print
    }
})());

/**
 * Array.prototype
 * @namespace {Array} Array
 */
Object.extend(Array.prototype, (function () {
    /**
     * @method Array.clear
     * @returns {Array}
     * @description Array를 빈 Array 로 변경합니다.
     * @example
     * ```js
     * var a = [1,2,3];
     * trace(a);
     * // [1, 2, 3]
     * trace(a.clear());
     * // []
     * trace(a);
     * // []
     * ```
     */
    function clear() {
        this.length = 0;
        return this;
    }

    /**
     * @method Array.first
     * @returns {Object}
     * @description Array의 첫번째 아이템을 반환합니다.
     * @example
     * ```js
     * var a = [1,2,3];
     * trace(a.first());
     * // 1
     *
     * var b = [{a:"액시스제이"}, 2, 3];
     * trace(b.first());
     * // {"a":"액시스제이"}
     *
     * var c = [[1,2,3], 2, 3];
     * trace(c.first());
     * // [1, 2, 3]
     * ```
     */
    function first() {
        return this[0];
    }

    /**
     * @method Array.last
     * @returns {Object}
     * @description Array의 마지막 아이템을 반환합니다.
     * @example
     * ```js
     * var a = [1,2,3];
     * trace(a.last());
     * // 1
     *
     * var b = [1, 2, {a:"액시스제이"}];
     * trace(b.last());
     * // {"a":"액시스제이"}
     *
     * var c = [1, 2, [1,2,3]];
     * trace(c.last());
     * // [1, 2, 3]
     * ```
     */
    function last() {
        return this[this.length - 1];
    }

    /**
     * 인자값에 해당하는 인덱스의 아이템을 반환합니다.
     * @method Array.getToSeq
     * @param {Number} seq
     * @returns {Object}
     * @example
     * ```js
     * var a = [1,2,3];
     * trace(a.getToSeq(1));
     * // 2
     *
     * var a = [1,{a:2},3];
     * trace(a.getToSeq(1));
     * // {"a":2}
     * ```
     */
    function getToSeq(seq) {
        if (seq > (this.length - 1)) {
            return null;
        }
        else {
            return this[seq];
        }
    }

    function axtoJSON(qoute) {
        var results = [];
        for (var i = 0; i < this.length; i++) results.push(Object.toJSON(this[i], qoute));
        return '[' + results.join(', ') + ']';
    }

    function toJSONforMobile() {
        var results = [];
        for (var i = 0; i < this.length; i++) results.push(Object.toJSONforMobile(this[i]));
        return '[' + results.join(', ') + ']';
    }

    /**
     * 사용자가 정의한 조건에 맞는 아이템을 제거한 Array 를 반환합니다.
     * @method Array.remove
     * @param {Function} callBack - remove 처리할 대상에 return true; 하면 true 인 대상이 제거 됩니다.
     * @returns {Array}
     * @example
     * ```js
     * var a = [1,2,3,4];
     * trace(a);
     * // [1, 2, 3, 4]
     * a = a.remove(function(idx, item){
	 *     return (item == 3);
	 * });
     * trace(a);
     * // [1, 2, 4]
     *  * var b = [1,2,3,4];
     * trace(b);
     * // [1, 2, 3, 4]
     * b = b.remove(function(){
	 *     return (this.item == 3 || this.index == 0);
	 * });
     * trace(b);
     * // [2, 4]
     * ```
     */
    function remove(callBack) {
        var _self = this;
        var collect = [];
        AXUtil.each(this, function (index, O) {
            if (!callBack.call({index: index, item: O}, index, O)) collect.push(O);
        });
        return collect;
    }

    /**
     * 사용자가 정의한 조건에 맞는 아이템 갯수를 반환합니다.
     * @method Array.search
     * @param {Function} callBack
     * @returns {Number}
     * @example
     * ```js
     * var a = [1,2,3,4];
     * trace(a);
     * // [1, 2, 3, 4]
     * trace(a.search(function(idx, item){
	 *     return (item < 3);
	 * }));
     * // 2
     * ```
     */
    function search(callBack) {
        var _self = this;
        var collect = [];
        AXUtil.each(this, function (index, O) {
            if (callBack.call({index: index, item: O}, index, O)) collect.push(O);
        });
        return collect.length;
    }

    /**
     * 사용자가 정의한 조건에 맞는 아이템을 모두 반환합니다.
     * @method Array.searchObject
     * @param {Function} callBack
     * @returns {Array}
     * @example
     * ```js
     * var a = [1,2,3,4];
     * trace(a);
     * // [1, 2, 3, 4]
     * trace(a.searchObject(function(idx, item){
	 *     return (item < 3);
	 * }));
     * // [1, 2]
     *
     * var b = [1,2,3,4];
     * trace(b);
     * // [1, 2, 3, 4]
     * trace(b.searchObject(function(idx, item){
	 *     return (this.item < 3);
	 * }));
     * // [1, 2]
     * ```
     */
    function getObject(callBack) {
        var _self = this;
        var collect = [];
        AXUtil.each(this, function (index, O) {
            if (callBack.call({index: index, item: O}, index, O)) collect.push(O);
        });
        return collect;
    }

    /**
     * 사용자가 정의한 조건에 맞는 아이템을 한 개만 반환합니다.
     * @method Array.hasObject
     * @param {Function} callBack
     * @returns {Object}
     * @example
     * ```js
     * var a = [1,2,3,4];
     * trace(a);
     * // [1, 2, 3, 4]
     * trace(a.has(function(idx, item){
	 *     return (item == 3);
	 * }));
     * // 3
     *
     * var b = [1,2,3,4];
     * trace(b);
     * // [1, 2, 3, 4]
     * trace(b.has(function(idx, item){
	 *     return (this.item == 3);
	 * }));
     * // 3
     * ```
     */
    function hasObject(callBack) {
        var _self = this;
        var collect = null;
        AXUtil.each(this, function (index, O) {
            if (callBack.call({index: index, item: O}, index, O)) {
                collect = O;
                return false;
            }
        });
        return collect;
    }

    /* 13-06-13 메소드 확장 */

    /**
     * Object Array의 키를 정렬한후 가장 작은 값을 반환합니다.
     * @method Array.getMinObject
     * @param {String} key
     * @returns {Object}
     * @example
     * ```js
     * var myArray = [{a:99},{a:2},{a:1}];
     * myArray.getMinObject("a");
     * // Object {a: 1}
     * ```
     */
    function getMinObject(key) {
        var tempArray = this.concat();
        tempArray = tempArray.sort(function (pItem, nItem) {
            var v1 = pItem[key];
            var v2 = nItem[key];
            if (v1 < v2) return -1;
            else if (v1 > v2) return 1;
            else if (v1 == v2) return 0;
        });
        return (tempArray.first() || {});
    }

    /**
     * Object Array의 키를 정렬한후 가장 큰 값을 반환합니다.
     * @method Array.getMaxObject
     * @param {String} key
     * @returns {Object}
     * @example
     * ```js
     * var myArray = [{a:2},{a:99},{a:1}];
     * myArray.getMaxObject("a");
     * // Object {a: 99}
     * ```
     */
    function getMaxObject(key) {
        var tempArray = this.concat();
        tempArray = tempArray.sort(function (pItem, nItem) {
            var v1 = pItem[key];
            var v2 = nItem[key];
            if (v1 < v2) return 1;
            else if (v1 > v2) return -1;
            else if (v1 == v2) return 0;
        });
        return (tempArray.first() || {});
    }

    function m_notall(context) {
        context = context || function (x) { return x; };
        var result = true;
        var i = 0;
        while (i < this.length) {
            result = !Boolean(context(this[i]));
            if (!result) break;
            i++;
        }
        return result;
    }

    function m_any(context) {
        context = context || function (x) { return x; };
        var result = false;
        var i = 0;
        while (i < this.length) {
            result = Boolean(context(this[i], i));
            if (result) break;
            i++;
        }
        return result;
    }

    function m_find(context) {
        context = context || function (x) { return false; };
        var myselect;
        var i = 0;
        while (i < this.length) {
            if (context(this[i], i)) {
                myselect = this[i];
                break;
            }
            i++;
        }
        return myselect;
    }

    function m_find2(context) {
        if (!Object.isFunction(context)) {
            findObj = context;
            context = function (x) { return (x == findObj); }
        }
        var myselect, myindex;
        var i = 0;
        while (i < this.length) {
            if (context(this[i], i)) {
                myselect = this[i];
                myindex = i;
                break;
            }
            i++;
        }
        return {obj: myselect, index: myindex};
    }

    function m_findAll(context) {
        context = context || function (x) { return false; };
        var myselect = [];
        ;
        var i = 0;
        while (i < this.length) {
            if (context(this[i], i)) myselect.push(this[i]);
            i++;
        }
        return myselect;
    }

    /**
     * 리스트형 데이터를 부모 참조키와 자식 참조키를 이용하여 트리형 데이터로 변환처리 합니다.
     * @method Array.convertTree
     * @param {String} parentKey
     * @param {String} childKey
     * @param {String} [hashDigit=3] - 트리의 주소값에 해당하는 hash 의 자릿수 단위 설정 (기본값 3)
     * @returns {Object}
     * @example
     * ```js
     * var a = [
     *     {pno:0, no:1, name:"장기영"},
     *     {pno:1, no:2, name:"장기영"},
     *     {pno:1, no:3, name:"장기영"},
     *     {pno:3, no:4, name:"장기영"},
     *     {pno:3, no:5, name:"장기영"},
     *     {pno:5, no:6, name:"장기영"},
     *     {pno:5, no:7, name:"장기영"}
     * ];
     *
     * var myTree = a.convertTree("pno", "no");
     * trace(myTree);
     * //[{"pno":0, "no":1, "name":"장기영", "subTree":[{"pno":1, "no":2, "name":"장기영", "__subTreeLength":0, "subTree":[], "pHash":"000_000", "hash":"000_000_000"}, {"pno":1, "no":3, "name":"장기영", "__subTreeLength":2, "subTree":[{"pno":3, "no":4, "name":"장기영", "__subTreeLength":0, "subTree":[], "pHash":"000_000_001", "hash":"000_000_001_000"}, {"pno":3, "no":5, "name":"장기영", "__subTreeLength":2, "subTree":[{"pno":5, "no":6, "name":"장기영", "__subTreeLength":0, "subTree":[], "pHash":"000_000_001_001", "hash":"000_000_001_001_000"}, {"pno":5, "no":7, "name":"장기영", "__subTreeLength":0, "subTree":[], "pHash":"000_000_001_001", "hash":"000_000_001_001_001"}], "pHash":"000_000_001", "hash":"000_000_001_001"}], "pHash":"000_000", "hash":"000_000_001"}], "__subTreeLength":2, "pHash":"000", "hash":"000_000"}]
     * ```
     */
    function convertTree(parentKey, childKey, hashDigit) {
        var tree = [];
        var pointer = {};
        var seq = 0;
        var hashDigit = hashDigit || 3;
        for (var idx = 0; idx < this.length; idx++) {
            var L = this[idx];
            if (!L.isRoot) {
                pointer[L[childKey]] = idx;

                if (typeof L[parentKey] === "undefined" || L[parentKey] == "" || L[parentKey].number() == 0) {
                    L["subTree"] = [];
                    L.__subTreeLength = 0;
                    L["pHash"] = "0".setDigit(hashDigit);
                    L["hash"] = "0".setDigit(hashDigit) + "_" + seq.setDigit(hashDigit);
                    tree.push(AXUtil.copyObject(L));
                    seq++;
                }
                else {
                    L.__subTreeLength = 0;
                }
            }
        }

        for (var idx = 0; idx < this.length; idx++) {
            var L = this[idx];
            if (L["pHash"] == undefined && !L.isRoot) {
                var pItem = this[pointer[L[parentKey]]];
                var pHash = pItem["hash"];
                var pHashs = pHash.split(/_/g);
                var pTree = tree;
                var pTreeItem;
                axf.each(pHashs, function (idx, T) {
                    if (idx > 0) {
                        pTreeItem = pTree[T.number()];
                        pTree = pTree[T.number()].subTree;
                    }
                });
                L["subTree"] = [];
                var __subTreeLength = pItem.__subTreeLength;

                L["pHash"] = pHash;
                L["hash"] = pHash + "_" + __subTreeLength.setDigit(hashDigit);
                pTree.push(AXUtil.copyObject(L));
                pItem.__subTreeLength++;
                pTreeItem.__subTreeLength = pItem.__subTreeLength;
            }
        }
        return tree;
    }

    /**
     * 조건에 맞는 아이템을 index 값과 함께 반환합니다.
     * @method Array.getIndex
     * @param {Function} context
     * @returns {Object}
     * @example
     * ```js
     * var b = [1,2,3,4];
     * trace(b);
     * // [1, 2, 3, 4]
     * trace(b.getIndex(function(idx, item){
	 *     return (this.item >= 3);
	 * }));
     * //  {"item":3, "index":2}
     * ```
     */
    function getIndex(context) {
        if (!Object.isFunction(context)) {
            findObj = context;
            context = function (x) { return (x == findObj); }
        }
        var findObject, findIndex;
        var i = 0;
        while (i < this.length) {
            var sobj = {
                index: i,
                item: this[i]
            };
            if (context.call(sobj, sobj)) {
                findObject = this[i];
                findIndex = i;
                break;
            }
            i++;
        }
        return {item: findObject, index: findIndex};
    }

    return {
        clear: clear,
        first: first,
        last: last,
        getToSeq: getToSeq,
        axtoJSON: axtoJSON,
        toJSONforMobile: toJSONforMobile,
        remove: remove,
        search: search,
        has: hasObject,
        searchObject: getObject,
        getMinObject: getMinObject,
        getMaxObject: getMaxObject,

        not: m_notall,
        or: m_any,
        get: m_find,
        gets: m_findAll,
        getObj: m_find2,
        getIndex: getIndex,
        convertTree: convertTree
    }
})());

//JSON.stringify = Object.toJSON;
function AXgetId(id) { return document.getElementById(id); }
function AX_A(iterable) {
    if (!iterable) return [];
    if ('toArray' in Object(iterable)) return iterable.toArray();
    var length = iterable.length || 0, results = new Array(length);
    while (length--) results[length] = iterable[length];
    return results;
}

var trace = axf.console;
var getUrlInfo = axf.getUrlInfo;
/* ---------------------------- */
/**
 * AXJ UI 클래스 기본형
 * @class AXJ
 */
var AXJ = Class.create({
/**
 * @member AXJ.config
 * @description UI클래스 설정 변수
 */
    initialize: function () {
        this.config = {
            debugMode: false,
            hashSpliter: "_",
            href: "href=\"javascript:;\""
        };
    },
    init: function () {
        trace(Object.toJSON(this.config));
    },
    echo: function (msg, mtype) {
        if (mtype == undefined || mtype == "console")
            trace(msg);
        else if (mtype == "alert")
            AXUtil.alert(msg);
        else if (mtype == "toast")
            toast.push(msg);
        else if (mtype == "dialog")
            dialog.push(msg);
    },
/**
 * @method AXJ.setConfig
 * @param {Object} configs - 속성오브젝트
 * @returns {AXJ}
 * @description UI 클래스의 속성을 정의 또는 재정의 하고 클래스내부에 init 메소드를 호출합니다.
 * @example
 ```js
myClass.setConfig({
	a:1, b:2, c:function(){}
});
 ```
 */
    setConfig: function (configs) {
		// overwrite this.config
		if (configs) {for ( k in configs ) {if (configs.hasOwnProperty(k)) this.config[k] = configs[k];}}
		// configs에 targetID가 없고 target만 지정한 경우 targetID 자동생성
        if(this.config.target) if(this.config.target.id === undefined || this.config.target.id == "") axdom(this.config.target).attr("id", this.config.target.id = this.config.targetID = "AXJUnique_"+axf.getUniqueId());
        this.init();
	    return this;
    },
/**
 * @method AXJ.changeConfig
 * @param {Object} configs - 속성오브젝트
 * @returns {AXJ}
 * @description UI 클래스의 속성을 변경 합니다.
 * @example
 ```js
myClass.changeConfig({
	a:1
});
 ```
 */
    changeConfig: function (configs) {
	    if (configs) {for ( k in configs ) {if (configs.hasOwnProperty(k)) this.config[k] = configs[k];}}
	    return this;
    },
/**
 * @method AXJ.getEventTarget
 * @param {Object} args - 설명
 * @returns {Null}
 * @description 설명
 * @example
 ```js
var myTarget = this.getEventTarget({
    evt : event.target,
	until:function(evt, evtIDs){
		// 선택 조건
		// event bubble 탐색 종료 시점 정의 함수 argument 로 받은 eventTarget 과 evtIDs 객체로 부터 다양한 조건으로 설정가능
		// return true; 하면 버블 탐색 종료 됨.
		// return ( axdom(evt.parentNode).hasClass("CTclassName") );
		return (evt.parentNode.tagName == "body");
	},
	find:function(evt, evtIDs){
		// return true; 하면 버블탐색 종료 후 현재 eventTarget 리턴
		//return ( axdom(evt).hasClass("colHeadTd") );
		return ( evt.id == objID || (evtIDs[0] == cfg.targetID && evtIDs[1] == objID) );
	}
});

if(myTarget){
	//something
}
 ```
*/
    getEventTarget: function (args) {
        var eventTarget = args.evt;
        var eid = (eventTarget && eventTarget.id && eventTarget.id != "") ? eventTarget.id.split(/_AX_/g) : [];
        if (eventTarget) {
            while (!args.find(eventTarget, eid)) {
                if (!eventTarget.parentNode) { eventTarget = null; break; }
                if (args.until) { if (args.until(eventTarget, eid)) { eventTarget = null; break; } }
                if (eventTarget.parentNode) {
                    eventTarget = eventTarget.parentNode;
                    try {
                        eid = (eventTarget && eventTarget.id && eventTarget.id != "") ? eventTarget.id.split(/_AX_/g) : [];
                    } catch (e) {
                        eid = [];
                    }
                } else {
                    break;
                }
            }
        }
        return eventTarget;
    },
/**
 * @method AXJ.getMousePositon
 * @param {eventObject} event
 * @returns {Object} css - pageX, pageY
 * @description 스크롤된 페이지에서 이벤트의 마우스 x,y 페이지포지션을 구해줍니다.
 */
    getMousePositon: function (event) {
        var eventDoc, doc, body;
        eventDoc = document;
        doc = eventDoc.documentElement;
        body = eventDoc.body;
        var css = {};

        //trace({ cy: event.clientY, st: (doc && doc.scrollTop || body && body.scrollTop || 0), ct: (doc && doc.clientTop || body && body.clientTop || 0) });
        css.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
        css.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        return css;
    },
/**
 * @method AXJ.stopEvent
 * @param {eventObject} event - 이벤트
 * @description 이벤트 버블링을 중지 합니다.
 * @example
```js
var _this = this;
axdom("#" + elementID).on("mousedown", function(event){
	_this.stopEvent();
});
 ```
 */
    stopEvent: function (event) {
		try {
			if (event.preventDefault) event.preventDefault();
	        if (event.stopPropagation) event.stopPropagation();
			event.cancelBubble = true;
		}catch(e){

		}
        return false;
    },
/**
 * @method AXJ.clearRange
 * @returns {AXJ}
 * @description 현재 페이지의 모든 사용자 선택을 취소 합니다.
 * @example
```js
this.clearRange();
```
 */
    clearRange: function () {
        if (window.getSelection) {
            if (window.getSelection().empty) {  // Chrome
                window.getSelection().empty();
            } else if (window.getSelection().removeAllRanges) {  // Firefox
                window.getSelection().removeAllRanges();
            }
        } else if (document.selection) {  // IE?
            document.selection.empty();
        }
		return this;
    },
/**
 * @method AXJ.windowResize
 * @description windowResizeApply메소드 호출을 연속으로 수행되지 않도록 하는 보호장치
 * @example
```js
 var _this = this;
 $(window).resize(function(){
   _this.windowResize();
 });
 // 결과적으로 windowResizeApply가 호출됩니다.
```
 */
    windowResize: function () {
        var windowResizeApply = this.windowResizeApply.bind(this);
        if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
        this.windowResizeObserver = setTimeout(function () {
            windowResizeApply();
        }, 1);
    },
    windowResizeApply: function () {

    }
});

/**
 * @namespace {jQueryObject} jQueryExtends
 */

// -- AXReq ----------------------------------------------
/**
 * @class AXReqQue
 * @version v1.4
 * @author tom@axisj.com
 * @logs
 * 2012-09-28 오후 2:58:32 - 시작
 * 2014-04-10 - tom : onbeforesend 옵션 추가 return false 하면 호출 제어됨.
 * 2014-10-06 - tom : dataSendMethod bug fix.
 * 2014-12-31 - tom : AXConfig.AXReq.pars 확장
 * 2015-03-19 - tom : AXConfig.AXReq.dataSendMethod = "json|query-json|parameter" 옵션을 수용하도록 변경 *
 */
var AXReqQue = Class.create({
/**
 * AJAX호출 큐
 * @member {Array} AXReqQue.que
 */
/**
 * AJAX호출 진행상태
 * @member {Boolean} AXReqQue.busy
 */
    initialize: function () {
        this.que = [];
        this.busy = false;
    },
/**
 * @method AXReqQue.add
 * @param {Object} obj - ajax config
 * @returns {AXReqQue}
 * @description que.push
 */
    add: function (obj) {
        this.que.push(obj);
        try {
            this.start();
        } catch (e) {

        }
		return this;
    },
/**
 * @method AXReqQue.start
 * @description que에 담긴 AJAX호출을 처리합니다.
 */
    start: function () {
        if (this.que.length == 0) return;
        if (this.busy) return;

        this.busy = true;
        var myQue = this.que.first();
        var _self = this;
        var config = {
            type: "post",
            onsucc: "",
            async: AXConfig.AXReq.async,
            responseType: AXConfig.AXReq.responseType,
            dataType: AXConfig.AXReq.dataType,
            contentType: AXConfig.AXReq.contentType,
            debug: false
        };
        axf.each(myQue.configs, function (k, v) { // update to {this.config}
            if (k == "pars") {

            }
            else {
                config[k] = v;
            }
        });

        var onerr = this.onerror.bind(this);
        var ontimeout = this.ontimeout.bind(this);
        var onsucc = this.onsucc.bind(this);
		var dataSendMethod = (myQue.configs.dataSendMethod || AXConfig.AXReq.dataSendMethod || "");
        if (dataSendMethod != "json") {

        } else {
            if (typeof myQue.configs.pars == "object") {
                myQue.configs.pars.dummy = AXUtil.timekey();
            } else if (typeof myQue.configs.pars == "string") {
                if (myQue.configs.pars == "") myQue.configs.pars += "dummy=" + AXUtil.timekey();
                else myQue.configs.pars += "&dummy=" + AXUtil.timekey();
            }
        }

        if (config.debug) trace({ url: myQue.url, pars: myQue.configs.pars });

        var ajaxOption = {}, pars;
        axf.each(config, function (k, v) { // update to {this.config}
            ajaxOption[k] = v;
        });
        ajaxOption.url = myQue.url;
        pars = myQue.configs.pars;
        if(dataSendMethod != "DTO" && AXConfig.AXReq.pars){
            if (typeof pars == "object") {
                if (typeof AXConfig.AXReq.pars == "object") {
                    pars = jQuery.extend(pars, AXConfig.AXReq.pars);
                } else if (typeof AXConfig.AXReq.pars == "string") {
                    pars = jQuery.extend(pars, AXConfig.AXReq.pars.queryToObject());
                }
            }else if (typeof pars == "string") {
                if (typeof AXConfig.AXReq.pars == "object") {
                    pars += "&" + jQuery.param(AXConfig.AXReq.pars);
                } else if (typeof AXConfig.AXReq.pars == "string") {
                    pars += "&" + AXConfig.AXReq.pars;
                }
            }
        }

		if (dataSendMethod == "json") {
			ajaxOption["data"] = Object.toJSON( ((typeof pars == "string") ? pars.queryToObject() : pars ) );
		}else if (dataSendMethod == "query-json") {
			ajaxOption["data"] = "{queryString:\"" + pars + "\"}";
		}else {
			ajaxOption["data"] = pars;
		}

		ajaxOption.success = onsucc;
        ajaxOption.error = onerr;
        ajaxOption.timeout = ontimeout;

        if (myQue.configs.onbeforesend) {
            if(!myQue.configs.onbeforesend.call(ajaxOption)){
                return false;
            }
        }

        this.que[0]._jQueryAjax = axdom.ajax(ajaxOption);
    },
    onsucc: function (req) {
        if (req != undefined) {
            var myQue = this.que.first(), res;

            try {
                if (myQue.configs.debug) trace("onsucc" + req);

                if (myQue.configs.responseType == "text/html") {
                    res = req;
                } else {
                    if ((typeof req) == "string") {
                        res = req.object();
                    } else {
                        res = AXConfig.AXReq.resultFormatter.call(req);
                    }
                }

                if (res.result == "syntaxerr") {
                    if (myQue.configs.onerr) myQue.configs.onerr(res);
                } else {
                    if (myQue.configs.onsucc) myQue.configs.onsucc(res);
                }
            } catch (e) {
                if (myQue.configs.responseType == "text/html") {

                } else {
                    res.e = e;
                }
                if (myQue.configs.onerr) myQue.configs.onerr(res);
            }

            this.que.shift();
            this.busy = false;
            this.start();
        }
    },
    onerror: function (req) {
        var myQue = this.que.first();
        if (myQue.configs.onerr) myQue.configs.onerr(req);
        else trace("error : " + Object.toJSON(req));

        this.que.shift();
        this.busy = false;
        try {
            mask.close();
        } catch (e) { }
    },
    ontimeout: function (req) {
        trace("onTimeout:" + req.responseText);
        this.que.shift();
        this.busy = false;
        try {
            mask.close();
        } catch (e) { }
    },
/**
 * @method AXReqQue.abort
 * @returns {AXReqQue} AXReqQue
 * @description 설명
 * @example
```js
 // AXCore.js파일 에서 미리선언된 AXReqQue의 인스턴스 myAXreqQue를 이용하여 abort 명령을 내릴수 있습니다.
 myAXreqQue.abort();
 // 또는
 AXReqAbort();
 // 현재 진행중인 AJAX호출을 취소시켜줍니다.
```
 */
    abort: function(){
        try{
            this.que[0]._jQueryAjax.abort();
        }catch(e){

        }
		return this;
    }
});
var myAXreqQue = new AXReqQue();
var AXReqAbort = function(){
    myAXreqQue.abort();
};

/**
 * @class AXReq
 * @param {String} url - 비동기 호출 URL
 * @param {Object} config - 비동기 호출 설정
 * @description AJAX 호출구문을 AXReqQue 에 add 하여 비동기 호출합니다.
 * @example
```
var url = "";
var pars = "";
new AXReq(url, {
	debug: [true|false] default false,
	type: ["GET"|"POST"|"PUT"|"DELETE"|String] default "POST",
	contentType: [AJAX content type] optional,
	responseType: [AJAX response type] optional,
	dataType: [Ajax data type] optional,
	headers: [AJAX headers] optional,
	pars: [parameter|Object],
	onsucc: [Function],
	onerr: [Function] optional
});
```
 */
var AXReq = Class.create({
    initialize: function (url, configs) {
        myAXreqQue.add({ url: url, configs: configs });
    }
});
/* ---------------------------------------------- AXReq -- */

/* -- AXMask ---------------------------------------------- */
/**
 * @class AXMask
 * @version v1.4
 * @author tom@axisj.com
 * @logs
 * 2012-09-28 오후 2:58:32 - 시작
 * append 메소드 추가
 * 2014-09-17 hyunjun19 : 지정한 대상의 영역만 masking 하도록 style 추가
 * 2015-04-19 tom : body.data에 마스크상태값 저장
 * 2015-05-16 tom : mask.close(delay) 중 open 되면 예외처리, open상태에서 다시 open 도 예외처리
 * @description 웹페이지 전체에 사용자 입력을 막기위한 마스크를 추가하는데 사용
 * ```js
 mask.open();
 ```
 *
 */
var AXMask = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();
        this.selects = [];
        this.config.maskClassName = "AXMask";
        this.config.maskContentClassName = "AXMaskContent";
        this.config.content = "disable content";
        this.config.maskZindex = "5000";
        this.blinkTrack = [];
    },
    init: function () {
        this.mask = axdom("<div class=\"" + this.config.maskClassName + "\" style=\"z_index:" + this.config.maskZindex + "\"></div>");
    },
    open: function (configs) {
        if(this.maskDelay) clearTimeout(this.maskDelay);
        if(axdom(document.body).data("masked") != "true"){
            axdom(document.body).append(this.mask);
            axdom(document.body).data("masked", "true");
            var bodyHeight = 0;
            (AXUtil.docTD == "Q") ? bodyHeight = document.body.clientHeight : bodyHeight = document.documentElement.clientHeight;

            if (configs) {
                if (!configs.onclick) configs.onclick = configs.onClick;
                if (configs.onclick) {
                    this.mask.bind("click.AXMask", configs.onclick);
                }
            }
        }
    },
    append: function (targetID, configs) {
        var target = axdom("#"+targetID);
        if (target.css("position") == "static") { target.css("position", "relative") }
        target.append(this.mask.css({ 'position': 'absolute', 'top': 0, 'left': 0 }));

        if(configs){
            if(!configs.onclick) configs.onclick = configs.onClick;
            if(configs.onclick){
                this.mask.bind("click.AXMask", configs.onclick);
            }
        }
    },
    close: function (delay) {
        if (!delay) {
            this.mask.unbind("click.AXMask");
            this.mask.remove();
            axdom(document.body).data("masked", null);
        } else {
            var maskHide = this.hide.bind(this);
            if(this.maskDelay) clearTimeout(this.maskDelay);
            this.maskDelay = setTimeout(maskHide, delay);
        }
        this.blinkTrack.clear();
    },
    hide: function () {
        this.mask.unbind("click.AXMask");
        this.mask.remove();
        axdom(document.body).data("masked", null);
        this.blinkTrack.clear();
    },
    setCSS: function (CSS) {
        this.mask.css(CSS);
    },
    addClass: function (className) {
        this.mask.addClass(className);
    },
    removeClass: function (className) {
        this.mask.removeClass(className);
    },
    blink: function (obj) {
        this.blinkTrack = [{ css: { opacity: 0.1 }, time: 1000 }, { css: { opacity: 0.8 }, time: 1000 }];
        if (obj) this.blinkTrack = obj;
        this.blinking(0);
    },
    stopBlink: function (obj) {
        this.blinkTrack.clear();
    },
    blinking: function (blinkIndex) {
        if (this.blinkTrack.length > 0) {
            var blinkTrack = this.blinkTrack;
            var onblink = this.blinking.bind(this);
            this.mask.animate(blinkTrack[blinkIndex].css, blinkTrack[blinkIndex].time, 'circInOut', function () {
                onblink((blinkIndex + 1) % blinkTrack.length);
            });
        }
    },
    setContent: function(content){
        var po = [];
        if(Object.isString(content)){
            po.push(content);
        }else{
            var po = [];
            po.push("<div style='width: "+content.width+"px;height:"+content.height+"px;position: absolute;left:50%;top:50%;text-align: center;margin-left: -"+ (content.width/2) +"px;margin-top:-"+ (content.height/2) +"px;'>");
            po.push(content.html);
            po.push("</div>")
        }
        this.mask.html(po.join(''));
    }
});
var mask = new AXMask();
mask.setConfig();

/**
 * @method AXMask.open
 * @param {Object} config - 설명
 * @returns {Null}
 * @description 설명
 * @example
```
 mask.open({onclick:function(){
    // mask click event
 });
 mask.open();
```
 */


/**
 * @method jQueryExtends.mask
 * @param {Object} config - 설명
 * @returns {jQueryObject}
 * @description mask 삽입위치를 엘리먼트 다음의 위치로 합니다.
 * @example
 ```
 $("#target").mask();
 $("#target").mask({
    onclick: function(){
        // mask click event
    }
 });
 ```
 */
axdom.fn.mask = function (configs) {
	axf.each(this, function () {
		mask.append(this.id, configs);
	});
	return this;
};

/* ---------------------------------------------- AXMask -- */

/* -- AXNotification ---------------------------------------------- */
/**
 * AXNotification
 * @class AXNotification
 * @extends AXJ
 * @version v1.7
 * @author tom@axisj.com
 * @logs
 "2012-10-30 오후 12:01:10",
 "2013-01-09 오후 1:46:55 push type bug fix - tom"
 "2014-05-23 tom : dialog 에서 mask 제어 안하도록 변경"
 "2014-05-26 tom : dialog 에서 top 속성 설정 추가"
 "2014-08-16 tom : dialog body에서 \n -> <br/> auto replace "
 "2014-08-25 tom : dialog body에서 \n -> <br/> auto replace 예외처리 "
 "2015-01-12 tom : ie7,8 fadeOut error fix https://github.com/axisj-com/axisj/issues/386"
 "2015-01-19 tom : https://github.com/axisj-com/axisj/issues/392 dialog에 onConfirm 추가"
 "2015-04-14 tom : https://github.com/axisj-com/axisj/issues/532 dialog에 onclose 추가"
 */
var AXNotification = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();
        this.Observer = null;
        this.lasBreadSeq = 0;
        this.bread = [];
        this.config.easing = { open: { duration: 300, easing: "expoOut" }, close: { duration: 500, easing: "expoOut" } };
        this.config.eatUpTime = 2500;
        this.config.confirmStr = "확인";
        this.config.cancelStr = "취소";
    },
    init: function () {
        var config = this.config;
        if (config.type == "toast") {
            this.toastTray = axdom("<div class=\"AXNotificationTray\" id=\"" + config.targetID + "\"></div>");
        } else if (config.type == "dialog") {
            this.dialogTray = axdom("<div class=\"AXNotificationTrayDialog\" id=\"" + config.targetID + "\"></div>");
            //dialog type display center;
        }
    },
    push: function (obj) {
        var config = this.config;
        var breadID = config.targetID + "" + this.lasBreadSeq;
        this.lasBreadSeq++;

        var po = [];
        if ((typeof obj).toLowerCase() != "object") {
            po.push("<div class=\"AXNotification\" id=\"bread_AX_" + breadID + "\" style=\"display:none;\">");
            if (config.type == "dialog") {
                po.push("<div class=\"AXNotificationHead\">" + (obj.title || "Dialog Message") + "</div>");
            }
            po.push("<div class=\"AXNotificationCT\">");
            po.push("	<table cellpadding=\"0\" cellspacing=\"0\" class=\"AXNotificationTable\">");
            po.push("		<tbody>");
            po.push("			<tr>");
            po.push("				<td class=\"AXNotificationIcon\"></td>");
            po.push("				<td class=\"AXNotificationBody\">");
	        if(Object.isString(obj)){
		        po.push(obj.crlf());
	        }else{
		        po.push(obj);
	        }
            po.push("				</td>");
            po.push("			</tr>");
            po.push("		</tbody>");
            po.push("	</table>");

            if (config.type == "dialog") {
                po.push("	<div class=\"AXNotificationButtons\">");
                po.push("	<input type=\"button\" value=\"" + config.confirmStr + "\" class=\"AXButton Red\"  id=\"bread_AX_" + breadID + "_AX_confirm\" />");
                po.push("	</div>");
            }

            po.push("</div>");
            po.push("</div>");

        } else {
            po.push("<div class=\"AXNotification " + obj.type + "\" id=\"bread_AX_" + breadID + "\" style=\"display:none;\">");
            if (config.type == "dialog") {
                po.push("<div class=\"AXNotificationHead\">" + (obj.title || "Dialog Message") + "</div>");
            }
            po.push("<div class=\"AXNotificationCT\">");
            po.push("	<table cellpadding=\"0\" cellspacing=\"0\" class=\"AXNotificationTable\">");
            po.push("		<tbody>");
            po.push("			<tr>");
            po.push("				<td class=\"AXNotificationIcon\"></td>");
            po.push("				<td class=\"AXNotificationBody\">");
            if(Object.isString(obj.body)){
	            po.push(obj.body.crlf());
            }else{
	            po.push(obj.body);
            }
            po.push("				</td>");
            if (obj.type == "Caution" && config.type != "dialog") {
                if (!obj.buttons) {
                    po.push("				<td class=\"AXNotificationButton\" align=\"right\">");
                    po.push("				<input type=\"button\" value=\"" + config.confirmStr + "\" class=\"AXButton Red\"  id=\"bread_AX_" + breadID + "_AX_confirm\" />");
                    po.push("				</td>");
                }
            }
            po.push("			</tr>");
            po.push("		</tbody>");
            po.push("	</table>");
            if (obj.buttons) {
                po.push("	<div class=\"AXNotificationButtons\">");
                AXUtil.each(obj.buttons, function (index, B) {
                    po.push("	<input type=\"button\" value=\"" + this.buttonValue + "\" class=\"AXButton " + (this.buttonClass || "") + "\"  id=\"bread_AX_" + breadID + "_AX_buttons_AX_" + index + "\" />");
                });
                po.push("	</div>");
            } else if (config.type == "dialog") {
                po.push("	<div class=\"AXNotificationButtons\">");
                po.push("	<input type=\"button\" value=\"" + config.confirmStr + "\" class=\"AXButton Red\"  id=\"bread_AX_" + breadID + "_AX_confirm\" />");
                po.push("	</div>");
            }
            po.push("</div>");
            po.push("</div>");

        }

        if (config.type == "toast") {
            if (!AXgetId(config.targetID)) axdom(document.body).append(this.toastTray);
            this.bread.push({ breadID: breadID, type: obj.type, html: po.join('').enc() });
            this.insertBread(obj);
        }
        else
        if (config.type == "dialog") {
            if (!AXgetId(config.targetID)) axdom(document.body).append(this.dialogTray);
            this.dialogTray.prepend(po.join(''));

            var bodyWidth = (AXUtil.docTD == "Q") ? document.body.clientWidth : document.documentElement.clientWidth;
            //var l = bodyWidth / 2 - this.dialogTray.width() / 2;
	        if(obj.top != undefined){
		        this.dialogTray.css({ top:obj.top });
	        }else{
		        this.dialogTray.css({ top:50 });
	        }

            var breadBox = axdom("#bread_AX_" + breadID);
            breadBox.fadeIn();

            var endCheck = this.endCheck.bind(this);

            //Confirm button
            axdom("#bread_AX_" + breadID + "_AX_confirm").bind("click", function () {
                if (obj.onConfirm) obj.onConfirm(obj.data);
                breadBox.find("button, input").hide();
                breadBox.fadeOut({
                    duration: config.easing.close.duration, easing: config.easing.close.easing, complete: function () {
                        breadBox.remove();
                        endCheck();
                    }
                });
            });

            //AXBUTTON
            axdom(".AXNotificationButtons").find(".AXButton").bind("click", function (event) {
                var eid = event.target.id.split(/_AX_/g);
                var myBreadID = eid[1];
                var buttonSeq = eid.last(), breadBox = axdom("#bread_AX_" + myBreadID);
                if (obj.buttons) {
                    if (obj.buttons[buttonSeq]) {
                        if (obj.buttons[buttonSeq].onClick) obj.buttons[buttonSeq].onClick(obj.buttons[buttonSeq].data);
                    }
                }
                breadBox.find("button, input").hide();
                breadBox.fadeOut({
                    duration: config.easing.close.duration, easing: config.easing.close.easing, complete: function () {
                        breadBox.remove();
                        endCheck();
                    }
                });
            });

            axdom(".AXNotificationButtons").find(".AXButton").get(0).focus();

            axdom(document.body).unbind("keyup."+breadID).bind("keyup."+breadID, function(event){
                if(event.keyCode == AXUtil.Event.KEY_ESC){
                    axdom("#bread_AX_" + breadID).fadeOut({
                        duration: config.easing.close.duration, easing: config.easing.close.easing, complete: function () {
                            axdom("#bread_AX_" + breadID).remove();
                            endCheck(breadID, obj);
                        }
                    });
                }
            });
        }
    },
    insertBread: function (obj) {
        var config = this.config;
        if (this.bread.length == 0) {
            return;
        }
        if (this.busy) return;
        this.busy = true;

        var nextBread = this.nextBread.bind(this);
        var endCheck = this.endCheck.bind(this);

        var myQue = this.bread.first();
        var breadID = myQue.breadID, breadBox;
        axdom("#" + config.targetID).prepend(myQue.html.decode());
        breadBox = axdom("#bread_AX_" + breadID);

        axdom("#bread_AX_" + breadID + "_AX_confirm").bind("click", function () {
            if (obj.onConfirm) obj.onConfirm(obj.data);
            breadBox.find("button, input").hide();
            breadBox.fadeOut({
                duration: config.easing.close.duration, easing: config.easing.close.easing, complete: function () {
                    breadBox.remove();
                    endCheck();
                }
            });
        });

        axdom("#bread_AX_" + breadID).slideDown({
            duration: config.easing.open.duration, easing: config.easing.open.easing, complete: function () {
                nextBread();
                //axdom("#msg").html(axdom("#msg").html()+"<br/>"+AXgetId("bread_AX_"+breadID)+"/"+breadID);
                if (myQue.type != "Caution") {
                    setTimeout(function () {
                        breadBox.fadeOut({
                            duration: config.easing.close.duration, easing: config.easing.close.easing, complete: function () {
                                breadBox.remove();
                                endCheck();
                            }
                        });
                    }, config.eatUpTime);
                }
            }
        });
    },
    nextBread: function () {
        this.bread.shift();
        this.busy = false;
        this.insertBread();
    },
    endCheck: function (breadID, obj) {
        if (axdom("#" + this.config.targetID).html() == "") {
            this.lasBreadSeq = 0;
            if (this.config.type == "dialog") {
                if(breadID) {
                    axdom(document.body).unbind("keyup." + breadID);
                    if(obj && obj.onclose) obj.onclose.call(obj, obj);
                }
            }
        }
    }
});

/**
 * @method AXNotification.push
 * @param {Object|String} content - 대상물 문자열 혹은 오브젝트로 구성
 * @description notification은 dialog, toast 2가지 형태가 존재하고 각각 push 메소드를 이용하여 출력한다.
 * @example
```
 //toast
 toast.push('<b>Complete</b>\n Complete messange send !!');
 toast.push({body:'<b>Warning</b> Warning messange send !!', type:'Warning'});
 toast.push({body:'<b>Caution</b> Caution messange send !!', type:'Caution'});

 //dialog
 dialog.push('<b>Alert</b>\n Application Call dialog push');
 dialog.push({body:'<b>Warning</b> Application Call dialog push', type:'Warning'});
 dialog.push({body:'<b>Caution</b> Application Call dialog push', type:'Caution', onConfirm:fnObj.btnOnConfirm, data:'onConfirmData'});
 dialog.push({
	body:'<b>Caution</b> Application Call dialog push', top:0, type:'Caution', buttons:[
	    {buttonValue:'button1', buttonClass:'Red W100', onClick:fnObj.btnClick, data:'data1'},
	    {buttonValue:'button2', buttonClass:'Blue', onClick:fnObj.btnClick, data:'data2'},
	    {buttonValue:'button3', buttonClass:'Green', onClick:fnObj.btnClick, data:'data3'}
	]
 });
```
 */
var toast = new AXNotification();
toast.setConfig({ targetID: "basicToast", type: "toast" });

var dialog = new AXNotification();
dialog.setConfig({ targetID: "basicDialog", type: "dialog" });
/* ---------------------------------------------- AXNotification -- */

/**
 * AXScroll
 * @class AXScroll
 * @extends AXJ
 * @version v1.53.1
 * @author tom@axisj.com, axisj.com
 * @logs
 "2012-10-10 오전 11:17:34",
 "2013-01-08 오후 2:33:39 스크롤대상을 스크롤바에서 컨테이너 기준으로 변경 - root",
 "2013-01-09 오후 1:29:26 mobile 환경에서 클릭버그수정 - tom",
 "2013-01-11 오후 4:18:21 스크롤바 드래그시 컨테이너 top 계산 수정-root",
 "2013-01-11 오후 5:18:54 컨테이너와 스크롤타겟의 높이에 따른 스크롤바표시 관련 수정-root",
 "2013-01-31 오후 3:10:02 스크롤바가 최소일때 휠 및 드래그 계산수정-root ",
 "2013-02-08 오후 5:48:26 컨테이너가 스크롤타켓보다 길때 휠 함수 중단 처리 - tom",
 "2013-02-16 오후 4:13:16 unbind 후 다시 bind할때 생기는 이벤트 중첩현상 처리 - tom",
 "2013-08-01 오후 4:54:17 mobile touch 버그픽스 - tom ",
 "2013-10-16 오후 6:45:48 mobile 스크롤 속도문제 패치 - tom",
 "2013-11-28 오전 11:23:11 tom - AX scrollTop 메소드 추가",
 "2013-12-12 오전 10:25:28 tom - moveTo 메소드 추가",
 "2014-01-06 오후 12:55:20 tom - 관성 작용중 touchStart stop 버그픽스",
 "2014-03-31 오후 6:26:34 root - yscroll 이 없어지면 scroll top 을 0으로"
 "2014-06-13 tom scrollBar 와 content 싱크방식 변경 / 버그픽스"
 "2014-07-14 tom issue#221, issue#222 fix"
 "2014-08-20 tom focusElement 버그픽스"
 "2014-08-28 tom setSBPosition 예외사항 exeception"
 * @example
 *```js
 * var myUIScroll = new AXScroll(); // 스크롤 인스턴스 선언
 * myUIScroll.setConfig({
 *     targetID:"UIScrollContainer",
 *     scrollID:"UIScrollTarget"
 * });
 *```
 *
 */
var AXScroll = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();
        this.config.CT_className = "AXScroll";
        this.config.ST_className = "scrollTarget";
        this.scrollBarMove = false;
        this.scrollBarAttr = {};
        this.Observer = null;
        this.config.yscroll = true;
        this.config.xscroll = false;
	    this.config.scrollBarMargin = 3;

        this.minHeightSB = { TF: false, h: 0 };
        this.minWidthSB = { TF: false, w: 0 };
    },
    /**
     * @method AXScroll.setConfig
     * @param {Object} configs - 스크롤 속성 오브젝트
     * @description 스크롤 대상과 스크롤 컨테이너를 지정하여 스크롤UI를 구현합니다.
     * @example
     *```js
     * myUIScroll.setConfig({
     *     targetID:"UIScrollContainer",
     *     scrollID:"UIScrollTarget",
     *     bounces:true
     * });
     *```
     */
    init: function () {
        var config = this.config;
        if (Object.isUndefined(config.targetID)) {
            trace("need targetID - setConfig({targetID:''})");
            return;
        }
        if (Object.isUndefined(config.scrollID)) {
            trace("need scrollID - setConfig({scrollID:''})");
            return;
        }
        this.scrollTargetID = axdom("#" + config.targetID);
        this.scrollScrollID = axdom("#" + config.scrollID);
        this.scrollTargetID.addClass(this.config.CT_className);
        this.scrollScrollID.addClass(this.config.ST_className);
        this.initScroll();
        this.bindEvent();
    },
    /**
     * @method AXScroll.updateScroll
     * @returns {AXScroll}
     * @description 스크롤 처리 대상의 사이즈를 재정의 합니다. 스크롤 대상의 크기가 변경되었을 때 호출
     * @example
     * ```js
     * myUIScroll.updateScroll();
     * myUIScroll.resizeScroll(); // updateScroll과 동일한 기능
     * ```
     */
    updateScroll: function () {
        this.initScroll();
		return this;
    },
	resizeScroll: function () {
		this.initScroll();
		return this;
	},
    initScroll: function () {
        var cfg = this.config, _this = this;
        if (!this.scroll) {
            var po = [];
            if (cfg.yscroll) {
                po.push("<div class=\"scrollTrack\" id=\"" + cfg.targetID + "_AX_scrollTrack\"></div>");
                po.push("<div class=\"scrollBar\" id=\"" + cfg.targetID + "_AX_scrollBar\"></div>");
            } else {
                this.scrollTargetID.css({ height: this.scrollScrollID.outerHeight() });
                /*
                setTimeout(function(){

                }, 10);
                */
            }
            if (cfg.xscroll) {
                po.push("<div class=\"xscrollTrack\" id=\"" + cfg.targetID + "_AX_xscrollTrack\"></div>");
                po.push("<div class=\"xscrollBar\" id=\"" + cfg.targetID + "_AX_xscrollBar\"></div>");
            }

            this.scrollTargetID.append(po.join(''));
            this.scroll = true;

            if (cfg.yscroll) {
                this.scrollTrack = axdom("#" + cfg.targetID + "_AX_scrollTrack");
                this.scrollBar = axdom("#" + cfg.targetID + "_AX_scrollBar");
            }
            if (cfg.xscroll) {
                this.xscrollTrack = axdom("#" + cfg.targetID + "_AX_xscrollTrack");
                this.xscrollBar = axdom("#" + cfg.targetID + "_AX_xscrollBar");
            }
        } else {
            if (!cfg.yscroll) {
                this.scrollTargetID.css({ height: this.scrollScrollID.outerHeight() });
            }
        }

        var CTheight = this.scrollTargetID.innerHeight();
        var CTwidth = this.scrollTargetID.innerWidth();

        if (cfg.yscroll) {
            this.scrollTrack.css({ height: CTheight - (cfg.scrollBarMargin*2) });
        }
        if (cfg.xscroll) {
            this.xscrollTrack.css({ width: CTwidth - (cfg.scrollBarMargin*2) });
        } else {
            this.scrollScrollID.css({ width: CTwidth });
        }

        var Cheight = this.scrollScrollID.outerHeight();
        var Cwidth = this.scrollScrollID.outerWidth();

        if (cfg.yscroll) {
            var SBheight = CTheight * (CTheight - (cfg.scrollBarMargin*2)) / Cheight;
	        if(SBheight < 30) SBheight = 30;
            this.scrollBar.css({ height: Math.ceil(SBheight) });
	        /*
            if (SBheight < 30) {
                this.minHeightSB.TF = true;
                this.minHeightSB.h = SBheight;
            }
            */
            if (CTheight == Cheight || CTheight > Cheight) {
                this.scrollTrack.hide();
                this.scrollBar.hide();
                this.scrollScrollID.css({ top: 0 });
            } else {
                this.scrollTrack.show();
                this.scrollBar.show();
            }
        }
        if (cfg.xscroll) {
            var SBwidth = CTwidth * (CTwidth - (cfg.scrollBarMargin*2)) / Cwidth;
	        if(SBwidth < 30) SBwidth = 30;
            this.xscrollBar.css({ width: Math.ceil(SBwidth) });
	        /*
            if (SBwidth < 30) {
                this.minWidthSB.TF = true;
                this.minWidthSB.w = SBwidth;
            }
            */
            if (CTwidth == Cwidth || CTwidth > Cwidth) {
                this.xscrollTrack.hide();
                this.xscrollBar.hide();
            } else {
                this.xscrollTrack.show();
                this.xscrollBar.show();
            }
        }
    },

    bindEvent: function () {
        var cfg = this.config;

        var CTheight = this.scrollTargetID.innerHeight();
        var Cheight = this.scrollScrollID.outerHeight();

        if (cfg.xscroll) {
            var CTwidth = this.scrollTargetID.innerWidth();
            var Cwidth = this.scrollScrollID.outerWidth();
        }

        /* event 선언자 */
        var tractActive = this.tractActive.bind(this);
        this.tractActiveBind = function (event) {
            tractActive(event);
        }
        var tractInActive = this.tractInActive.bind(this);
        this.tractInActiveBind = function (event) {
            tractInActive(event);
        }
        var cancelEvent = this.cancelEvent.bind(this);
        this.cancelEventBind = function (event) {
            cancelEvent(event);
        }
        var SBonMouseDown = this.SBonMouseDown.bind(this);
        this.SBonMouseDownBind = function (event) {
            SBonMouseDown(event);
        }
        var SBonMouseMove = this.SBonMouseMove.bind(this);
        this.SBonMouseMoveBind = function (event) {
            SBonMouseMove(event);
        }
        var SBonMouseUp = this.SBonMouseUp.bind(this);
        this.SBonMouseUpBind = function (event) {
            SBonMouseUp(event);
        }
        this.SBonWheelBind = this.SBonWheel.bind(this);
        /* event 선언자 */

        this.scrollTargetID.bind("mouseover", this.tractActiveBind);
        this.scrollTargetID.bind("mouseout", this.tractInActiveBind);

        if (cfg.yscroll) {
            this.scrollBar.bind("dragstart", this.cancelEventBind);
            this.scrollBar.bind("mousedown", this.SBonMouseDownBind);
        }

        if (cfg.xscroll) {
            var SBonMouseDownX = this.SBonMouseDownX.bind(this);
            this.SBonMouseDownXBind = function (event) {
                SBonMouseDownX(event);
            }
            var SBonMouseMoveX = this.SBonMouseMoveX.bind(this);
            this.SBonMouseMoveXBind = function (event) {
                SBonMouseMoveX(event);
            }
            var SBonMouseUpX = this.SBonMouseUpX.bind(this);
            this.SBonMouseUpXBind = function (event) {
                SBonMouseUpX(event);
            }

            this.xscrollBar.bind("dragstart", this.cancelEventBind);
            this.xscrollBar.bind("mousedown", this.SBonMouseDownXBind);
        }

        var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel";
        if (document.attachEvent) { //if IE (and Opera depending on user setting)
            if (AXgetId(cfg.targetID)) AXgetId(cfg.targetID).attachEvent("on" + mousewheelevt, this.SBonWheelBind);
        } else if (document.addEventListener) { //WC3 browsers
            if (AXgetId(cfg.targetID)) AXgetId(cfg.targetID).addEventListener(mousewheelevt, this.SBonWheelBind, false);
        }
        if (document.addEventListener) {
            var touchstart = this.touchstart.bind(this);
            this.touchstartBind = function () {
                touchstart();
            };
            if (AXgetId(cfg.targetID)){
                AXgetId(cfg.targetID).addEventListener("touchstart", this.touchstartBind, false);
            }
        }
    },
    tractActive: function (event) {
        var cfg = this.config;

        if (cfg.yscroll) {
            this.scrollBar.addClass("scrollBar_hover");
            this.scrollTrack.addClass("scrollTrack_hover");
        }

        if (cfg.xscroll) {
            this.xscrollBar.addClass("xscrollBar_hover");
            this.xscrollTrack.addClass("xscrollTrack_hover");
        }

        if (this.Observer) clearTimeout(this.Observer); //닫기 명령 제거
        this.initScroll();
    },
    tractInActive: function (event) {
        var SBonWheelEnd = this.SBonWheelEnd.bind(this);
        this.Observer = setTimeout(function () {
            SBonWheelEnd();
        }, 500);
    },
    getMousePosition: function (event) {
        var config = this.config;
        var pos = (this.scrollTrack) ? this.scrollTrack.offset() : { left: 0, top: 0 };
        var posx = (this.xscrollTrack) ? this.xscrollTrack.offset() : { left: 0, top: 0 };

        var x = (event.pageX - posx.left);
        var y = (event.pageY - pos.top);
        return { x: x, y: y };
    },
    getTouchPosition: function (event) {
        /* 사용안함. 옵션 */
        var config = this.config;
        var touch = event.touches[0];
        var pos = this.scrollTrack.offset();
        if (this.config.touchDirection) {
            var x = (touch.pageX - pos.left);
            var y = (touch.pageY - pos.top);
        } else {
            var x = (-touch.pageX - pos.left);
            var y = (-touch.pageY - pos.top);
        }
        return { x: x, y: y };
    },


    /* touch event init --- s */
    touchstart: function (e) {
        if (this.touhEndObserver) clearTimeout(this.touhEndObserver);
        if (this.touhMoveObserver) clearTimeout(this.touhMoveObserver);

        var cfg = this.config;
        var touch;
        var event = window.event;
        touch = event.touches[0];
        if (!touch.pageX) return;

        this.touchStartXY = {
            sTime: ((new Date()).getTime() / 1000),
            sTop: this.scrollScrollID.position().top,
            sLeft: this.scrollScrollID.position().left,
            scrollWidth: this.scrollScrollID.outerWidth(),
            scrollHeight: this.scrollScrollID.outerHeight(),
            targetWidth: this.scrollTargetID.outerWidth(),
            targetHeight: this.scrollTargetID.outerHeight(),
            x: touch.pageX,
            y: touch.pageY
        };

        var touchEnd = this.touchEnd.bind(this);
        this.touchEndBind = function () {
            touchEnd(event);
        };
        var touchMove = this.touchMove.bind(this);
        this.touchMoveBind = function () {
            touchMove(event);
        };

        if (document.removeEventListener) {
            document.removeEventListener("touchend", this.touchEndBind, false);
            document.removeEventListener("touchmove", this.touchMoveBind, false);
        }
        if (document.addEventListener) {
            document.addEventListener("touchend", this.touchEndBind, false);
            document.addEventListener("touchmove", this.touchMoveBind, false);
        }

        var minLeft = 0;
        var maxLeft = - (this.touchStartXY.scrollWidth - this.touchStartXY.targetWidth);
        var minTop = 0;
        var maxTop = - (this.touchStartXY.scrollHeight - this.touchStartXY.targetHeight);
        var scrollPosition = this.scrollScrollID.position();

        if((scrollPosition.left < minLeft && scrollPosition.left > maxLeft) || (scrollPosition.top < minTop && scrollPosition.top > maxTop)){
            this.scrollScrollID.stop();
            if(cfg.yscroll) this.scrollBar.stop();
            if(cfg.xscroll) this.xscrollBar.stop();
        }

        this.tractActive();
    },
    touchMove: function (e) {
        if (this.touhEndObserver) clearTimeout(this.touhEndObserver);
        if (this.touhMoveObserver) clearTimeout(this.touhMoveObserver);
        var cfg = this.config;

        var touch;
        var event = window.event;
        touch = event.touches[0];
        if (!touch.pageX) return;

        if ((this.touchStartXY.x - touch.pageX).abs() < (this.touchStartXY.y - touch.pageY).abs()) {
            if (cfg.yscroll && this.touchStartXY.scrollHeight > this.touchStartXY.targetHeight) {
                this.touchMode = "ns";
                var touchDirection = ((this.touchStartXY.y - touch.pageY) <= 0) ? "T" : "B"; /* 위아래 이동 */

                if(touchDirection != this.touchDirection){
                    this.touchMoveAfter(touch);
                }

                this.touchDirection = touchDirection;
                if(this.moveBlock({top:touch.pageY - this.touchStartXY.y})){
                    if (event.preventDefault) event.preventDefault();
                    else return false;
                }
            }
        } else if ((this.touchStartXY.x - touch.pageX).abs() > (this.touchStartXY.y - touch.pageY).abs()) {
            if (cfg.xscroll && this.touchStartXY.scrollWidth > this.touchStartXY.targetWidth) {
                this.touchMode = "we";
                var touchDirection = ((this.touchStartXY.x - touch.pageX) <= 0) ? "L" : "R"; /* 좌우 이동 */

                if(touchDirection != this.touchDirection){
                    this.touchMoveAfter(touch);
                }

                this.touchDirection = touchDirection;
                if(this.moveBlock({left:touch.pageX - this.touchStartXY.x})){
                    if (event.preventDefault) event.preventDefault();
                    else return false;
                }
            }
        }
        if (((this.touchStartXY.x - touch.pageX).abs() - (this.touchStartXY.y - touch.pageY).abs()).abs() < 5) {
            //this.touchSelecting = true;
        }
        var touchMoveAfter = this.touchMoveAfter.bind(this);
        this.touhMoveObserver = setTimeout(function () {
            touchMoveAfter(touch);
        }, 50);
    },
    touchMoveAfter: function(touch){
        try{
            this.touchStartXY.sTime = ((new Date()).getTime() / 1000);
            this.touchStartXY.sTop = this.scrollScrollID.position().top;
            this.touchStartXY.sLeft = this.scrollScrollID.position().left;
            this.touchStartXY.x = touch.pageX;
            this.touchStartXY.y = touch.pageY;
        }catch(e){
            //trace(e);
        }
    },
    touchEnd: function (e) {
        var cfg = this.config;
        var event = window.event || e;
        //this.moveSens = 0;
        //this.touchMode = false;

        if (document.removeEventListener) {
            document.removeEventListener("touchend", this.touchEndBind, false);
            document.removeEventListener("touchmove", this.touchMoveBind, false);
        }

        var moveEndBlock = this.moveEndBlock.bind(this);
        if(this.touchStartXY){
            this.touhEndObserver = setTimeout(function () {
                moveEndBlock();
            }, 10);
        }
    },
    moveBlock: function(moveXY){
        var cfg = this.config;
        var returnTF = true;
        if(moveXY.left != undefined){
            var newLeft = (this.touchStartXY.sLeft + (moveXY.left));
            var minLeft = 0;
            var maxLeft = - (this.touchStartXY.scrollWidth - this.touchStartXY.targetWidth);
            if(cfg.bounces){
                minLeft = this.touchStartXY.targetWidth * 0.4;
                maxLeft = -((this.touchStartXY.scrollWidth - this.touchStartXY.targetWidth) * 1.2);
            }
            if(newLeft > minLeft){
                newLeft = minLeft;
                returnTF = false;
            }else if(newLeft < maxLeft){
                newLeft = maxLeft;
                returnTF = false;
            }
            this.scrollScrollID.css({left: newLeft});
            this.setScrollbarPositionForWheel("left");
        }else if(moveXY.top != undefined){
            var newTop = (this.touchStartXY.sTop + (moveXY.top));
            var minTop = 0;
            var maxTop = - (this.touchStartXY.scrollHeight - this.touchStartXY.targetHeight);
            if(cfg.bounces){
                minTop = this.touchStartXY.targetHeight * 0.4;
                maxTop = -((this.touchStartXY.scrollHeight - this.touchStartXY.targetHeight) * 1.2);
            }
            if(newTop > minTop){
                newTop = minTop;
                returnTF = false;
            }else if(newTop < maxTop){
                newTop = maxTop;
                returnTF = false;
            }
            this.scrollScrollID.css({top: newTop});
            this.setScrollbarPositionForWheel("top");
        }
        /*trace(moveXY);*/
        return returnTF;
        //return true;
    },
    moveEndBlock: function(){
	    var cfg = this.config;
        /* 관성발동여부 체크 */
        if(!this.touchStartXY) return;
        var sTime = this.touchStartXY.sTime;
        var eTime = ((new Date()).getTime() / 1000);
        var dTime = eTime - sTime;
        //var setScrollbarPositionForWheel = this.setScrollbarPositionForWheel.bind(this);
        var tractInActive = this.tractInActive.bind(this);

        if(this.touchMode == "we"){ /* 좌우 */
            if (this.touchStartXY.scrollWidth <= this.touchStartXY.targetWidth) return;
            var eLeft = this.scrollScrollID.position().left;
            var dLeft = eLeft - this.touchStartXY.sLeft;
            var velocityLeft = Math.ceil((dLeft/dTime)/1); // 속력= 거리/시간
            var endLeft = Math.ceil(eLeft + velocityLeft); //스크롤할때 목적지
            if(endLeft > 0) endLeft = 0;
            else if(endLeft < - (this.touchStartXY.scrollWidth - this.touchStartXY.targetWidth)){
                endLeft = - (this.touchStartXY.scrollWidth - this.touchStartXY.targetWidth);
            }
            var newLeft = endLeft.abs();
            this.touchStartXY.sLeft = -newLeft;
            this.scrollScrollID.animate({left: -newLeft}, (eLeft + newLeft).abs(), "circOut", function () {
                tractInActive();
            });
            this.setScrollbarPositionForWheel("left", (eLeft + newLeft).abs(), "circOut", {left: -newLeft});

            if (cfg.yscroll){
                var eTop = this.scrollScrollID.position().top;
                var topChange = false;
                if(eTop > 0){
                    eTop = 0;
                    topChange = true;
                }else if(eTop < - (this.touchStartXY.scrollHeight - this.touchStartXY.targetHeight)){
                    eTop = (this.touchStartXY.scrollHeight - this.touchStartXY.targetHeight);
                    topChange = true;
                }
                if(topChange) this.scrollScrollID.css({top: -eTop});
            }

        }else{ /* 위아래 */
            if (this.touchStartXY.scrollHeight <= this.touchStartXY.targetHeight) return;
            var eTop = this.scrollScrollID.position().top;
            var dTop = eTop - this.touchStartXY.sTop;
            var velocityTop = Math.ceil((dTop/dTime)/1); // 속력= 거리/시간
            var endTop = Math.ceil(eTop + velocityTop); //스크롤할때 목적지
            if(endTop > 0) endTop = 0;
            else if(endTop < - (this.touchStartXY.scrollHeight - this.touchStartXY.targetHeight)){
                endTop = - (this.touchStartXY.scrollHeight - this.touchStartXY.targetHeight);
            }

            var newTop = endTop.abs();
            this.touchStartXY.sTop = -newTop;
            this.scrollScrollID.animate({top: -newTop}, (eTop + newTop).abs(), "circOut", function () {
                tractInActive();
            });
            this.setScrollbarPositionForWheel("top", (eTop + newTop).abs(), "circOut", {top: -newTop});

            if (cfg.xscroll){
                var eLeft = this.scrollScrollID.position().left;
                var leftChange = false;
                if(eLeft > 0){
                    eLeft = 0;
                    leftChange = true;
                }else if(eLeft < - (this.touchStartXY.scrollWidth - this.touchStartXY.targetWidth)){
                    eLeft = (this.touchStartXY.scrollWidth - this.touchStartXY.targetWidth);
                    leftChange = true;
                }
                if(leftChange) this.scrollScrollID.css({left: -eLeft});
            }
        }
        this.touchStartXY = null;

    },
    /* touch event init --- e */


    /* scrollBar event */
    SBonMouseDown: function (event) {
        var config = this.config;
        this.scrollBarMove = true;
        var pos = this.getMousePosition(event);
        var SBpos = this.scrollBar.position();
        var SBh = this.scrollBar.height();
        var STh = this.scrollTrack.height();
        var Ch = this.scrollScrollID.outerHeight();

        this.Ch = Ch;
        this.STh = STh;

        this.scrollBarAttr = { x: (SBpos.left - pos.x).number(), y: (SBpos.top - pos.y).number(), h: SBh.number(), sth: STh };
        //trace("y:"+SBpos.top +" - "+ pos.y +", h:"+ SBh +", sth:"+STh+", calc y : "+(SBpos.top - pos.y).number());

        axdom(document.body).bind("mousemove.AXScroll", this.SBonMouseMoveBind);
        axdom(document.body).bind("mouseup.AXScroll", this.SBonMouseUpBind);
        axdom(document.body).bind("mouseleave.AXScroll", this.SBonMouseUpBind);
    },
    SBonMouseMove: function (event) {
        var config = this.config;
        if (this.scrollBarMove) {
            axdom(document.body).attr("onselectstart", "return false");
            //axdom(document.body).addClass("AXUserSelectNone");
            var pos = this.getMousePosition(event);

            var SBy = pos.y + this.scrollBarAttr.y;
            //trace(SBy +" = "+ pos.y +"+"+ this.scrollBarAttr.y);

            if (SBy < config.scrollBarMargin) SBy = config.scrollBarMargin;
            if ((SBy + this.scrollBarAttr.h) > this.scrollBarAttr.sth) {
                SBy = this.scrollBarAttr.sth - this.scrollBarAttr.h + config.scrollBarMargin;
                //trace(SBy)
            }
            this.scrollBar.css({ top: SBy });
            this.setContentPosition();
        }
    },
    SBonMouseUp: function (event) {
        if (this.scrollBarMove) {
            var config = this.config;
            this.scrollBarMove = false;
            axdom(document.body).removeAttr("onselectstart");
            //axdom(document.body).removeClass("AXUserSelectNone");
        }
        axdom(document.body).unbind("mousemove.AXScroll");
        axdom(document.body).unbind("mouseup.AXScroll");
        axdom(document.body).unbind("mouseleave.AXScroll");
    },

    SBonMouseDownX: function (event) {
        var config = this.config;
        this.scrollBarMove = true;
        var pos = this.getMousePosition(event);
        var SBpos = this.xscrollBar.position();
        var SBw = this.xscrollBar.width();
        var STw = this.xscrollTrack.width();
        var Cw = this.scrollScrollID.outerWidth();

        this.Cw = Cw;
        this.STw = STw;

        this.scrollBarAttr = { x: (SBpos.left - pos.x).number(), w: SBw.number(), stw: STw };

        axdom(document.body).bind("mousemove.AXScroll", this.SBonMouseMoveXBind);
        axdom(document.body).bind("mouseup.AXScroll", this.SBonMouseUpXBind);
        axdom(document.body).bind("mouseleave.AXScroll", this.SBonMouseUpXBind);
    },
    SBonMouseMoveX: function (event) {
        var config = this.config;
        if (this.scrollBarMove) {

            axdom(document.body).attr("onselectstart", "return false");
            //axdom(document.body).addClass("AXUserSelectNone");
            var pos = this.getMousePosition(event);

            var SBx = pos.x + this.scrollBarAttr.x;
            //trace(SBy +" = "+ pos.y +"+"+ this.scrollBarAttr.y);

            if (SBx < config.scrollBarMargin) SBx = config.scrollBarMargin;
            if ((SBx + this.scrollBarAttr.w) > this.scrollBarAttr.stw) {
                SBx = this.scrollBarAttr.stw - this.scrollBarAttr.w + config.scrollBarMargin;
            }

            this.xscrollBar.css({ left: SBx });
            this.setContentPosition("xscroll");
        }
    },
    SBonMouseUpX: function (event) {
        if (this.scrollBarMove) {
            var config = this.config;
            this.scrollBarMove = false;
            axdom(document.body).removeAttr("onselectstart");
            //axdom(document.body).removeClass("AXUserSelectNone");
        }
        axdom(document.body).unbind("mousemove.AXScroll");
        axdom(document.body).unbind("mouseup.AXScroll");
        axdom(document.body).unbind("mouseleave.AXScroll");
    },

    SBonWheel: function (e) {
        //content top handle
        var config = this.config;

        var event = (window.event || e);
        var delta = event.detail ? event.detail * (-10) : event.wheelDelta; //check for detail first so Opera uses that instead of wheelDelta

        var Sy = this.scrollScrollID.position().top;
        var Sh = this.scrollScrollID.outerHeight();
        var TGh = this.scrollTargetID.height();

        //trace(Sh+" + "+Sy+" < "+TGh );
        if (Sh < TGh) return; //스크롤 할 대상이 없음 2013-02-08 오후 5:48:07 tom@axmods.com

        var eventCancle = false;
        Sy += delta;
        if (Sy > 0) {
            Sy = 0;
            eventCancle = true;
        }

        //trace(Sh+" + "+Sy+" < "+TGh );

        if ((Sh + Sy) < TGh) {
            Sy = (TGh - Sh);
            eventCancle = true;
        }
        this.scrollScrollID.css({ top: Sy });

        //this.setContentPosition();
        this.setScrollbarPositionForWheel("top");

        if (!eventCancle) {
            if (event.preventDefault) event.preventDefault();
            if (event.stopPropagation) event.stopPropagation();
            event.cancelBubble = true;
            return false;
        }

    },
    SBonWheelEnd: function () {
        if (this.scrollBarMove) return;
        var config = this.config;

        if (config.yscroll) {
            this.scrollBar.removeClass("scrollBar_hover");
            this.scrollTrack.removeClass("scrollTrack_hover");
        }

        if (config.xscroll) {
            this.xscrollBar.removeClass("xscrollBar_hover");
            this.xscrollTrack.removeClass("xscrollTrack_hover");
        }

    },
    cancelEvent: function (event) {
        event.stopPropagation(); // disable  event
        return false;
    },
    setContentPosition: function (xscroll) {
        var config = this.config;

        if (xscroll == "xscroll") {

	        if (!this.contentScrollXAttr) {
		        this.contentScrollXAttr = {
			        bodyWidth: this.scrollTargetID.width(),
			        scrollWidth: this.scrollScrollID.width(),
			        scrollTrackXWidth: this.xscrollTrack.width(),
			        scrollXHandleWidth: this.xscrollBar.width()
		        };
	        }else{
		        // scrollContent height update
		        this.contentScrollXAttr.scrollWidth = this.scrollScrollID.width();
		        this.contentScrollXAttr.scrollTrackXWidth = this.xscrollTrack.width();
		        this.contentScrollXAttr.scrollXHandleWidth = this.xscrollBar.width();
	        }

            var SBx = this.xscrollBar.position().left - config.scrollBarMargin;
	        var L = (this.contentScrollXAttr.scrollWidth * (SBx) / this.contentScrollXAttr.scrollTrackXWidth).round(0);
            this.scrollScrollID.css({ left: -L });

        } else {

	        if (!this.contentScrollYAttr) {
		        this.contentScrollYAttr = {
			        bodyHeight: this.scrollTargetID.height(),
			        scrollHeight: this.scrollScrollID.height(),
			        scrollTrackYHeight: this.scrollTrack.height(),
			        scrollYHandleHeight: this.scrollBar.height()
		        };
	        }else{
		        // scrollContent height update
		        this.contentScrollYAttr.scrollHeight = this.scrollScrollID.height();
		        this.contentScrollYAttr.scrollTrackYHeight = this.scrollTrack.height();
		        this.contentScrollYAttr.scrollYHandleHeight = this.scrollBar.height();
	        }

            var SBy = this.scrollBar.position().top - config.scrollBarMargin;
	        var T = (this.contentScrollYAttr.scrollHeight - this.contentScrollYAttr.bodyHeight) * ( (SBy) / (this.contentScrollYAttr.scrollTrackYHeight - this.contentScrollYAttr.scrollYHandleHeight) ).number();
            this.scrollScrollID.css({ top: -T });
        }

    },

    setScrollbarPositionForWheel: function (direction, duration, easing, position) {
        //scrollbar top position handle for wheel
        var config = this.config;

        if(direction == "left"){

	        if (!this.contentScrollXAttr) {
		        this.contentScrollXAttr = {
			        bodyWidth: this.scrollTargetID.width(),
			        scrollWidth: this.scrollScrollID.width(),
			        scrollTrackXWidth: this.xscrollTrack.width(),
			        scrollXHandleWidth: this.scrollBar.outerWidth()
		        };
	        }else{
		        // scrollContent height update
		        this.contentScrollXAttr.scrollWidth = this.scrollScrollID.width();
		        this.contentScrollXAttr.scrollTrackXWidth = this.xscrollTrack.width();
		        this.contentScrollXAttr.scrollXHandleWidth = this.xscrollBar.outerWidth();
	        }

	        var Sy = (position) ? position.left : this.scrollScrollID.position().left;
	        var L = (this.contentScrollXAttr.scrollTrackXWidth - this.contentScrollXAttr.scrollXHandleWidth) * ((Sy) / (this.contentScrollXAttr.scrollWidth - this.contentScrollXAttr.bodyWidth));
	        L -= config.scrollBarMargin;
	        if(easing){
                this.xscrollBar.animate({
                    left: -L
                    //,width: Math.ceil(this.scrollTargetID.outerWidth() * (this.scrollTargetID.outerWidth() - 4) / (this.scrollScrollID.outerWidth() + addY))
                }, duration, easing, function () {});
            }else{
                this.xscrollBar.css({
                    left: -L
                    //,width: Math.ceil(this.scrollTargetID.outerWidth() * (this.scrollTargetID.outerWidth() - 4) / (this.scrollScrollID.outerWidth() + addY))
                });
            }
        }else{

            if (!config.yscroll) return false;
            //wheel control event is not jquery event !

	        if (!this.contentScrollYAttr) {
		        this.contentScrollYAttr = {
			        bodyHeight: this.scrollTargetID.height(),
			        scrollHeight: this.scrollScrollID.height(),
			        scrollTrackYHeight: this.scrollTrack.height(),
			        scrollYHandleHeight: this.scrollBar.outerHeight()
		        };
	        }else{
		        // scrollContent height update
		        this.contentScrollYAttr.scrollHeight = this.scrollScrollID.height();
		        this.contentScrollYAttr.scrollTrackYHeight = this.scrollTrack.height();
		        this.contentScrollYAttr.scrollYHandleHeight = this.scrollBar.outerHeight();
	        }

	        var Sy = (position) ? position.top : this.scrollScrollID.position().top;
	        var T = (this.contentScrollYAttr.scrollTrackYHeight - this.contentScrollYAttr.scrollYHandleHeight) * ((Sy) / (this.contentScrollYAttr.scrollHeight - this.contentScrollYAttr.bodyHeight));
			T -= config.scrollBarMargin;
            if(easing){
                //trace({ top: SBy }, duration, easing);

                this.scrollBar.animate({
                    top: -T
                    //,height: Math.ceil(this.scrollTargetID.outerHeight() * (this.scrollTargetID.outerHeight() - 4) / (this.scrollScrollID.outerHeight() + addY))
                }, duration, easing, function () {});
            }else{
                this.scrollBar.css({
                    top: -T
                    //,height: Math.ceil(this.scrollTargetID.outerHeight() * (this.scrollTargetID.outerHeight() - 4) / (this.scrollScrollID.outerHeight() + addY))
                });
            }

        }
    },


    setSBPosition: function () {
        var config = this.config;
	    try {

		    var Ctop = this.scrollScrollID.position().top;
		    var CTheight = this.scrollTargetID.innerHeight();
		    var STh = this.scrollTrack.height();
		    var Ch = this.scrollScrollID.outerHeight();

		    var SBh = this.scrollBar.height();

		    //trace({Ctop:Ctop, CTheight:CTheight, Ch:Ch, STh:STh, SBh:SBh, x:(STh*Ctop)/Ch});
		    var SBtop = -(STh * Ctop) / Ch;
		    if (SBtop < config.scrollBarMargin) SBtop = config.scrollBarMargin;
		    if ((SBtop + SBh) > STh) {
			    SBtop = STh - SBh + config.scrollBarMargin;
		    }
		    this.scrollBar.css({ top: SBtop });
	    }catch(e){

	    }
    },
    /**
     * @method AXScroll.focusElement
     * @param {String} id - 포커스 할 대상 엘리먼트 아이디
     * @returns {AXScroll}
     * @description 스크롤 오브젝트 안에 엘리먼트를 포커스 합니다.
     * @example
     *```js
     * myUIScroll.focusElement("resizer01");
     *```
     */
    focusElement: function (id) {
        var config = this.config;
        if (AXgetId(id)) {
            //trace(axdom("#"+id).position());
	        var ppos = this.scrollScrollID.offset();
            var pos = axdom("#" + id).offset();

            var myNewTop = pos.top - ppos.top;
            var CTheight = this.scrollTargetID.innerHeight();
            var Cheight = this.scrollScrollID.outerHeight();
            if ((Cheight - myNewTop) < CTheight) {
                myNewTop = Cheight - CTheight;
            }
            if (myNewTop < 0) myNewTop = 0;
            this.scrollScrollID.css({ top: -myNewTop });
            this.setSBPosition();
        }
		return this;
    },
    /**
     * @method AXScroll.scrollTop
     * @param {Number} top - scrollTop position
     * @returns {AXScroll}
     * @description 스크롤 포지션을 원하는 포지션으로 이동합니다.
     * @example
     *```js
     * myUIScroll.scrollTop(0);
     *```
     */
    scrollTop: function (top) {
        var myNewTop = top;
        var CTheight = this.scrollTargetID.innerHeight();
        var Cheight = this.scrollScrollID.outerHeight();
        if ((Cheight - myNewTop) < CTheight) {
            myNewTop = Cheight - CTheight;
        }
        if (myNewTop < 0) myNewTop = 0;
        this.scrollScrollID.css({ top: -myNewTop });
        this.setSBPosition();
		return this;
    },
    /**
     * @method AXScroll.moveTo
     * @param {Number} x - scrollTop position (optional)
     * @param {Number} y - scrollLeft position (optional)
     * @returns {AXScroll}
     * @description 스크롤위치를 이동시킵니다.
     * @example
     *```js
     * myUIScroll.moveTo();
     *```
     */
    moveTo: function (x, y) {
        var cfg = this.config;
        var css = {};
        if (!AXUtil.isEmpty(x)) {
            css.left = -x;
        }
        if (!AXUtil.isEmpty(y)) {
            css.top = -y;
        }

        this.scrollScrollID.css(css);
        if (cfg.yscroll && !AXUtil.isEmpty(css.top)) {
            this.scrollBar.css({ top: css.top });
        }
        if (cfg.xscroll && !AXUtil.isEmpty(css.left)) {
            this.xscrollBar.css({ left: css.left });
        }
		return this;
    },
    /**
     * @method AXScroll.unbind
     * @returns {AXScroll}
     * @description 스크롤을 UI를 제거합니다.
     * @example
     * ```js
     * myUIScroll.unbind();
     * ```
     */
    unbind: function () {
        var config = this.config;
        this.scroll = false;

        this.scrollTrack.remove();
        this.scrollBar.remove();

        this.scrollTargetID.unbind("mouseover", this.tractActiveBind);
        this.scrollTargetID.unbind("mouseout", this.tractInActiveBind);

        //axdom("#"+config.targetID+"_AX_scrollBar").unbind("dragstart", this.cancelEventBind);
        //axdom("#"+config.targetID+"_AX_scrollBar").unbind("mousedown", this.SBonMouseDownBind);
        axdom(document.body).unbind("mousemove.AXScroll", this.SBonMouseMoveBind);
        axdom(document.body).unbind("mouseup.AXScroll", this.SBonMouseUpBind);

        var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel";
        if (document.attachEvent) { //if IE (and Opera depending on user setting)
            if (AXgetId(config.targetID)) AXgetId(config.targetID).detachEvent("on" + mousewheelevt, this.SBonWheelBind);
        } else if (document.addEventListener) { //WC3 browsers
            if (AXgetId(config.targetID)) AXgetId(config.targetID).removeEventListener(mousewheelevt, this.SBonWheelBind, false);
        }

        if (document.addEventListener) {
            if (AXgetId(config.targetID)) AXgetId(config.targetID).removeEventListener("touchstart", this.SBtouchstartBind, false)
        }
		return this;
    }
});
/* ---------------------------------------------- AXScroll -- */

/* -- AXCalendar ---------------------------------------------- */
/**
 * @class AXCalendar
 * @extends AXJ
 * @version v1.2
 * @author tom@axisj.com
 * @logs
 * "2012-12-05 오후 11:54:27"
 * "2014-03-31 오후 4:53:02 - tom : timePage PM 이면 12시 선택 못하도록 기능 변경"
 * "2015-03-17 tom : 0시 0분 입력 가능 하도록 수정"
 *
 */
var AXCalendar = Class.create(AXJ, {
    /**
     * AXCalendar 기본속성
     * @member {Object} AXCalendar.config
     * @example
     *```js
     * {
     *     CT_className : {String},
     *     weeks : {
     *        { name: "SUN" },
     *        { name: "MON" },
     *        { name: "TUE" },
     *        { name: "WED" },
     *        { name: "THU" },
     *        { name: "FRI" },
     *        { name: "SAT" }
     *     },
     *     printFormat : "dd",
     *     titleFormat : "yyyy/mm/dd",
     *     valueFormat : "yyyy-mm-dd"
     * }
     *```
     */
    initialize: function (AXJ_super) {
        AXJ_super();
        this.config.CT_className = "AXCalendar";
        this.Observer = null;
        this.config.weeks = [
            { name: "SUN" },
            { name: "MON" },
            { name: "TUE" },
            { name: "WED" },
            { name: "THU" },
            { name: "FRI" },
            { name: "SAT" }
        ];
        this.config.printFormat = "dd";
        this.config.titleFormat = "yyyy/mm/dd";
        this.config.valueFormat = "yyyy-mm-dd";
    },
    /**
     * @method AXCalendar.setConfig
     * @param {Object} config
     * @description 선언된 스크롤 클래스를 사용하기 위해 속성을 정의합니다.
     * @example
     *```js
     * mycalendar.setConfig(config);
     *
     * var config = {
     *     CT_className : {String},
     *     weeks : {Object} [{ { name: "SUN" }, { name: "MON" }, { name: "TUE" }, { name: "WED" }, { name: "THU" }, { name: "FRI" }, { name: "SAT" } }],
     *     printFormat : {String} [dd],
     *     titleFormat : {String} [yyyy/mm/dd],
     *     valueFormat : {String} [yyyy-mm-dd]
     * };
     *```
     */
    init: function () {

    },
    getBasicDate: function () {
        var cfg = this.config;
        if (cfg.basicDate != undefined) {
            return cfg.basicDate.date();
        } else {
            return new Date();
        }
    },
    getCalendarStartDate: function (date) {
        var cfg = this.config;
        var calendarStartDate, monthStartDate, basicDate;
        basicDate = (date) ? date.date() : this.getBasicDate();
        monthStartDate = new Date(basicDate.getFullYear(), basicDate.getMonth(), 1, 12);
        var calendarStartDateDay = monthStartDate.getDay();
        if (calendarStartDateDay == 0) calendarStartDateDay = 7;
        calendarStartDate = monthStartDate.add(-calendarStartDateDay);
        return { calendarStartDate: calendarStartDate, monthStartDate: monthStartDate };
    },
    /**
     * @method AXCalendar.printDayPage
     * @param {String} [toDay]
     * @returns {AXCalendar}
     * @description 일자 캘린더를 targetID 안에 출력합니다
     * @example
     *```js
     * mycalendar.printDayPage("2014-11-01");
     *```
     */
    printDayPage: function (date) {
        var cfg = this.config;

        if (Object.isUndefined(cfg.targetID)) {
            trace("need targetID - setConfig({targetID:''})");
            return;
        }

        var calendarDate = this.getCalendarStartDate(date);
        var calendarStartDate = calendarDate.calendarStartDate;
        var monthStartDate = calendarDate.monthStartDate;
        var basicDate = this.getBasicDate();
        var setDate = (date) ? date.date() : new Date();
        //
        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_box\" class=\"" + cfg.CT_className + "\">");
        po.push("<table cellspacing=\"0\" cellpadding=\"0\" class=\"calendarPage\">");
        po.push("<thead>");
        po.push("<tr>");
        axf.each(cfg.weeks, function (wi, ww) {
            po.push("<td class=\"head_" + wi + " dayofweek_" + wi + "\">" + ww.name + "</td>");
        });
        po.push("</tr>");
        po.push("</thead>");
        po.push("<tbody>");

        var minTime = -1;
        var maxTime = -1;
        var onBeforeShowDay;
        var roopDate = calendarStartDate;
        if (cfg.minDate) { minTime = cfg.minDate.date().getTime(); }
        if (cfg.maxDate) { maxTime = cfg.maxDate.date().getTime(); }
        if (cfg.onBeforeShowDay) { onBeforeShowDay = cfg.onBeforeShowDay.bind(this); }
        var i = 0; while (i < 6) {
            po.push("<tr>");
            var k = 0; while (k < 7) {
                var roopTime = roopDate.getTime();
                var dayValue = roopDate.print(this.config.printFormat);
                var addClass = [];
                var addStyle = "";
                var tdClass = [];
                var printTitle = roopDate.print(this.config.titleFormat);
                var isEnable = true;
                if (onBeforeShowDay) {
                    var addData = onBeforeShowDay(roopDate); // addData -> { isEnable: true|false, title:'성탄절', className: 'holyday', style: 'color:red' }
                    if (addData) {
                        if (addData.className) { addClass.push(addData.className); } // ie7 이하에서 class 예약어라 사용안됨
                        if (addData.style) { addStyle = addData.style; }
                        if (addData.title) { printTitle = addData.title; }
                        if (addData.isEnable === false) { isEnable = false; }
                    }
                }
                if (isEnable && minTime > -1) { isEnable = !(roopTime < minTime); }
                if (isEnable && maxTime > -1) { isEnable = !(roopTime > maxTime); }
                if (roopDate.getMonth() != monthStartDate.getMonth()) addClass.push("notThisMonth");
                if (setDate.diff(roopDate, "D") == 0) tdClass.push("setDate");
                if (!isEnable) { addClass.push("disabled"); }
                po.push("<td class=\"bodyCol_" + k + " bodyRow_" + i + " " + tdClass.join(" ") + "\"><a " + cfg.href + " class=\"calendarDate " + addClass.join(" ") + "\" id=\"" + cfg.targetID + "_AX_" + roopDate.print(this.config.valueFormat) + "_AX_date\" title=\"" + printTitle + "\">" + dayValue.number() + "</a></td>");
                k++;
                roopDate = roopDate.add(1);
            }
            po.push("</tr>");
            i++;
        }
        po.push("</tbody>");
        po.push("</table>");
        po.push("</div>");
        axdom("#" + cfg.targetID).html(po.join(''));
		return this;
    },
    /**
     * @method AXCalendar.dayPageSetDay
     * @param {Date} - 날짜
     * @returns {AXCalendar}
     * @description 일자달력의 표시 날짜를 변경합니다.
     * @example
     *```js
     * var myDate = new Date();
     * // var myDate = "2014-11-01".date();
     * mycalendar.dayPageSetDay(myDate);
     *```
     */
    dayPageSetDay: function (date) {
        var cfg = this.config;
        axdom("#" + cfg.targetID).find(".calendarDate").removeClass("selected");
        axdom("#" + cfg.targetID + "_AX_" + date.print(this.config.valueFormat) + "_AX_date").addClass("selected");
		return this;
    },
    /**
     * @method AXCalendar.printMonthPage
     * @param {String} [toDay]
     * @returns {AXCalendar}
     * @description 월 선택 캘린더를 targetID 안에 출력합니다.
     * @example
     *```js
     * mycalendar.printMonthPage("2014-11-01");
     *```
     */
    printMonthPage: function (date) {
        var cfg = this.config;
        if (Object.isUndefined(cfg.targetID)) {
            trace("need targetID - setConfig({targetID:''})");
            return;
        }
        var setDate = (date) ? date.date() : new Date();
        //alert(setDate);
        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_box\" class=\"" + cfg.CT_className + "\">");
        po.push("<table cellspacing=\"0\" cellpadding=\"0\" class=\"calendarPageMonth\">");
        po.push("<tbody>");

        var m = 1;
        var i = 0; while (i < 4) {
            po.push("<tr>");
            var k = 0; while (k < 3) {
                var tdClass = [];
                if (m == (setDate.getMonth() + 1)) tdClass.push("setDate");
                po.push("<td class=\"bodyCol_" + k + " bodyRow_" + i + " " + tdClass.join(" ") + "\"><a " + cfg.href + " class=\"calendarMonth\" id=\"" + cfg.targetID + "_AX_" + m + "_AX_month\" title=\"\">" + m + "월</a></td>");
                k++;
                m++;
            }
            po.push("</tr>");
            i++;
        }
        po.push("</tbody>");
        po.push("</table>");
        po.push("</div>");
        axdom("#" + cfg.targetID).html(po.join(''));
		return this;
    },
    /**
     * @method AXCalendar.monthPageSetMonth
     * @param {Date} - 날짜
     * @returns {AXCalendar}
     * @description 월달력의 표시 날짜를 변경합니다.
     * @example
     *```js
     * var myDate = new Date();
     * // var myDate = "2014-11-01".date();
     * mycalendar.monthPageSetMonth(myDate);
     *```
     */
    monthPageSetMonth: function (date) {
        var cfg = this.config;
        axdom("#" + cfg.targetID).find(".calendarMonth").removeClass("selected");
        axdom("#" + cfg.targetID + "_AX_" + (date.getMonth() + 1) + "_AX_month").addClass("selected");
    },
    /**
     * @method AXCalendar.printYearPage
     * @param {(String|Number)}
     * @returns {AXCalendar}
     * @description 년도 선택 캘린더를 targetID 안에 출력합니다.
     * @example
     *```js
     * mycalendar.printYearPage("2014");
     * mycalendar.printYearPage(2014);
     *```
     */
    printYearPage: function (year) {
        var cfg = this.config;
        if (Object.isUndefined(cfg.targetID)) {
            trace("need targetID - setConfig({targetID:''})");
            return;
        }
        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_box\" class=\"" + cfg.CT_className + "\">");
        po.push("<table cellspacing=\"0\" cellpadding=\"0\" class=\"calendarPageMonth\">");
        po.push("<tbody>");

        var m = year - 4;
        var i = 0; while (i < 4) {
            po.push("<tr>");
            var k = 0; while (k < 3) {
                var tdClass = [];
                if (m == year) tdClass.push("setDate");
                po.push("<td class=\"bodyCol_" + k + " bodyRow_" + i + " " + tdClass.join(" ") + "\"><a " + cfg.href + " class=\"calendarMonth\" id=\"" + cfg.targetID + "_AX_" + m + "_AX_year\" title=\"\">" + m + "년</a></td>");
                k++;
                m++;
            }
            po.push("</tr>");
            i++;
        }
        po.push("</tbody>");
        po.push("</table>");
        po.push("</div>");
        axdom("#" + cfg.targetID).html(po.join(''));
    },
    /**
     * @method AXCalendar.yearPageSetYear
     * @param {Date} - 날짜
     * @returns {AXCalendar}
     * @description 년도달력의 표시 날짜를 변경합니다.
     * @example
     *```js
     * var myDate = new Date();
     * // var myDate = "2014-11-01".date();
     * mycalendar.yearPageSetYear(myDate);
     *```
     */
    yearPageSetYear: function (date) {
        var cfg = this.config;
        axdom("#" + cfg.targetID).find(".calendarMonth").removeClass("selected");
        axdom("#" + cfg.targetID + "_AX_" + date.print("yyyy") + "_AX_year").addClass("selected");
    },
    /**
     * @method AXCalendar.printTimePage
     * @param {String}
     * @returns {AXCalendar}
     * @description 시간 선택 캘린더를 targetID 안에 출력합니다.
     * @example
     *```js
     * mycalendar.printTimePage("06:36 AM");
     *```
     */
    printTimePage: function (displayTime) {
        var cfg = this.config;
        if (Object.isUndefined(cfg.targetID)) {
            trace("need targetID - setConfig({targetID:''})");
            return;
        }

        if (displayTime) {
            var now = displayTime.split(":");
            var hh = now[0].setDigit(2);
            var mm = now[1].left(2).setDigit(2);
            var apm = now[1].right(2);
            if (hh == "00" && mm == "00") {
                //hh = "12";
                apm = "AM";
            }
            if (apm == "00") apm = "AM";
        } else {
            var now = new Date();
            var hh = now.getHours();
            var mm = now.getMinutes();
            var apm = "AM";
            if (hh == 0 && mm == 0) {
                //hh = 24;
            }
            if (hh > 12) {
                apm = "PM";
                hh -= 12;
            }
            hh = hh.setDigit(2);
            mm = mm.setDigit(2);
        }

        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_box\" class=\"" + cfg.CT_className + "\" style=\"padding:0px;\">");
        po.push("<div class='timeBox'>");
        po.push("<div class='hourTitle'>Hour</div>");
        po.push("<div class='hourSlider'><input type='text' value='" + hh + "' id='" + cfg.targetID + "_AX_hour' class='AXInput' /></div>");
        po.push("<div class='minuteTitle'>Minute</div>");
        po.push("<div class='minuteSlider'><input type='text' value='" + mm + "' id='" + cfg.targetID + "_AX_minute' class='AXInput' /></div>");
        po.push("<div class='timeDisplay'>" + hh + ":" + mm + " " + apm + "</div>");
        po.push("<div class='AMPM'><input type='text' id='" + cfg.targetID + "_AX_AMPM' value='" + apm + "' style='width:50px;height:21px;border:0px none;' /></div>");
        po.push("</div>");
        po.push("</div>");
        axdom("#" + cfg.targetID).html(po.join(''));

        var timePageChange = this.timePageChange.bind(this);
        axdom("#" + cfg.targetID + "_AX_hour").unbindInput();
        axdom("#" + cfg.targetID + "_AX_minute").unbindInput();
        axdom("#" + cfg.targetID + "_AX_AMPM").unbindInput();
        axdom("#" + cfg.targetID + "_AX_hour").bindSlider({
            min: 0, max: 12, onChange: function (objID, objVal) {
                timePageChange(objID, objVal);
            }
        });
        axdom("#" + cfg.targetID + "_AX_minute").bindSlider({
            min: 0, max: 59, onChange: function (objID, objVal) {
                timePageChange(objID, objVal);
            }
        });
        axdom("#" + cfg.targetID + "_AX_AMPM").bindSwitch({
            off: "AM", on: "PM", onChange: function (objID, objVal) {
                timePageChange(objID, objVal);
            }
        });
    },
	// 내부 함수
    timePageChange: function () {
        var cfg = this.config, hh, mi, apm, mytime;
	    hh = axdom("#" + cfg.targetID + "_AX_hour").val().number();
	    mi = axdom("#" + cfg.targetID + "_AX_minute").val().number();
	    apm = axdom("#" + cfg.targetID + "_AX_AMPM").val();
        if(apm == "PM"){
	        //hh += 12;
            if(hh > 12){
                axdom("#" + cfg.targetID + "_AX_hour").val(12);
                axdom("#" + cfg.targetID + "_AX_hour").setValueInput(12);
            }
        }
        mytime = hh.setDigit(2) + ":" + mi.setDigit(2) + " " + apm;
        axdom("#" + cfg.targetID + "_AX_box").find(".timeDisplay").html(mytime);
        if (cfg.onChange) {
            cfg.onChange(hh.setDigit(2) + ":" + mi.setDigit(2));
        }
    },
    /**
     * @method AXCalendar.getTime
     * @returns {String} hh:mm
     * @description 현재 시간과 분을 리턴합니다.
     * @example
     *```js
     * myCalendar.getTime();
     * // 09:20
     *```
     */
    getTime: function () {
        var cfg = this.config;
        var hh = (axdom("#" + cfg.targetID + "_AX_hour").val()||0).number();
        var mi = (axdom("#" + cfg.targetID + "_AX_minute").val()||0).number();
        var apm = axdom("#" + cfg.targetID + "_AX_AMPM").val();
        if (apm == "PM" && hh < 12) hh += 12;
        return hh.setDigit(2) + ":" + mi.setDigit(2);
    }
});
/* ---------------------------------------------- AXCalendar -- */

/* -- AXMultiSelect ---------------------------------------------- */
/**
 * @class AXMultiSelect
 * @classdesc 박스안에 아이템들중에 약속된 Class를 가진 아이템에 대해 다중선택를 할 수 있도록 지원합니다.
 * @extends AXJ
 * @version v1.9
 * @author tom@axisj.com
 * @logs
 "2013-01-31 오후 5:01:12",
 "2013-11-12 오전 9:19:09 - tom : 버그픽스",
 "2013-11-12 오전 11:59:38 - tom : body relative 버그 픽스, 스크롤바 마우스 선택 문제 해결",
 "2013-11-13 오후 3:01:15 - tom : 모바일 터치 기능 지원"
 "2015-04-01 tom : 드래그 셀렉트 버그 픽스"
 * @example
 *```js
 * var multiSelector = new AXMultiSelect();
 * multiSelector.setConfig({
 *     selectStage       : "selectStageBox", // 컨테이너 타겟 아이디
 *     selectClassName   : "readyselect", // 셀렉트 대상
 *     beselectClassName : "beSelected", // 셀렉트 되었을 때.
 *     selectingClassName: "AX_selecting" // 셀렉트중일 때
 * });
 *```
 */
var AXMultiSelect = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();

        /**
         * 선택된 아이템 <en>Array of selected Item.</en>
         * @member {Array} AXMultiSelect.selects
         */
        this.selects = [];
	    this.moveSens = 0;
	    this.touchMode;

        this.config.selectClassName = "readySelect";
        this.config.beselectClassName = "beSelected";
        this.config.selectingClassName = "AX_selecting";
        this.config.moveSens = 5;
        this.config.useHelper = true;
    },
    /**
     * @method AXMultiSelect.setConfig
     * @param {Object} config
     * @description 멀티셀렉트
     * @example
     *```js
     * var config = {
     *     selectStage: {String} - Element ID of select item container,
     *     selectClassName: {String} [readySelect] - CSS Class Name of select item,
     *     beselectClassName: {String} [beSelected] - CSS Class Name of selected item,
     *     selectingClassName: {String} [AX_selecting] - CSS Class Name of selecting item,
     *     moveSens: {Number} [5] - mouse position move of detect select,
     *     useHelper: {Boolean} [true] - use mouse select box
     * }
     * multiSelector.setConfig(config);
     *```
     */
    init: function () {

        var mouseClick = this.onmouseClick.bind(this);
        this._selectStage = axdom("#" + this.config.selectStage);
        this._selectStage.css({ "position": "relative" });

        /*
         if(AXUtil.browser.mobile){
         this._selectStage.css({"overflow":"visible", "min-height":this._selectStage.innerHeight(), "height":"auto"});
         }
         */

        this._selectStage.bind("mousedown", this.mousedown.bind(this));

        this._selectStage.bind("click", function (event) {
            mouseClick(this, event);
        });

        this.helper = axdom("<div class='AXMultiselectorHelper'></div>");
        this.collect();

        axdom(window).bind("resize.AXMultiSelect", this.collect.bind(this));
        axdom(window).bind("keydown.AXMultiSelect", this.onKeydown.bind(this));
        this._selectStage.bind("scroll", this.onScrollStage.bind(this));

        this._selectStage.bind("touchstart", this.touchstart.bind(this));
    },
    onKeydown: function (event) {
        if (event.keyCode == AXUtil.Event.KEY_ESC) {
            this.clearSelects();
        }
    },
    onScrollStage: function (event) {
        var cfg = this.config;
        if (!AXUtil.browser.mobile) {
            if (this.helperAppened || this.helperAppenedReady) {
                this.moveSens = 0;
                axdom(document.body).unbind("mousemove.AXMultiSelect");
                axdom(document.body).unbind("mouseup.AXMultiSelect");
                axdom(document.body).unbind("mouseleave.AXMultiSelect");
                axdom(document.body).removeAttr("onselectstart");
                //axdom(document.body).removeClass("AXUserSelectNone");
                this.helperAppenedReady = false;
                this.helperAppened = false;
                this.helper.remove();
            }
        }

    },
    /* ------------------------------------------------------------------------------------------------------------------ */
    /* observe method ~~~~~~ */
    onmouseClick: function (element, event) {
        if (this.helperAppened){
            return this;
        }
        var cfg = this.config;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            until: function (evt, evtIDs) { return (AXgetId(evt.parentNode) == AXgetId(cfg.selectStage)) ? true : false; },
            find: function (evt, evtIDs) { return (axdom(evt).hasClass(cfg.selectClassName)) ? true : false; }
        });

        if (myTarget) {
            var selectElement = myTarget;
            if (selectElement) {
                if (event.shiftKey) {
                    this.shiftSelects(selectElement);
                } else if (event.metaKey || event.ctrlKey) {
                    this.toggleSelects(selectElement);
                } else {
                    this.clickSelects(selectElement);
                }
            }
        } else {
            if (event.target.id == cfg.selectStage && AXUtil.browser.name != "ie") this.clearSelects();
        }
        return this;
    },
    /* ------------------------------------------------------------------------------------------------------------------ */
    /* class method ~~~~~~ */
    /**
     * @method AXMultiSelect.collect
     * @returns {AXMultiSelect}
     * @description 컨테이너안에 셀렉트 아이템을 재정의 합니다.
     * @example
     *```js
     * multiSelector.collect();
     * // 컨테이너안에 아이템의 변화가 생긴 경우 호출합니다.
     *```
     */
    collect: function () {
        var cfg = this.config;
        this._selectTargets = axdom("#" + cfg.selectStage + " ." + cfg.selectClassName);
        this.selectTargets = this._selectTargets.get();
        var scrollLeft = this._selectStage.scrollLeft().number();
        var scrollTop = this._selectStage.scrollTop().number();
        this._selectTargets.each(function () {
            var jQuerythis = axdom(this), pos = jQuerythis.position();
            axdom.data(this, "selectableItem", {
                element: this,
                jQueryelement: jQuerythis,
                left: pos.left + scrollLeft,
                top: pos.top + scrollTop,
                right: pos.left + scrollLeft + jQuerythis.outerWidth(),
                bottom: pos.top + scrollTop + jQuerythis.outerHeight(),
                selected: jQuerythis.hasClass(cfg.beselectClassName),
                selecting: jQuerythis.hasClass(cfg.selectingClassName)
            });
        });
	    return this;
    },
    clearSelects: function () {
        var cfg = this.config;
        this._selectTargets.each(function () {
            var selectTarget = axdom.data(this, "selectableItem");
            if (selectTarget) {
                if (selectTarget.selecting) {
                    selectTarget.jQueryelement.removeClass(cfg.selectingClassName);
                    selectTarget.selecting = false;
                }
                if (selectTarget.selected) {
                    selectTarget.jQueryelement.removeClass(cfg.beselectClassName);
                    selectTarget.selected = false;
                }
            }
        });
    },
    pushSelects: function (Obj) {
        var hasSelect = this.selects.has(function () {
            return this.item == Obj;
        });
        if (!hasSelect) this.selects.push(Obj);
    },
    clickSelects: function (Obj) {
        var cfg = this.config;

        this.clearSelects();

        var selectTarget = axdom.data(Obj, "selectableItem");
        selectTarget.jQueryelement.addClass(cfg.beselectClassName);
        selectTarget.selected = true;
    },
    toggleSelects: function (Obj) {
        var cfg = this.config;

        var selectTarget = axdom.data(Obj, "selectableItem");
        if (selectTarget.selected) {
            selectTarget.jQueryelement.removeClass(cfg.beselectClassName);
            selectTarget.selected = false;
        } else {
            selectTarget.jQueryelement.addClass(cfg.beselectClassName);
            selectTarget.selected = true;
        }
    },
    shiftSelects: function (Obj) {
        var cfg = this.config;

        var selectedLength = 0;
        var li, si;
        this._selectTargets.each(function (stIndex, ST) {
            var selectTarget = axdom.data(this, "selectableItem");
            if (selectTarget) {
                if (selectTarget.selected) {
                    selectedLength++;
                    li = stIndex;
                }
            }
            if (this === Obj) si = stIndex;
        });

        if (selectedLength == 0) {
            this.clickSelects(Obj);
        } else {
            //마지막 selects 개체를 찾는다.
            if (si == li) return;
            this.clearSelects();
            var temp;
            if (si > li) {
                temp = si;
                si = li;
                li = temp;
            }
            this._selectTargets.each(function (stIndex, ST) {
                var selectTarget = axdom.data(this, "selectableItem");
                if (selectTarget) {
                    if (si <= stIndex && li >= stIndex) {
                        selectTarget.jQueryelement.addClass(cfg.beselectClassName);
                        selectTarget.selected = true;
                    }
                }
            });
        }
    },

    /* mouser helper */
    mousedown: function (event) {
        var cfg = this.config;

        axdom(document.body).bind("mousemove.AXMultiSelect", this.mousemove.bind(this));
        axdom(document.body).bind("mouseup.AXMultiSelect", this.mouseup.bind(this));
        axdom(document.body).bind("mouseleave.AXMultiSelect", this.mouseup.bind(this));
        axdom(document.body).attr("onselectstart", "return false");
        //axdom(document.body).addClass("AXUserSelectNone");

        this.helperAppenedReady = true;
    },
    mousemove: function (event) {
        var cfg = this.config;
        if (!event.pageX) return;

        /*드래그 감도 적용 */
        if (this.config.moveSens > this.moveSens) this.moveSens++;
        if (this.moveSens == this.config.moveSens) this.selectorHelperMove(event);
    },
    mouseup: function (event) {
        var cfg = this.config, _this = this;

        this.helperAppenedReady = false;
        this.moveSens = 0;

        axdom(document.body).unbind("mousemove.AXMultiSelect");
        axdom(document.body).unbind("mouseup.AXMultiSelect");
        axdom(document.body).unbind("mouseleave.AXMultiSelect");

        axdom(document.body).removeAttr("onselectstart");
        //axdom(document.body).removeClass("AXUserSelectNone");

        if (this.helperAppened) {
            setTimeout(function(){
                _this.helperAppened = false;
                _this.helper.remove();
            }, 100);


            /* selected change */
            this._selectTargets.each(function () {
                var selectTarget = axdom.data(this, "selectableItem");
                if (selectTarget) {
                    if (selectTarget.selecting) {
                        selectTarget.jQueryelement.removeClass(cfg.selectingClassName);
                        selectTarget.selecting = false;
                        selectTarget.jQueryelement.addClass(cfg.beselectClassName);
                        selectTarget.selected = true;
                    }
                    /*
                    else if (selectTarget.selected) {

                    }
                    */
                }
            });
        }

    },
    selectorHelperMove: function (event) {
        var cfg = this.config;

        if (!cfg.useHelper) {
            return;
        }

        if (this.helperAppened) {

            var _helperPos = this.helperPos;
            var tmp,
                x1 = this.helperPos.x,
                y1 = this.helperPos.y,
                x2 = event.pageX - _helperPos.bodyLeft,
                y2 = event.pageY - _helperPos.bodyTop;
            if (x1 > x2) { tmp = x2; x2 = x1; x1 = tmp; }
            if (y1 > y2) { tmp = y2; y2 = y1; y1 = tmp; }
            this.helper.css({ left: x1, top: y1, width: x2 - x1, height: y2 - y1 });

            this._selectTargets.each(function () {

                var selectTarget = axdom.data(this, "selectableItem"), hit = false;
                /*trace({sl:selectTarget.left, sr:selectTarget.right, st:selectTarget.top, sb:selectTarget.bottom, x1:x1, x2:x2, y1:y1, y2:y2}); */
                if (!selectTarget) return;

                var stL = selectTarget.left.number(), stR = selectTarget.right.number(), stT = selectTarget.top.number(), stB = selectTarget.bottom.number();
                stL = stL + _helperPos.stageX - _helperPos.scrollLeft - _helperPos.bodyLeft;
                stR = stR + _helperPos.stageX - _helperPos.scrollLeft - _helperPos.bodyLeft;
                stT = stT + _helperPos.stageY - _helperPos.scrollTop - _helperPos.bodyTop;
                stB = stB + _helperPos.stageY - _helperPos.scrollTop - _helperPos.bodyTop;

                hit = (!(stL > x2 || stR < x1 || stT > y2 || stB < y1)); /* touch */
                /* hit = (selectTarget.left > x1 && selectTarget.right < x2 && selectTarget.top > y1 && selectTarget.bottom < y2); fit */
                if (hit) {
                    /* SELECT */
                    if (selectTarget.selected) {
                        selectTarget.jQueryelement.removeClass(cfg.beselectClassName);
                        selectTarget.selected = false;
                    }
                    if (!selectTarget.selecting) {
                        selectTarget.jQueryelement.addClass(cfg.selectingClassName);
                        selectTarget.selecting = true;
                    }
                } else {
                    /* UNSELECT */
                    if (selectTarget.selecting) {
                        selectTarget.jQueryelement.removeClass(cfg.selectingClassName);
                        selectTarget.selecting = false;
                    }
                    if (selectTarget.selected) {
                        if (!event.metaKey && !event.shiftKey && !event.ctrlKey) {
                            selectTarget.jQueryelement.removeClass(cfg.beselectClassName);
                            selectTarget.selected = false;
                        }
                    }
                }
            });

        } else {
            this.helperAppened = true;
            axdom(document.body).append(this.helper);

            var css = { left: (event.pageX - axdom(document.body).offset().left), top: (event.pageY - axdom(document.body).offset().top), width: 0, height: 0 };
            this.helper.css(css);
            var stagePos = this._selectStage.offset();
            this.helperPos = {
                stageX: stagePos.left.number(),
                stageY: stagePos.top.number(),
                x: css.left.number(),
                y: css.top.number(),
                scrollLeft: this._selectStage.scrollLeft().number(),
                scrollTop: this._selectStage.scrollTop().number(),
                bodyLeft: axdom(document.body).offset().left,
                bodyTop: axdom(document.body).offset().top
            };
        }
    },

    /* touch helper */
    touchstart: function (event) {
        var cfg = this.config;

        var touchEnd = this.touchEnd.bind(this);
        this.touchEndBind = function () {
            touchEnd(event);
        };

        var touchMove = this.touchMove.bind(this);
        this.touchMoveBind = function () {
            touchMove(event);
        };

        if (document.addEventListener) {
            document.addEventListener("touchend", this.touchEndBind, false);
            document.addEventListener("touchmove", this.touchMoveBind, false);
        }

        this.helperAppenedReady = true;
    },
    touchMove: function (event) {
        var cfg = this.config;
        var event = window.event || e;
        var touch = event.touches[0];
        if (!touch.pageX) return;
        var offset = this._selectStage.offset();
        var right = offset.left + this._selectStage.width();
        var bottom = offset.top + this._selectStage.height();

        if (this.moveSens == 0) {
            this.touchStartXY = { x: touch.pageX, y: touch.pageY, scrollTop: this._selectStage.scrollTop() };
        }

        /*드래그 감도 적용 */
        if (this.config.moveSens > this.moveSens) this.moveSens++;
        if (this.moveSens == this.config.moveSens) {
            if (this.touchMode == "drag") {
                if (bottom < touch.pageY) this._selectStage.scrollTop(this.touchStartXY.scrollTop - (bottom - touch.pageY));
                else if (offset.top > touch.pageY) this._selectStage.scrollTop(this.touchStartXY.scrollTop - (offset.top - touch.pageY));
                if (right < touch.pageX) this._selectStage.scrollLeft(this.touchStartXY.scrollLeft - (right - touch.pageX));
                else if (offset.left > touch.pageX) this._selectStage.scrollLeft(this.touchStartXY.scrollLeft - (offset.left - touch.pageX));
                this.selectorHelperMoveByTouch(event);
            } else if (this.touchMode == "scrollTop") {
                this._selectStage.scrollTop(this.touchStartXY.scrollTop + (this.touchStartXY.y - touch.pageY));
            } else if (this.touchMode == "scrollLeft") {
                this._selectStage.scrollLeft(this.touchStartXY.scrollLeft + (this.touchStartXY.x - touch.pageX));
            } else {
                if (((this.touchStartXY.x - touch.pageX).abs() - (this.touchStartXY.y - touch.pageY).abs()).abs() < 5) {
                    this.touchMode = "drag"
                    this.selectorHelperMoveByTouch(event);
                } else if ((this.touchStartXY.x - touch.pageX).abs() < (this.touchStartXY.y - touch.pageY).abs()) {
                    this.touchMode = "scrollTop";
                    this._selectStage.scrollTop(this.touchStartXY.scrollTop + (this.touchStartXY.y - touch.pageY));
                } else if ((this.touchStartXY.x - touch.pageX).abs() > (this.touchStartXY.y - touch.pageY).abs()) {
                    this.touchMode = "scrollLeft";
                    this._selectStage.scrollLeft(this.touchStartXY.scrollLeft + (this.touchStartXY.x - touch.pageX));
                }
            }
        }

        if (event.preventDefault) event.preventDefault();
        else return false;
    },
    selectorHelperMoveByTouch: function (e) {
        var cfg = this.config;
        var event = window.event || e;
        var touch = event.touches[0];

        if (this.helperAppened) {

            var _helperPos = this.helperPos;
            var tmp,
                x1 = this.helperPos.x,
                y1 = this.helperPos.y,
                x2 = touch.pageX - _helperPos.bodyLeft,
                y2 = touch.pageY - _helperPos.bodyTop;
            if (x1 > x2) { tmp = x2; x2 = x1; x1 = tmp; }
            if (y1 > y2) { tmp = y2; y2 = y1; y1 = tmp; }
            this.helper.css({ left: x1, top: y1, width: x2 - x1, height: y2 - y1 });

            this._selectTargets.each(function () {

                var selectTarget = axdom.data(this, "selectableItem"), hit = false;
                /*trace({sl:selectTarget.left, sr:selectTarget.right, st:selectTarget.top, sb:selectTarget.bottom, x1:x1, x2:x2, y1:y1, y2:y2}); */
                if (!selectTarget) return;

                var stL = selectTarget.left.number(), stR = selectTarget.right.number(), stT = selectTarget.top.number(), stB = selectTarget.bottom.number();
                stL = stL + _helperPos.stageX - _helperPos.scrollLeft - _helperPos.bodyLeft;
                stR = stR + _helperPos.stageX - _helperPos.scrollLeft - _helperPos.bodyLeft;
                stT = stT + _helperPos.stageY - _helperPos.scrollTop - _helperPos.bodyTop;
                stB = stB + _helperPos.stageY - _helperPos.scrollTop - _helperPos.bodyTop;

                hit = (!(stL > x2 || stR < x1 || stT > y2 || stB < y1)); /* touch */
                /* hit = (selectTarget.left > x1 && selectTarget.right < x2 && selectTarget.top > y1 && selectTarget.bottom < y2); fit */
                if (hit) {
                    /* SELECT */
                    if (selectTarget.selected) {
                        selectTarget.jQueryelement.removeClass(cfg.beselectClassName);
                        selectTarget.selected = false;
                    }
                    if (!selectTarget.selecting) {
                        selectTarget.jQueryelement.addClass(cfg.selectingClassName);
                        selectTarget.selecting = true;
                    }
                } else {
                    /* UNSELECT */
                    if (selectTarget.selecting) {
                        selectTarget.jQueryelement.removeClass(cfg.selectingClassName);
                        selectTarget.selecting = false;
                    }
                    if (selectTarget.selected) {
                        if (!event.metaKey && !event.shiftKey && !event.ctrlKey) {
                            selectTarget.jQueryelement.removeClass(cfg.beselectClassName);
                            selectTarget.selected = false;
                        }
                    }
                }
            });

        } else {
            this.helperAppened = true;
            axdom(document.body).append(this.helper);

            var css = { left: (touch.pageX - axdom(document.body).offset().left), top: (touch.pageY - axdom(document.body).offset().top), width: 0, height: 0 };
            this.helper.css(css);
            var stagePos = this._selectStage.offset();
            this.helperPos = {
                stageX: stagePos.left.number(),
                stageY: stagePos.top.number(),
                x: css.left.number(),
                y: css.top.number(),
                scrollLeft: this._selectStage.scrollLeft().number(),
                scrollTop: this._selectStage.scrollTop().number(),
                bodyLeft: axdom(document.body).offset().left,
                bodyTop: axdom(document.body).offset().top
            };
        }
    },
    touchEnd: function (e) {
        var cfg = this.config;
        var event = window.event || e;
        this.helperAppenedReady = false;
        this.moveSens = 0;

        this.touchMode = false;

        if (document.removeEventListener) {
            document.removeEventListener("touchend", this.touchEndBind, false);
            document.removeEventListener("touchmove", this.touchMoveBind, false);
        }

        if (this.helperAppened) {
            this.helperAppened = false;
            this.helper.remove();

            /* selected change */
            this._selectTargets.each(function () {
                var selectTarget = axdom.data(this, "selectableItem");
                if (selectTarget) {
                    if (selectTarget.selecting) {
                        selectTarget.jQueryelement.removeClass(cfg.selectingClassName);
                        selectTarget.selecting = false;
                        selectTarget.jQueryelement.addClass(cfg.beselectClassName);
                        selectTarget.selected = true;
                    } else if (selectTarget.selected) {

                    }
                }
            });
        }
    },
    /**
     * @method AXMultiSelect.getSelects
     * @returns {Array} selects
     * @description 셀렉트된 아이템 엘리먼트 배열을 반환합니다. Return Array of selected item element
     * @example
     *```js
     * multiSelector.getSelects();
     *```
     */
    getSelects: function () {
        var cfg = this.config;
        var selects = [];
        this._selectTargets.each(function () {
            var selectTarget = axdom.data(this, "selectableItem");
            if (selectTarget) {
                if (selectTarget.selected) {
                    selects.push(selectTarget.element);
                }
            }
        });
        return selects;
    },
    size: function () {
        var cfg = this.config;
        var selects = [];
        this._selectTargets.each(function () {
            var selectTarget = axdom.data(this, "selectableItem");
            if (selectTarget) {
                if (selectTarget.selected) {
                    selects.push(selectTarget.element);
                }
            }
        });
        return selects.length;
    }
});
/* ---------------------------------------------- AXMultiSelect -- */

/* -- AXResizable ---------------------------------------------- */
/**
 * 아이템을 주어진 조건에 맞게 리사이즈 할 수 있는 클래스
 * @class AXResizable
 * @classdesc
 * @extends AXJ
 * @version v0.9
 * @author tom@axisj.com
 * @logs
 "2013-11-12 오전 10:22:06"
 */
var AXResizable = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();
        this.moveSens = 0;
	    this.objects = [];

        this.config.moveSens = 2;
        this.config.bindResiableContainer = "AXResizable";
        this.config.bindResiableHandle = "AXResizableHandle";
    },
/**
 * @method AXResizable.setConfig
 * @param {Object} config
 * @description targetID를 지정합니다. 인스턴스간에 구분을 할 수 있게 해줍니다.
 * @example
```js
 var AXResizableBinder = new AXResizable();
 AXResizableBinder.setConfig({ targetID: "defaultResiable" });
```
 */
    init: function () {
        this.helper = axdom("<div class='AXResizableHelper'></div>");
    },
/**
 * @method AXResizable.bind
 * @param {Object} obj
 * @returns {AXResizable}
 * @example
```js
 var config = {
    id: {String} - Element ID,
    minWidth: {Number} [0],
    minHeight: {Number} [0],
	maxWidth: {Number} [0],
	maxHeight: {Number} [0],
	animate: {easing:"bounceOut", duration:500},
	aspectRatio: {Number} - 2/1,
	snap: {Number} - 10,
	onChange: function(){
		// this.id, this.element, this.jQueryElement, this.config
		toast.push(this.id);
	}
 };
 myResizer.bind(config);
```
 */
    bind: function (obj) {
        var cfg = this.config;
        if (!obj.id) {
            trace("bind 대상 ID가 없어 bind 처리할 수 없습니다.");
            return;
        }
        if (!AXgetId(obj.id)) {
            trace("bind 대상이 없어 bind 처리할 수 없습니다.");
            return;
        }
        var objID = obj.id;
        var objSeq = null;

        AXUtil.each(this.objects, function (idx, O) {
            /*if (this.id == objID && this.isDel == true) objSeq = idx;*/
            if (this.id == objID) {
                objSeq = idx;
            }
        });
        if (objSeq == null) {
            objSeq = this.objects.length;
            this.objects.push({
                id: objID,
                element: AXgetId(objID),
                jQueryElement: axdom("#" + objID),
                config: obj
            });
        } else {
            this.objects[objSeq].isDel = undefined;
            this.objects[objSeq].config = obj;
        }
        this.bindResizer(objID, objSeq);
		return this;
    },
/**
 * @method AXResizable.unbind
 * @param {Object} obj
 * @returns {AXResizable}
 * @description 바인드 해제 합니다.
 * @example
```js
 myResizer.unbind({id:"ElementID"});
```
 */
    unbind: function (obj) {
        var cfg = this.config;
        var removeIdx;
        AXUtil.each(this.objects, function (idx, O) {
            if (O.id != obj.id) {
            } else {
                if (O.isDel != true) {
                    removeIdx = idx;
                }
            }
        });
        if (removeIdx != undefined) {
            this.objects[removeIdx].isDel = true;
            /* unbind 구문 */
        }
		return this;
    },
    bindResizer: function (objID, objSeq) {
        var _this = this;
        var cfg = this.config;

        var obj = this.objects[objSeq];

        var po = [];
        po.push("<div class=\"" + cfg.bindResiableHandle + "\"></div>");
        obj.jQueryElement.addClass(cfg.bindResiableContainer);
        obj.jQueryElement.append(po.join(''));

        //obj.jQueryElement.bind("mousedown.AXResizable", function(){_this.mousedown(objID, objSeq, event)});
        obj.jQueryElement.bind("mousedown.AXResizable", this.mousedown.bind(this, objID, objSeq));
    },
    mousedown: function (objID, objSeq, event) {
        var _this = this;
        var cfg = this.config;

        axdom(window).bind("mousemove.AXResizable", this.mousemove.bind(this, objID, objSeq));
        axdom(window).bind("mouseup.AXResizable", this.mouseup.bind(this, objID, objSeq));
        /*axdom(document.body).bind("mouseleave.AXResizable", this.mouseup.bind(this, objID, objSeq));*/

        axdom(document.body).attr("onselectstart", "return false");
        //axdom(document.body).addClass("AXUserSelectNone");

        this.helperAppenedReady = true;
    },
    mousemove: function (objID, objSeq, event) {
        var cfg = this.config;
        if (!event.pageX) return;

        /*드래그 감도 적용 */
        if (this.config.moveSens > this.moveSens) this.moveSens++;
        if (this.moveSens == this.config.moveSens) this.selectorHelperMove(objID, objSeq, event);
    },
    mouseup: function (objID, objSeq, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        this.helperAppenedReady = false;
        this.moveSens = 0;

        axdom(window).unbind("mousemove.AXResizable");
        axdom(window).unbind("mouseup.AXResizable");
        /*axdom(document.body).unbind("mouseleave.AXResizable");*/

        axdom(document.body).removeAttr("onselectstart");
        //axdom(document.body).removeClass("AXUserSelectNone");

        if (this.helperAppened) {
            this.helperAppened = false;

            var newWidth = this.helper.width();
            var newHeight = this.helper.height();

            var paddingLeft = obj.jQueryElement.css("padding-left");
            var paddingRight = obj.jQueryElement.css("padding-right");
            var paddingTop = obj.jQueryElement.css("padding-top");
            var paddingBottom = obj.jQueryElement.css("padding-bottom");
            var paddingW = paddingLeft.number() + paddingRight.number();
            var paddingH = paddingTop.number() + paddingBottom.number();

            if (obj.config.animate) {
                obj.jQueryElement.animate(
                    { width: newWidth - paddingW, height: newHeight - paddingH },
                    (obj.config.animate.duration || 300), (obj.config.animate.easing || "liner"),
                    function () {
                        if (obj.config.onChange) {
                            obj.config.onChange.call(obj, obj);
                        }
                    }
                );
            } else {
                obj.jQueryElement.css({ width: newWidth - paddingW, height: newHeight - paddingH });
                if (obj.config.onChange) {
                    obj.config.onChange.call(obj, obj);
                }
            }

            this.helper.remove();
        }
    },
    selectorHelperMove: function (objID, objSeq, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        if (this.helperAppened) {

            var _helperPos = this.helperPos;
            var tmp,
                x1 = this.helperPos.x,
                y1 = this.helperPos.y,
                x2 = event.pageX - _helperPos.bodyLeft,
                y2 = event.pageY - _helperPos.bodyTop;

            var minWidth = (obj.config.minWidth || 0),
                minHeight = (obj.config.minHeight || 0),
                maxWidth = (obj.config.maxWidth || 0),
                maxHeight = (obj.config.maxHeight || 0);

            var myWidth = x2 - x1, myHeight = y2 - y1;

            if (minWidth != 0 && myWidth < minWidth) myWidth = minWidth;
            if (minHeight != 0 && myHeight < minHeight) myHeight = minHeight;
            if (maxWidth != 0 && myWidth > maxWidth) myWidth = maxWidth;
            if (maxHeight != 0 && myHeight > maxHeight) myHeight = maxHeight;

            if (obj.config.aspectRatio) {
                myWidth = myHeight * obj.config.aspectRatio;
            }

            if (obj.config.snap) {
                myWidth = obj.config.snap * (myWidth / obj.config.snap).ceil();
                myHeight = obj.config.snap * (myHeight / obj.config.snap).ceil();
            }
            //trace({width: myWidth, height: myHeight});
            this.helper.css({ width: myWidth, height: myHeight });

        } else {
            this.helperAppened = true;
            axdom(document.body).append(this.helper);

            var bodyLeft = axdom(document.body).offset().left;
            var bodyTop = axdom(document.body).offset().top;

            var pos = obj.jQueryElement.offset();
            var css = {
                left: pos.left + bodyLeft,
                top: pos.top + bodyLeft,
                width: obj.jQueryElement.outerWidth(),
                height: obj.jQueryElement.outerHeight()
            };
            this.helper.css(css);

            this.helperPos = {
                x: css.left,
                y: css.top,
                bodyLeft: axdom(document.body).offset().left,
                bodyTop: axdom(document.body).offset().top
            };
        }
    }
});
var AXResizableBinder = new AXResizable();
AXResizableBinder.setConfig({ targetID: "defaultResizable" });

/**
 * @method jQueryExtends.bindAXResizable
 * @param {Object} config
 * @returns {jQueryObject}
 * @description box 엘리먼트 크기를 조정할 수 있게 해줍니다.
 * @example
 ```js
 $("#mytarget").bindAXResizable({
	minWidth:50, minHeight:50,
	maxWidth:200, maxHeight:200,
	animate: {easing:"bounceOut", duration:500},
	aspectRatio: 2/1,
	snap:10,
	onChange: function(){
		toast.push(this.id);
	}
 });

 // 옵션 스펙
 var config = {
    minWidth: {Number} [0],
    minHeight: {Number} [0],
	maxWidth: {Number} [0],
	maxHeight: {Number} [0],
	animate: {easing:"bounceOut", duration:500},
	aspectRatio: {Number} - 2/1,
	snap: {Number} - 10,
	onChange: function(){
		// this.id, this.element, this.jQueryElement, this.config
		toast.push(this.id);
	}
 };

 ```
 */
axdom.fn.bindAXResizable = function (config) {
    AXUtil.each(this, function () {
        config = config || {}; config.id = this.id;
        AXResizableBinder.bind(config);
        return this;
    });
	return this;
};

/**
 * @method jQueryExtends.unbindAXResizable
 * @param {Object} [config]
 * @returns {jQueryObject}
 * @description box 엘리먼트 크기를 조정자를 제거합니다.
 * @example
 ```js
 $("#mytarget").unbindAXResizable();
 ```
 */
axdom.fn.unbindAXResizable = function (config) {
    AXUtil.each(this, function () {
        if (config == undefined) config = {};
        config.id = this.id;
        AXResizableBinder.unbind(config);
        return this;
    });
	return this;
};
/* ---------------------------------------------- AXResizable -- */

/* -- AXContextMenu ---------------------------------------------- */
/**
 * AXContextMenuClass
 * @class AXContextMenuClass
 * @extends AXJ
 * @version v1.28
 * @author tom@axisj.com, axisj.com
 * @logs
 "2013-03-22 오후 6:08:57",
 "2013-09-03 오후 7:10:14 메뉴확장 위치 제어 버그 픽스",
 "2013-12-16 href=javascript 설정했을 때 onbeforeunload 이벤트 충돌문제 해결",
 "2013-12-26 오후 4:27:00 tom, left, top position ",
 "2014-02-11 오전 11:06:13 root, subMenu underLine, upperLine add",
 "2014-04-07 오전 9:55:57 tom, extent checkbox, sortbox"
 "2014-06-24 tom : reserveKeys.subMenu 설정할 수 있도록 기능 보강, 콜백함수 개선"
 "2014-12-18 tom : onclose 속성을 추가 할 수 있도록 속성 추가
 "2014-12-22 tom : filter를 통과한 메뉴 아이템이 없을 경우 표시 안하도록 변경"
 "2015-01-22 tom : item false 이면 표시 안하도록 변경"
 "2015-02-26 tom : bind를 다시 할때 reserveKeys 초기화 버그 픽스"
 */

var AXContextMenuClass = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();
        this.showedItem = {};
        this.objects = [];
        this.config.theme = "AXContextMenu";
        this.config.width = "140";
        this.config.responsiveMobile = 0; /* 모바일 반응 너비 */
	    this.config.reserveKeys = {
		    subMenu: "subMenu"
	    };
    },
/**
 * @method AXContextMenuClass.setConfig
 * @param {Object} configs
 * @description 선언된 클래스를 사용하기 위해 속성을 정의합니다.
 * @example
```js
 var AXContextMenu = new AXContextMenuClass();
 AXContextMenu.setConfig({});
```
 */
    init: function () {

    },
/**
 * @method AXContextMenuClass.bindSetConfig
 * @param {String} objID - object ID
 * @param {Object} configs - contentMenu config
 * @description contextmenu 오브젝트에 속성을 변경합니다.
 * @example
```js
 AXContextMenu.bindSetConfig("contenxt01", {});
```
 */
    bindSetConfig: function (objID, configs) {
        var findIndex = null;
        AXUtil.each(this.objects, function (index, O) {
            if (O.id == objID) {
                findIndex = index;
                return false;
            }
        });
        if (findIndex == null) {
            //trace("바인드 된 오브젝트를 찾을 수 없습니다.");
            return;
        } else {
            var _self = this.objects[findIndex];
            axf.each(configs, function (k, v) {
                _self.config[k] = v;
            });
        }
    },
/**
 * @method AXContextMenuClass.bind
 * @param {Object} obj - 컨텍스트메뉴 속성
 * @returns {AXContextMenuClass}
 * @description 컨텍스트메뉴를 선언하여 컨텍스트메뉴를 사용준비합니다. bind한 컨텍스트메뉴는 id로 open 할 수 있습니다.
 * @example
```js
 AXContextMenu.bind({
		id:"myContextMenu",
		theme:"AXContextMenu", // 선택항목
		width:"150", // 선택항목
		checkbox:"checkbox", // [checkbox|radio]
		sortbox:true,
		menu:[
			{
				label:'선택 1',
				checked:true,
				className: 'doc | docline | plus | minus | group | edit | copy | cut | paste | up | down | left | right | link | unlink | openall | closeall'
				onclick:function(){
					return false;
				}
			},
			{label:'선택 2', checked:true,
				subMenu:[
					{label:"하위메뉴1"},
					{label:"하위메뉴2",
						subMenu:[
							{label:"하위메뉴21"},
							{label:"하위메뉴22"}
						]
					},
					{label:"하위메뉴3"},
					{label:"하위메뉴3"},
					{label:"하위메뉴3"}
				]
			},
			{label:'선택 3', checked:true},
			{label:'선택 4', checked:false, sort:"asc"} // config 에 checkbox 가 있는데. menu에 onclick 가 없으면 체크박스 액션이 작동합니다.
		],
		onchange: function(){ // 체크박스 선택값이 변경 된 경우 호출 됩니다.
			trace(this.menu);

			// return true; 메뉴 창이 닫히지 않게 합니다.
		},
		onsort: function(){ // 정렬이 변경 된 경우 호출 됩니다.
			trace(this.sortMenu);

			// return true; 메뉴 창이 닫히지 않게 합니다.
		}
	});
```
 */
    bind: function (obj) {
        var cfg = this.config;
        if (!obj.id) {
            trace("ID가 없어 bind 처리할 수 없습니다. AXContentMenu.bind({id:'idValue'});");
            return;
        }
        var objSeq = null;
        axf.each(this.objects, function (idx, O) {
            if (this.id == obj.id) {
                objSeq = idx;
                return false;
            }
        });

		if(!obj.reserveKeys){
			obj.reserveKeys = cfg.reserveKeys;
		}
        if (objSeq != null) {
            this.objects[objSeq] = obj;
            return this;
        }
        objSeq = this.objects.length;

        this.objects.push(obj);
		return this;
    },
    filter: function (objSeq, objID, myobj, menu) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        if (myobj.filter) {
            var sendObj = {
                menu: menu,
                sendObj: obj.sendObj
            };
            return myobj.filter.call(sendObj, objID);
        } else {
            return true;
        }
    },
    getSubMenu: function (parentID, objSeq, objID, myobj, subMenu, depth) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        var theme = obj.theme || cfg.theme;
        var width = obj.width || cfg.width;

        var filter = this.filter.bind(this);
        var getSubMenu = this.getSubMenu.bind(this);
        var subMenuID = parentID + "_AX_subMenu";

        var href = (obj.href == undefined) ? cfg.href : obj.href;
        var po = [];
        po.push("<div id=\"" + subMenuID + "\" class=\"" + theme + "\" style=\"width:" + width + "px;left:" + (width.number() - 15) + "px;display:none;\">");
        AXUtil.each(subMenu, function (idx, menu) {
            if (filter(objSeq, objID, myobj, menu)) {
                if (menu.upperLine) po.push("<div class=\"hline\"></div>");
                var className = (menu.className) ? menu.className : "";
                var hasSubMenu = (menu[obj.reserveKeys.subMenu]) ? " hasSubMenu" : "";
                po.push("<a " + href + " class=\"contextMenuItem " + className + hasSubMenu + "\" id=\"" + subMenuID + "_AX_" + depth + "_AX_" + idx + "\">");
                var checked = "";
                if(obj.checkbox){
                    if(menu.checked) checked = " on";
                    po.push("<div class='tool-checkbox"+ checked +"' id=\"" + subMenuID + "_tool_AX_" + depth + "_AX_" + idx + "\"></div>");
                }

                po.push("<span class='label'>" + menu.label + "</span>");

                if(menu.shotCut) po.push("<span class='shot-cut'>" + menu.shotCut + "</span>");

                po.push("<div class='tool-rightGroup'>");
                if (menu[obj.reserveKeys.subMenu] && menu[obj.reserveKeys.subMenu].length > 0) po.push("<div class=\"contextSubMenuIcon\"></div>");
                po.push("</div>");
                po.push("</a>");
                menu.__axdomId = subMenuID + "_AX_" + depth + "_AX_" + idx;

                if (menu[obj.reserveKeys.subMenu] && menu[obj.reserveKeys.subMenu].length > 0) po.push(getSubMenu(subMenuID + "_AX_" + depth + "_AX_" + idx, objSeq, objID, myobj, menu[obj.reserveKeys.subMenu], (depth + 1)));
                if (menu.underLine) po.push("<div class=\"hline\"></div>");
            }
        });
        po.push("</div>");
        return po.join('');
    },
/**
 * @method AXContextMenuClass.open
 * @param {Object} myobj
 * @param {Event|Object} position - 이벤트 객체를 전달하거나 {left:[Number], top:[Number]} 를 전달합니다.
 * @returns {AXContextMenuClass}
 * @description bind된 컨텍스트메뉴 개체를 오픈합니다. (이벤트속성에 정해진 마우스 포지션또는 사용자가 정한 left, top 포지션에)
 * @example
```js
AXContextMenu.open({
	id:"myContextMenuTree", sendObj:{id:"전달하고싶은 오브젝트", name:"형식은 자유"}
}, event); // event 직접 연결 방식

AXContextMenu.open({
	id:"myContextMenuTree", sendObj:{id:"전달하고싶은 오브젝트", name:"형식은 자유"}
}, {left:0, top:0}); // position 직접 결정 방식
```
 */
    open: function (myobj, position) {
        var cfg = this.config;
        if(axf.clientWidth() < cfg.responsiveMobile){
            this.mobileOpen(myobj, position);
        }else{
            this.deskTopOpen(myobj, position);
        }
		return this;
    },
    mobileOpen: function(myobj, position){
        var cfg = this.config;
        var objSeq = null;
        AXUtil.each(this.objects, function (index, O) {
            if (O.id == myobj.id) {
                objSeq = index;
                return false;
            }
        });
        if (objSeq == null) {
            //trace("바인드 된 오브젝트를 찾을 수 없습니다.");
            return;
        }
        var obj = this.objects[objSeq];
        var objID = obj.id;

        this.modal = new AXMobileModal();
        this.modal.setConfig({
            addClass:"",
            height: 388,
            width: 300,
            head:{
                //title:(myobj.title||AXConfig.AXContextMenu.title),
                close:{
                    onclick:function(){}
                }
            },
            onclose: function(){}
        });

        var initMobileModalBind = this.initMobileModal.bind(this);
        var onLoad = function(modalObj){
            initMobileModalBind(objID, objSeq, myobj, modalObj);
        };
        this.modal.open(null, onLoad);
        this.mobileMode = true;
    },
    initMobileModal: function(objID, objSeq, myobj, modalObj){ // 현재 선택된 모바일 메뉴를 오픈합니다.
        var cfg = this.config, _this = this;
        var obj = this.objects[objSeq];
        this.mobileModalObj = {
            myobj:myobj,
            modalObj:modalObj
        }; // memo mobileModal
        if (myobj.sendObj) {
            obj.sendObj = myobj.sendObj;
        }
        var href = (obj.href == undefined) ? cfg.href : obj.href;
        var filter = this.filter.bind(this);

        var headPo = [];
        /* 현재 선택된 메뉴 선택 하는 기능구현 필요 */
        headPo.push('<a ' + href + ' class="AXContextMenuHome">home</a>');
        headPo.push('<span id="' + objID + '_AX_mobileMenuPrevBox"></span>');
        modalObj.modalHead.empty();
        modalObj.modalHead.append(headPo.join(''));

        modalObj.modalHead.find(".AXContextMenuHome").bind("click", function(){
            _this.initMobileModal(objID, objSeq, myobj, modalObj);
        });

        var styles = [];
        styles.push("height:339px;");
        var menuList = obj.menu;
        var po = [];
        po.push("<div id=\"" + objID + "_AX_containerBox\" class=\"AXContextMenuContainer\" style=\"" + styles.join(";") + "\">");
        po.push("<div id=\"" + objID + "_AX_scroll\" class=\"AXContextMenuScroll\">");

	    if(typeof obj.reserveKeys == "undefined"){
		    obj.reserveKeys = cfg.reserveKeys;
	    }

        axf.each(menuList, function (idx, menu) {
            if (menu && filter(objSeq, objID, myobj, menu)) {
                //if (menu.upperLine) po.push("<div class=\"hline\"></div>");
                var className = (menu.className) ? " " + menu.className : "";
                var hasSubMenu = (menu[obj.reserveKeys.subMenu]) ? " hasSubMenu" : "";
                po.push("<a " + href + " class=\"contextMenuItem" + className + hasSubMenu + "\" id=\"" + objID + "_AX_contextMenu_AX_"+ 0 +"_AX_" + idx + "\">");

                var checked = "";
                if(obj.checkbox){
                    if(menu.checked) checked = " on";
                    po.push("<div class='tool-checkbox"+ checked +"' id=\"" + objID + "_AX_contextMenuToolCheck_AX_"+ 0 +"_AX_" + idx + "\"></div>");
                }

                po.push("<span class='label'>" + menu.label + "</label>");

                if(menu.shotCut) po.push("<span class='shot-cut'>" + menu.shotCut + "</span>");

                po.push("<div class='tool-rightGroup'>");
                if (menu[obj.reserveKeys.subMenu] && menu[obj.reserveKeys.subMenu].length > 0) po.push("<div class=\"contextSubMenuIcon\"></div>");
                if (obj.sortbox){
                    var sortdirect = "";
                    if(menu.sort){
                        sortdirect = " " + menu.sort.toString().lcase();
                    }
                    po.push("<div class=\"tool-sort"+ sortdirect +"\" id=\"" + objID + "_AX_contextMenuToolSort_AX_"+ 0 +"_AX_" + idx + "\"></div>");
                }
                po.push("</div>");
                po.push("</a>");

                menu.__axdomId = objID + "_AX_contextMenu_AX_0_AX_" + idx;
                //if (menu.underLine) po.push("<div class=\"hline\"></div>");
            }
        });
        po.push("</div>");
        po.push("</div>");

        modalObj.modalBody.empty();
        modalObj.modalBody.append(po.join(''));

        this.myUIScroll = new AXScroll();
        this.myUIScroll.setConfig({
            targetID: objID + "_AX_containerBox",
            scrollID: objID + "_AX_scroll"
        });

        var contextMenuItemClick = this.contextMenuItemClick.bind(this);
        var closeMobileModal = this.closeMobileModal.bind(this);
        this.contextMenuItemClickBind = function (event) {
            contextMenuItemClick(event, objSeq, objID);
            //closeMobileModal();
        };
        modalObj.modalBody.find(".contextMenuItem").bind("click", this.contextMenuItemClickBind);
    },

    mobileModalSubMenu: function (parentID, objSeq, objID, myobj, modalObj, pMenu, depth) {
        var cfg = this.config, _this = this;
        var obj = this.objects[objSeq];
        var theme = obj.theme || cfg.theme;
        var width = obj.width || cfg.width;

        var filter = this.filter.bind(this);
        var mobileModalSubMenu = this.mobileModalSubMenu.bind(this);
        var subMenuID = parentID + "_AX_subMenu";

        var href = (obj.href == undefined) ? cfg.href : obj.href;

        var poi = parentID.split(/_AX_/g);
        var pdepth = poi[poi.length - 2].number();
        /*
         if(pdepth == 0) {
         this.mobileModalObj.previousMenu = "root";
         this.mobileModalObj.nowMenu = pMenu.__axdomId;
         }else{
         this.mobileModalObj.previousMenu = this.mobileModalObj.nowMenu;
         this.mobileModalObj.nowMenu = pMenu.__axdomId;
         }
         */
        //trace(axdom("#" + objID + "_AX_mobileMenuPrevBox").get(0));
        axdom("#" + objID + "_AX_mobileMenuPrevBox").html('<a class="AXContextMenuPrev" id="'+objID+'_AX_prev_AX_'+poi.join("_")+'">'+pMenu.label+'</a>');

        axdom("#"+objID+'_AX_prev_AX_'+poi.join("_")).bind("click", function(){
            if(pdepth == 0) {
                _this.initMobileModal(objID, objSeq, myobj, modalObj);
            }else{
                var poi = pMenu.__axdomId.split(/_AX_/g);
                var _depth = poi[poi.length - 2].number();
                var hashs = [];

                var mystrPosition = poi.length - 1;
                for (var r = 0; r < depth + 1; r++) {
                    if(!isNaN(poi[mystrPosition])) hashs.push(poi[mystrPosition]);
                    mystrPosition -= 3;
                }
                hashs = hashs.reverse();
                hashs.pop();
                var menu = obj.menu;
                for (var hash, idx= 0, __arr = hashs; (idx < __arr.length && (hash = __arr[idx])); idx++) {
                    if (idx == 0) menu = menu[hash];
                    else menu = menu[obj.reserveKeys.subMenu][hash];
                }
                _this.mobileModalSubMenu(menu.__axdomId,  objSeq, objID,  _this.mobileModalObj.myobj, _this.mobileModalObj.modalObj, menu, (depth-1));
            }
        });

        var styles = [];
        styles.push("height:339px;");
        var menuList = pMenu[obj.reserveKeys.subMenu];
        var po = [];
        po.push("<div id=\"" + objID + "_AX_containerBox\" class=\"AXContextMenuContainer\" style=\"" + styles.join(";") + "\">");
        po.push("<div id=\"" + objID + "_AX_scroll\" class=\"AXContextMenuScroll\">");
        axf.each(menuList, function (idx, menu) {
            if (menu && filter(objSeq, objID, myobj, menu)) {
                var className = (menu.className) ? " " + menu.className : "";
                var hasSubMenu = (menu[obj.reserveKeys.subMenu]) ? " hasSubMenu" : "";
                po.push("<a " + href + " class=\"contextMenuItem" + className + hasSubMenu + "\" id=\"" + subMenuID + "_AX_" + depth + "_AX_" + idx + "\">");

                var checked = "";
                if(obj.checkbox){
                    if(menu.checked) checked = " on";
                    po.push("<div class='tool-checkbox"+ checked +"' id=\"" + subMenuID + "_AX_contextMenuToolCheck_AX_" + depth + "_AX_" + idx + "\"></div>");
                }

                po.push("<span class='label'>" + menu.label + "</label>");

                if(menu.shotCut) po.push("<span class='shot-cut'>" + menu.shotCut + "</span>");

                po.push("<div class='tool-rightGroup'>");
                if (menu[obj.reserveKeys.subMenu] && menu[obj.reserveKeys.subMenu].length > 0) po.push("<div class=\"contextSubMenuIcon\"></div>");
                if (obj.sortbox){
                    var sortdirect = "";
                    if(menu.sort){
                        sortdirect = " " + menu.sort.toString().lcase();
                    }
                    po.push("<div class=\"tool-sort"+ sortdirect +"\" id=\"" + subMenuID + "_AX_contextMenuToolSort_AX_"+ depth +"_AX_" + idx + "\"></div>");
                }
                po.push("</div>");

                po.push("</a>");

                menu.__axdomId = subMenuID + "_AX_" + depth + "_AX_" + idx;
            }
        });
        po.push("</div>");
        po.push("</div>");

        modalObj.modalBody.empty();
        modalObj.modalBody.append(po.join(''));

        this.myUIScroll = new AXScroll();
        this.myUIScroll.setConfig({
            targetID: objID + "_AX_containerBox",
            scrollID: objID + "_AX_scroll"
        });

        var contextMenuItemClick = this.contextMenuItemClick.bind(this);
        var closeMobileModal = this.closeMobileModal.bind(this);
        this.contextMenuItemClickBind = function (event) {
            contextMenuItemClick(event, objSeq, objID);
            //closeMobileModal();
        };
        modalObj.modalBody.find(".contextMenuItem").bind("click", this.contextMenuItemClickBind);
    },

    closeMobileModal: function(){
        var cfg = this.config;
        this.modal.close();
    },
    deskTopOpen: function (myobj, position) {
        var cfg = this.config;
        var objSeq = null;
        this.mobileMode = false;
        AXUtil.each(this.objects, function (index, O) {
            if (O.id == myobj.id) {
                objSeq = index;
                return false;
            }
        });
        if (objSeq == null) {
            //trace("바인드 된 오브젝트를 찾을 수 없습니다.");
            return;
        }
        var obj = this.objects[objSeq];
        var objID = obj.id;

        if (myobj.sendObj) {
            obj.sendObj = myobj.sendObj;
        }

        if (AXgetId(objID)) return;

        var theme = obj.theme || cfg.theme;
        var width = obj.width || cfg.width;

        axdom("#" + objID).remove();

        var href = (obj.href == undefined) ? cfg.href : obj.href;

        var filter = this.filter.bind(this);
        var getSubMenu = this.getSubMenu.bind(this);

        var displayMenuCount = 0;
        var po = [];
        po.push("<div id=\"" + objID + "\" class=\"" + theme + "\" style=\"width:" + width + "px;\">");
        AXUtil.each(obj.menu, function (idx, menu) {
            if (menu && filter(objSeq, objID, myobj, menu)) {

                if (menu.upperLine) {
                    po.push("<div class=\"hline\"></div>");
                }
                var className = (menu.className) ? " " + menu.className : "";
                var hasSubMenu = (menu[obj.reserveKeys.subMenu]) ? " hasSubMenu" : "";
                po.push("<a " + href + " class=\"contextMenuItem" + className + hasSubMenu + "\" id=\"" + objID + "_AX_contextMenu_AX_0_AX_" + idx + "\">");
                var checked = "";
                if(obj.checkbox){
                    if(menu.checked) checked = " on";
                    po.push("<div class='tool-checkbox"+ checked +"' id=\"" + objID + "_AX_contextMenuTool_AX_0_AX_" + idx + "\"></div>");
                }

                po.push("<span class='label'>" + menu.label + "</span>");

                if(menu.shotCut) po.push("<span class='shot-cut'>" + menu.shotCut + "</span>");

                po.push("<div class='tool-rightGroup'>");
                if (menu[obj.reserveKeys.subMenu] && menu[obj.reserveKeys.subMenu].length > 0) po.push("<div class=\"contextSubMenuIcon\"></div>");
                if (obj.sortbox)  po.push("<div class=\"tool_sort desc\"></div>");
                po.push("</div>");
                po.push("</a>");

                menu.__axdomId = objID + "_AX_contextMenu_AX_0_AX_" + idx;

                if (menu[obj.reserveKeys.subMenu]) {
                    if (menu[obj.reserveKeys.subMenu].length > 0) {
                        po.push(getSubMenu(objID + "_AX_contextMenu_AX_0_AX_" + idx, objSeq, objID, myobj, menu[obj.reserveKeys.subMenu], 1));
                    }
                }
                if (menu.underLine) {
                    po.push("<div class=\"hline\"></div>");
                }
                displayMenuCount++;
            }
        });
        po.push("</div>");

        if(displayMenuCount == 0){
            // 표시할 메뉴가 없음.
            return false;
        }
        axdom(document.body).append(po.join(''));

        axdom("#" + objID + " .contextMenuItem:first-child").addClass("first");
        axdom("#" + objID + " .contextMenuItem:last-child").addClass("last");

        var contextMenuItemMouseOver = this.contextMenuItemMouseOver.bind(this);
        this.contextMenuItemMouseOverBind = function (event) {
            contextMenuItemMouseOver(event, objSeq, objID);
        };
        axdom("#" + objID + " .contextMenuItem").bind("mouseover", this.contextMenuItemMouseOverBind);

        //컨텍스트 메뉴의 위치 지정
        var css = {};
        if (!position.clientX) {
            if (position.left != undefined) css.left = position.left;
            else css.right = position.right;
            css.top = position.top;
        } else {
            var mouse = this.getMousePositon(position);
            css.left = mouse.pageX;
            css.top = mouse.pageY;
        }

        // -- 부모박스 정보와 박스 정보
        var pElement = axdom("#" + objID).offsetParent();
        var pBox = { width: pElement.width(), height: pElement.height() };
        var clientHeight = (AXUtil.docTD == "Q") ? document.body.scrollHeight : document.documentElement.scrollHeight;
        var clienWidth = (AXUtil.docTD == "Q") ? document.body.scrollWidth : document.documentElement.scrollWidth;
        if (clienWidth > pBox.width) pBox.width = clienWidth;
        if (clientHeight > pBox.height) pBox.height = clientHeight;
        var _box = { width: axdom("#" + objID).outerWidth(), height: axdom("#" + objID).outerHeight() };
        // -- 부모박스 정보와 박스 정보

        if ((_box.height.number() + css.top.number()) > pBox.height) {
            css.top -= ((_box.height.number() + css.top.number()) - pBox.height) + 25;
            this.openTB = "up";
            if(css.top < 0) css.top = 0;
        }

        if (css.left != undefined) {

            if ((_box.width.number() + css.left.number()) > pBox.width) {
                var moveLeft = ((_box.width.number() + css.left.number()) - pBox.width) + 25;
                css.left -= moveLeft;
                this.openLR = "left";
            } else {
                if ((_box.width.number() * 2 + css.left.number()) > pBox.width) {
                    this.openLR = "left";
                }
            }

            /*
             if((_box.width.number() + css.left.number()) > pBox.width){
             css.left -= ((_box.width.number() + css.left.number()) - pBox.width) + 5;
             this.openLR = "left";
             }
             */
        } else {
            css.left = "auto";
            this.openLR = "right";
        }
        axdom("#" + objID).css(css);

        this.eventBind(objSeq, objID);
    },
    eventBind: function (objSeq, objID) {
        var cfg = this.config;
        /* closeEvent bind */
        var contextMenuItemDown = this.contextMenuItemDown.bind(this);
        var contextMenuItemDownBind = function (event) {
            contextMenuItemDown(event, objSeq, objID);
        };

        axdom(document).bind("mousedown.AXContenxtMenu", contextMenuItemDownBind);
        axdom(document).bind("keydown.AXContenxtMenu", contextMenuItemDownBind);

        axdom(document).find("iframe").each(function () {
            try{
                axdom(window[this.name].document).bind("mousedown.AXContenxtMenu", contextMenuItemDownBind);
                axdom(window[this.name].document).bind("keydown.AXContenxtMenu", contextMenuItemDownBind);
            }catch(e){

            }
        });

        /* closeEvent bind ~~~~~~~~~~~~~~~~~~~ */
        //click
        var contextMenuItemClick = this.contextMenuItemClick.bind(this);
        this.contextMenuItemClickBind = function (event) {
            contextMenuItemClick(event, objSeq, objID);
        };
        axdom("#" + objID).find(".contextMenuItem").bind("click", this.contextMenuItemClickBind);
    },
    // 이벤트로 인한 닫기
    _close: function (objSeq, objID) {
        var cfg = this.config,
            obj = this.objects[objSeq],
            that = {id:obj.id, event_type:"event"};

        if(this.mobileMode){
            this.closeMobileModal();
        }else{
            axdom("#" + objID).fadeOut("fast", function () {
                axdom("#" + objID).remove();
            });
        }

        axdom(document).unbind("keydown.AXContenxtMenu");
        axdom(document).unbind("mousedown.AXContenxtMenu");

        axdom(document).find("iframe").each(function () {
	        if(window[this.name]){
		        axdom(window[this.name].document).unbind("mousedown.AXContenxtMenu");
		        axdom(window[this.name].document).unbind("keydown.AXContenxtMenu");
	        }
        });

        this.showedItem = {}; // 초기화
        this.openTB = "";
        this.openLR = "";

        if(obj.onclose){
            obj.onclose.call(that);
        }
    },
/**
 * @method AXContextMenuClass.close
 * @param {Object} obj
 * @returns {AXContextMenuClass}
 * @description 열린 컨텍스트메뉴 개체를 닫습니다.
 * @example
```js
AXContextMenu.close({
	id:"myContextMenuTree"
});
```
 */
    close: function (myobj) {
        var cfg = this.config,
            objSeq = null;

        axf.each(this.objects, function (index, O) {
            if (O.id == myobj.id) {
                objSeq = index;
                return false;
            }
        });
        if (objSeq == null) {
            //trace("바인드 된 오브젝트를 찾을 수 없습니다.");
            return;
        }

        var obj = this.objects[objSeq], objID = obj.id,
            that = {id:obj.id, event_type:"script"};

        if(this.mobileMode){
            this.closeMobileModal();
        }else{
            axdom("#" + objID).fadeOut("fast", function () {
                axdom("#" + objID).remove();
            });
        }

        axdom(document).unbind("keydown", this.contextMenuItemDownBind);
        axdom(document).unbind("mousedown", this.contextMenuItemDownBind);

        this.showedItem = {}; // 초기화
        this.openTB = "";
        this.openLR = "";

        if(obj.onclose){

        }

		return this;
    },
    contextMenuItemMouseOver: function (event, objSeq, objID) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        var menuWidth = obj.width || cfg.width;
        // event target search -
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            find: function (evt, evtIDs) { return (axdom(evt).hasClass("contextMenuItem")) ? true : false; }
        });
        // event target search ------------------------
        if (myTarget) {
            var poi = myTarget.id.split(/_AX_/g);
            var depth = poi[poi.length - 2];
            if (this.showedItem[depth]) {
                axdom("#" + this.showedItem[depth]).hide();
            }
            if (axdom(myTarget).hasClass("hasSubMenu")) {

                // -- 부모박스 정보와 박스 정보
                var pElement = axdom("#" + myTarget.id + "_AX_subMenu").offsetParent();
                var pBox = { width: pElement.width(), height: pElement.height() };
                var clientHeight = (AXUtil.docTD == "Q") ? document.body.scrollHeight : document.documentElement.scrollHeight;
                var clienWidth = (AXUtil.docTD == "Q") ? document.body.scrollWidth : document.documentElement.scrollWidth;
                if (clienWidth > pBox.width) pBox.width = clienWidth;
                if (clientHeight > pBox.height) pBox.height = clientHeight;
                var _box = { width: axdom("#" + myTarget.id + "_AX_subMenu").outerWidth(), height: axdom("#" + myTarget.id + "_AX_subMenu").outerHeight() };
                // -- 부모박스 정보와 박스 정보

                var subMenuTop = axdom("#" + myTarget.id).position().top;

                var css;
                if (this.openTB == "up") {
                    var ph = axdom("#" + myTarget.id).offsetParent().height();
                    var h = axdom("#" + myTarget.id).height();
                    var bottom = ph - subMenuTop - h;
                    css = { top: "auto", bottom: bottom };
                } else {
                    css = { top: subMenuTop };
                }
                if (this.openLR == "left") {
                    //css.left = -(menuWidth - 15);
                    css.left = -(20);
                }

                axdom("#" + myTarget.id + "_AX_subMenu").css(css);
                axdom("#" + myTarget.id + "_AX_subMenu").show();

                this.showedItem[depth] = myTarget.id + "_AX_subMenu";
            }
        }
    },
    contextMenuItemDown: function (event, objSeq, objID) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        if (event.keyCode == AXUtil.Event.KEY_ESC) {
            this._close(objSeq, objID, event);
            return;
        }

        // event target search -
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            find: function (evt, evtIDs) { return (axdom(evt).hasClass("contextMenuItem")) ? true : false; }
        });
        // event target search ------------------------

        if (myTarget) {

        } else {
            this._close(objSeq, objID, event);
        }
    },
    contextMenuItemClick: function (event, objSeq, objID) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        // event target search -
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            find: function (evt, evtIDs) { return (axdom(evt).hasClass("contextMenuItem") || axdom(evt).hasClass("tool-checkbox") || axdom(evt).hasClass("tool-sort")) ? true : false; }
        });
        // event target search ------------------------

        if (myTarget) {

            var poi = myTarget.id.split(/_AX_/g);
            var depth = poi[poi.length - 2].number();
            var hashs = [];

            var mystrPosition = poi.length - 1;
            for (var r = 0; r < depth + 1; r++) {
                hashs.push(poi[mystrPosition]);
                mystrPosition -= 3;
            }
            hashs = hashs.reverse();

            var menu = obj.menu;
            for (var hash, idx= 0, __arr = hashs; (idx < __arr.length && (hash = __arr[idx])); idx++) {
                if (idx == 0) menu = menu[hash];
                else menu = menu[obj.reserveKeys.subMenu][hash];
            }

            if (menu[obj.reserveKeys.subMenu] && menu[obj.reserveKeys.subMenu].length > 0 && this.mobileMode){
                //this.initMobileModal(objID, objSeq, this.mobileModalObj.myobj, this.mobileModalObj.modalObj, (depth+1), menu.subMenu);
                this.mobileModalSubMenu(myTarget.id,  objSeq, objID,  this.mobileModalObj.myobj, this.mobileModalObj.modalObj, menu, (depth+1));
                return false;
            }

            if (axdom(myTarget).hasClass("tool-checkbox")){
                menu.checked = !menu.checked;
                axdom("#" + menu.__axdomId).find(".tool-checkbox").toggleClass("on");

                if (obj.onchange) {
                    obj.onchange.call({ menu: obj.menu, clickMenu: menu, sendObj: obj.sendObj }, objID);
                }
                return true;
            }

            if (axdom(myTarget).hasClass("tool-sort")){

                // 다른 메뉴들은 모두 정렬 헤제
                for (var M, midx= 0, __arr = obj.menu; (midx < __arr.length && (M = __arr[midx])); midx++) {
                    if(menu != M){
                        M.sort = undefined;
                        axdom("#" + M.__axdomId).find(".tool-sort").removeClass("asc").removeClass("desc");
                    }
                }


                if(menu.sort == undefined) menu.sort = "";
                if(menu.sort.toString().lcase() == "asc"){
                    axdom("#" + menu.__axdomId).find(".tool-sort").removeClass("asc").addClass("desc");
                    menu.sort = "desc";
                }else if(menu.sort.toString().lcase() == "desc"){
                    axdom("#" + menu.__axdomId).find(".tool-sort").removeClass("desc").addClass("asc");
                    menu.sort = "asc";
                }else{
                    axdom("#" + menu.__axdomId).find(".tool-sort").addClass("desc");
                    menu.sort = "desc";
                }

                if (obj.onsort) {
                    if(obj.onsort.call({ menu: obj.menu, sortMenu: menu, sendObj: obj.sendObj }, objID) != true){
                        this._close(objSeq, objID, event);
                    }
                }
                return true;
            }

            if (menu.onclick) {
                if(menu.onclick.call({ menu: menu, sendObj: obj.sendObj }, objID) != true){
                    this._close(objSeq, objID, event);
                }
                return true;
            }else if (obj.onchange) { // 라벨 선택 할 때. 정렬항목도 없는 경우만 체크 모드로 연결
                menu.checked = !menu.checked;
                axdom("#" + menu.__axdomId).find(".tool-checkbox").toggleClass("on");

                if (obj.onchange) {
                    if (obj.onchange.call({ menu: obj.menu, clickMenu: menu, sendObj: obj.sendObj }, objID) != true){
                        this._close(objSeq, objID, event);
                    }
                }
                return true;
            }
        }
    }
});

var AXContextMenu = new AXContextMenuClass();
AXContextMenu.setConfig({});

/**
 * @namespace AXContextMenu
 * @description AXContextMenu 오브젝트는 AXContextMenuClass 를 이용하여 AXJ에서 미리 선언한 인스턴스입니다.
 * AXContentMenu와 같이 사용할 때마다 new를 하지 않고 사용되는 UI들은 AXJ에서 미리 선언해두고 있습니다.
 */
/**
 * @method AXContextMenu.bindSetConfig
 * @param {String} objID - object ID
 * @param {Object} configs - contentMenu config
 * @description contextmenu 오브젝트에 속성을 변경합니다.
 * @example
 ```js
 AXContextMenu.bindSetConfig("contenxt01", {});
 ```
 */
/**
 * @method AXContextMenu.bind
 * @param {Object} obj - 컨텍스트메뉴 속성
 * @returns {AXContextMenu}
 * @description 컨텍스트메뉴를 선언하여 컨텍스트를 메뉴를 사용준비합니다. bind한 컨텍스트 메뉴는 id로 open 할 수 있습니다.
 * @example
 ```js
 AXContextMenu.bind({
		id:"myContextMenu",
		theme:"AXContextMenu", // 선택항목
		width:"150", // 선택항목
		checkbox:"checkbox", // [checkbox|radio]
		sortbox:true,
		menu:[
			{label:'선택 1', checked:true, onclick:function(){
				return false;
			}},
			{label:'선택 2', checked:true,
				subMenu:[
					{label:"하위메뉴1"},
					{label:"하위메뉴2",
						subMenu:[
							{label:"하위메뉴21"},
							{label:"하위메뉴22"}
						]
					},
					{label:"하위메뉴3"},
					{label:"하위메뉴3"},
					{label:"하위메뉴3"}
				]
			},
			{label:'선택 3', checked:true},
			{label:'선택 4', checked:false, sort:"asc"} // config 에 checkbox 가 있는데. menu에 onclick 가 없으면 체크박스 액션이 작동합니다.
		],
		onchange: function(){ // 체크박스 선택값이 변경 된 경우 호출 됩니다.
			trace(this.menu);

			// return true; 메뉴 창이 닫히지 않게 합니다.
		},
		onsort: function(){ // 정렬이 변경 된 경우 호출 됩니다.
			trace(this.sortMenu);

			// return true; 메뉴 창이 닫히지 않게 합니다.
		}
	});
 ```
 */
/**
 * @method AXContextMenu.open
 * @param {Object} myobj
 * @param {Event|Object} position - 이벤트 객체를 전달하거나 {left:[Number], top:[Number]} 를 전달합니다.
 * @returns {AXContextMenu}
 * @description bind된 컨텍스트메뉴 개체를 오픈합니다. (이벤트속성에 정해진 마우스 포지션또는 사용자가 정한 left, top 포지션에)
 * @example
 ```js
 AXContextMenu.open({
	id:"myContextMenuTree", sendObj:{id:"전달하고싶은 오브젝트", name:"형식은 자유"}
}, event); // event 직접 연결 방식

 AXContextMenu.open({
	id:"myContextMenuTree", sendObj:{id:"전달하고싶은 오브젝트", name:"형식은 자유"}
}, {left:0, top:0}); // position 직접 결정 방식
 ```
 */
/**
 * @method AXContextMenu.close
 * @param {Object} obj
 * @returns {AXContextMenu}
 * @description 열린 컨텍스트메뉴 개체를 닫습니다.
 * @example
 ```js
 AXContextMenu.close({
	id:"myContextMenuTree"
});
 ```
 */


/**
 * @class AXPopOverClass
 * @extends AXContextMenuClass
 * @version v1.0
 * @author tom@axisj.com, axisj.com
 * @description AXContextMenuClass를 상속하여 만들어진 클래스로 마우스 오버이벤트에 최적화 됨
 * @example
```js
 var AXPopOver = new AXPopOverClass();
 AXPopOver.setConfig({ theme: "AXPopOver" });
```
 */
var AXPopOverClass = Class.create(AXContextMenuClass, {
/**
 * @method AXPopOverClass.bind
 * @param {Object} obj 팝오버메뉴 속성
 * @returns AXPopOverClass
 * @description 팝오버메뉴를 선언하여 팝오버 메뉴를 사용준비합니다. bind한 팝오버메뉴는 id로 open 할 수 있습니다.
 * @example
 ```js
 AXPopOver.bind({
	id:"myPopOver",
	theme:"AXPopOver", // 선택항목
	width:"200", // 선택항목
	menu:[
		{userType:0, label:"Friends", className:"groupName"},
		{userType:0, label:"Invite friends", className:"", onclick:function(){}},
		{userType:0, label:"Find friends", className:"", onclick:function(){}},
		{userType:0, label:"Photo", className:"groupName"},
		{userType:0, label:"Cut", className:"", onclick:function(){}},
		{userType:0, label:"Roll", className:"", onclick:function(){}},
		{userType:0, label:"Equipment", className:"groupName"},
		{userType:0, label:"Setting", className:""},
		{userType:0, label:"Screen", className:"", onclick:function(){}},
		{userType:0, label:"Securities", className:"groupName"},
		{userType:0, label:"Account", className:"", onclick:function(){}},
		{userType:0, label:"Logout", className:"", onclick:function(){}},
	]
});

 $("#popoverBtn1").bind("mouseover", function(){
	var pos = $(this).offset();
	AXPopOver.open({
		id:"myPopOver", sendObj:{id:"전달하고싶은 오브젝트", name:"형식은 자유"}},
		{left:pos.left-60, top:pos.top+30}
	);
});
 ```
 */

/**
 * @method AXPopOverClass.open
 * @param {Object} myobj
 * @param {Event|Object} position - 이벤트 객체를 전달하거나 {left:[Number], top:[Number]} 를 전달합니다.
 * @returns {AXPopOverClass}
 * @description bind된 컨텍스트메뉴 개체를 오픈합니다. (이벤트속성에 정해진 마우스 포지션또는 사용자가 정한 left, top 포지션에)
 * @example
 ```js
 AXPopOver.open({
	id:"myPopover", sendObj:{id:"전달하고싶은 오브젝트", name:"형식은 자유"}
}, event); // event 직접 연결 방식

 AXPopOver.open({
	id:"myPopover", sendObj:{id:"전달하고싶은 오브젝트", name:"형식은 자유"}
}, {left:0, top:0}); // position 직접 결정 방식
 ```
 */

/**
 * @method AXPopOverClass.close
 * @param {Object} obj
 * @returns {AXPopOverClass}
 * @description 열린 팝오버메뉴 개체를 닫습니다.
 * @example
 ```js
 AXPopOver.close({
	id:"myPopOver"
});
 ```
 */
    open: function (myobj, position) {
        var cfg = this.config;
        var objSeq = null;
        AXUtil.each(this.objects, function (index, O) {
            if (O.id == myobj.id) {
                objSeq = index;
                //return false;
            } else {
                axdom("#" + O.id).remove();
            }
        });
        if (objSeq == null) {
            //trace("바인드 된 오브젝트를 찾을 수 없습니다.");
            return;
        }

        var obj = this.objects[objSeq];
        var objID = obj.id;

        if (myobj.sendObj) {
            obj.sendObj = myobj.sendObj;
        }

        if (this.observer) clearTimeout(this.observer); //닫기 명령 제거
        var direction = obj.direction || "top";

        if (AXgetId(objID)) {
            if (position.clientX) {
                this.contentMenuSetCss(event, position, objSeq, objID);
            }
            return;
        }

        var theme = obj.theme || cfg.theme;
        var width = obj.width || cfg.width;

        //컨텍스트 메뉴의 위치 지정

        var arrowStyle = "";
        if (position.clientX) {
            arrowStyle = "background-position:10px 0px;"
        } else {
            if (position.arrowLeft) arrowStyle = "background-position:" + position.arrowLeft + "px 0px;"
        }

        axdom("#" + objID).remove();

        var href = (obj.href == undefined) ? cfg.href : obj.href;

        var filter = this.filter.bind(this);
        var getSubMenu = this.getSubMenu.bind(this);
        var po = [];
        po.push("<div id=\"" + objID + "\" class=\"" + theme + "\" style=\"width:" + width + "px;\">");
        po.push("<div class=\"arrowTop\" style=\"" + arrowStyle + "\"></div>");
        po.push("<div class=\"arrowBottom\" style=\"" + arrowStyle + "\"></div>");
        po.push("<div class=\"blockContainer\">");
        if (obj.menu) {
            AXUtil.each(obj.menu, function (idx, menu) {
                if (!menu) return false;
                if (filter(objSeq, objID, myobj, menu)) {
                    if (menu.upperLine) {
                        po.push("<div class=\"hline\"></div>");
                    }
                    var className = (menu.className) ? " " + menu.className : "";
                    var hasSubMenu = (menu.subMenu) ? " hasSubMenu" : "";
                    po.push("<a " + href + " class=\"contextMenuItem" + className + hasSubMenu + "\" id=\"" + objID + "_AX_contextMenu_AX_0_AX_" + idx + "\">");
                    po.push(menu.label);
                    if (menu.subMenu) {
                        if (menu.subMenu.length > 0) {
                            po.push("<div class=\"contextSubMenuIcon\"></div>");
                        }
                    }
                    po.push("</a>");
                    if (menu.subMenu) {
                        if (menu.subMenu.length > 0) {
                            po.push(getSubMenu(objID + "_AX_contextMenu_AX_0_AX_" + idx, objSeq, objID, myobj, menu.subMenu, 1));
                        }
                    }
                    if (menu.underLine) {
                        po.push("<div class=\"hline\"></div>");
                    }
                }
            });
        } else if (obj.body) {
            po.push("<div class=\"contextMenuBody\">");
            po.push(obj.body);
            po.push("</div>");
        }
        po.push("</div>");
        po.push("</div>");
        axdom(document.body).append(po.join(''));

        if (direction == "top") {
            axdom("#" + objID).find(".arrowTop").show();
            axdom("#" + objID).find(".arrowBottom").hide();
        } else if (direction == "bottom") {
            axdom("#" + objID).find(".arrowTop").hide();
            axdom("#" + objID).find(".arrowBottom").show();
        } else {
            axdom("#" + objID).find(".arrowTop").show();
            axdom("#" + objID).find(".arrowBottom").hide();
        }

        axdom("#" + objID + " .contextMenuItem:first-child").addClass("first");
        axdom("#" + objID + " .contextMenuItem:last-child").addClass("last");

        var contextMenuItemMouseOver = this.contextMenuItemMouseOver.bind(this);
        this.contextMenuItemMouseOverBind = function (event) {
            contextMenuItemMouseOver(event, objSeq, objID);
        };
        var contextMenuMouseOut = this.contextMenuMouseOut.bind(this);
        this.contextMenuMouseOutBind = function (event) {
            contextMenuMouseOut(event, objSeq, objID);
        };

        var eventClear = function () {
            if (this.observer) clearTimeout(this.observer); //닫기 명령 제거
        }
        axdom("#" + objID + " .contextMenuItem").bind("mouseover", this.contextMenuItemMouseOverBind);
        axdom("#" + objID).bind("mouseover", eventClear.bind(this));
        axdom("#" + objID).bind("mouseout", this.contextMenuMouseOutBind);

        this.contentMenuSetCss(null, position, objSeq, objID);

        //var eventBind = this.eventBind.bind(this);
        this.eventBind(objSeq, objID);
        //setTimeout(function(){}, 1);

		return this;
    },
    contentMenuSetCss: function (event, position, objSeq, objID) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        var direction = obj.direction || "top";
        var css = {};

        if (!position.clientX) {
            if (position.left != undefined) {
                css.left = position.left;
            } else {
                css.left = "auto";
                css.right = position.right;
            }
            css.top = position.top;
        } else {
            var mouse = this.getMousePositon(position);
            obj.eventPosition = true;
            css.left = mouse.pageX;
            css.left -= 20;
            css.top = mouse.pageY;
        }
        // -- 부모박스 정보와 박스 정보
        var pElement = axdom("#" + objID).offsetParent();
        var pBox = { width: pElement.width(), height: pElement.height() };
        var clientHeight = (AXUtil.docTD == "Q") ? document.body.scrollHeight : document.documentElement.scrollHeight;
        var clienWidth = (AXUtil.docTD == "Q") ? document.body.scrollWidth : document.documentElement.scrollWidth;
        if (clienWidth > pBox.width) pBox.width = clienWidth;
        if (clientHeight > pBox.height) pBox.height = clientHeight;
        var _box = { width: axdom("#" + objID).outerWidth(), height: axdom("#" + objID).outerHeight() };
        // -- 부모박스 정보와 박스 정보
        var openTB = "";
        if (direction == "top") {
            openTB = "top";
        } else if (direction == "bottom") {
            css.top -= axdom("#" + objID).outerHeight();
            openTB = "bottom";
        } else {
            if ((_box.height.number() + css.top.number()) > pBox.height) {
                css.top = css.top - _box.height.number() - position.handleHeight - 3;
                axdom("#" + objID).find(".arrowTop").hide();
                axdom("#" + objID).find(".arrowBottom").show();
                //css.top -= ((_box.height.number() + css.top.number()) - pBox.height) + 5;
                openTB = "bottom";
            } else {
                axdom("#" + objID).find(".arrowTop").show();
                axdom("#" + objID).find(".arrowBottom").hide();
                openTB = "top";
            }
        }

        if (css.left != undefined) {
            if ((_box.width.number() + css.left.number()) > pBox.width) {
                var moveLeft = ((_box.width.number() + css.left.number()) - pBox.width) + 5;
                css.left -= moveLeft;
                if (openTB == "top") {
                    axdom("#" + objID).find(".arrowTop").css({ "background-position": (moveLeft + 5) + "px 0px;" });
                } else {
                    axdom("#" + objID).find(".arrowBottom").css({ "background-position": (moveLeft + 5) + "px 0px;" });
                }
            } else {

            }
        } else {

        }
        axdom("#" + objID).css(css);
    },
    contextMenuItemMouseOver: function (event, objSeq, objID) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        if (this.observer) clearTimeout(this.observer); //닫기 명령 제거

        var menuWidth = obj.width || cfg.width;
        // event target search -
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            find: function (evt, evtIDs) { return (axdom(evt).hasClass("contextMenuItem")) ? true : false; }
        });
        // event target search ------------------------
        if (myTarget) {
            var poi = myTarget.id.split(/_AX_/g);
            var depth = poi[poi.length - 2];
            if (this.showedItem[depth]) {
                axdom("#" + this.showedItem[depth]).hide();
            }
            if (axdom(myTarget).hasClass("hasSubMenu")) {
                var subMenuTop = axdom("#" + myTarget.id).position().top;
                var css;
                if (this.openTB == "up") {
                    var ph = axdom("#" + myTarget.id).offsetParent().height();
                    var h = axdom("#" + myTarget.id).height();
                    var bottom = ph - subMenuTop - h;
                    css = { top: "auto", bottom: bottom };
                } else {
                    css = { top: subMenuTop };
                }
                if (this.openLR == "left") {
                    //css.left = -(menuWidth - 15);
                    css.left = -(20);
                }
                axdom("#" + myTarget.id + "_AX_subMenu").css(css);
                axdom("#" + myTarget.id + "_AX_subMenu").show();

                this.showedItem[depth] = myTarget.id + "_AX_subMenu";
            }
        }
    },
    contextMenuMouseOut: function (event, objSeq, objID) {
        var close = this._close.bind(this);
        this.observer = setTimeout(function () {
            close(objSeq, objID);
        }, 200);
    }
});
var AXPopOver = new AXPopOverClass();
AXPopOver.setConfig({ theme: "AXPopOver" });

/**
 * @namespace AXPopOver
 * @description AXPopOver 오브젝트는 AXPopOverClass 를 이용하여 AXJ에서 미리 선언한 인스턴스입니다.
 * AXPopOver 같이 사용할 때마다 new를 하지 않고 사용되는 UI들은 AXJ에서 미리 선언해두고 있습니다.
 */
/**
 * @method AXPopOver.bindSetConfig
 * @param {String} objID - object ID
 * @param {Object} configs contentMenu config
 * @description contextmenu 오브젝트에 속성을 변경합니다.
 * @example
 ```js
 AXPopOver.bindSetConfig("popover01", {});
 ```
 */
/**
 * @method AXPopOver.bind
 * @param {Object} obj - 컨텍스트메뉴 속성
 * @returns {AXPopOver}
 * @description 컨텍스트메뉴를 선언하여 컨텍스트를 메뉴를 사용준비합니다. bind한 컨텍스트 메뉴는 id로 open 할 수 있습니다.
 * @example
 ```js
 AXPopOver.bind({
	id:"myPopOver",
	theme:"AXPopOver", // 선택항목
	width:"200", // 선택항목
	menu:[
		{userType:0, label:"Friends", className:"groupName"},
		{userType:0, label:"Invite friends", className:"", onclick:function(){}},
		{userType:0, label:"Find friends", className:"", onclick:function(){}},
		{userType:0, label:"Photo", className:"groupName"},
		{userType:0, label:"Cut", className:"", onclick:function(){}},
		{userType:0, label:"Roll", className:"", onclick:function(){}},
		{userType:0, label:"Equipment", className:"groupName"},
		{userType:0, label:"Setting", className:""},
		{userType:0, label:"Screen", className:"", onclick:function(){}},
		{userType:0, label:"Securities", className:"groupName"},
		{userType:0, label:"Account", className:"", onclick:function(){}},
		{userType:0, label:"Logout", className:"", onclick:function(){}},
	]
});

 $("#popoverBtn1").bind("mouseover", function(){
	var pos = $(this).offset();
	AXPopOver.open({
		id:"myPopOver", sendObj:{id:"전달하고싶은 오브젝트", name:"형식은 자유"}},
		{left:pos.left-60, top:pos.top+30}
	);
});
 ```
 */
/**
 * @method AXPopOver.open
 * @param {Object} myobj
 * @param {Event|Object} position - 이벤트 객체를 전달하거나 {left:[Number], top:[Number]} 를 전달합니다.
 * @returns {AXPopOver}
 * @description bind된 컨텍스트메뉴 개체를 오픈합니다. (이벤트속성에 정해진 마우스 포지션또는 사용자가 정한 left, top 포지션에)
 * @example
 ```js
 AXPopOver.open({
	id:"myPopover", sendObj:{id:"전달하고싶은 오브젝트", name:"형식은 자유"}
}, event); // event 직접 연결 방식

 AXPopOver.open({
	id:"myPopover", sendObj:{id:"전달하고싶은 오브젝트", name:"형식은 자유"}
}, {left:0, top:0}); // position 직접 결정 방식
 ```
 */
/**
 * @method AXPopOver.close
 * @param {Object} obj
 * @returns {AXPopOver}
 * @description 열린 팝오버 개체를 닫습니다.
 * @example
 ```js
 AXPopOver.close({
	id:"myPopover"
});
 ```
 */


/**
 * @method jQueryExtends.bindTooltip
 * @param {Object} configs - 툴팁설정
 * @returns {jQueryObject}
 * @description 툴팁을 바인드 하는 대상의 '아이디+"_AX_tooltip"'를 아이디로 하는 엘리먼트를 대상이 마우스 오버 이벤트 발생 할때 툴팁으로 표시 합니다.
 * @example
```js

 <div style="position:relative;">
	 <button class="AXButton" onclick="" id="tooltip4"><div class="black_help">Bottom</div></button>
	 <div id="tooltip4_AX_tooltip" class="AXTooltipContent">
		 AXCore 에서는 자바스크립트 자료형에 대한 prototype 확장 메소드,
		 AXJ 클래스 원형, AXUtil 개체, AXReq(AJAX통신용) 클래스, AXCalendar 클래스, AXContext 클래스, AXPopOver 클래스, AXMask 클래스, AXNotification 클래스,
		 AXScroll 클래스, AXMultiSelect 클래스, jQuery extend(eventType, easing) 구문 등을 포함하고 있습니다.
	 </div>

	 <button class="AXButton" onclick="" id="tooltip5"><div class="black_help">Top</div></button>
	 <div id="tooltip5_AX_tooltip" class="AXTooltipContent">
		 AXCore 에서는 자바스크립트 자료형에 대한 prototype 확장 메소드,
		 AXJ 클래스 원형, AXUtil 개체, AXReq(AJAX통신용) 클래스, AXCalendar 클래스, AXContext 클래스, AXPopOver 클래스, AXMask 클래스, AXNotification 클래스,
		 AXScroll 클래스, AXMultiSelect 클래스, jQuery extend(eventType, easing) 구문 등을 포함하고 있습니다.
	 </div>

	 <button class="AXButton" onclick="" id="tooltip6"><div class="black_help">Auto</div></button>
	 <div id="tooltip6_AX_tooltip" class="AXTooltipContent">
		 AXCore 에서는 자바스크립트 자료형에 대한 prototype 확장 메소드,
		 AXJ 클래스 원형, AXUtil 개체, AXReq(AJAX통신용) 클래스, AXCalendar 클래스, AXContext 클래스, AXPopOver 클래스, AXMask 클래스, AXNotification 클래스,
		 AXScroll 클래스, AXMultiSelect 클래스, jQuery extend(eventType, easing) 구문 등을 포함하고 있습니다.
	 </div>
 </div>
 <script>
	// configs:{
	//	theme: (config.theme || "AXPopOverTooltip"), // (optional)
	//	width: (config.width || ""), // (optional)
	//	direction: (config.direction || "top"), // (optional)
	// }

	// class 가 tooltipbind인 모든 엘리먼트에 툴팁설정
	$(".tooltipbind").bindTooltip({width:300});

	//AXPopOverTooltip (bindTooltip) 방향설정 방식
	$("#tooltip4").bindTooltip({direction:"bottom", width:300}); //{direction:"[auto|top|bottom]"}
	$("#tooltip5").bindTooltip({direction:"top", width:300}); //{direction:"[auto|top|bottom]"}
	$("#tooltip6").bindTooltip({direction:"auto", width:300}); //{direction:"[auto|top|bottom]"}
 </script>
```
 */
axdom.fn.bindTooltip = function (config) {
    if (config == undefined) config = {};
    AXUtil.each(this, function () {
        var tooltipContent = axdom("#" + this.id + "_AX_tooltip").html();
        AXPopOver.bind({
            id: this.id + "_AX_tooltipobj",
            theme: (config.theme || "AXPopOverTooltip"), // 선택항목
            width: (config.width || ""), // 선택항목
            direction: (config.direction || "top"), // 선택항목
            body: tooltipContent
        });

        axdom(this).bind((config.event || "mouseover"), function () {
            var pos = axdom(this).offset();
            var direction = (config.direction || "top");
            var posTop = pos.top;
            if (direction == "bottom") {
                posTop -= 3;
            } else {
                posTop += axdom(this).outerHeight() + 3;
            }
            AXPopOver.open({ id: this.id + "_AX_tooltipobj", sendObj: {} }, { left: pos.left, top: posTop, handleHeight: (axdom(this).outerHeight().number() + 3) }); // event 직접 연결 방식
        });
    });
	return this;
};
/* ---------------------------------------------- AXContextMenu -- */

/* -- AXMobileModal ---------------------------------------------- */
/**
 * @class AXMobileModal
 * @extends AXJ
 * @version v1.0
 * @author tom@axisj.com, axisj.com
 * @logs
 "2013-12-11 오후 5:48:28"
 "2014-04-14 : tom - modalOpen위치 scrollTop 적용"
 * @example
```js
 var myMobileModal = new AXMobileModal();
 // default config
 myMobileModal.config.theme = "AXMobileModal";
 myMobileModal.config.width = "auto";
 myMobileModal.config.height = "auto";
 myMobileModal.config.margin = "10px";
 myMobileModal.config.align = "center";
 myMobileModal.config.valign = "center";
```
 */
var AXMobileModal = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();
        this.config.theme = "AXMobileModal";
        this.config.width = "auto";
        this.config.height = "auto";
        this.config.margin = "10px";
        this.config.align = "center";
        this.config.valign = "center";
    },
/**
 * @method AXMobileModal.setConfig
 * @param {Object} configs
 * @description 모바일모달 개체 초기화
 * @example
```js
myMobileModal.setConfig({
	//theme, margin, align, valign
	width:300,
	height:300,
	head:{
		close:{
			onclick:function(){

			}
		}
	},
	onclose: function(){
		trace("close bind");
	}
});
```
 */
    init: function () {
        var cfg = this.config;

        if (!cfg.head) {
            cfg.head = {};
        }
    },
/**
 * @method AXMobileModal.open
 * @returns {Object} modalObject - 열린 모달의 오브젝트
 * @description 모바일 모달창을 열고 열린 모달의 엘리먼트 정보를 리턴합니다.
 * @example
```js
var obj = myMobileModal.open();
// 다음의 정보를 리턴합니다.
// obj: {
//    jQueryModal: 모달,
//    modalPanel: 모달의 패널,
//    modalHead: 모달패널의 헤드,
//    modalBody: 모달패널의 바디,
//    modalFoot: 모달패널의 풋
// }

obj.modalHead.html("자유Head 설정테스트");
obj.modalBody.html("<div style='height:250px;background:#fff;text-align: center;line-height:30px;'>자유body 테스트</div>");
//obj.modalFoot.html("자유footer 테스트");
```
 */
    open: function (configs, onLoad) {
        var cfg = this.config;
        if (!configs) configs = {};
        var theme = (configs.theme || cfg.theme);
        if (cfg.addClass) {
            theme += " " + cfg.addClass;
        }
        this.modalId = "AXMobileModal" + AXUtil.timekey();
        var modalId = this.modalId;
        var clientWidth = (configs.clientWidth || AXUtil.clientWidth());

        var po = [];
        po.push('<div id="', modalId, '" class="', theme, '" style="left:0px;top:0px;width:100%;height:100%;">');
        po.push('	<div  id="', modalId, '_AX_modal" class="AXMobileModalPanel" style="height:50px;width:50px;left:', (AXUtil.clientWidth() - 50) / 2, 'px;top:', (AXUtil.clientHeight() - 50) / 2,'px;">');
        po.push('		<div  id="', modalId, '_AX_head" class="mobileModalHead">');
        po.push('			<div class="modalTitle">' + (cfg.head.title || "") + '</div>');
        po.push('		</div>');
        if (cfg.head.close) {
            po.push('		<a ' + cfg.href + ' class="mobileModelClose">Close</a>');
        }
        po.push('		<div  id="', modalId, '_AX_body" class="mobileModalBody"></div>');
        po.push('		<div  id="', modalId, '_AX_foot" class="mobileModalFoot"></div>');
        po.push('	</div>');
        po.push('</div>');
        this.jQueryModal = axdom(po.join(''));
        axdom(document.body).append(this.jQueryModal);

        this.modalPanel = this.jQueryModal.find(".AXMobileModalPanel");
        this.modalHead = this.modalPanel.find(".mobileModalHead");
        this.modalBody = this.modalPanel.find(".mobileModalBody");
        this.modalFoot = this.modalPanel.find(".mobileModalFoot");

        this.openConfigs = configs;
        this.setSizeModal(this.openConfigs, onLoad);
        this.modalPanel.find(".mobileModelClose").bind("click", this.close.bind(this));
        this.jQueryModal.bind("click", this.modalClick.bind(this));

        axdom(window).unbind("resize.AXMobileModal").bind("resize.AXMobileModal", this.reposition.bind(this));

        this.opened = true;

        return {
            jQueryModal: this.jQueryModal,
            modalPanel: this.modalPanel,
            modalHead: this.modalHead,
            modalBody: this.modalBody,
            modalFoot: this.modalFoot
        };
    },
    setSizeModal: function (configs, onLoad) {
        var cfg = this.config;
        var cssStyles = {};
        var clientWidth, width, height, left, top, margin, align, valign;
        var modalWidth, modalHeight;
        var clientWidth = this.jQueryModal.innerWidth();
        var clientHeight = AXUtil.clientHeight();
        var width = (configs.width || cfg.width);
        var height = (configs.height || cfg.height);
        var margin = (configs.margin || cfg.margin);
        var align = (configs.align || cfg.align);
        var valign = (configs.valign || cfg.valign);

        this.openModalAttr = {
            width:width, height:height, margin:margin, align:align, valign:valign
        };

        if (width == "auto") {
            if (margin.right(1) == "%") {
                modalWidth = clientWidth * (100 - margin.number() * 2) / 100;
            } else {
                modalWidth = clientWidth - margin.number() * 2;
            }
        } else {
            modalWidth = width;
        }
        left = (clientWidth - modalWidth) / 2;

        if (height == "auto") {
            if (margin.right(1) == "%") {
                modalHeight = clientHeight * (100 - margin.number() * 2) / 100;
            } else {
                modalHeight = clientHeight - margin.number() * 2;
            }
        } else {
            modalHeight = height;
        }
        top = (clientHeight - modalHeight) / 2;

        if (left < 0) left = margin;
	    if (top < -5) top = -5;

        var cssStylesStart = {
            left: (axf.clientWidth() - (modalWidth*0.8)) / 2,
            top: (axf.clientHeight() - (modalHeight*0.8)) / 2,
            width: (modalWidth*0.8),
            height: (modalHeight*0.8)
        };
        //cssStylesStart.top += jQuery(window).scrollTop();
        this.modalPanel.css(cssStylesStart);

        cssStyles.left = left;
        cssStyles.top = top;
        cssStyles.width = modalWidth;
        cssStyles.height = modalHeight;
        mask.open();

        var returnObj = {
            jQueryModal: this.jQueryModal,
            modalPanel: this.modalPanel,
            modalHead: this.modalHead,
            modalBody: this.modalBody,
            modalFoot: this.modalFoot
        };

        if(AXUtil.browser.name == "android"){
            //alert(AXUtil.browser.version);
            this.modalPanel.css(cssStyles);
            if(onLoad){
                onLoad.call(returnObj, returnObj);
            }
        }else{
            this.modalPanel.animate(cssStyles, 300, "expoOut", function () {
                if(onLoad){
                    onLoad.call(returnObj, returnObj);
                }
            });
        }
    },
    modalClick: function(event){
        var cfg = this.config;
        if(event.target.id == this.modalId){
            this.close();
        }
    },

/**
 * @method AXMobileModal.close
 * @returns {AXMobileModal}
 * @description 모바일모달창을 닫습니다.
 * @example
```js
 myMobileModal.close();
```
 */
    close: function () {
        var cfg = this.config;
        mask.close();

        var modalWidth, modalHeight;
        modalWidth = this.modalPanel.width();
        modalHeight = this.modalPanel.height();

        var cssStylesStart = {
            left: (AXUtil.clientWidth() - (modalWidth*0.8)) / 2,
            top: (AXUtil.clientHeight() - (modalHeight*0.8)) / 2,
            width: (modalWidth*0.8),
            height: (modalHeight*0.8),
            opacity:0
        };
        var remove = this.remove.bind(this);
        this.modalPanel.animate(cssStylesStart, 300, "expoOut", function () {
            remove();
            if (cfg.onclose) {
                cfg.onclose();
            }
        });
        this.modalPanel.empty();
        //this.jQueryModal.fadeOut();
        //this.remove();
        /*

         remove.delay(0.01);
         */
        this.opened = false;
        axdom(window).unbind("resize.AXMobileModal");

		return this;
    },
    remove: function () {
        var cfg = this.config;
        this.jQueryModal.remove();
    },
    reposition: function(){
        var cfg = this.config;

        var clientWidth = AXUtil.clientWidth();
        var clientHeight = AXUtil.clientHeight();
        this.jQueryModal.css({width:clientWidth, height:clientHeight});

        var modalWidth, modalHeight, left, top;
        var width = this.openModalAttr.width;
        var height = this.openModalAttr.height;
        var margin = this.openModalAttr.margin;
        var align = this.openModalAttr.align;
        var valign = this.openModalAttr.valign;
        var cssStyles = {};

        if (width == "auto") {
            if (margin.right(1) == "%") {
                modalWidth = clientWidth * (100 - margin.number() * 2) / 100;
            } else {
                modalWidth = clientWidth - margin.number() * 2;
            }
        } else {
            modalWidth = width;
        }
        left = (clientWidth - modalWidth) / 2;

        if (height == "auto") {
            if (margin.right(1) == "%") {
                modalHeight = clientHeight * (100 - margin.number() * 2) / 100;
            } else {
                modalHeight = clientHeight - margin.number() * 2;
            }
        } else {
            modalHeight = height;
        }
        top = (clientHeight - modalHeight) / 2;

        if (left < 0) left = margin;
        if (top < -5) top = -5;

        cssStyles.left = left;
        cssStyles.top = top;
        cssStyles.width = modalWidth;
        cssStyles.height = modalHeight;

        this.modalPanel.css(cssStyles);
    }
});
/* ---------------------------------------------- AXMobileModal -- */

/* -- jQuery easing plugin ---------------------------------------------- */
axdom.extend(true, {
    easing: {
        backIn: function (p, n, f, d) { var c = f + d; var s = 1.70158; return c * (p /= 1) * p * ((s + 1) * p - s) + f; },
        backOut: function (p, n, f, d) { var c = f + d; var s = 1.70158; return c * ((p = p / 1 - 1) * p * ((s + 1) * p + s) + 1) + f; },
        backInOut: function (p, n, f, d) { var c = f + d; var s = 1.70158; if ((p /= 0.5) < 1) return c / 2 * (p * p * (((s *= (1.525)) + 1) * p - s)) + f; else return c / 2 * ((p -= 2) * p * (((s *= (1.525)) + 1) * p + s) + 2) + f; },
        bounceIn: function (p, n, f, d) { var c = f + d; var inv = this.bounceOut(1 - p, 1, 0, d); return c - inv + f; },
        bounceOut: function (p, n, f, d) { var c = f + d; if (p < (1 / 2.75)) return c * (7.5625 * p * p) + f; else if (p < (2 / 2.75)) return c * (7.5625 * (p -= (1.5 / 2.75)) * p + .75) + f; else if (p < (2.5 / 2.75)) return c * (7.5625 * (p -= (2.25 / 2.75)) * p + .9375) + f; else return c * (7.5625 * (p -= (2.625 / 2.75)) * p + .984375) + f; },
        circIn: function (p, n, f, d) { var c = f + d; return -c * (Math.sqrt(1 - (p /= 1) * p) - 1) + f; },
        circOut: function (p, n, f, d) { var c = f + d; return c * Math.sqrt(1 - (p = p / 1 - 1) * p) + f; },
        circInOut: function (p, n, f, d) { var c = f + d; if ((p /= 0.5) < 1) return -c / 2 * (Math.sqrt(1 - p * p) - 1) + f; else return c / 2 * (Math.sqrt(1 - (p -= 2) * p) + 1) + f; },
        cubicIn: function (p, n, f, d) { var c = f + d; return c * (p /= 1) * p * p + f; },
        cubicOut: function (p, n, f, d) { var c = f + d; return c * ((p = p / 1 - 1) * p * p + 1) + f; },
        cubicInOut: function (p, n, f, d) { var c = f + d; if ((p /= 0.5) < 1) return c / 2 * p * p * p + f; else return c / 2 * ((p -= 2) * p * p + 2) + f; },
        elasticIn: function (p, n, f, d) { var c = f + d; if (p == 0) return f; if (p == 1) return c; var peroid = 0.25; var s; var amplitude = c; if (amplitude < Math.abs(c)) { amplitude = c; s = peroid / 4; } else { s = peroid / (2 * Math.PI) * Math.asin(c / amplitude); } return -(amplitude * Math.pow(2, 10 * (p -= 1)) * Math.sin((p * 1 - s) * (2 * Math.PI) / peroid)) + f; },
        elasticOut: function (p, n, f, d) { var c = f + d; if (p == 0) return f; if (p == 1) return c; var peroid = 0.25; var s; var amplitude = c; if (amplitude < Math.abs(c)) { amplitude = c; s = peroid / 4; } else { s = peroid / (2 * Math.PI) * Math.asin(c / amplitude); } return -(amplitude * Math.pow(2, -10 * p) * Math.sin((p * 1 - s) * (2 * Math.PI) / peroid)) + c; },
        expoIn: function (p, n, f, d) { var c = f + d; return (p == 0) ? f : c * Math.pow(2, 10 * (p - 1)) + f - c * 0.001; },
        expoOut: function (p, n, f, d) { var c = f + d; return (p == 1) ? c : d * 1.001 * (-Math.pow(2, -10 * p) + 1) + f; },
        expoInOut: function (p, n, f, d) { var c = f + d; if (p == 0) return f; if (p == 1) return c; if ((p /= 0.5) < 1) return c / 2 * Math.pow(2, 10 * (p - 1)) + f - c * 0.0005; else return c / 2 * 1.0005 * (-Math.pow(2, -10 * --p) + 2) + f; },
        quadIn: function (p, n, f, d) { var c = f + d; return c * (p /= 1) * p + f; },
        quadOut: function (p, n, f, d) { var c = f + d; return -c * (p /= 1) * (p - 2) + f; },
        quadInOut: function (p, n, f, d) { var c = f + d; if ((p /= 0.5) < 1) return c / 2 * p * p + f; else return -c / 2 * ((--p) * (p - 2) - 1) + f; },
        quartIn: function (p, n, f, d) { var c = f + d; return c * (p /= 1) * p * p * p + f; },
        quartOut: function (p, n, f, d) { var c = f + d; return -c * ((p = p / 1 - 1) * p * p * p - 1) + f; },
        quartInOut: function (p, n, f, d) { var c = f + d; if ((p /= 0.5) < 1) return c / 2 * p * p * p * p + f; else return -c / 2 * ((p -= 2) * p * p * p - 2) + f; },
        quintIn: function (p, n, f, d) { var c = f + d; return c * (p /= 1) * p * p * p * p + f; },
        quintOut: function (p, n, f, d) { var c = f + d; return c * ((p = p / 1 - 1) * p * p * p * p + 1) + f; },
        quintInOut: function (p, n, f, d) { var c = f + d; if ((p /= 0.5) < 1) return c / 2 * p * p * p * p * p + f; else return c / 2 * ((p -= 2) * p * p * p * p + 2) + f; },
        sineIn: function (p, n, f, d) { var c = f + d; return -c * Math.cos(p * (Math.PI / 2)) + c + f; },
        sineOut: function (p, n, f, d) { var c = f + d; return c * Math.sin(p * (Math.PI / 2)) + f; },
        sineInOut: function (p, n, f, d) { var c = f + d; return -c / 2 * (Math.cos(Math.PI * p) - 1) + f; }
    }
});
/* ---------------------------------------------- jQuery easing plugin -- */

// jQuery misc plugin
// 2014-08-08 tom : select option 이 없으면 엘리먼트를 찾지 않는 버그 픽스
var __r20 = /%20/g,
    __rbracket = /\[\]$/,
    __rCRLF = /\r?\n/g,
    __rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
    __rselectTextarea = /^(?:select|textarea)/i;

// jquery event extend for mobile
var rkeyEvent = /^key/;
var rmouseEvent = /^(?:mouse|contextmenu)|click/;
axf.each(("touchstart touchmove touchend").split(" "), function (i, name) {
	axdom.fn[name] = function (data, fn) {
		if (fn == null) { fn = data; data = null; }
		return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
	};
	if (rkeyEvent.test(name)) { axdom.event.fixHooks[name] = axdom.event.keyHooks; }
	if (rmouseEvent.test(name)) { axdom.event.fixHooks[name] = axdom.event.mouseHooks; }
});

/**
 * 설명
 * @member {type} AXJ.name
 */
/**
 * @method jQueryExtends.serializeObject
 * @returns {Array}
 * @description 엘리먼트 안에 폼아이템 요소들을 수집합니다. <en>Collect 'form item' inside target element</en>
 * @example
 ```js
 var myItems = $("#mytarget").serializeObject();
 ```
 */
axdom.fn.serializeObject = function () {
    var myArray = this.map(function () {
            return this.elements ? axdom.makeArray(this.elements) : this;
        })
        .filter(function () {
            return this.name && !this.disabled &&
                (this.checked || __rselectTextarea.test(this.nodeName) ||
                    __rinput.test(this.type));
        })
        .map(function (i, elem) {
            var val = axdom(this).val();
            var label = (axdom(elem).attr("title") || axdom(elem).attr("placeholder") || "");

	        if(val == null){
		        if(this.nodeName.lcase() == "select") val = "";
	        }

            return val == null ?
                null :
                axdom.isArray(val) ?
                    axdom.map(val, function (val, i) {
                        return { id: elem.id, name: elem.name, type: elem.type, value: val.replace(__rCRLF, "\r\n"), label: label };
                    }) :
                { id: elem.id, name: elem.name, type: elem.type, value: val.replace(__rCRLF, "\r\n"), label: label };

        }).get();
    return myArray;
};

/**
 * @method jQueryExtends.endFocus
 * @returns {jQueryObject}
 * @description input 엘리먼트 맨끝에 포커스되도록 합니다.
 * @example
 ```js
 $("#mytarget").endFocus();
 ```
 */
axdom.fn.endFocus = function () {
	var elem = this;
	var elemLen = elem.val().length;
	if (elemLen == 0) {
		elem.focus();
		return;
	}
	// For IE Only
	if (document.selection) {
		// Set focus
		elem.focus();
		elem.val(elem.val());
	}
	else if (document.selection == undefined || elem.selectionStart || elem.selectionStart == '0') {
		// Firefox/Chrome
		elem.focus().val(elem.val());
	} // if
	return this;
};

/**
 * @method jQueryExtends.setCaret
 * @param {Number} [pos=valueLength] - 포커스 포지션 넘버
 * @returns {jQueryObject}
 * @description input 엘리먼트 특정위치에 커서를 위치시켜 줍니다.
 * @example
 ```js
 $("#mytarget").setCaret(2);
 ```
 */
axdom.fn.setCaret = function (pos) {
    var input = this[0];
    if(typeof pos == "undefined"){
        pos = input.value.length;
    }
    if (input.setSelectionRange) {
        input.focus();
        input.setSelectionRange(pos, pos);
    } else if (input.createTextRange) {
        var range = input.createTextRange();
        range.collapse(true);
        range.moveEnd('character', pos);
        range.moveStart('character', pos);
        range.select();
    } else if(input.selectionStart){
        input.focus();
        input.selectionStart = pos;
        input.selectionEnd = pos;
    }
	return this;
};

/**
 * @method jQueryExtends.onwheel
 * @param {String} handler - 이벤트 키 네임
 * @param {Function} callBackFn - 이벤트 콜백 함수
 * @returns {jQueryObject}
 * @description 엘리먼트에 휠이벤트를 바인드 합니다. (단 엘리먼트에 id속성이 없는 경우 제대로 작동하지 않을 수 있습니다.)
 * @example
 ```
$("#mytarget").onwheel("mywheel", function(event){
	var delta = event.detail ? event.detail * (-20) : event.wheelDelta / 2;
	trace(delta);
});
 ```
 */
axdom.fn.onwheel = function(handler, callBackFn){
	axf.each(this,  function(){
		if(typeof axf._customerEvents == "undefined") axf._customerEvents = {};
		axf._customerEvents[this.id+"_AX_"+handler] = callBackFn;
		if (document.attachEvent) {
			this.attachEvent("on" + axf.mousewheelevt, axf._customerEvents[this.id+"_AX_"+handler]);
		} else if (document.addEventListener) {
			this.addEventListener(axf.mousewheelevt, axf._customerEvents[this.id+"_AX_"+handler], false);
		}
	});
	return this;
};

/**
 * @method jQueryExtends.offwheel
 * @param {String} handler - 이벤트 키 네임
 * @returns {jQueryObject}
 * @description 엘리먼트에 휠이벤트를 언바인드 합니다. (단 엘리먼트에 id속성이 없는 경우 제대로 작동하지 않을 수 있습니다.)
 * @example
 ```
 $("#mytarget").offwheel("mywheel");
 ```
 */
axdom.fn.offwheel = function(handler){
	axf.each(this,  function(){
		if (document.attachEvent) {
			this.detachEvent("on" + axf.mousewheelevt, axf._customerEvents[this.id+"_AX_"+handler]);
		} else if (document.addEventListener) {
			this.removeEventListener(axf.mousewheelevt, axf._customerEvents[this.id+"_AX_"+handler], false);
		}
	});
	return this;
};

/*
input type=text, textarea가 일부 브라우저에서 포커스 되지 않는 현상해결 해주는 구문
 */
axdom(document.body).ready(function () {
	axdom("input[type=text]").bind("mousedown", function () { this.focus(); });
	axdom("textarea").bind("mousedown", function () { this.focus(); });
});
/* ---------------------------- */
/* http://www.axisj.com, license : http://www.axisj.com/license */
 
 /*
 아래 코드는 husky_framework 의 HuskyRange.js 코드를 참조하여 개발 되었습니다.
 */
 
var DOMfix = {
	DF_parentNode: function(node){
		if(AXUtil.browser.name == "ie" || AXUtil.browser.name == "op"){
			if(!node) return node;
			while(node.previousSibling){node = node.previousSibling;}
			return node.parentNode;			
		}else{
			return node.parentNode;
		}
	},
	DF_childNode: function(node){
		if(AXUtil.browser.name == "ie" || AXUtil.browser.name == "op"){
			var result = null;
			var ni = 0;	
			if(node){
				var result = [];
				node = node.firstChild;
				while(node){
					result[ni++] = node;
					node = node.nextSibling;
				}
			}			
			return result;		
		}else{
			return node.childNodes;
		}
	}
}

var AXDOMRange = Class.create({
	START_TO_START	:0,
	START_TO_END	:1,
	END_TO_END		:2,
	END_TO_START	:3,	
	initialize		: function(_document){
		this._doc = _document || document;
		this.collapsed = true;
		this.commonAncestorContainer = this._doc.body;
		this.endContainer = this._doc.body;
		this.endOffset = 0;
		this.startContainer = this._doc.body;
		this.startOffset = 0;
	},
	cloneContents : function(){
		var oClonedContents = this._doc.createDocumentFragment();
		var oTmpContainer 	= this._doc.createDocumentFragment();
		var aNodes 			= this._getNodesInRange();
		if(aNodes.length < 1) return oClonedContents;
		var oClonedContainers = this.DF_constructClonedTree(aNodes, oTmpContainer);
		var oTopContainer = oTmpContainer.firstChild;
		if(oTopContainer){
			var elCurNode = oTopContainer.firstChild;
			var elNextNode;
			while(elCurNode){
				elNextNode = elCurNode.nextSibling;
				oClonedContents.appendChild(elCurNode);
				elCurNode = elNextNode;
			}
		}
		oClonedContainers = this._splitTextEndNodes({oStartContainer: oClonedContainers.oStartContainer, iStartOffset: this.startOffset, 
													oEndContainer: oClonedContainers.oEndContainer, iEndOffset: this.endOffset});
		if(oClonedContainers.oStartContainer && oClonedContainers.oStartContainer.previousSibling)
			DOMfix.DF_parentNode(oClonedContainers.oStartContainer).removeChild(oClonedContainers.oStartContainer.previousSibling);

		if(oClonedContainers.oEndContainer && oClonedContainers.oEndContainer.nextSibling)
			DOMfix.DF_parentNode(oClonedContainers.oEndContainer).removeChild(oClonedContainers.oEndContainer.nextSibling);

		return oClonedContents;
	},
	DF_constructClonedTree : function(aNodes, oClonedParentNode){
		var oClonedStartContainer = null;
		var oClonedEndContainer = null;

		var oStartContainer = this.startContainer;
		var oEndContainer = this.endContainer;

		recurConstructClonedTree = function(aAllNodes, iCurIdx, oParentNode, oClonedParentNode){
			if(iCurIdx < 0) return iCurIdx;
			var iChildIdx = iCurIdx-1;
			var oCurNodeCloneWithChildren = aAllNodes[iCurIdx].cloneNode(false);
			if(aAllNodes[iCurIdx] == oStartContainer) oClonedStartContainer = oCurNodeCloneWithChildren;
			if(aAllNodes[iCurIdx] == oEndContainer) oClonedEndContainer = oCurNodeCloneWithChildren;
			while(iChildIdx >= 0 && DOMfix.DF_parentNode(aAllNodes[iChildIdx]) == aAllNodes[iCurIdx]){
				iChildIdx = this.recurConstructClonedTree(aAllNodes, iChildIdx, aAllNodes[iCurIdx], oCurNodeCloneWithChildren, oClonedStartContainer, oClonedEndContainer);
			}
			oClonedParentNode.insertBefore(oCurNodeCloneWithChildren, oClonedParentNode.firstChild);
			return iChildIdx;
		};

		aNodes[aNodes.length] = DOMfix.DF_parentNode(aNodes[aNodes.length-1]);
		recurConstructClonedTree(aNodes, aNodes.length-1, aNodes[aNodes.length-1], oClonedParentNode);

		return {oStartContainer: oClonedStartContainer, oEndContainer: oClonedEndContainer};
	},
	cloneRange : function(){
		return this.DF_copyRange(new AXDOMRange(this._doc));
	},
	DF_copyRange : function(oClonedRange){
		oClonedRange.collapsed = this.collapsed;
		oClonedRange.commonAncestorContainer = this.commonAncestorContainer;
		oClonedRange.endContainer = this.endContainer;
		oClonedRange.endOffset = this.endOffset;
		oClonedRange.startContainer = this.startContainer;
		oClonedRange.startOffset = this.startOffset;
		oClonedRange._document = this._doc;
		
		return oClonedRange;
	},
	collapse : function(toStart){
		if(toStart){
			this.endContainer = this.startContainer;
			this.endOffset = this.startOffset;
		}else{
			this.startContainer = this.endContainer;
			this.startOffset = this.endOffset;
		}
		this._updateRangeInfo();
	},
	compareBoundaryPoints : function(how, sourceRange){
		switch(how){
			case this.START_TO_START:
				return this._compareEndPoint(this.startContainer, this.startOffset, sourceRange.startContainer, sourceRange.startOffset);
			case this.START_TO_END:
				return this._compareEndPoint(this.endContainer, this.endOffset, sourceRange.startContainer, sourceRange.startOffset);
			case this.END_TO_END:
				return this._compareEndPoint(this.endContainer, this.endOffset, sourceRange.endContainer, sourceRange.endOffset);
			case this.END_TO_START:
				return this._compareEndPoint(this.startContainer, this.startOffset, sourceRange.endContainer, sourceRange.endOffset);
		}
	},
	DF_getBody : function(node){
		if(!node) return null;
		while(node){
			if(node.tagName == "BODY") return node;
			node = DOMfix.DF_parentNode(node);
		}
		return null;
	},
	_compareEndPoint : function(oContainerA, iOffsetA, oContainerB, iOffsetB){
		var iIdxA, iIdxB;

		if(!oContainerA || this.DF_getBody(oContainerA) != this._doc.body){
			oContainerA = this._doc.body;
			iOffsetA = 0;
		}

		if(!oContainerB || this.DF_getBody(oContainerB) != this._doc.body){
			oContainerB = this._doc.body;
			iOffsetB = 0;
		}

		var compareIdx = function(iIdxA, iIdxB){
			if(iIdxB == -1) iIdxB = iIdxA+1;
			if(iIdxA < iIdxB) return -1;
			if(iIdxA == iIdxB) return 0;
			return 1;
		};

		var oCommonAncestor = this._getCommonAncestorContainer(oContainerA, oContainerB);

		var nodeA = oContainerA;
		if(nodeA != oCommonAncestor){
			while((oTmpNode = DOMfix.DF_parentNode(nodeA)) != oCommonAncestor){nodeA = oTmpNode;}
			iIdxA = this._getPosIdx(nodeA)+0.5;
		}else iIdxA = iOffsetA;
		
		var nodeB = oContainerB;
		if(nodeB != oCommonAncestor){
			while((oTmpNode = DOMfix.DF_parentNode(nodeB)) != oCommonAncestor){nodeB = oTmpNode;}
			iIdxB = this._getPosIdx(nodeB)+0.5;
		}else iIdxB = iOffsetB;

		return compareIdx(iIdxA, iIdxB);
	},
	_getCommonAncestorContainer : function(node1, node2){
		var oComparingNode = node2;

		while(node1){
			while(oComparingNode){
				if(node1 == oComparingNode) return node1;
				oComparingNode = DOMfix.DF_parentNode(oComparingNode);
			}
			oComparingNode = node2;
			node1 = DOMfix.DF_parentNode(node1);
		}

		return this._doc.body;
	},

	deleteContents : function(){
		if(this.collapsed) return;

		this._splitTextEndNodesOfTheRange();

		var aNodes = this._getNodesInRange();

		if(aNodes.length < 1) return;

		var oPrevNode = aNodes[0].previousSibling;
		while(oPrevNode && this._isBlankTextNode(oPrevNode)) oPrevNode = oPrevNode.previousSibling;
		
		var oNewStartContainer, iNewOffset;
		if(!oPrevNode){
			oNewStartContainer = DOMfix.DF_parentNode(aNodes[0]);
			iNewOffset = 0;
		}

		for(var i=0; i<aNodes.length; i++){
			var node = aNodes[i];
			if(!node.firstChild){
				if(oNewStartContainer == node){
					iNewOffset = this._getPosIdx(oNewStartContainer);
					oNewStartContainer = DOMfix.DF_parentNode(node);
				}
				DOMfix.DF_parentNode(node).removeChild(node);
			}
		}

		if(!oPrevNode){
			this.setStart(oNewStartContainer, iNewOffset);
		}else{
			if(oPrevNode.tagName == "BODY")
				this.setStartBefore(oPrevNode);
			else
				this.setStartAfter(oPrevNode);
		}

		this.collapse(true);
	},

	extractContents : function(){
		var oClonedContents = this.cloneContents();
		this.deleteContents();
		return oClonedContents;
	},

	insertNode : function(newNode){
		var oFirstNode = null;
		var oParentContainer;
		if(this.startContainer.nodeType == "3"){
			oParentContainer = DOMfix.DF_parentNode(this.startContainer);
			if(this.startContainer.nodeValue.length <= this.startOffset)
				oFirstNode = this.startContainer.nextSibling;
			else
				oFirstNode = this.startContainer.splitText(this.startOffset);
		}else{
			oParentContainer = this.startContainer;
			oFirstNode = DOMfix.DF_childNode(this.startContainer)[this.startOffset];
		}
		if(!oFirstNode || !DOMfix.DF_parentNode(oFirstNode)) oFirstNode = null;
		oParentContainer.insertBefore(newNode, oFirstNode);
		this.setStartBefore(newNode);
	},
	selectNode : function(refNode){
		this.setStartBefore(refNode);
		this.setEndAfter(refNode);
	},
	selectNodeContents : function(refNode){
		this.setStart(refNode, 0);
		this.setEnd(refNode, DOMfix.DF_childNode(refNode).length);
	},
	_endsNodeValidation : function(node, iOffset){
		if(!node || this.DF_getBody(node) != this._doc.body) throw new Error("node error");
		if(node.nodeType == 3){
			if(iOffset > node.nodeValue.length) iOffset = node.nodeValue.length;
		}else{
			if(iOffset > DOMfix.DF_childNode(node).length) iOffset = DOMfix.DF_childNode(node).length;
		}
		return iOffset;
	},
	setEnd : function(refNode, offset){
		offset = this._endsNodeValidation(refNode, offset);
		this.endContainer = refNode;
		this.endOffset = offset;
		if(!this.startContainer || this._compareEndPoint(this.startContainer, this.startOffset, this.endContainer, this.endOffset) != -1) this.collapse(false);
		this._updateRangeInfo();
	},
	setEndAfter : function(refNode){
		if(!refNode) throw new Error("setEndAfter");
		if(refNode.tagName == "BODY"){
			this.setEnd(refNode, DOMfix.DF_childNode(refNode).length);
			return;
		}
		this.setEnd(DOMfix.DF_parentNode(refNode), this._getPosIdx(refNode)+1);
	},
	setEndBefore : function(refNode){
		if(!refNode) throw new Error("setEndBefore");
		if(refNode.tagName == "BODY"){
			this.setEnd(refNode, 0);
			return;
		}
		this.setEnd(DOMfix.DF_parentNode(refNode), this._getPosIdx(refNode));
	},
	setStart : function(refNode, offset){
		offset = this._endsNodeValidation(refNode, offset);
		this.startContainer = refNode;
		this.startOffset = offset;
		if(!this.endContainer || this._compareEndPoint(this.startContainer, this.startOffset, this.endContainer, this.endOffset) != -1) this.collapse(true);
		this._updateRangeInfo();
	},
	setStartAfter : function(refNode){
		if(!refNode) throw new Error("setStartAfter");
		if(refNode.tagName == "BODY"){
			this.setStart(refNode, DOMfix.DF_childNode(refNode).length);
			return;
		}
		this.setStart(DOMfix.DF_parentNode(refNode), this._getPosIdx(refNode)+1);
	},

	setStartBefore : function(refNode){
		if(!refNode) throw new Error("setStartBefore");
		if(refNode.tagName == "BODY"){
			this.setStart(refNode, 0);
			return;
		}
		this.setStart(DOMfix.DF_parentNode(refNode), this._getPosIdx(refNode));
	},
	surroundContents : function(newParent){
		newParent.appendChild(this.extractContents());
		this.insertNode(newParent);
		this.selectNode(newParent);
	},
	toString : function(){
		var oTmpContainer = this._doc.createElement("DIV");
		oTmpContainer.appendChild(this.cloneContents());
		return oTmpContainer.textContent || oTmpContainer.innerText || "";
	},
	_isBlankTextNode : function(node){
		if(node.nodeType == 3 && node.nodeValue == "") return true;
		return false;
	},
	_getPosIdx : function(refNode){
		var idx = 0;
		for(var node = refNode.previousSibling; node; node = node.previousSibling) idx++;

		return idx;
	},
	_updateRangeInfo : function(){
		if(!this.startContainer){
			this.init(this._doc);
			return;
		}
		this.collapsed = this._isCollapsed(this.startContainer, this.startOffset, this.endContainer, this.endOffset);
		this.commonAncestorContainer = this._getCommonAncestorContainer(this.startContainer, this.endContainer);
	},
	_isCollapsed : function(oStartContainer, iStartOffset, oEndContainer, iEndOffset){
		var bCollapsed = false;
		if(oStartContainer == oEndContainer && iStartOffset == iEndOffset){
			bCollapsed = true;
		}else{
			var oActualStartNode = this._getActualStartNode(oStartContainer, iStartOffset);
			var oActualEndNode = this._getActualEndNode(oEndContainer, iEndOffset);
			oActualStartNode = this._getNextNode(this._getPrevNode(oActualStartNode));
			oActualEndNode = this._getPrevNode(this._getNextNode(oActualEndNode));
			if(oActualStartNode && oActualEndNode && oActualEndNode.tagName != "BODY" && 
				(this._getNextNode(oActualEndNode) == oActualStartNode || (oActualEndNode == oActualStartNode && this._isBlankTextNode(oActualEndNode)))
			)
				bCollapsed = true;
		}
		return bCollapsed;
	},

	_splitTextEndNodesOfTheRange : function(){
		var oEndPoints = this._splitTextEndNodes({oStartContainer: this.startContainer, iStartOffset: this.startOffset, 
													oEndContainer: this.endContainer, iEndOffset: this.endOffset});

		this.startContainer = oEndPoints.oStartContainer;
		this.startOffset = oEndPoints.iStartOffset;

		this.endContainer = oEndPoints.oEndContainer;
		this.endOffset = oEndPoints.iEndOffset;
	},

	_splitTextEndNodes : function(oEndPoints){
		oEndPoints = this._splitStartTextNode(oEndPoints);
		oEndPoints = this._splitEndTextNode(oEndPoints);

		return oEndPoints;
	},

	_splitStartTextNode : function(oEndPoints){
		var oStartContainer = oEndPoints.oStartContainer;
		var iStartOffset = oEndPoints.iStartOffset;

		var oEndContainer = oEndPoints.oEndContainer;
		var iEndOffset = oEndPoints.iEndOffset;

		if(!oStartContainer) return oEndPoints;
		if(oStartContainer.nodeType != 3) return oEndPoints;
		if(iStartOffset == 0) return oEndPoints;

		if(oStartContainer.nodeValue.length <= iStartOffset) return oEndPoints;

		var oLastPart = oStartContainer.splitText(iStartOffset);

		if(oStartContainer == oEndContainer){
			iEndOffset -= iStartOffset;
			oEndContainer = oLastPart;
		}
		oStartContainer = oLastPart;
		iStartOffset = 0;

		return {oStartContainer: oStartContainer, iStartOffset: iStartOffset, oEndContainer: oEndContainer, iEndOffset: iEndOffset};
	},

	_splitEndTextNode : function(oEndPoints){
		var oStartContainer = oEndPoints.oStartContainer;
		var iStartOffset = oEndPoints.iStartOffset;

		var oEndContainer = oEndPoints.oEndContainer;
		var iEndOffset = oEndPoints.iEndOffset;

		if(!oEndContainer) return oEndPoints;
		if(oEndContainer.nodeType != 3) return oEndPoints;

		if(iEndOffset >= oEndContainer.nodeValue.length) return oEndPoints;
		if(iEndOffset == 0) return oEndPoints;

		oEndContainer.splitText(iEndOffset);

		return {oStartContainer: oStartContainer, iStartOffset: iStartOffset, oEndContainer: oEndContainer, iEndOffset: iEndOffset};
	},
	
	_getNodesInRange : function(){
		if(this.collapsed) return [];

		var oStartNode = this._getActualStartNode(this.startContainer, this.startOffset);
		var oEndNode = this._getActualEndNode(this.endContainer, this.endOffset);

		return this._getNodesBetween(oStartNode, oEndNode);
	},

	_getActualStartNode : function(oStartContainer, iStartOffset){
		var oStartNode = oStartContainer;;

		if(oStartContainer.nodeType == 3){
			if(iStartOffset >= oStartContainer.nodeValue.length){
				oStartNode = this._getNextNode(oStartContainer);
				if(oStartNode.tagName == "BODY") oStartNode = null;
			}else{
				oStartNode = oStartContainer;
			}
		}else{
			if(iStartOffset < DOMfix.DF_childNode(oStartContainer).length){
				oStartNode = DOMfix.DF_childNode(oStartContainer)[iStartOffset];
			}else{
				oStartNode = this._getNextNode(oStartContainer);
				if(oStartNode.tagName == "BODY") oStartNode = null;
			}
		}

		return oStartNode;
	},

	_getActualEndNode : function(oEndContainer, iEndOffset){
		var oEndNode = oEndContainer;

		if(iEndOffset == 0){
			oEndNode = this._getPrevNode(oEndContainer);
			if(oEndNode.tagName == "BODY") oEndNode = null;
		}else if(oEndContainer.nodeType == 3){
			oEndNode = oEndContainer;
		}else{
			oEndNode = DOMfix.DF_childNode(oEndContainer)[iEndOffset-1];
		}

		return oEndNode;
	},

	_getNextNode : function(node){
		if(!node || node.tagName == "BODY") return this._doc.body;

		if(node.nextSibling) return node.nextSibling;
		
		return this._getNextNode(DOMfix.DF_parentNode(node));
	},

	_getPrevNode : function(node){
		if(!node || node.tagName == "BODY") return this._doc.body;

		if(node.previousSibling) return node.previousSibling;
		
		return this._getPrevNode(DOMfix.DF_parentNode(node));
	},

	// includes partially selected
	// for <div id="a"><div id="b"></div></div><div id="c"></div>, _getNodesBetween(b, c) will yield to b, "a" and c
	_getNodesBetween : function(oStartNode, oEndNode){
		var aNodesBetween = [];

		if(!oStartNode || !oEndNode) return aNodesBetween;

		this._recurGetNextNodesUntil(oStartNode, oEndNode, aNodesBetween);
		return aNodesBetween;
	},

	_recurGetNextNodesUntil : function(node, oEndNode, aNodesBetween){
		if(!node) return false;

		if(!this._recurGetChildNodesUntil(node, oEndNode, aNodesBetween)) return false;

		var oNextToChk = node.nextSibling;
		
		while(!oNextToChk){
			if(!DOMfix.DF_parentNode(node)) return false;
			node = DOMfix.DF_parentNode(node);

			aNodesBetween[aNodesBetween.length] = node;

			if(node == oEndNode) return false;

			oNextToChk = node.nextSibling;
		}

		return this._recurGetNextNodesUntil(oNextToChk, oEndNode, aNodesBetween);
	},

	_recurGetChildNodesUntil : function(node, oEndNode, aNodesBetween){
		if(!node) return false;

		var bEndFound = false;
		var oCurNode = node;
		if(oCurNode.firstChild){
			oCurNode = oCurNode.firstChild;
			while(oCurNode){
				if(!this._recurGetChildNodesUntil(oCurNode, oEndNode, aNodesBetween)){
					bEndFound = true;
					break;
				}
				oCurNode = oCurNode.nextSibling;
			}
		}

		aNodesBetween[aNodesBetween.length] = node;

		if(bEndFound) return false;
		if(node == oEndNode) return false;

		return true;
	},
	getNodes : function(bSplitTextEndNodes, fnFilter){
		if(bSplitTextEndNodes) this._splitTextEndNodesOfTheRange();

		var aAllNodes = this._getNodesInRange();
		var aFilteredNodes = [];

		if(!fnFilter) return aAllNodes;

		for(var i=0; i<aAllNodes.length; i++)
			if(fnFilter(aAllNodes[i])) aFilteredNodes[aFilteredNodes.length] = aAllNodes[i];

		return aFilteredNodes;
	},

	getTextNodes : function(bSplitTextEndNodes){
		var txtFilter = function(oNode){
			if (oNode.nodeType == 3 && oNode.nodeValue != "\n" && oNode.nodeValue != "")
				return true;
			else
				return false;
		}

		return this.getNodes(bSplitTextEndNodes, txtFilter);
	},
	surroundContentsWithNewNode : function(sTagName){
		var oNewParent = this._doc.createElement(sTagName);
		this.surroundContents(oNewParent);
		return oNewParent;
	},
	pasteHTML : function(sHTML){
		var oTmpDiv = this._doc.createElement("DIV");
		oTmpDiv.innerHTML = sHTML;

		var oFirstNode = oTmpDiv.firstChild;
		var oLastNode = oTmpDiv.lastChild;

		var clone = this.cloneRange();
		var sBM = clone.placeStringBookmark();

		while(oTmpDiv.lastChild) this.insertNode(oTmpDiv.lastChild);

		this.setEndNodes(oFirstNode, oLastNode);

		// delete the content later as deleting it first may mass up the insertion point
		// eg) <p>[A]BCD</p> ---paste O---> O<p>BCD</p>
		clone.moveToBookmark(sBM);
		clone.deleteContents();
		clone.removeStringBookmark(sBM);
	}
});

SSelection = function(win){
	this.init = function(win){
		this._window = win || window;
		this._document = this._window.document;
	};
	this.init(win);

	if('getSelection' in win){
		SSelectionImpl_FF.apply(this);
	}else{
		SSelectionImpl_IE.apply(this);
	}

	this.selectRange = function(oRng){
		this.selectNone();
		this.addRange(oRng);
	};

	this.selectionLoaded = true;
	if(!this._oSelection) this.selectionLoaded = false;
};

SSelectionImpl_FF = function(){
	this._oSelection = this._window.getSelection();

	this.getRangeAt = function(iNum){
		iNum = iNum || 0;

		try{
			var oFFRange = this._oSelection.getRangeAt(iNum);
		}catch(e){return new AXDOMRange(this._document);}
		return this._FFRange2W3CRange(oFFRange);
	};

	this.addRange = function(oW3CRange){
		var oFFRange = this._W3CRange2FFRange(oW3CRange);
		this._oSelection.addRange(oFFRange);
	};

	this.selectNone = function(){
		this._oSelection.removeAllRanges();
	};

	this._FFRange2W3CRange = function(oFFRange){
		var oW3CRange = new AXDOMRange(this._document);
		oW3CRange.setStart(oFFRange.startContainer, oFFRange.startOffset);
		oW3CRange.setEnd(oFFRange.endContainer, oFFRange.endOffset);
		return oW3CRange;
	};

	this._W3CRange2FFRange = function(oW3CRange){
		var oFFRange = this._document.createRange();
		oFFRange.setStart(oW3CRange.startContainer, oW3CRange.startOffset);
		oFFRange.setEnd(oW3CRange.endContainer, oW3CRange.endOffset);

		return oFFRange;
	};
};

SSelectionImpl_IE = function(){
	this._oSelection = this._document.selection;

	this.getRangeAt = function(iNum){
		iNum = iNum || 0;

		if(this._oSelection.type == "Control"){
			var oW3CRange = new AXDOMRange(this._document);

			var oSelectedNode = this._oSelection.createRange().item(iNum);

			// if the selction occurs in a different document, ignore
			if(!oSelectedNode || oSelectedNode.ownerDocument != this._document) return oW3CRange;

			oW3CRange.selectNode(oSelectedNode);

			return oW3CRange;
		}else{
			this._document.body.focus();

			var oSelectedNode = this._oSelection.createRangeCollection().item(iNum).parentElement();

			// if the selction occurs in a different document, ignore
			if(!oSelectedNode || oSelectedNode.ownerDocument != this._document){
				var oW3CRange = new AXDOMRange(this._document);
				return oW3CRange;
			}
			return this._IERange2W3CRange(this._oSelection.createRangeCollection().item(iNum));
		}
	};

	this.addRange = function(oW3CRange){
		var oIERange = this._W3CRange2IERange(oW3CRange);
		oIERange.select();
	};

	this.selectNone = function(){
		this._oSelection.empty();
	};

	this._W3CRange2IERange = function(oW3CRange){
		var oStartIERange = this._getIERangeAt(oW3CRange.startContainer, oW3CRange.startOffset);
		var oEndIERange = this._getIERangeAt(oW3CRange.endContainer, oW3CRange.endOffset);
		oStartIERange.setEndPoint("EndToEnd", oEndIERange);

		return oStartIERange;
	};

	this._getIERangeAt = function(oW3CContainer, iW3COffset){
		var oIERange = this._document.body.createTextRange();

		var oEndPointInfoForIERange = this._getSelectableNodeAndOffsetForIE(oW3CContainer, iW3COffset);

		var oSelectableNode = oEndPointInfoForIERange.oSelectableNodeForIE;
		var iIEOffset = oEndPointInfoForIERange.iOffsetForIE;

		oIERange.moveToElementText(oSelectableNode);
		oIERange.collapse(oEndPointInfoForIERange.bCollapseToStart);
		oIERange.moveStart("character", iIEOffset);

		return oIERange;
	};

	this._getSelectableNodeAndOffsetForIE = function(oW3CContainer, iW3COffset){
		var oIERange = this._document.body.createTextRange();

		var oNonTextNode = null;
		var aChildNodes =  null;
		var iNumOfLeftNodesToCount = 0;

		if(oW3CContainer.nodeType == 3){
			oNonTextNode = DOMfix.DF_parentNode(oW3CContainer);
			aChildNodes = DOMfix.DF_childNode(oNonTextNode);
			iNumOfLeftNodesToCount = aChildNodes.length;
		}else{
			oNonTextNode = oW3CContainer;
			aChildNodes = DOMfix.DF_childNode(oNonTextNode);
			iNumOfLeftNodesToCount = iW3COffset;
		}

		var oNodeTester = null;

		var iResultOffset = 0;

		var bCollapseToStart = true;

		for(var i=0; i<iNumOfLeftNodesToCount; i++){
			oNodeTester = aChildNodes[i];

			if(oNodeTester.nodeType == 3){
				if(oNodeTester == oW3CContainer) break;

				iResultOffset += oNodeTester.nodeValue.length;
			}else{
				oIERange.moveToElementText(oNodeTester);
				oNonTextNode = oNodeTester;
				iResultOffset = 0;

				bCollapseToStart = false;
			}
		}

		if(oW3CContainer.nodeType == 3) iResultOffset += iW3COffset;

		return {oSelectableNodeForIE:oNonTextNode, iOffsetForIE: iResultOffset, bCollapseToStart: bCollapseToStart};
	};

	this._IERange2W3CRange = function(oIERange){
		var oW3CRange = new AXDOMRange(this._document);

		var oIEPointRange = null;
		var oPosition = null;

		oIEPointRange = oIERange.duplicate();
		oIEPointRange.collapse(true);

		oPosition = this._getW3CContainerAndOffset(oIEPointRange, true);

		oW3CRange.setStart(oPosition.oContainer, oPosition.iOffset);

		var oCollapsedChecker = oIERange.duplicate();
		oCollapsedChecker.collapse(true);
		if(oCollapsedChecker.isEqual(oIERange)){
			oW3CRange.collapse(true);
		}else{
			oIEPointRange = oIERange.duplicate();
			oIEPointRange.collapse(false);
			oPosition = this._getW3CContainerAndOffset(oIEPointRange);
			oW3CRange.setEnd(oPosition.oContainer, oPosition.iOffset);
		}

		return oW3CRange;
	};

	this._getW3CContainerAndOffset = function(oIEPointRange, bStartPt){
		var oRgOrigPoint = oIEPointRange;

		var oContainer = oRgOrigPoint.parentElement();
		var offset = -1;

		var oRgTester = this._document.body.createTextRange();
		var aChildNodes = DOMfix.DF_childNode(oContainer);
		var oPrevNonTextNode = null;
		var pointRangeIdx = 0;

		for(var i=0;i<aChildNodes.length;i++){
			if(aChildNodes[i].nodeType == 3) continue;

			oRgTester.moveToElementText(aChildNodes[i]);

			if(oRgTester.compareEndPoints("StartToStart", oIEPointRange)>=0) break;

			oPrevNonTextNode = aChildNodes[i];
		}

		var pointRangeIdx = i;

		if(pointRangeIdx != 0 && aChildNodes[pointRangeIdx-1].nodeType == 3){
			var oRgTextStart = this._document.body.createTextRange();
			var oCurTextNode = null;
			if(oPrevNonTextNode){
				oRgTextStart.moveToElementText(oPrevNonTextNode);
				oRgTextStart.collapse(false);
				oCurTextNode = oPrevNonTextNode.nextSibling;
			}else{
				oRgTextStart.moveToElementText(oContainer);
				oRgTextStart.collapse(true);
				oCurTextNode = oContainer.firstChild;
			}

			var oRgTextsUpToThePoint = oRgOrigPoint.duplicate();
			oRgTextsUpToThePoint.setEndPoint("StartToStart", oRgTextStart);

			var textCount = oRgTextsUpToThePoint.text.length

			while(textCount > oCurTextNode.nodeValue.length && oCurTextNode.nextSibling){
				textCount -= oCurTextNode.nodeValue.length;
				oCurTextNode = oCurTextNode.nextSibling;
			}

			// this will enforce IE to re-reference oCurTextNode
			var oTmp = oCurTextNode.nodeValue;

			if(bStartPt && oCurTextNode.nextSibling && oCurTextNode.nextSibling.nodeType == 3 && textCount == oCurTextNode.nodeValue.length){
				textCount -= oCurTextNode.nodeValue.length;
				oCurTextNode = oCurTextNode.nextSibling;
			}

			oContainer = oCurTextNode;
			offset = textCount;
		}else{
			oContainer = oRgOrigPoint.parentElement();
			offset = pointRangeIdx;
		}

		return {"oContainer" : oContainer, "iOffset" : offset};
	};
}
/* ---------------------------- */
/* http://www.axisj.com, license : http://www.axisj.com/license */
 

var AXDrag = Class.create(AXJ, {
    version: "AXJDrag V1.2",
	author: "tom@axisj.com",
	logs: [
		"2013-08-21 오후 11:47:11 - modsAX 변환",
		"2013-12-17 오후 4:56:13 - multiselect 와 호환성 작업"
	],
    initialize: function(AXJ_super) {
        AXJ_super();
        this.config.dragBoxClassName = "AXJDragBox";
        this.config.bedragClassName = "bedraged";
        this.config.bedropClassName = "bedroped";
        this.config.dragClassName = "readyDrag";
        this.config.dropClassName = "readyDrop";
        this.config.sort = false;
        this.sortOn = false;
        this.config.moveSens = 5;
        this.moveSens = 0;
        this.config.scrollPos = true;
    },
    /* ------------------------------------------------------------------------------------------------------------------ */
    /* init ~~~~~~ */
    init: function() {
        this.draged = false;
        //this.dragBox = new Element('div', { 'class':this.config.dragBoxClassName});
        this.dragBox = jQuery("<div class='" + this.config.dragBoxClassName + "'></div>");
        this.dragBox.html("<div class=\"boxshadow\"></div><div class=\"boxicon\"></div><div class=\"boxcounter\">0</div>");

        if (this.config.sort) {
            this.sorter = jQuery(this.config.sort.sorter);
        }

        var mouseMove = this.onmouseMove.bind(this);
        this.dragBox.bind("mousemove", function(event) {
            mouseMove(this, event);
        });
        this.dragCount = this.dragBox.find("div.boxcounter");
        this.dragBoxDim = {};
        this.dragItem = [];
        //ready dragBox

        if (this.config.multiSelector) { //AXJMselect init
        	this.mselector = new AXMultiSelect();
        	this.config.multiSelector.useHelper = false;
            this.mselector.setConfig(this.config.multiSelector);
        }
    },
    active: function() {
        this.mouseDown = this.onmouseDown.bind(this);
        this.dragStart = this.ondragStart.bind(this);

        jQuery("#" + this.config.dragStage).bind("mousedown", this.mouseDown);
        jQuery("#" + this.config.dragStage).bind("dragstart", this.dragStart);
    },
    draging: function(power) {
        if (power) {
            this.draging(false);
            this.mouseMove = this.onmouseMove.bind(this);
            this.mouseOver = this.onmouseOver.bind(this);
            this.mouseOut = this.onmouseOut.bind(this);
            this.mouseUp = this.onmouseUp.bind(this);
            this.selectstart = this.onselectStart.bind(this);
            this.keyUp = this.onkeyUp.bind(this);
            jQuery("#" + this.config.dragStage).bind("mousemove", this.mouseMove);
            jQuery("#" + this.config.dragStage).bind("mouseover", this.mouseOver);
            jQuery("#" + this.config.dragStage).bind("mouseout", this.mouseOut);
            jQuery(document).bind("mouseup", this.mouseUp);
            jQuery(document).bind("selectstart", this.selectstart);
            jQuery(document).bind("keyup", this.keyUp);
            //jQuery("#" + this.config.dragStage).addClass("AXJSelectNone");
            //alert("x");
        } else {
            if (this.mouseMove) jQuery("#" + this.config.dragStage).unbind('mousemove', this.mouseMove);
            if (this.mouseOver) jQuery("#" + this.config.dragStage).unbind('mouseover', this.mouseOver);
            if (this.mouseUp) jQuery(document).unbind("mouseup", this.mouseup);
            if (this.selectstart) jQuery(document).unbind("selectstart", this.selectstart);
            if (this.keyUp) jQuery(document).unbind("keyup", this.keyup);
            //jQuery("#" + this.config.dragStage).removeClass("AXJSelectNone");
            //alert("y");
        }
    },
    inactive: function() {
        if (this.mouseDown) jQuery("#" + this.config.dragStage).unbind('mousedown', this.mouseDown);
        if (this.dragStart) jQuery("#" + this.config.dragStage).unbind('dragstart', this.dragStart);
    },
    /* ------------------------------------------------------------------------------------------------------------------ */
    /* on observe method ~~~~~~ */
    onmouseDown: function(event) {

        if (event.button == 2) return;
        var eventTarget = event.target;

        if (eventTarget) {
            while (!axdom(eventTarget).hasClass(this.config.dragClassName)) {
                if (eventTarget.parentNode) eventTarget = eventTarget.parentNode;
                else break;
            }
        }
        if (!jQuery(eventTarget).hasClass(this.config.dragClassName)) return;

        var dragElement = eventTarget;
        if (dragElement) {
            if (AXUtil.browser.name == "moz") {
                this.dragParent = jQuery(dragElement).parent();
                if (this.dragParent.css("overflow") == "visible") {
                    this.dragParent = null;
                }
            }

            if (this.config.multiSelector) {
            	if (event.shiftKey || event.metaKey || event.ctrlKey) {
            		
            	}else{
            		this.mselector.clickSelects(dragElement);
            	}
            	this.dragReady();
            } else {
            	this.dragReady([dragElement]);
            }
        }
    },
    ondragStart: function(event) {
        event.stopPropagation(); // disable  event
        return false;
    },
    onselectStart: function(event) {
        event.stopPropagation();
        return false;
    },
    onmouseUp: function(event) {
        var dropElement;
        var eventTarget;

        if (this.config.sort) {
            eventTarget = event.target;
            if (eventTarget) {
                while (!axdom(eventTarget).hasClass(this.config.dragClassName)) {

                    if (eventTarget.parentNode) eventTarget = eventTarget.parentNode;
                    else break;
                }
            }
            var isSort = jQuery(eventTarget).hasClass(this.config.dragClassName);
        }

        if (!isSort) { //소트타입이 아니라면
            eventTarget = event.target;
            var isDrop = jQuery(eventTarget).hasClass(this.config.dropClassName);
        }

        if (isSort) {
            if (eventTarget && this.draged) {
                if (this.config.onSort) this.config.onSort({ dragItem: this.dragItem, sortItem: eventTarget });
                this.endSort();
            }
        } else if (isDrop) {
            if (eventTarget && this.draged) {
                jQuery(eventTarget).removeClass(this.config.bedropClassName);
                if (this.config.onDrop) this.config.onDrop({ dragItem: this.dragItem, dropItem: eventTarget });
            }
        }

        this.draging(false);
        this.endDrag();
    },
    onkeyUp: function(event) {

    },
    onmouseMove: function(event) {
        if (!event.pageX) return;

        if (this.config.scrollPos) {
            if (document.body.scrollTop == 0) {
                var st = document.documentElement.scrollTop;
                var sl = document.documentElement.scrollLeft;
            } else {
                var st = document.body.scrollTop;
                var sl = document.body.scrollLeft;
            }
            this.mouse = { x: (event.pageX - sl) || 0, y: (event.pageY - st) || 0 }; //Event.pointer(event);
        } else {
            this.mouse = { x: event.pageX || 0, y: event.pageY || 0 }; //Event.pointer(event);
        }
        //드래그 감도 적용
        if (this.config.moveSens > this.moveSens) this.moveSens++;
        if (this.moveSens == this.config.moveSens) this.dragboxMove();
    },
    onmouseOver: function(event) {
        var eventTarget;

        if (this.config.sort) {
            eventTarget = event.target;
            if (eventTarget) {
                while (!axdom(eventTarget).hasClass(this.config.dragClassName)) {

                    if (eventTarget.parentNode) eventTarget = eventTarget.parentNode;
                    else break;
                }
            }
            var isSort = jQuery(eventTarget).hasClass(this.config.dragClassName);
        }

        if (!isSort) { //소트타입이 아니라면
            eventTarget = event.target;
            var isDrop = jQuery(eventTarget).hasClass(this.config.dropClassName);
        }

        if (isDrop) {
            if (eventTarget) jQuery(eventTarget).addClass(this.config.bedropClassName);
            this.endSort();
        } else if (isSort) {
            if (eventTarget) this.startSort(eventTarget);
        } else {
            if (this.sortOn) this.endSort();
        }
    },
    onmouseOut: function(event) {
        if (!jQuery(event.target).hasClass(this.config.dropClassName)) return;
        var dropElement = event.target;
        if (dropElement) {
            jQuery(dropElement).removeClass(this.config.bedropClassName);
        }
    },
    startSort: function(target) {
        jQuery(target).before(this.sorter);
        this.sortOn = true;
    },
    endSort: function() {
        if (this.sortOn) {
            jQuery(this.sorter).detach();
        }
        if (this.config.onStopDrag) this.config.onStopDrag({ dragItem: this.dragItem });
    },
    dragboxMove: function() {
        if (!this.draged) {
            this.draged = true;
            if (this.dragParent) this.dragParent.css({ "overflow": "hidden" });
            var bedragClassName = this.config.bedragClassName;
            if (this.config.appendTarget)
                jQuery("#" + this.config.appendTarget).append(this.dragBox);
            else
                jQuery("#" + this.config.dragStage).after(this.dragBox);

            this.dragBoxDim = { width: this.dragBox.width(), height: this.dragBox.height() }; //.getDimensions();
            this.dragCount.html(this.dragItem.length);
            this.dragTrigger();
            //draged dragItem
            jQuery(this.dragItem).addClass(bedragClassName);
        }

        this.dragBox.css({ left: this.mouse.x + (20) + "px", top: this.mouse.y + (20) + "px" });
    },
    endDrag: function() {
        if (this.draged) {
            if (this.dragParent) this.dragParent.css({ "overflow": "auto" });

            var bedragClassName = this.config.bedragClassName;
            this.draged = false;
            this.dragBox.detach();
            this.endSort();
            //undraged dragItem
            jQuery(this.dragItem).removeClass(bedragClassName);
            if (this.config.multiSelector) this.mselector.clearSelects();
            else this.dragItem.clear();
            this.moveSens = 0;
        }
    },
    /* ------------------------------------------------------------------------------------------------------------------ */
    /* class method ~~~~~~ */
    dragReady: function(dragItems) {
        if (this.config.multiSelector) this.dragItem = this.mselector.getSelects();
        else this.dragItem = dragItems;
        this.draging(true);
    },
    dragTrigger: function() {
        if (this.config.onDrag) this.config.onDrag({ dragItem: this.dragItem });
    },
    collectItem: function() {
        if (this.config.multiSelector) {
            if (this.observer) clearTimeout(this.observer);
            this.observer = setTimeout(this.collectItemAct.bind(this), 100);
        }
    },
    collectItemAct: function() {
        this.mselector.collect();
    },
    nothing: function() {

    }
});
/* ---------------------------- */
/* http://www.axisj.com, license : http://www.axisj.com/license */
 

var AXEditorLang = {
	en:{
		home:"HOME",
		attch:"Attachment",
		table:"Table",
		layout:"Layouts",
		option:"Options",
		external:"External",
		editor:"Editor",
		HTML:"HTML",
		textColor:"TEXT COLOR",
		textBgColor:"TEXT BGCOLOR",
		fontFamily:"Font Family",
		fontSize:"Font Size",
		fontSample:"가나Ab",
		lineHeight:"Line Height(em)",
		url:"Link",
		upload:"Upload",
		insertDoc:"Insert",
		delSelected:"Delete",
		selectAll:"SelectAll",
		invalidUrlMsg:"invalid url make fail",
		volumeOverMsg:"upload Maxium size over",
		noSelectedFileMsg:"No selected target file",
		fileDeleteConfirm:"Do you want to delete it?",
		externalTitle:"Custom AX Pannel",
		imoticon:"Imoticon"
	},
	kr:{
		home:"홈",
		attch:"파일첨부",
		table:"테이블",
		layout:"레이아웃",
		option:"옵션",
		external:"추가기능",
		editor:"Editor",
		HTML:"HTML",
		textColor:"텍스트 컬러",
		textBgColor:"텍스트 배경컬러",
		fontFamily:"글꼴",
		fontSize:"글자크기",
		fontSample:"가나Ab",
		lineHeight:"줄간격(em)",
		url:"링크걸기",
		upload:"업로드",
		insertDoc:"본문삽입",
		delSelected:"선택삭제",
		selectAll:"전체선택",
		invalidUrlMsg:"url 형식이 잘못되어 url연결에 실패 하였습니다.",
		volumeOverMsg:"업로드 용량이 초과 되어 업로드 하실 수 없습니다.",
		noSelectedFileMsg:"선택된 파일이 없습니다.",
		fileDeleteConfirm:"정말 삭제 하시겠습니까?",
		externalTitle:"Custom AX Pannel",
		imoticon:"이모티콘"
	},
	jp:{
		home:"HOME",
		attch:"Attachment",
		table:"Table",
		layout:"Layouts",
		option:"Options",
		external:"External",
		editor:"Editor",
		HTML:"HTML",
		textColor:"TEXT COLOR",
		textBgColor:"TEXT BGCOLOR",
		fontFamily:"Font Family",
		fontSize:"Font Size",
		fontSample:"가나Ab",
		lineHeight:"Line Height(em)",
		url:"Link",
		upload:"Upload",
		insertDoc:"Insert",
		delSelected:"Delete",
		selectAll:"Select",
		invalidUrlMsg:"invalid url make fail",
		volumeOverMsg:"upload Maxium size over",
		noSelectedFileMsg:"No selected target file",
		fileDeleteConfirm:"Do you want to delete it?",
		externalTitle:"Custom AX Pannel",
		imoticon:"Imoticon"
	},
	cn:{
		home:"HOME",
		attch:"Attachment",
		table:"Table",
		layout:"Layouts",
		option:"Options",
		external:"External",
		editor:"Editor",
		HTML:"HTML",
		textColor:"TEXT COLOR",
		textBgColor:"TEXT BGCOLOR",
		fontFamily:"Font Family",
		fontSize:"Font Size",
		fontSample:"가나Ab",
		lineHeight:"Line Height(em)",
		url:"Link",
		upload:"Upload",
		insertDoc:"Insert",
		delSelected:"Delete",
		selectAll:"Select",
		invalidUrlMsg:"invalid url make fail",
		volumeOverMsg:"upload Maxium size over",
		noSelectedFileMsg:"No selected target file",
		fileDeleteConfirm:"Do you want to delete it?",
		externalTitle:"Custom AX Pannel",
		imoticon:"Imoticon"
	}
};

/*
2014-04-17 : tom - insert image & remove image 아이디 문제 해결
*/

/**
 * AXEditor
 * @class AXEditor
 * @extends AXJ
 * @version v1.4
 * @author tom@axisj.com
 * @logs
 * "2014-06-04 tom : method [insertImg] Insert prevent duplicate images
 * "2014-08-05 tom : add event onresize"
 * "2014-08-08 tom : AXConfig.AXEditor 설정 추가"
 * "2014-09-01 tom : toolbar config 추
 *
 */

var AXEditor = Class.create(AXJ, {
	_GID: function (ids) {
		var myid = [];
		for (var a = 0; a < ids.length; a++) {
			myid.push(ids[a]);
		}
		return myid.join("_");
	},
	_GPT: function (myid, idx) {
		var ids = myid.split(/_/g);
		if (idx == undefined) {
			return ids.last();
		} else {
			return ids[idx];
		}
	},
	initialize: function(AXJ_super){
		AXJ_super();
		this.moveSens = 0;
		this.contentMode = "editor";
		this.panelNum = 0;
		this.attchFiles = [];
		this.readyFiles = [];
		with(this){
			config.containerCss = "AXEditor";
			config.headCss = "editorHead";
			config.bodyCss = "editorBody";
			config.footCss = "editorFoot";
			config.height = 300;
			config.lang = "en";
			config.moveSens = 5;
			config.ie67adj = -2;
			config.selectMenuIndex = 0;
			config.tabFileUsed = false;
			config.tabTableUsed = false;
			config.tabLayoutUsed = false;
			config.tabOptionUsed = false;
			config.tabExternalUsed = false;
			config.frameSrc = (AXConfig.AXEditor.editor_frameSrc||"/_AXJ/lib/AXEditor.html");
			config.editorFontSize = "12px";
			config.editorFontFamily = "Malgun Gothic";
			config.colors = ["ffffff","faedd4","fff3b4","ffffbe","ffeaea","ffeaf8","e6ecfe","d6f3f9","e0f0e9","eaf4cf","e8e8e8","e7c991","f3d756","ffe409","f9b4cb","dfb7ee","b1c4fc","96ddf3","b1dab7","b8d63d","c2c2c2","d18e0a","ec9c2c","ff8b16","f3709b","af65dd","7293fa","49b5d5","6abb9a","5fb636","8e8e8e","9d6c08","c84205","e31600","c8056a","801fbf","3058d2","0686a8","318561","2b8400","474747","654505","8c3c04","840000","8c044b","57048c","193da9","004c5f","105738","174600","000000","463003","612a03","5b0000","610334","320251"];
			config.fonts = ["Malgun Gothic","Gulim","Dotum","궁서"];
			config.fontsizes = [8,9,10,11,12,14,16,18,20];
			config.lineHeights = [1.0, 1.2, 1.5, 1.8, 2.0, 2.5];
			config.swfUploader = "";
			config.uploadUrl = "";
			config.uploadPars = ["p1=1","p2=2"];
			config.deleteUrl = "",
			config.deletePars = [],
			config.uploadVolume = (5 * 1024 * 1024);
			config.uploadFilterName = "All,Image";
    		config.uploadFilterValue = "*.*,*.jpg; *.gif; *.png";
    		config.uploadCallBack = "mmuCall";
    		config.tabExternals = [];
    		config.readyTofocus = true;
			config.msg = {
				alreadyInsertImg:"이미 추가된 이미지 입니다."
			}
		}

		this.config.toolbar = {
			fontFamily: true,
			fontSize: true,
			fontDecoration: true,
			color: true,
			textAlign: true,
			orderList: true,
			lineHeight: true,
			url: true,
			imoticon: true,
			pageBreak: true
		};


        this.config.AXEditorIcons = [
            {
                categoryNM:"Grimi",
                copyRights:"<a href='http://jowrney.com/xe/grimi/' target='_blank'>Copyright © Jowrney.com. All rights reserved.</a>",
                imageFolder: (AXConfig.AXEditor.iconDirectory || "/ui/icons/") + "grimi/",
                icons:["grimi_big_smile16.png","grimi_cry16.png","grimi_doze16.png","grimi_happy16.png","grimi_love16.png","grimi_smile16.png","grimi_so_what16.png","grimi_vomit16.png"]
            },
            {
                categoryNM:"Fugue Icons",
                copyRights:"<a href='http://p.yusukekamiyamane.com/' target='_blank'>Copyright © Yusuke Kamiyamane. All rights reserved.</a>",
                imageFolder: (AXConfig.AXEditor.iconDirectory || "/ui/icons/"),
                icons:["address-book.png","alarm-clock.png","arrow-000-medium.png","arrow-045-medium.png","arrow-045.png","arrow-090-medium.png","arrow-090.png",
                    "arrow-135-medium.png","arrow-135.png","arrow-180-medium.png","arrow-180.png","arrow-225-medium.png","arrow-225.png","arrow-270-medium.png","arrow-270.png",
                    "arrow-315-medium.png","arrow-315.png","arrow.png","asterisk.png","auction-hammer.png","balance.png","balloon-ellipsis.png","balloon-quotation.png","balloon.png",
                    "bandaid.png","bell.png","bin.png","binocular.png","block.png","bomb.png","bookmark.png","box.png","briefcase.png","broom.png","building.png","burn.png",
                    "calculator.png","camcorder.png","camera.png","car--exclamation.png","car-red.png","clapperboard.png","compass.png","credit-card.png","crown-bronze.png",
                    "crown-silver.png","crown.png","currency-euro.png","currency-pound.png","currency-yen.png","currency.png","cursor-small.png","cursor.png","direction.png",
                    "drill.png","eraser.png","eye.png","hammer.png","hand.png","heart-break.png","heart.png","inbox.png","keyboard.png","leaf.png","lifebuoy.png","light-bulb.png",
                    "mail-open.png","mail.png","marker.png","megaphone.png","microphone.png","mobile-phone.png","money.png","mouse.png","music.png","paint-can.png","pipette-color.png",
                    "plug.png","printer.png","safe.png","smiley-confuse.png","smiley-cool.png","smiley-cry.png","smiley-eek.png","smiley-evil.png","smiley-fat.png","smiley-grin.png",
                    "smiley-lol.png","smiley-mad.png","smiley-mr-green.png","smiley-neutral.png","smiley-paint-brush.png","smiley-razz.png","smiley-red.png","smiley-roll.png","smiley-sad.png",
                    "smiley-slim.png","smiley-surprise.png","smiley-twist.png","smiley-wink.png","smiley-yell.png","smiley.png"]
            }
        ];


	},

/**
 * 선언된 스크롤 클래스를 사용하기 위해 속성을 정의합니다.
 * @method AXEditor.setConfig
 * @param {Object}
 * @example
```js
var myEditor = new AXEditor();

myEditor.setConfig({
	targetID: "AXEditorTarget", // 에디터 표시 타겟
	lang: "kr",
	height: 300,
	frameSrc: "lib/AXEditor.html", // 에디터 컨텐츠 기본 HTML 위치
	editorFontFamily: "Malgun Gothic",
	fonts: ["Malgun Gothic","Gulim","Dotum","궁서"],
	onReady: function(){ // 에디터 준비완료
		myEditor.setContent($("#editContent"));
	},
    onresize: function(){ // 에디터 높이 변경 이벤트
        trace(this);
    }
});
```
 */
	init: function(){
		this._self    = jQuery("#"+this.config.targetID);
	    var config = this.config;
	    // po
	    var po = [];
	    po.push("<div id=\""+config.targetID+"_container\" class=\""+config.containerCss+"\">");
	    po.push("	<div id=\""+config.targetID+"_head\"   class=\""+config.headCss+"\"></div>");
	    po.push("	<div id=\""+config.targetID+"_body\"   class=\""+config.bodyCss+"\"></div>");
	    po.push("	<div id=\""+config.targetID+"_foot\"   class=\""+config.footCss+"\"></div>");
	    po.push("</div>");
	    this._self.append(po.join(''));

	    // define element
	    this.container= jQuery("#"+config.targetID+"_container");
	    this.head     = jQuery("#"+config.targetID+"_head");
	    this.body     = jQuery("#"+config.targetID+"_body");
	    this.foot     = jQuery("#"+config.targetID+"_foot");

	    //init head
    	this.initHead();

    	//init foot
    	this.initFoot();

    	//init body
    	this.initBody();
	},
	initHead: function(){
		var config = this.config;
		var re = config.targetID;
		var lg = AXEditorLang[config.lang];
		var po = [];
		/*메뉴탭과 패널*/
		/*po.push("<div id=\""+re+"_headTab\" class='me___tabContainer'></div>");*/
		po.push("<div id=\""+re+"_headPanel\" class='me___headPanel'></div>");
		this.head.append(po.join(''));
		/*메뉴 내용 구성*/

		this.initPanel();
	},
	initPanel: function()
	{
		var config = this.config;
		var re = config.targetID;
		var po = [];
		if (config.toolbar.fontFamily)
		{
			po.push( "<div class='me___selectW'>" );
			po.push( "	<a href='#axExecption' class='me___value selectCommand me_ffs' style='font-family:" + config.editorFontFamily + "' id='" + this._GID( [ re, "fontname" ] ) + "'>" + config.editorFontFamily + "</a>" );
			po.push( "</div>" );
		}
		if (config.toolbar.fontSize)
		{
			po.push( "<div class='me___selectS'>" );
			po.push( "	<a href='#axExecption' class='me___value selectCommand me_fss' id='" + this._GID( [ re, "fontsize" ] ) + "'>" + config.editorFontSize + "</a>" );
			po.push( "</div>" );
		}

		if (config.toolbar.fontDecoration)
		{
			po.push( "<div class='me___vline'></div>" );
			po.push( "<a href='#axExecption' class='me___btnL'>" );
			po.push( "	<span class='me_icon me___bold simpleCommand' id='" + this._GID( [ re, "bold" ] ) + "'>Bold</span>" );
			po.push( "</a>" );

			po.push( "<a href='#axExecption' class='me___btnM'>" );
			po.push( "	<span class='me_icon me___italic simpleCommand' id='" + this._GID( [ re, "italic" ] ) + "'>Italic</span>" );
			po.push( "</a>" );
			po.push( "<a href='#axExecption' class='me___btnM'>" );
			po.push( "	<span class='me_icon me___underLine simpleCommand' id='" + this._GID( [ re, "underline" ] ) + "'>UnderLine</span>" );
			po.push( "</a>" );
			po.push( "<a href='#axExecption' class='me___btnR'>" );
			po.push( "	<span class='me_icon me___strike simpleCommand' id='" + this._GID( [ re, "strikethrough" ] ) + "'>strike</span>" );
			po.push( "</a>" );
		}

		if (config.toolbar.color)
		{
			po.push( "<div class='me___vline'></div>" );
			po.push( "<div class='me___selectTL'>" );
			po.push( "	<div class='me___fontColor_disp' style='background:#444444;' id='" + this._GID( [ re, "foreColorVal" ] ) + "'></div>" );
			po.push( "	<a href='#axExecption' class='me___value colorCommand' id='" + this._GID( [ re, "foreColor" ] ) + "'>foreColor</a>" );
			po.push( "	<a href='#axExecption' class='me___arrow selectCommand me_picker' id='" + this._GID( [ re, "foreColorExt" ] ) + "'>+</a>" );
			po.push( "</div>" );
			po.push( "<div class='me___selectTR'>" );
			po.push( "	<div class='me___fontBgColor_disp' style='background:#ffffff;' id='" + this._GID( [ re, "backColorVal" ] ) + "'></div>" );
			po.push( "	<a href='#axExecption' class='me___value colorCommand' id='" + this._GID( [ re, "backColor" ] ) + "'>backColor</a>" );
			po.push( "	<a href='#axExecption' class='me___arrow selectCommand me_picker' id='" + this._GID( [ re, "backColorExt" ] ) + "'>+</a>" );
			po.push( "</div>" );
		}
		if (config.toolbar.textAlign)
		{
			po.push( "<div class='me___vline'></div>" );
			po.push( "<a href='#axExecption' class='me___btnL'>" );
			po.push( "	<span class='me_icon me___alignLeft simpleCommand' id='" + this._GID( [ re, "JustifyLeft" ] ) + "'>alignLeft</span>" );
			po.push( "</a>" );
			po.push( "<a href='#axExecption' class='me___btnM'>" );
			po.push( "	<span class='me_icon me___alignCenter simpleCommand' id='" + this._GID( [ re, "JustifyCenter" ] ) + "'>alignCenter</span>" );
			po.push( "</a>" );
			po.push( "<a href='#axExecption' class='me___btnM'>" );
			po.push( "	<span class='me_icon me___alignRight simpleCommand' id='" + this._GID( [ re, "JustifyRight" ] ) + "'>alignRight</span>" );
			po.push( "</a>" );
			po.push( "<a href='#axExecption' class='me___btnR'>" );
			po.push( "	<span class='me_icon me___alignJustify simpleCommand' id='" + this._GID( [ re, "JustifyFull" ] ) + "'>alignJustify</span>" );
			po.push( "</a>" );
		}
		if (config.toolbar.orderList)
		{
			po.push( "<div class='me___vline'></div>" );
			po.push( "<a href='#axExecption' class='me___btnL'>" );
			po.push( "	<span class='me_icon me___li simpleCommand' id='" + this._GID( [ re, "InsertUnorderedList" ] ) + "'>li</span>" );
			po.push( "</a>" );
			
			po.push( "<a href='#axExecption' class='me___btnR'>" );
			po.push( "	<span class='me_icon me___ol simpleCommand' id='" + this._GID( [ re, "InsertOrderedList" ] ) + "'>ol</span>" );
			po.push( "</a>" );
		}

		if (config.toolbar.lineHeight)
		{
			po.push( "<div class='me___vline'></div>" );
			po.push( "<a href='#axExecption' class='me___btnSa'>" );
			po.push( "	<span class='me_icon me___lineHeight selectCommand me_lhs' id='" + this._GID( [ re, "lineHeight" ] ) + "'>lineHeight</span>" );
			po.push( "</a>" );
		}
		if (config.toolbar.url)
		{
			po.push( "<div class='me___vline'></div>" );
			po.push( "<a href='#axExecption' class='me___btnSa'>" );
			po.push( "	<span class='me_icon me___url selectCommand me_url' id='" + this._GID( [ re, "url" ] ) + "'>url</span>" );
			po.push( "</a>" );
		}
		if (config.toolbar.imoticon)
		{
			po.push( "<div class='me___vline'></div>" );
			po.push( "<a href='#axExecption' class='me___btnSa'>" );
			po.push( "	<span class='me_icon me___imoticon selectCommand me_ico' id='" + this._GID( [ re, "imoticon" ] ) + "'>imoticon</span>" );
			po.push( "</a>" );
		}
		if (config.toolbar.pageBreak)
		{
			po.push( "<div class='me___vline'></div>" );
			po.push( "<a href='#axExecption' class='me___btnSa'>" );
			po.push( "	<span class='me_icon me___pageBreak pbCommand' id='" + this._GID( [ re, "pageBreak" ] ) + "'>pageBreak</span>" );
			po.push( "</a>" );
		}
		jQuery("#"+re+"_headPanel").append(po.join(''));
		jQuery("#"+re+"_headPanel").find(".simpleCommand").bind("click", this.onSimpleCommandClick.bind(this));
		jQuery("#"+re+"_headPanel").find(".colorCommand").bind("click", this.onColorCommandClick.bind(this));
		jQuery("#"+re+"_headPanel").find(".selectCommand").bind("click", this.onSelectCommandClick.bind(this));
		jQuery("#"+re+"_headPanel").find(".pbCommand").bind("click", this.onInsertCommand.bind(this));
	},
	closePanel: function(){
		var config = this.config;
		var re = config.targetID;
		var items = ["home_btn","attch_btn","table_btn","layout_btn","option_btn","external_btn"];
		jQuery("#"+re+"_"+items[this.panelNum]).parent().removeClass("me___itemOn");
		if(this.panelNum == 0) return;
		if(this.panelNum == 1) this.initFlashButtonMoveTo(jQuery("#"+re+"_"+items[this.panelNum]).parent());
		
		/*this.closeFileStatus();*/
		this.divPanel.remove();
		jQuery("#"+config.targetID+"_head").removeClass("editorHeadExt");	
	},
	openPanel: function(){
		var config = this.config;
		var re = config.targetID;
		var lg = AXEditorLang[config.lang];
		var items = ["home_btn","attch_btn","table_btn","layout_btn","option_btn","external_btn"];
		jQuery("#"+re+"_"+items[this.panelNum]).parent().addClass("me___itemOn");
		
		if(this.panelNum == 0) return;
		if(this.panelNum == 1){
			this.divPanel = jQuery("<div id='"+this._GID([re, "divPanel", "attch"])+"' class='me___headDivPanel_attch'></div>");	
			var po = [];
			po.push("<div class='me___headDivPanel_attch_btns' id='"+re+"_divPanel_attchBtns'>");
			po.push("	<span class='me___span' style='margin-left:33px;'>&nbsp;</span>");
			po.push("	<a href='#axExecption' class='me___btnS1' id='"+this._GID([re, "attbtns", "insertDoc"])+"'>"+lg.insertDoc+"</a>");
			po.push("	<a href='#axExecption' class='me___btnS1' id='"+this._GID([re, "attbtns", "delete"])+"'>"+lg.delSelected+"</a>");
			po.push("	<span class='me___span'>&nbsp;</span>");
			po.push("	<a href='#axExecption' class='me___btnS1' id='"+this._GID([re, "attbtns", "selectAll"])+"'>"+lg.selectAll+"</a>");
			po.push("</div>");
			po.push("<div class='me___headDivPanel_attch_CT' nowrap='nowrap' align='left'>");

		jQuery.each(this.attchFiles, function(si, fo){
			if(fo.checked){
			po.push("<div class='attchItem attchItemON' id='"+re+"_attchItem_"+si+"' title='"+fo.ti.dec()+"'>");
			}else{
			po.push("<div class='attchItem' id='"+re+"_attchItem_"+si+"' title='"+fo.ti.dec()+"'>");
			}
			po.push("<div class='attchItemName'>"+fo.ti.dec()+"</div>");
			po.push("<div class='attchItemPreview'>");
			var ty = fo.ty.dec().toLowerCase();
			if(ty == ".gif" | ty == ".jpg" | ty == ".png" | ty == ".bmp"){
			po.push("<img src='"+fo.path.dec()+fo.nm.dec()+"' width='100%' height='100%' alt='' />")
			}
			po.push("</div>");
			po.push("</div>");
		});
						
			po.push("	<div class='attchItemEnd' id='"+re+"_divPanel_attchItemEnd'>&nbsp;</div>");
			po.push("</div>");
			this.divPanel.html(po.join(''));
			
			this.openFileStatus();
		}
		if(this.panelNum == 5){
			this.divPanel = jQuery("<div id='"+this._GID([re, "divPanel", "external"])+"' class='me___headDivPanel_attch'></div>");
			var po = [];
			po.push("<div class='me___headDivPanel_attch_btns' id='"+re+"_divPanel_attchBtns'>");
			po.push("<div class='headTitle'>"+lg.externalTitle+"</div>");
			po.push("</div>");
			po.push("<div class='me___headDivPanel_attch_CT' nowrap='nowrap' align='left'>");
			
			jQuery.each(config.tabExternals, function(idx, n){
			po.push("<div class='componentItem' id='"+n.component+"' title='"+n.title+"'>");
			po.push("<div class='componentItemName'>"+n.title+"</div>");
			po.push("<div class='componentItemPreview'>");
			if(n.ico != ""){
			po.push("<img src='"+n.ico+"' alt='' />")
			}
			po.push("</div>");
			po.push("</div>");
			});
			
			po.push("	<div class='attchItemEnd' id='"+re+"_divPanel_attchItemEnd'>&nbsp;</div>");
			po.push("</div>");
			this.divPanel.html(po.join(''));
		}
		
		jQuery("#"+re+"_headPanel").append(this.divPanel);
		jQuery("#"+config.targetID+"_head").addClass("editorHeadExt");
		if(this.panelNum == 1){
			this.initFlashButtonMoveTo(jQuery("#"+re+"_divPanel_attchBtns"));
			jQuery("#"+re+"_divPanel_attch").find(".me___btnS1").bind("click", this.onAttbtnsClick.bind(this));
			jQuery("#"+re+"_divPanel_attch").find(".attchItem").bind("click", this.onAttchItemClick.bind(this));
		}
		if(this.panelNum == 5){
			jQuery("#"+re+"_divPanel_external").find(".componentItem").bind("click", this.onClickComponent.bind(this));
		}
	},
	setAttchItem: function(arg){
		var config = this.config;
		var re = config.targetID;
		var lg = AXEditorLang[config.lang];
		if(!arg) return;
		
		/*file size check*/
		var useByte = 0;
		var volumeByte = config.uploadVolume;
		jQuery.each(this.attchFiles, function(){
			useByte += this.size.number();
		});
		jQuery.each(arg, function(index){
			useByte += this.size.number();
		});
		if(useByte > volumeByte){
			/*alert(	lg.volumeOverMsg + "\n\n(" + useByte.byte() + "/" + volumeByte.byte() +")" );*/
			/*AXFlash.requestFn(re+"_attched_swf","uploadCancel");*/
			/*return;*/
		}
		this.readyFiles = arg;
		this.readyUpload();
		/*업로드 시작*/
		/*AXFlash.requestFn(re+"_attched_swf", "uploadStart");*/
	},
	readyUpload: function(){
		if(this.readyFiles.length == 0) return;
		var config = this.config;
		var re = config.targetID;
		/*ready file*/
		var startIndex = this.attchFiles.length;
		var po = [];
			po.push("<div class='attchItem' id='"+re+"_attchItem_"+startIndex+"'>");
			po.push("	<div class='attchItemName'>.....</div>");
			po.push("	<div class='attchItemPreviewLoad'></div>");
			po.push("</div>");
		jQuery("#"+re+"_divPanel_attchItemEnd").before(po.join(''));
	},
	uploadedFile: function(arg){
		var config = this.config;
		var re = config.targetID;
		var startIndex = this.attchFiles.length;
		jQuery("#"+re+"_attchItem_"+startIndex).attr('title', arg.ti.dec());
		jQuery("#"+re+"_attchItem_"+startIndex).find(".attchItemName").html(arg.ti.dec());
		jQuery("#"+re+"_attchItem_"+startIndex).find(".attchItemPreviewLoad").addClass("attchItemPreview");
		jQuery("#"+re+"_attchItem_"+startIndex).bind("click", this.onAttchItemClick.bind(this));
		var ty = arg.ty.dec().toLowerCase();
		if(ty == ".gif" | ty == ".jpg" | ty == ".png" | ty == ".bmp"){
			jQuery("#"+re+"_attchItem_"+startIndex).find(".attchItemPreviewLoad").html("<img src='"+arg.path.dec()+arg.nm.dec()+"' width='100%' height='100%' alt='' />")
			/*본문삽입*/
			var imgObj = new Image();
			imgObj.src = arg.path.dec()+arg.nm.dec();
			imgObj.id = "MF_"+arg.nm.replace(arg.ty, "").dec();
			var pasteHTML = this.__pasteHTML.bind(this);
			var canvasWidth = this.canvas.width() - 40;
			imgObj.onload = function(){
				var ow = imgObj.width;
				var oh = imgObj.height;
				if(imgObj.width > canvasWidth){
					imgObj.width = canvasWidth;
					imgObj.height = oh * (imgObj.width / ow);
				}
				try{
					pasteHTML(imgObj);
				}catch(e){
					alert(e.print());	
				}
			}
		}
		this.attchFiles.push(arg);
		this.readyFiles.pop();
		this.readyUpload();
		this.updateFileStatus();
	},
/**
 * 에디터 바디에 이미지를 추가합니다.
 * @method AXEditor.insertIMG
 * @param {Object} img
 * @returns {AXEditor}
 * @example
```js
 var file = {
	id:"식별자", nm:"저장된파일이름", ty:"파일타입"
};
 myEditor.insertIMG(file);
```
 */
	insertIMG: function(file){
		
		/*trace(file);*/
		
		/*{id:"", ti:"", nm:"", ty:"", sz:"", path:"", thumb:""}*/
		var config = this.config;
		var re = config.targetID;
		var ty = file.ty.dec().toLowerCase();
		var tyReg = /(bmp|jpg|jpeg|gif|png)$/;
 		if (tyReg.test(ty)) {
		    var imgTagId = "MF_"+file.nm.replace(new RegExp("[\.]"+file.ty, "i"), "").dec();
		    if(axdom(this.myEDT.document).find("#"+imgTagId).get(0)) {
			    alert(config.msg.alreadyInsertImg);
			    return;
		    }
			var imgObj = new Image();
			imgObj.src = file.path.dec()+file.nm.dec();
			imgObj.id = imgTagId;

			var pasteHTML = this.__pasteHTML.bind(this);
			var canvasWidth = this.canvas.width() - 40;
			imgObj.onload = function(){
				var ow = imgObj.width;
				var oh = imgObj.height;
				if(imgObj.width > canvasWidth){
					imgObj.width = canvasWidth;
					imgObj.height = oh * (imgObj.width / ow);
				}
				try{
					pasteHTML(imgObj);
				}catch(e){
					alert(e.print());	
				}
			}
		}
		return this;
	},
/**
 * 에디터 바디에서 이미지를 제거합니다.
 * @method AXEditor.removeIMG
 * @param {String} fileID
 * @returns {AXEditor}
 * @example
 ```js
 myEditor.removeIMG("IMG_00110011");
 ```
 */
	removeIMG: function(fileID){
		this.onFeilDeleteInFrame("#"+fileID);
		return this;
	},
	initFoot: function(){
		var config = this.config;
		var po = [];
		po.push("<a class='me___handle'>resizer</a>");
		po.push("<div class='me___container'>");
		po.push("	<a href='#axExecption' id='"+config.targetID+"_contentMode_0' class='me____tab me____tabOn'>Editor</a>");
		po.push("	<a href='#axExecption' id='"+config.targetID+"_contentMode_1' class='me____tab'>HTML</a>");
		po.push("</div>");
		this.foot.append(po.join(''));
		this.foot.find("a.me___handle").bind("mousedown", this.footOnDrag.bind(this));
		this.foot.find("a.me____tab").bind("click", this.onContentMode.bind(this));
	},
	/* initFoot sub functions */
		footOnDrag: function(){
			this.footOnMover = this.footOnMove.bind(this);
			jQuery(document).bind("mousemove", this.footOnMover);
			this.footOnDroper = this.footOnDrop.bind(this);
			jQuery(document).bind("mouseup", this.footOnDroper);
			this.selectstart = this.onselectStart.bind(this);
			jQuery(document).bind("selectstart", this.selectstart);
			this.canvasMask.show();
		},
		footOnMove: function(event){
			if(!event.pageX) return;
		    this.mouse = {x:event.pageX||0, y:event.pageY||0}; 
		    if(this.config.moveSens > this.moveSens) this.moveSens++;
		    if(this.moveSens == this.config.moveSens) this.footMove();
		},
		footMove: function(){
		    if(!this.draged){
		    	this.draged = true;
				this.canvasTop = (this.contentMode == "html") ? this.htmlArea.offset().top : this.canvas.offset().top;
		    }
		    if( (this.mouse.y - this.canvasTop) > 100 ) this.config.height = (this.mouse.y - this.canvasTop - 2);
		    if(this.observer) clearTimeout(this.observer);
      		this.observer = setTimeout(this.footSetCanvasHeight.bind(this), 10);
		},
		footOnDrop: function(){
			this.moveSens = 0;
			jQuery(document).unbind("mousemove", this.footOnMover);
			jQuery(document).unbind("mouseup", this.footOnDroper);
			jQuery(document).unbind("selectstart", this.selectstart);
			clearTimeout(this.observer);
			this.canvasMask.hide();
			this.draged = false;
		},
		footSetCanvasHeight: function(){
			this.canvas.css({height:this.config.height+"px"});
			if(this.contentMode == "html"){
				this.htmlArea.css({height:this.canvas.height()+"px"});
			}
			if(Object.isFunction(this.config.onresize)){
				this.config.onresize.call({canvas:this.canvas, height:this.canvas.height()});
			}
		},
	/* initFoot sub functions */
	initBody: function(){
		var config = this.config;
		this.canvas = jQuery("<iframe src='"+config.frameSrc+"' id='"+config.targetID+"_canvas' name='"+config.targetID+"_canvas' frameBorder='0' allowTransparency='true'></iframe>");
		this.canvasMask = jQuery("<div id='"+config.targetID+"_canvasMask' class='me___AXMask' style='display:none;z-index:10;'></div>");
		this.body.append(this.canvas);
		this.body.append(this.canvasMask);
		this.canvas.css({"width":"100%",height:config.height+"px"});
		this.canvas.bind("load", this.readyFrame.bind(this));
	},
	setHtmlMode: function(power){
		if(power == "on"){
			var config = this.config;
			var canvasHeight = this.canvas.height();
			this.canvas.hide();
			this.htmlArea = jQuery("<textarea id='"+config.targetID+"_html' name='"+config.targetID+"_html' class='me__htmlArea'></textarea>");
			this.body.append(this.htmlArea);
			this.htmlArea.css({"width":"100%",height:canvasHeight+"px"});
			this.htmlArea.val(this.__getContent());
		}else{
			this.setContent(this.htmlArea.val());
			this.canvas.show();
			this.htmlArea.remove();
		}
	},
	readyFrame: function(){
		var config = this.config;
		this.myEDT = window[config.targetID+"_canvas"];

		var editorBody = this.myEDT.document;
		if(AXUtil.browser.name == "ie")	editorBody.body.contentEditable = true;
		else if(AXUtil.browser.name == "webkit"){
			editorBody.body.contentEditable = true;
			editorBody.designMode = "On";
		}else if(AXUtil.browser.name == "mozilla")	editorBody.designMode = "On";
		else	editorBody.designMode = "On";
		try{
			jQuery(editorBody.body).css({"font-size":config.editorFontSize});
			jQuery(editorBody.body).css({"font-family":config.editorFontFamily});
		}catch(e){
		}
	    
	    this.bindFocusFrame();
	    if(this.config.onReady) this.config.onReady();
	},
	focusFrame: function(){
		/* close all menu*/
		this.closeColorPicker();
		this.closeffPicker();
		this.closefsPicker();
		this.closelhPicker();
		
		this.closeicPicker();
	},
	unbindFocusFrame: function(){
		var editorBody = this.myEDT.document;
		if(AXUtil.browser.name == "mozilla") jQuery(editorBody).unbind("focus", this.focusFrame.bind(this));
	    else	jQuery(editorBody.body).unbind("focus", this.focusFrame.bind(this));
	},
	bindFocusFrame: function(){
		var editorBody = this.myEDT.document;
		if(AXUtil.browser.name == "mozilla") jQuery(editorBody).bind("focus", this.focusFrame.bind(this));
	    else	jQuery(editorBody.body).bind("focus", this.focusFrame.bind(this));
	},
	onselectStart: function(event){
    	event.stopPropagation();
    	return false;
	},
	/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
	__command: function(sCommand, bUserInterface, vValue){
		var myEDT = this.myEDT.document;
		myEDT.execCommand(sCommand, bUserInterface, vValue);
	},
	__pasteHTML: function(sHTML){
		var myEDT = this.myEDT.document;
		var oTmpDiv = myEDT.createElement("DIV");
		var oTmpP = myEDT.createElement("P");
		oTmpDiv.appendChild(oTmpP);
		if(typeof(sHTML) == "string") oTmpDiv.innerHTML = sHTML;
		else  oTmpP.appendChild(sHTML);
		
		if(this.contentMode == "editor"){
			var myRange = new SSelection(this.myEDT);
			var rng = myRange.getRangeAt(0);
			rng.insertNode(oTmpDiv.lastChild);
		}else{
			jQuery("#"+this.config.targetID+"_html").val(jQuery("#"+this.config.targetID+"_html").val()+oTmpDiv.innerHTML);
		}
	},
	/* click event */
	onHeadClick: function(event){
		if(typeof(event) == "object"){
			var myID = event.target.id;
			if(!myID) return;
			var ids = myID.split(/_/g);
			var headNM = ids[1];
			var headCMD = ids[2];
		}else{
			var headNM = event;
			var headCMD = "";
		}
		if(headNM == "home"){
			this.closePanel();
			this.panelNum = 0;
			this.openPanel();
		}else if(headNM == "attch"){
			if(this.panelNum == 1) return;
			this.closePanel();
			this.panelNum = 1;
			this.openPanel();
		}else if(headNM == "external"){
			if(this.panelNum == 5) return;
			this.closePanel();
			this.panelNum = 5;
			this.openPanel();
		}
	},
	onAttchPanelOpen: function(arg){
		if(this.panelNum == 1){
			if(arg)	this.setAttchItem(arg);
			return;
		}
		this.closePanel();
		this.panelNum = 1;
		this.openPanel();
		if(arg)	this.setAttchItem(arg);
	},
	onSimpleCommandClick: function(event){
		var myID = event.target.id;
		if(!myID) return;
		var command = this._GPT(myID);
		this.__command(command);
	},
	onColorCommandClick: function(event){
		var config = this.config;
		var re = config.targetID;
		var myEDT = this.myEDT.document;
		var myID = event.target.id;
		if(!myID) return;
		var myCommand = this._GPT(myID);
		var myColor = jQuery("#"+myID+"Val").css("background-color").toColor();
		this.__command(myCommand, false, myColor);

		var myRange = new SSelection(this.myEDT);
		var rng = myRange.getRangeAt(0);
		var nodes = rng.getNodes();
		if(nodes.length){
			for(var a=0;a<nodes.length;a++){
				var myNode = nodes[a];
				var pnode = DOMfix.DF_parentNode(myNode);
				try{
					while(pnode.tagName != "FONT" && pnode.tagName != "SPAN"){
						pnode = DOMfix.DF_parentNode(pnode);
					}
					if(myCommand == "foreColor"){
						pnode.style.color = myColor;
						pnode.removeAttribute("color");
					}else{
						pnode.style.backgroundColor = myColor;
						pnode.removeAttribute("bgcolor");
					}
				}catch(e){}
			}
		}else{
			if(myCommand == "foreColor") myEDT.body.style.color = myColor;
			else myEDT.body.style.backgroundColor = myColor;
		}

	},
	onInsertCommand: function(event){
		var myID = event.target.id;
		if(!myID) return;
		var command = this._GPT(myID);
		if(command == "pageBreak"){
			this.__pasteHTML("<hr style='page-break-before:always;border:1px dashed #444;' />");
		}
	},
	onSelectCommandClick: function(event){
		var myEDT = this.myEDT.document;
		var myID = event.target.id;
		if(!myID) return;
		var command = this._GPT(myID);
		/*alert("select Command : " + command);*/
		if(command == "foreColorExt" || command == "backColorExt") this.openColorPicker(command);
		if(command == "fontname") this.fontFamilyPicker(command);
		if(command == "fontsize") this.fontSizePicker(command);
		if(command == "lineHeight") this.lineHeightPicker(command);
		if(command == "url") this.urlPicker(command);
		if(command == "imoticon") this.icoPicker(command);
	},
	onAttbtnsClick: function(event){
		var config = this.config;
		var re = config.targetID;
		var lg = AXEditorLang[config.lang];
		var myID = event.target.id;
		if(!myID) return;
		var cmd = myID.split(/_/g).last();
		if(cmd == "selectAll"){
			jQuery.each(this.attchFiles, function(idx, f){
				f.checked = true;
				jQuery("#"+re+"_attchItem_"+idx).addClass("attchItemON");
			});
		}
		if(cmd == "delete"){
			var delFiles = [];
			jQuery.each(this.attchFiles, function(idx, f){
				if(f.checked){
					delFiles.push("file="+f.nm+"&path="+f.path)	
				}
			});
			if(delFiles.length == 0){
				alert(lg.noSelectedFileMsg);
				return;
			}
			if(!confirm(lg.fileDeleteConfirm)) return;
			var url = config.deleteUrl;
			var pars = config.deletePars.join("&");
			if(pars != "") pars += "&";
			pars += delFiles.join("&")+"&dummy="+AXUtil.timekey();
			/*new AXreq(url, {pars:pars, onsucc:this.onFileDelete.bind(this)});*/
		}
		if(cmd == "insertDoc"){
			var insertFiles = jQuery.map(this.attchFiles, function(f){
				if(f.checked) return f;
			});
			if(insertFiles.length == 0){
				alert(lg.noSelectedFileMsg);
				return;
			}
			
			try{
			this.myEDT.document.body.focus();
			}catch(e){}
				
			for(var si = 0;si<insertFiles.length;si++){
				var fo = insertFiles[si];
				var ty = fo.ty.dec().toLowerCase();
				if(ty == ".gif" | ty == ".jpg" | ty == ".png" | ty == ".bmp"){
					var imgObj = new Image();
					imgObj.src = fo.path.dec()+fo.nm.dec();
					imgObj.id = "MF_"+fo.nm.replace(fo.ty, "").dec();
					
					var pasteHTML = this.__pasteHTML.bind(this);
					var canvasWidth = this.canvas.width() - 40;
					imgObj.onload = function(){
						var ow = imgObj.width;
						var oh = imgObj.height;
						if(imgObj.width > canvasWidth){
							imgObj.width = canvasWidth;
							imgObj.height = oh * (imgObj.width / ow);
						}
						try{
							pasteHTML(imgObj);
						}catch(e){
							alert(e.print());	
						}
					}
					
				}else{
					this.__pasteHTML("<a href='"+fo.path.dec()+fo.nm.dec()+"' id='MF_"+fo.nm.replace(fo.ty, "").dec()+"' target='_blank'>"+fo.ti.dec()+"</a>");
				}
			}
			/*img resize*/
		}
	},
	onFeilDeleteInFrame: function(rid){
		var editorBody = this.myEDT.document;
		if(AXUtil.browser.name == "mozilla"){
			jQuery(editorBody).find(rid).remove();
		}else{
			jQuery(editorBody.body).find(rid).remove();
		}
	},
	onFileDelete: function(res){
		if(res.result == "ok"){
			var config = this.config;
			var re = config.targetID;
			
			var removeInFrame = this.onFeilDeleteInFrame.bind(this);
			this.attchFiles = jQuery.map(this.attchFiles, function(f, i){
				jQuery("#"+re+"_attchItem_"+i).remove();
				if(f.checked){
					removeInFrame("#MF_"+f.nm.replace(f.ty, "").dec());
				}else{
					return f;
				}
			});
		
			this.updateFileStatus();
						
			if(this.attchFiles.length == 0) return;
			jQuery.each(this.attchFiles, function(si, fo){
				var po = [];
				po.push("<div class='attchItem' id='"+re+"_attchItem_"+si+"' title='"+fo.ti.dec()+"'>");
				po.push("<div class='attchItemName'>"+fo.ti.dec()+"</div>");
				po.push("<div class='attchItemPreview'>");
				var ty = fo.ty.dec().toLowerCase();
				if(ty == ".gif" | ty == ".jpg" | ty == ".png" | ty == ".bmp")
				po.push("<img src='"+fo.path.dec()+fo.nm.dec()+"' width='100%' height='100%' alt='' />")
				po.push("</div>");
				po.push("</div>");
				jQuery("#"+re+"_divPanel_attchItemEnd").before(po.join(''));
			});
			
			jQuery("#"+re+"_divPanel_attch").find(".attchItem").bind("click", this.onAttchItemClick.bind(this));
			
		}else{
			alert(res.msg.dec());	
		}
	},
	onAttchItemClick: function(event){
		var config = this.config;
		var re = config.targetID;
		var myID = event.target.id;
		if(!myID){
			try{
				myID = jQuery(event.target).parents(".attchItem")[0].id;
			}catch(e){
			}
			if(!myID) return;
		};
		var fidx = myID.split(/_/g).last().number();
		this.attchFiles[fidx].checked = (!this.attchFiles[fidx].checked);
		if(this.attchFiles[fidx].checked){
			jQuery("#"+re+"_attchItem_"+fidx).addClass("attchItemON");
		}else{
			jQuery("#"+re+"_attchItem_"+fidx).removeClass("attchItemON");
		}
	},
	onClickComponent: function(event){
		var myID = event.target.id;
		if(!myID){
			try{
				myID = jQuery(event.target).parents(".componentItem")[0].id;
			}catch(e){
			}
			if(!myID) return;
		};
		if(this.config.onTabExternals) this.config.onTabExternals(myID);
	},
	/* ~~ colorPicker ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
	openColorPicker: function(command){
		if(this.colorPicker) this.colorPicker.remove();
		var config = this.config;
		var re = config.targetID;
		var lg = AXEditorLang[config.lang];
		var po = [];
		po.push("<div class='me___selecterBox me_picker' id='"+this._GID([re, command, "picker"])+"'>");
		po.push("	<div class='me___selecterArrow me_picker'></div>");
		if(command == "foreColorExt") po.push("	<div class='me___selecterTitle me_picker'>"+lg.textColor+"</div>");
		if(command == "backColorExt") po.push("	<div class='me___selecterTitle me_picker'>"+lg.textBgColor+"</div>");
		jQuery.each(config.colors, function(index, n){
			po.push("<a href='#AXExex' class='colorItem me_picker' style='background:#"+n+"'>"+n+"</a>");
		});
		po.push("</div>");
		this.colorPicker = jQuery(po.join(''));
		var myHeight = (config.colors.length / 7).ceil() * 21 + 28;
		if(command == "foreColorExt") this.colorPicker.css({width:150, height:myHeight, left:249, top:25});
		if(command == "backColorExt") this.colorPicker.css({width:150, height:myHeight, left:287, top:25});
		jQuery("#"+re+"_headPanel").append(this.colorPicker);

		/*other click observer init*/
		this.clickToClose = this.closeColorPicker.bind(this);
    	jQuery(document).bind("click", this.clickToClose);
    	this.keyDownToClose = this.closeColorPickerKey.bind(this);
    	jQuery(document).bind("keydown", this.keyDownToClose);
    	/*color select*/
    	this.colorPicker.find(".colorItem").bind("click", this.clickColor.bind(this, command));
	},
	closeColorPicker: function(event){
		if(event){
			if(!jQuery(event.target).hasClass("me_picker")){
				if(this.clickToClose) jQuery(document).unbind('click', this.clickToClose);
				if(this.keyDownToClose) jQuery(document).unbind('keydown', this.keyDownToClose);
				if(this.colorPicker) this.colorPicker.remove();
			}
		}else{
			if(this.clickToClose) jQuery(document).unbind('click', this.clickToClose);
			if(this.keyDownToClose) jQuery(document).unbind('keydown', this.keyDownToClose);
			if(this.colorPicker) this.colorPicker.remove();
		}
	},
	closeColorPickerKey: function(){
		if(event.keyCode == AXUtil.Event.KEY_ESC){
			if(this.clickToClose) jQuery(document).unbind('click', this.clickToClose);
			if(this.keyDownToClose) jQuery(document).unbind('keydown', this.keyDownToClose);
			if(this.colorPicker) this.colorPicker.remove();
		}
	},
	clickColor: function(command, event){
		var config = this.config;
		var re = config.targetID;
		var myEDT = this.myEDT.document;

		var myColor = jQuery(event.target).css("background-color").toColor();
		var myCommand = command.replace("Ext", "");
		this.__command(myCommand, false, myColor);

		var myRange = new SSelection(this.myEDT);
		var rng = myRange.getRangeAt(0);
		var nodes = rng.getNodes();
		if(nodes.length){
			for(var a=0;a<nodes.length;a++){
				var myNode = nodes[a];
				var pnode = DOMfix.DF_parentNode(myNode);
				try{
					while(pnode.tagName != "FONT" && pnode.tagName != "SPAN"){
						pnode = DOMfix.DF_parentNode(pnode);
					}
					if(myCommand == "foreColor"){
						pnode.style.color = myColor;
						pnode.removeAttribute("color");
					}else{
						pnode.style.backgroundColor = myColor;
						pnode.removeAttribute("bgcolor");
					}
				}catch(e){}
			}
		}else{
			if(myCommand == "foreColor") myEDT.body.style.color = myColor;
			else myEDT.body.style.backgroundColor = myColor;
		}


		jQuery("#"+this._GID([re, myCommand+"Val"])).css({background:"#"+myColor});
		this.closeColorPicker();
	},
	/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
	/* ~~ font family ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
	fontFamilyPicker: function(command){
		if(this.ffPicker) this.ffPicker.remove();
		var config = this.config;
		var re = config.targetID;
		var lg = AXEditorLang[config.lang];
		var po = [];
		po.push("<div class='me___selecterBox me_ffs' id='"+this._GID([re, command, "picker"])+"'>");
		po.push("	<div class='me___selecterArrow me_ffs'></div>");
		po.push("	<div class='me___selecterTitle me_ffs'>"+lg.fontFamily+"</div>");
		jQuery.each(config.fonts, function(index, n){
			po.push("<a href='#AXExex' class='ffItem me_ffs' style='font-family:"+n+"'>"+lg.fontSample+"("+n+")</a>");
		});
		po.push("</div>");
		this.ffPicker = jQuery(po.join(''));
		var myHeight = config.fonts.length * 25 + 30;
		this.ffPicker.css({width:150, height:myHeight, left:3, top:25});
		jQuery("#"+re+"_headPanel").append(this.ffPicker);

		/*other click observer init*/
		this.clickToCloseFF = this.closeffPicker.bind(this);
    	jQuery(document).bind("click", this.clickToCloseFF);
    	this.keyDownToCloseFF = this.closeffPickerKey.bind(this);
    	jQuery(document).bind("keydown", this.keyDownToCloseFF);
    	/*color select*/
    	this.ffPicker.find(".ffItem").bind("click", this.clickff.bind(this, command));
	},
	closeffPicker: function(event){
		if(event){
			if(!jQuery(event.target).hasClass("me_ffs")){
				if(this.clickToCloseFF) jQuery(document).unbind('click', this.clickToCloseFF);
				if(this.keyDownToCloseFF) jQuery(document).unbind('keydown', this.keyDownToCloseFF);
				if(this.ffPicker) this.ffPicker.remove();
			}
		}else{
			if(this.clickToCloseFF) jQuery(document).unbind('click', this.clickToCloseFF);
			if(this.keyDownToCloseFF) jQuery(document).unbind('keydown', this.keyDownToCloseFF);
			if(this.ffPicker) this.ffPicker.remove();
		}
	},
	closeffPickerKey: function(){
		if(event.keyCode == AXUtil.Event.KEY_ESC){
			if(this.clickToCloseFF) jQuery(document).unbind('click', this.clickToCloseFF);
			if(this.keyDownToCloseFF) jQuery(document).unbind('keydown', this.keyDownToCloseFF);
			if(this.ffPicker) this.ffPicker.remove();
		}
	},
	clickff: function(command, event){
		var config = this.config;
		var re = config.targetID;
		var myEDT = this.myEDT.document;
		var myfont = jQuery(event.target).css("font-family");

		this.__command(command, false, myfont);

		var myRange = new SSelection(this.myEDT);
		var rng = myRange.getRangeAt(0);
		var nodes = rng.getTextNodes();
		if(nodes.length){
			for(var a=0;a<nodes.length;a++){
				var myNode = nodes[a];
				var pnode = DOMfix.DF_parentNode(myNode);
				try{
					while(pnode.tagName != "FONT" && pnode.tagName != "SPAN"){
						pnode = DOMfix.DF_parentNode(pnode);
					}
					pnode.style.fontFamily = myfont;
					pnode.removeAttribute("face");
				}catch(e){}
			}
		}else{
			myEDT.body.style.fontFamily = myfont;
		}
		/*일단 현재 선택된 노드에 대한 합의의 형태로 일단락 추후 추가 개발토록 하자.*/

		jQuery("#"+this._GID([re, "fontname"])).html(myfont);
		jQuery("#"+this._GID([re, "fontname"])).css({"font-family":myfont});

		this.closeffPicker();
	},
	/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
	/* ~~ font size ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
	fontSizePicker: function(command){
		if(this.fsPicker) this.fsPicker.remove();
		var config = this.config;
		var re = config.targetID;
		var lg = AXEditorLang[config.lang];
		var po = [];
		po.push("<div class='me___selecterBox me_fss' id='"+this._GID([re, command, "picker"])+"'>");
		po.push("	<div class='me___selecterArrow me_fss'></div>");
		po.push("	<div class='me___selecterTitle me_fss'>"+lg.fontSize+"</div>");
		jQuery.each(config.fontsizes, function(index, n){
			po.push("<a href='#AXExex' class='ffItem me_fss' style='font-size:"+n+"px'>"+lg.fontSample+"("+n+"px)</a>");
		});
		po.push("</div>");
		this.fsPicker = jQuery(po.join(''));
		var myHeight = config.fontsizes.length * 25 + 30;
		this.fsPicker.css({width:150, height:myHeight, left:95, top:25});
		jQuery("#"+re+"_headPanel").append(this.fsPicker);

		/*other click observer init*/
		this.clickToCloseFS = this.closefsPicker.bind(this);
    	jQuery(document).bind("click", this.clickToCloseFS);
    	this.keyDownToCloseFS = this.closefsPickerKey.bind(this);
    	jQuery(document).bind("keydown", this.keyDownToCloseFS);
    	/*color select*/
    	this.fsPicker.find(".ffItem").bind("click", this.clickfs.bind(this, command));
	},
	closefsPicker: function(event){
		if(event){
			if(!jQuery(event.target).hasClass("me_fss")){
				if(this.clickToCloseFS) jQuery(document).unbind('click', this.clickToCloseFS);
				if(this.keyDownToCloseFS) jQuery(document).unbind('keydown', this.keyDownToCloseFS);
				if(this.fsPicker) this.fsPicker.remove();
			}
		}else{
			if(this.clickToCloseFS) jQuery(document).unbind('click', this.clickToCloseFS);
			if(this.keyDownToCloseFS) jQuery(document).unbind('keydown', this.keyDownToCloseFS);
			if(this.fsPicker) this.fsPicker.remove();
		}
	},
	closefsPickerKey: function(){
		if(event.keyCode == AXUtil.Event.KEY_ESC){
			if(this.clickToCloseFS) jQuery(document).unbind('click', this.clickToCloseFS);
			if(this.keyDownToCloseFS) jQuery(document).unbind('keydown', this.keyDownToCloseFS);
			if(this.fsPicker) this.fsPicker.remove();
		}
	},
	clickfs: function(command, event){
		var config = this.config;
		var re = config.targetID;
		var myEDT = this.myEDT.document;
		var mysize = jQuery(event.target).css("font-size");
		this.__command(command, false, 1);
		var myRange = new SSelection(this.myEDT);
		var rng = myRange.getRangeAt(0);
		var nodes = rng.getTextNodes();
		if(nodes.length){
			for(var a=0;a<nodes.length;a++){
				var myNode = nodes[a];
				var pnode = DOMfix.DF_parentNode(myNode);
				try{
					while(pnode.tagName != "FONT" && pnode.tagName != "SPAN"){
						pnode = DOMfix.DF_parentNode(pnode);
					}
					pnode.style.fontSize = mysize;
					pnode.removeAttribute("size");
				}catch(e){}
			}
		}else{
			myEDT.body.style.fontSize = mysize;
		}
		/*일단 현재 선택된 노드에 대한 합의의 형태로 일단락 추후 추가 개발토록 하자.*/
		jQuery("#"+this._GID([re, "fontsize"])).html(mysize);
		this.closefsPicker();
	},
	/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
	/* ~~ lineheight ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
	lineHeightPicker: function(command){
		if(this.lhPicker) this.lhPicker.remove();
		var config = this.config;
		var re = config.targetID;
		var lg = AXEditorLang[config.lang];
		var po = [];
		po.push("<div class='me___selecterBox me_lhs' id='"+this._GID([re, command, "picker"])+"'>");
		po.push("	<div class='me___selecterArrow me_lhs'></div>");
		po.push("	<div class='me___selecterTitle me_lhs'>"+lg.lineHeight+"</div>");
		jQuery.each(config.lineHeights, function(index, n){
			po.push("<a href='#AXExex' class='ffItem me_lhs' style='text-align:center;'>"+n+"</a>");
		});
		po.push("</div>");
		this.lhPicker = jQuery(po.join(''));
		var myHeight = config.lineHeights.length * 25 + 30;
		this.lhPicker.css({width:100, height:myHeight, left:491, top:25});
		jQuery("#"+re+"_headPanel").append(this.lhPicker);

		/*other click observer init*/
		this.clickToCloseLH = this.closelhPicker.bind(this);
    	jQuery(document).bind("click", this.clickToCloseLH);
    	this.keyDownToCloseLH = this.closelhPickerKey.bind(this);
    	jQuery(document).bind("keydown", this.keyDownToCloseLH);
    	/*color select*/
    	this.lhPicker.find(".ffItem").bind("click", this.clicklh.bind(this, command));
	},
	closelhPicker: function(event){
		if(event){
			if(!jQuery(event.target).hasClass("me_lhs")){
				if(this.clickToCloseLH) jQuery(document).unbind('click', this.clickToCloseLH);
				if(this.keyDownToCloseLH) jQuery(document).unbind('keydown', this.keyDownToCloseLH);
				if(this.lhPicker) this.lhPicker.remove();
			}
		}else{
			if(this.clickToCloseLH) jQuery(document).unbind('click', this.clickToCloseLH);
			if(this.keyDownToCloseLH) jQuery(document).unbind('keydown', this.keyDownToCloseLH);
			if(this.lhPicker) this.lhPicker.remove();
		}
	},
	closelhPickerKey: function(){
		if(event.keyCode == AXUtil.Event.KEY_ESC){
			if(this.clickToCloseLH) jQuery(document).unbind('click', this.clickToCloseLH);
			if(this.keyDownToCloseLH) jQuery(document).unbind('keydown', this.keyDownToCloseLH);
			if(this.lhPicker) this.lhPicker.remove();
		}
	},
	clicklh: function(command, event){
		var config = this.config;
		var re = config.targetID;
		var myEDT = this.myEDT.document;
		var mylh = jQuery(event.target).text();
		var myRange = new SSelection(this.myEDT);
		var rng = myRange.getRangeAt(0);
		var nodes = rng.getTextNodes();
		if(nodes.length){
			for(var a=0;a<nodes.length;a++){
				var myNode = nodes[a];
				var pnode = DOMfix.DF_parentNode(myNode);
				if(pnode.tagName == "BODY"){
					pnode.style.lineHeight = mylh+"em";
				}else{
					while(pnode.tagName != "P" && pnode.tagName != "DIV"){
						pnode = DOMfix.DF_parentNode(pnode);
					}
					pnode.style.lineHeight = mylh+"em";
				}
			}
		}else{
			myEDT.body.style.lineHeight = mylh+"em";
		}
		/*jQuery("#"+this._GID([re, "lineHeight"])).html(mylh);*/
		this.closelhPicker();
	},
	/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
	/* ~~ url ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
	urlPicker: function(command){
		/*this.unbindFocusFrame();*/

		if(this.ulPicker) this.ulPicker.remove();
		var config = this.config;
		var re = config.targetID;
		var lg = AXEditorLang[config.lang];
		var inpID = this._GID([re, command, "input"]);
		var target_blank = this._GID([re, command, "target_blank"]);
		var target_self = this._GID([re, command, "target_self"]);

		var po = [];
		po.push("<div class='me___selecterBox me_url' id='"+this._GID([re, command, "picker"])+"'>");
		po.push("	<div class='me___selecterArrow me_url' style='left:240px;'></div>");
		po.push("	<div class='me___selecterTitle me_url'>"+lg.url+"</div>");
		po.push("	<div class='me___inputUrl me_url'><input type='text' id='"+inpID+"' class='me_url' style='width:280px;'></div>");
		po.push("	<div class='me___inputBtn me_url'>");
		po.push("	<input type='radio' name='"+this._GID([re, command, "target"])+"' id='"+target_blank+"' class='me_url' value='_blank' checked='checked'> _blank");
		po.push("	<input type='radio' name='"+this._GID([re, command, "target"])+"' id='"+target_self+"' class='me_url' value='_self'> _self");
		po.push("	<input type='button' value='OK' class='AXButtonSmall me_url me___inputBtnOK' />");
		po.push("	</div>");
		po.push("</div>");
		this.ulPicker = jQuery(po.join(''));
		var myHeight = 90;
		this.ulPicker.css({width:300, height:myHeight, left:324, top:25});
		jQuery("#"+re+"_headPanel").append(this.ulPicker);

		/* url find */
		this.myRange = new SSelection(this.myEDT);
		this.oSelection = this.myRange.getRangeAt(0);
		var oNode = this.oSelection.commonAncestorContainer;
		while(oNode && oNode.tagName != "A") oNode = DOMfix.DF_parentNode(oNode);
		if(oNode){
			var sTarget = oNode.target;
			if(sTarget && sTarget == "_blank") jQuery("#"+target_blank)[0].checked = true;
			jQuery("#"+inpID).val( oNode.href?oNode.href:"http://" );
		}else{
			jQuery("#"+inpID).val("http://");
		}
		jQuery("#"+inpID).select();

		/*other click observer init*/
		this.clickToCloseUL = this.closeulPicker.bind(this);
    	jQuery(document).bind("click", this.clickToCloseUL);
    	this.keyDownToCloseUL = this.closeulPickerKey.bind(this);
    	jQuery(document).bind("keydown", this.keyDownToCloseUL);
    	/*color select*/
    	this.ulPicker.find(".me___inputBtnOK").bind("click", this.clickul.bind(this, command));
    	/*this.bindFocusFrame();*/
	},
	closeulPicker: function(event){
		if(event){
			if(!jQuery(event.target).hasClass("me_url")){
				if(this.clickToCloseUL) jQuery(document).unbind('click', this.clickToCloseUL);
				if(this.keyDownToCloseUL) jQuery(document).unbind('keydown', this.keyDownToCloseUL);
				if(this.ulPicker) this.ulPicker.remove();
			}
		}else{
			if(this.clickToCloseUL) jQuery(document).unbind('click', this.clickToCloseUL);
			if(this.keyDownToCloseUL) jQuery(document).unbind('keydown', this.keyDownToCloseUL);
			if(this.ulPicker) this.ulPicker.remove();
		}
	},
	closeulPickerKey: function(){
		if(event.keyCode == AXUtil.Event.KEY_ESC){
			if(this.clickToCloseUL) jQuery(document).unbind('click', this.clickToCloseUL);
			if(this.keyDownToCloseUL) jQuery(document).unbind('keydown', this.keyDownToCloseUL);
			if(this.ulPicker) this.ulPicker.remove();
		}
	},
	clickul: function(command, event){
		var config = this.config;
		var re = config.targetID;
		var myEDT = this.myEDT.document;
		var lg = AXEditorLang[config.lang];
		var inpID = this._GID([re, command, "input"]);
		var target_blank = this._GID([re, command, "target_blank"]);
		var target_self = this._GID([re, command, "target_self"]);

		var sURL = jQuery("#"+inpID).val();
		this.myRange.selectRange(this.oSelection);

		if(this._validateURL(sURL)){
			var sTarget = (jQuery("#"+target_blank)[0].checked) ? "_blank" : "_self";
				if(this.oSelection.collapsed){
					this.__pasteHTML("<a href='"+sURL+"' target='"+sTarget+"'>"+sURL+"</a>");
				}else{
					this.__command("CreateLink", false, sURL);
					this.myRange = new SSelection(this.myEDT);
					this.oSelection = this.myRange.getRangeAt(0);
					var oNode = this.oSelection.commonAncestorContainer;
					while(oNode && oNode.tagName != "A") oNode = DOMfix.DF_parentNode(oNode);
					if(oNode) oNode.target = sTarget;
				}
		}else{
			alert(lg.invalidUrlMsg);
		}
		this.closeulPicker();
	},
	_validateURL : function(sURL){
		return /^(http|https|ftp|mailto):(?:\/\/)?((\w|-)+(?:[\.:@](\w|-))+)(?:\/|@)?([^"\?]*?)(?:\?([^\?"]*?))?$/.test(sURL);
	},
	/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
	/* ~~ imoticon ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
	icoPicker: function(command){
		if(this.icPicker) this.icPicker.remove();
		var config = this.config;
		var re = config.targetID;
		var lg = AXEditorLang[config.lang];
		if(this.icoCategoryIndex == undefined) this.icoCategoryIndex = 0;
		var icoCategoryIndex = this.icoCategoryIndex;
		var po = [];
		po.push("<div class='me___selecterBox me_ico' id='"+this._GID([re, command, "picker"])+"'>");
		po.push("	<div class='me___selecterArrow me_ico' style='left:372px;'></div>");
		po.push("	<div class='me___selecterTitleTab me_ico'>");
		po.push("		<div class='me___selecterTitleTabTray me_ico'>");
		jQuery.each(config.AXEditorIcons, function(idx, ca){
			if(icoCategoryIndex == idx)
		po.push("<a href='#AXExec' class='categoryItem me_ico on' id='"+re+"_icoCategory_"+idx+"'>"+ca.categoryNM+"</a>");
			else
		po.push("<a href='#AXExec' class='categoryItem me_ico' id='"+re+"_icoCategory_"+idx+"'>"+ca.categoryNM+"</a>");
		});
		po.push("		</div>");
		po.push("	</div>");
		po.push("	<div class='me___selecterTray me_ico' style='height:120px;' id='"+re+"_icoTray'>");
		var icoFolder = config.AXEditorIcons[icoCategoryIndex].imageFolder;
		jQuery.each(config.AXEditorIcons[icoCategoryIndex].icons, function(index, n){
			po.push("<a href='#AXExex' class='icoItem me_ico'><img src='"+icoFolder+n+"' align='middle' alt='' /></a>");
		});
		po.push("	</div>");
		po.push("	<div class='me___selecterBot me_ico' id='"+re+"_icoBot'>");
		po.push("	"+config.AXEditorIcons[icoCategoryIndex].copyRights);
		po.push("	</div>");
		po.push("</div>");
		this.icPicker = jQuery(po.join(''));

		var myWidth = 396;
		var myHeight = 180;
		this.icPicker.css({width:myWidth, height:myHeight, left:214, top:25});
		jQuery("#"+re+"_headPanel").append(this.icPicker);

		
		/*other click observer init*/
		this.clickToCloseIC = this.closeicPicker.bind(this);
    	jQuery(document).bind("click", this.clickToCloseIC);
    	this.keyDownToCloseIC = this.closeicPickerKey.bind(this);
    	jQuery(document).bind("keydown", this.keyDownToCloseIC);
    	
    	/*select*/
    	this.icPicker.find(".icoItem img").bind("click", this.clickic.bind(this, command));
    	this.icPicker.find(".me___selecterTitleTabTray .categoryItem").bind("click", this.changeCategory.bind(this));
	},
	closeicPicker: function(event){
		if(event){
			if(!jQuery(event.target).hasClass("me_ico")){
				if(this.clickToCloseIC) jQuery(document).unbind('click', this.clickToCloseIC);
				if(this.keyDownToCloseIC) jQuery(document).unbind('keydown', this.keyDownToCloseIC);
				if(this.icPicker) this.icPicker.remove();
			}
		}else{
			if(this.clickToCloseIC) jQuery(document).unbind('click', this.clickToCloseIC);
			if(this.keyDownToCloseIC) jQuery(document).unbind('keydown', this.keyDownToCloseIC);
			if(this.icPicker) this.icPicker.remove();
		}
	},
	closeicPickerKey: function(){
		if(event.keyCode == AXUtil.Event.KEY_ESC){
			if(this.clickToCloseIC) jQuery(document).unbind('click', this.clickToCloseIC);
			if(this.keyDownToCloseIC) jQuery(document).unbind('keydown', this.keyDownToCloseIC);
			if(this.icPicker) this.icPicker.remove();
		}
	},
	clickic: function(command, event){
		var config = this.config;
		var re = config.targetID;
		var myEDT = this.myEDT.document;
		var sHTML = "<img src='"+event.target.src+"' align='middle' alt='' style='vertical-align:middle;' />"
		var oTmpDiv = myEDT.createElement("DIV");
		oTmpDiv.innerHTML = sHTML;
		var myRange = new SSelection(this.myEDT);
		var rng = myRange.getRangeAt(0);
		rng.insertNode(oTmpDiv.lastChild);
		this.closeicPicker();
	},
	changeCategory: function(event){
		var config = this.config;
		var re = config.targetID;
		var idx = event.target.id.split("_").last();
		if(this.icoCategoryIndex != undefined){
			jQuery("#"+re+"_icoCategory_"+this.icoCategoryIndex).removeClass("on");
		}
		this.icoCategoryIndex = idx;
		icoCategoryIndex = idx;
		jQuery("#"+re+"_icoCategory_"+idx).addClass("on");
		
		var po = [];
		var icoFolder = config.AXEditorIcons[icoCategoryIndex].imageFolder;
		jQuery.each(config.AXEditorIcons[icoCategoryIndex].icons, function(index, n){
			po.push("<a href='#AXExex' class='icoItem me_ico'><img src='"+icoFolder+n+"' align='middle' alt='' /></a>");
		});
		jQuery("#"+re+"_icoTray").html(po.join(''));
		this.icPicker.find(".icoItem img").bind("click", this.clickic.bind(this, "imoticon")); 
		jQuery("#"+re+"_icoBot").html(config.AXEditorIcons[icoCategoryIndex].copyRights);
	},
	/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
	onContentMode: function(event){
		var config = this.config;
		if(event.target.id == config.targetID+"_contentMode_0"){
			if(this.contentMode != "editor"){
				this.contentMode = "editor";
				jQuery("#"+config.targetID+"_contentMode_0").addClass("me____tabOn");
				jQuery("#"+config.targetID+"_contentMode_1").removeClass("me____tabOn");
				this.setHtmlMode("off");
			}
		}else{
			if(this.contentMode != "html"){
				this.contentMode = "html";
				jQuery("#"+config.targetID+"_contentMode_0").removeClass("me____tabOn");
				jQuery("#"+config.targetID+"_contentMode_1").addClass("me____tabOn");
				this.setHtmlMode("on");
			}
		}
		/*goto home*/
		/*this.onHeadClick("home");*/
	},
	/* ~~ get&set content ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
	__getContent: function(){
		var myEDT = this.myEDT.document;
		return myEDT.body.innerHTML;
	},
	getContentCheck: function(){
		var myEDT = this.myEDT.document;
		var editorContent = "";
		if(this.contentMode == "editor"){
			editorContent = myEDT.body.innerHTML;
		}else{
			editorContent = this.htmlArea.val();
		}
		
		if (editorContent.trim() != ""){
			return true;
		}else{
			return false;
		}
		
	},
/**
 * 에디터의 내용을 반환합니다.
 * @method AXEditor.getContent
 * @returns {String}
 * @example
 ```js
 var myContent = myEditor.getContent();
 var content = [];
 while(myContent.length > 0){
	content.push("content="+myContent.substr(0, 102399).enc());
	myContent = myContent.substr(102399);
 }
 alert(content);
 // post전송할 때 짤림현상 방지를 위해서는 content를 잘라서 보내야 합니다.
 ```
 */
	getContent: function(){
		var myEDT = this.myEDT.document;
		var ff = myEDT.body.style.fontFamily;
		var fs = myEDT.body.style.fontSize;
		var cl = myEDT.body.style.color;
		var bc = myEDT.body.style.backgroundColor;
		var lh = myEDT.body.style.lineHeight;

		if(lh == ""){
			lh = "1.5em";	
		}

		var sts = [];
		if(ff) sts.push("font-family:"+ff);
		if(fs) sts.push("font-size:"+fs);
		if(cl) sts.push("color:"+cl);
		if(bc) sts.push("background-color:"+bc);
		if(lh) sts.push("line-height:"+lh);

		if(this.contentMode == "editor"){
			return "<div class='AXEditorContentBody' style='"+sts.join(";")+";'>"+myEDT.body.innerHTML+"</div>";
		}else{
			return "<div class='AXEditorContentBody' style='"+sts.join(";")+";'>"+this.htmlArea.val()+"</div>";
		}
	},
/**
 * 에디터의 내용을 정의합니다.
 * @method AXEditor.setContent
 * @param {String|jQueryObject} content
 * @returns {AXEditor} name
 * @example
```js
 myEditor.setContent($("#editContent"));
 myEditor.setContent("액시스제이");
```
 */
	setContent: function(content){
		var myEDT = this.myEDT.document;
		if(typeof content == "string"){
			if(content == "") content = "<p></p>";
			myEDT.body.innerHTML = content;
		}else{
			var myBody = content.find(".AXEditorContentBody");
			if(myBody.html() == null){
				jQuery(myEDT.body).html(content.html());
			}else{
				content.children().each(function(){
					if(!jQuery(this).hasClass("AXEditorContentBody")){
						myBody.prepend(this);
					}
				});
				jQuery(myEDT.body).html(myBody.html());
				jQuery(myEDT.body).css({"font-family":myBody.css("fontFamily")});
				jQuery(myEDT.body).css({"font-size":myBody.css("fontSize")});
				jQuery(myEDT.body).css({"color":myBody.css("color")});
				jQuery(myEDT.body).css({"background-color":myBody.css("backgroundColor")});
				jQuery(myEDT.body).css({"line-height":myBody.css("lineHeight")});
			}
		}
		return this;
	},
	getFileList: function(){
		return this.attchFiles;
	},
	setFileList: function(files){
		this.attchFiles = files;
		this.updateFileStatus();
	},
	/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
	nothing: function(){}
});
/* ---------------------------- */
/* http://www.axisj.com, license : http://www.axisj.com/license */
 

var AXExcelConvert = Class.create(AXJ, {
    version: "AXExcelConvert V1",
	author: "tom@axisj.com",
	logs: [
		"2013-08-21 오후 11:47:11 - modsAX 변환"
	],
    initialize: function(AXJ_super) {
        AXJ_super();
        this.ds = [];
    },
    init: function() {
		
    },
	readyData: function(){
		this.ds = []; //엑셀 데이터 초기화
		var re = this.config.targetID;
		var po = [];
		po.push("<div id='"+re+"_CT'>");
		po.push("<div style='padding:5px;'>엑셀데이터 붙여넣기 <span>- 변환하실 엑셀 데이터를 선택하여 아래에 붙여넣기 해주세요.</span></div>");
		po.push("<textarea id='"+re+"_TEXT' style='width:"+this.config.ctWidth+"px;height:"+this.config.ctHeight+"px;' class='AXTextarea'></textarea>");
		po.push("<div style='padding:10px;' align='right'><input type='button' value='변환하기' class='AXButton' id='"+re+"_convert' /> <input type='button' value='창 닫기' class='AXButton' id='"+re+"_close' /></div>");
		po.push("</div>");
		
		jQuery("#"+re).html(po.join(''));
		setTimeout(function(){
			jQuery("#"+re+"_TEXT").focus();
		}, 500);
		
		jQuery("#"+re+"_convert").bind("click", this.onConvert.bind(this));
		jQuery("#"+re+"_close").bind("click", this.onClose.bind(this));
	},
	onConvert: function(){
		var re = this.config.targetID;
		var tStr = jQuery("#"+re+"_TEXT").val().trim();
		if(tStr == ""){
			alert("변환할 내용이 없습니다. 내용을 입력하세요.");
			return;	
		}

		var iePattern2 = /["]/gi;   //"문자제거
		var iePattern3 = / (?:\r\n|\r|\n)/g; //개행문자 바로 이전에 있는 공백 한개를 모두 제거
		var sStr  = tStr.replace(iePattern3, "").replace(iePattern2, "");
		var codeR = sStr.split(/\n/g);

		for(var a=0;a<codeR.length;a++){
			if(codeR[a].trim() != ""){
				codeR[a] = codeR[a].replace(/\t\t/gi, "\t \t");
				var codeC = codeR[a].trim().split(/[\t]/gi);
				this.ds.push(codeC);
			}
		}
		this.gridPrint();
	},
	onClose: function(){
		if(this.config.onClose){
			this.config.onClose();
		}
	},
	gridPrint: function(){
		var re = this.config.targetID;
		var colnames = this.config.colnames;
		
		function getCOPT(nm){
			var copt = [];
			copt.push("<select name='colNames' class='colNamesSelect'>");
			copt.push("	<option value=''></option>");
			jQuery.each(colnames, function(){
				if(nm == this.nm){
			copt.push("	<option value='"+this.nm+"' selected='selected'>"+this.val+"</option>");
				}else{
			copt.push("	<option value='"+this.nm+"'>"+this.val+"</option>");
				}
			});
			copt.push("</select>");
			return copt.join('');
		}
		
		var po = [];
		po.push("<div id='"+re+"_CT'>");
		po.push("<div style='padding:5px;'>엑셀데이터 확인</div>");
		po.push("<div style='width:"+this.config.ctWidth+"px;height:"+this.config.ctHeight+"px;overflow:auto;border:1px solid #ccc;'>");
		po.push("<form name='"+re+"_frm'>");
		po.push("	<table cellspacing='0' cellpadding='0'>");
		po.push("		<thead>");
		po.push("			<tr>");
		jQuery.each(colnames, function(){
		po.push("				<td>"+getCOPT(this.nm)+"</td>");
		});
		po.push("			</tr>");
		po.push("		</thead>");
		po.push("		<tbody>");
		jQuery.each(this.ds, function(idx, R){
		po.push("			<tr>");
			jQuery.each(colnames, function(icx, C){
		po.push("				<td class='nowrap' title='"+R[icx]+"'>"+R[icx]+"</td>");
			});
		po.push("			</tr>");
		});
		po.push("		</tbody>");
		po.push("	</table>");
		po.push("</form>");
		po.push("</div>");
		po.push("<div style='padding:10px;' align='right'><input type='button' value='변환완료' class='AXButton' id='"+re+"_convert' /> <input type='button' value='창 닫기' class='AXButton' id='"+re+"_close' /></div>");
		po.push("</div>");
		jQuery("#"+re).html(po.join(''));
		
		jQuery("#"+re+"_convert").bind("click", this.onInsert.bind(this));
		jQuery("#"+re+"_close").bind("click", this.onClose.bind(this));
		
		jQuery(".colNamesSelect").bind("change", this.onColNameSelect.bind(this));
	},
	onInsert: function(){
		var re = this.config.targetID;
		var frm = document[re+"_frm"];
		var cols = [];
		for(var a=0;a<frm.colNames.length;a++){
			cols.push(
				{
					nm:frm.colNames[a][frm.colNames[a].selectedIndex].value,
					val:frm.colNames[a][frm.colNames[a].selectedIndex].text
				}
			);
		}
		
		if(this.config.onConvert){
			this.config.onConvert({
				cols:cols,
				ds:this.ds
			});
		}
	},
	onColNameSelect: function(event){
		var selVal = event.target.value;
		jQuery(".colNamesSelect").each(function(){
			if(event.target != this)
				if(this.value == selVal) this.value = "";
		});
	}
});
/* ---------------------------- */
var AXSplit = Class.create(AXJ, {
	initialize: function(AXJ_super) {
		AXJ_super();

	},
	init: function() {
		var cfg = this.config;

		if(!cfg.onwindowresize) cfg.onwindowresize = cfg.onWindowResize;
		if(!cfg.onready) cfg.onready = cfg.onReady;
		if(!cfg.onsplitresize) cfg.onsplitresize = cfg.onSplitResize;
		if(!cfg.onsplitresizeend) cfg.onsplitresizeend = cfg.onSplitResizeEnd;

        $("html, body").css("overflow", "hidden"); // resize 이벤트 발생시 스크롤이 순간적으로 발생하는 현상을 막기위해 필수!


		this.target = axdom("#"+cfg.targetID);
		this.target.attr("ondragstart", "return false");

        if (typeof cfg.setTargetHeight === "function") {
            var targetHeight = cfg.setTargetHeight.call(this);
            this.target.height(targetHeight);
        }

		this.initChild(this.target);
		this.initEvent();
		axdom(window).resize(this.windowResize.bind(this));

		if(cfg.onready){
			cfg.onready.call({});
		}

        this.resizeInstances();
	},
	windowResize: function () {
		this.windowResizeApply();

		/*
		var windowResizeApply = this.windowResizeApply.bind(this);
		if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
		this.windowResizeObserver = setTimeout(function () {
			windowResizeApply();
		}, 1);
		*/
	},
	windowResizeApply: function(){
		var cfg = this.config;
		if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
		this.initChild(this.target);
		//axdom(window).resize();
		if(cfg.onwindowresize){
			cfg.onwindowresize.call({});
		}
	},
	initChild: function(parent){
		var cfg = this.config;
		var parentWidth = parent.innerWidth();
		var parentHeight = parent.innerHeight();

		var calcWidth = 0, calcHeight = 0, uncolCount = 0, unrowCount = 0, colindex = 1, rowindex = 1;
		var moreFindTarget = [];
        var getPixelValueBind = this.getPixelValue.bind(this);

        // data-width, data-height 속성이 선언된 element 길이 설정
		parent.children().each(function(){
			var dom_this = axdom(this);
			if(dom_this.hasClass("AXSplit-cols")){
				if(dom_this.attr("data-width")) {
                    var width = getPixelValueBind(dom_this.attr("data-width"), parentWidth);
					calcWidth += width;
                    dom_this.css("width", width);
				}else{
					uncolCount++;
				}
				if(!dom_this.attr("data-axsplit-colindex")) dom_this.attr("data-axsplit-colindex", colindex);
				colindex++;
			}else if(dom_this.hasClass("AXSplit-col-handle")){
				calcWidth += dom_this.width().number();
				if(!dom_this.attr("data-axsplit-colindex")) dom_this.attr("data-axsplit-colindex", colindex);
				colindex++;
			}else if(dom_this.hasClass("AXSplit-rows")){
				if(dom_this.attr("data-height")){
                    var height = getPixelValueBind(dom_this.attr("data-height"), parentHeight);
					calcHeight += height;
                    dom_this.css("height", height);
				}else{
					unrowCount++;
				}
				if(!dom_this.attr("data-axsplit-rowindex")) dom_this.attr("data-axsplit-rowindex", rowindex);
				rowindex++;
			}else if(dom_this.hasClass("AXSplit-row-handle")) {
				calcHeight += dom_this.height().number();
				if(!dom_this.attr("data-axsplit-rowindex")) dom_this.attr("data-axsplit-rowindex", rowindex);
				rowindex++;
			}
		});

        /**
         * min/max, width/height 설정
         * @param dom
         * @param type "width"|"height"
         */
        function setMinMaxLength(dom, type) {
            var min = dom.attr("data-min-" + type);
            var max = dom.attr("data-max-" + type);
            var parentLength = (type == "height" ? parentHeight : parentWidth);
            if(min) {
                var minValue = getPixelValueBind(min, parentLength);
                dom.css("min-" + type, minValue);
            }
            if (max) {
                var maxValue = getPixelValueBind(max, parentLength);
                dom.css("max-" + type, maxValue);
            }
        }

        // data-width, data-height 속성이 없는 element 길이 설정
        parent.children().each(function(){
			var dom_this = axdom(this);
			if(dom_this.hasClass("AXSplit-cols")){
				if(!dom_this.attr("data-width")){
					dom_this.css({width: (parentWidth - calcWidth) / uncolCount});
				}
                setMinMaxLength(dom_this, "width");
			}else if(dom_this.hasClass("AXSplit-rows")){
                if(!dom_this.attr("data-height")){
                    dom_this.css({height: (parentHeight - calcHeight) / unrowCount});
                }
                setMinMaxLength(dom_this, "height");
            }

			if( dom_this.find(".AXSplit-rows, .AXSplit-cols").length > 0 ){
				moreFindTarget.push(dom_this);
			}
		});

        // inner split을 처리하기 위한 재귀호출
		for(var i=0;i<moreFindTarget.length;i++){
			this.initChild(moreFindTarget[i]);
		}
    },
	initEvent: function(){
		var cfg = this.config, _this = this;
		this.target.find(".AXSplit-col-handle, .AXSplit-row-handle").bind("mousedown", function(event){
			_this.readyResize(axdom(this), event);
		});
	},
	readyResize: function(handleDom, event){
		var cfg = this.config, _this = this;
		this.resizeHandle_data = {
			parentDom: handleDom.parent(),
			dom: handleDom,
			isRowHandle: handleDom.hasClass("AXSplit-row-handle")
		};
		this.resizeHandle_data.dom.addClass("on");

		if(this.resizeHandle_data.isRowHandle){
			//rows
			this.resizeHandle_data.top = event.pageY;
			this.resizeHandle_data.hindex = this.resizeHandle_data.dom.attr("data-axsplit-rowindex").number();
			this.resizeHandle_data.pitem_dom = this.resizeHandle_data.parentDom.find(".AXSplit-rows[data-axsplit-rowindex="+ (this.resizeHandle_data.hindex-1) +"]");
			this.resizeHandle_data.nitem_dom = this.resizeHandle_data.parentDom.find(".AXSplit-rows[data-axsplit-rowindex="+ (this.resizeHandle_data.hindex+1) +"]");
			this.resizeHandle_data.pitem_dom_height = this.resizeHandle_data.pitem_dom.height().number();
			this.resizeHandle_data.pitem_dom_min_height = this.resizeHandle_data.pitem_dom.css("min-height").number();
			this.resizeHandle_data.pitem_dom_max_height = this.resizeHandle_data.pitem_dom.css("max-height").number();
			this.resizeHandle_data.nitem_dom_height = this.resizeHandle_data.nitem_dom.height().number();
			this.resizeHandle_data.nitem_dom_min_height = this.resizeHandle_data.nitem_dom.css("min-height").number();
			this.resizeHandle_data.nitem_dom_max_height = this.resizeHandle_data.nitem_dom.css("max-height").number();
		}else{
			//cols
			this.resizeHandle_data.left = event.pageX;
			this.resizeHandle_data.hindex = this.resizeHandle_data.dom.attr("data-axsplit-colindex").number();
			this.resizeHandle_data.pitem_dom = this.resizeHandle_data.parentDom.find(".AXSplit-cols[data-axsplit-colindex="+ (this.resizeHandle_data.hindex-1) +"]");
			this.resizeHandle_data.nitem_dom = this.resizeHandle_data.parentDom.find(".AXSplit-cols[data-axsplit-colindex="+ (this.resizeHandle_data.hindex+1) +"]");
			this.resizeHandle_data.pitem_dom_width = this.resizeHandle_data.pitem_dom.width().number();
			this.resizeHandle_data.pitem_dom_min_width = this.resizeHandle_data.pitem_dom.css("min-width").number();
			this.resizeHandle_data.pitem_dom_max_width = this.resizeHandle_data.pitem_dom.css("max-width").number();
			this.resizeHandle_data.nitem_dom_width = this.resizeHandle_data.nitem_dom.width().number();
			this.resizeHandle_data.nitem_dom_min_width = this.resizeHandle_data.nitem_dom.css("min-width").number();
			this.resizeHandle_data.nitem_dom_max_width = this.resizeHandle_data.nitem_dom.css("max-width").number();
		}

		axdom(document.body).bind("mousemove.axsplit", this.splitResize.bind(this));
		axdom(document.body).bind("mouseup.axsplit", this.splitResizeEnd.bind(this));
	},
	splitResize: function(event){
		var cfg = this.config, _this = this;
		var rdata = this.resizeHandle_data;

		if(rdata.isRowHandle){
			var dy = event.pageY - rdata.top;

			var pitem_dom_height = rdata.pitem_dom_height + dy;

            if (rdata.pitem_dom_min_height > 0 && rdata.pitem_dom_min_height > pitem_dom_height) { return; }
            if (rdata.pitem_dom_max_height > 0 && rdata.pitem_dom_max_height < pitem_dom_height) { return; }

			rdata.pitem_dom.css({height:pitem_dom_height});
			if(rdata.pitem_dom.attr("data-height")){
				rdata.pitem_dom.attr("data-height", pitem_dom_height);
			}

			var nitem_dom_height = rdata.nitem_dom_height - dy;

            if (rdata.nitem_dom_min_height > 0 && rdata.nitem_dom_min_height > nitem_dom_height) { return; }
            if (rdata.nitem_dom_max_height > 0 && rdata.nitem_dom_max_height < nitem_dom_height) { return; }

            rdata.nitem_dom.css({height:nitem_dom_height});
			if(rdata.nitem_dom.attr("data-height")){
				rdata.nitem_dom.attr("data-height", nitem_dom_height);
			}
		}else{
			var dx = event.pageX - rdata.left;

			var pitem_dom_width = rdata.pitem_dom_width + dx;

            if (rdata.pitem_dom_min_width > 0 && rdata.pitem_dom_min_width > pitem_dom_width) { return; }
            if (rdata.pitem_dom_max_width > 0 && rdata.pitem_dom_max_width < pitem_dom_width) { return; }

			rdata.pitem_dom.css({width:pitem_dom_width});
			if(rdata.pitem_dom.attr("data-width")){
				rdata.pitem_dom.attr("data-width", pitem_dom_width);
			}

			var nitem_dom_width = rdata.nitem_dom_width - dx;

            if (rdata.nitem_dom_min_width > 0 && rdata.nitem_dom_min_width > nitem_dom_width) { return; }
            if (rdata.nitem_dom_max_width > 0 && rdata.nitem_dom_max_width < nitem_dom_width) { return; }

			rdata.nitem_dom.css({width:nitem_dom_width});
			if(rdata.nitem_dom.attr("data-width")){
				rdata.nitem_dom.attr("data-width", nitem_dom_width);
			}
		}

        // 브라우저 부하로 인해 리사이즈 액션이 끊기는 문제가 있어서 일단 주석 처리함
        //this.resizeInstances();

        if(cfg.onsplitresize){
            cfg.onsplitresize.call(this.resizeHandle_data);
        }
	},
	splitResizeEnd: function(){
		var cfg = this.config, _this = this;
		this.resizeHandle_data.dom.removeClass("on");
		axdom(document.body).unbind("mousemove.axsplit");
		axdom(document.body).unbind("mouseup.axsplit");

		if(cfg.onsplitresizeend){
			cfg.onsplitresizeend.call({});
		}

        this.resizeInstances();
	},
    /**
     * '10%', '20px', '30' 등의 길이 표현을 픽셀단위의 number 값으로 변환한다.
     * @param value {String} - '10%', '20px', '30' 등의 길이 표현
     */
    getPixelValue: function(value, parentLength){
        if (typeof value !== "string" || value === "") { return 0; }

        if (value.indexOf("%") > -1) {
            var percent = value.number();
            var pixelValue = parentLength * (percent / 100);

            return pixelValue;
        } else {
            return value.number();
        }
    },
    /**
     * AXGrid_instances, AXTree_instances 중에 fill: true 설정된 인스턴스를 컨테이너에 꽉차게 만든다.
     */
    resizeInstances: function(){
        var axGrids = window.AXGrid_instances;
        if (axGrids && typeof axGrids.length === "number") {
            axf.each(axGrids, function(gi, grid) {
                if (grid.config.fill === true) {
                    grid.scrollBody.css("border", "none");

                    var ph = grid.target.parent().innerHeight();
                    var siblingsHeight = 0;
                    grid.target.siblings().each(function(si, sibling){
                        var s = $(sibling);
                        if (s.height() === 0) { return; }

                        siblingsHeight += s.outerHeight(true);
                    });

                    grid.setHeight(ph - siblingsHeight + 2/*border none size*/);
                }
            });
        }

        var axTree = window.AXTree_instances;
        if (axTree && typeof axTree.length === "number") {
            axf.each(axTree, function(ti, tree){
                if (tree.config.fill === true) {
                    tree.scrollBody.css("border", "none");

                    var ph = tree.target.parent().innerHeight();
                    var siblingsHeight = 0;
                    tree.target.siblings().each(function(si, sibling){
                        var s = $(sibling);
                        if (s.height() === 0) { return; }

                        siblingsHeight += s.outerHeight(true);
                    });

                    tree.target.height(ph - siblingsHeight);
                    tree.resetHeight();
                }
            });
        }
    }
});
/* ---------------------------- */
var AXGrid = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();
        
        this.Observer = null;
        this.list = [];
        this.removedList = [];
        this.pageActive = false;
        this.page = {pageNo: 0, pageSize: 100, pageCount: "", listCount: 0};
        
        this.moveSens = 0;
        this.config.viewMode = "grid"; // icon, mobile
        this.config.moveSens = 1;
        this.config.formPaddingRight = "11px";
        this.config.sort = true;
        this.config.colHeadTool = true;
        this.config.xscroll = true;
        this.config.fitToWidth = (AXConfig.AXGrid.fitToWidth || false);
        this.config.fitToWidthRightMargin = (AXConfig.AXGrid.fitToWidthRightMargin || 15);
        this.config.passiveMode = AXConfig.AXGrid.passiveMode;
        this.config.passiveRemoveHide = AXConfig.AXGrid.passiveRemoveHide;
        this.config.scrollContentBottomMargin = "10";
        this.config.listCountMargin = 12;
        this.config.headTdHeight = (AXConfig.AXGrid.headTdHeight || 30);
        
        this.config.mergeCells = false; // cells merge option
        this.config.control_lock_status = 0; // 0 : 모든 기능 사용가능, 1: 컨트롤(데이터는 변경가능하지만 내부 속성변경 금지), 2: 컨트롤+update(데이터와 속성 모두 변경 금지)
        this.selectedCells = [];
        this.selectedRow = [];
        this.copiedRow = [];
        this.clipBoard = {
            type: "copy", list: []
        };
        
        this.isMobile = AXUtil.browser.mobile;
        this.cachedDom = {};
        this.virtualScroll = {
            startIndex: 0,
            endIndex: 0,
            itemTrHeight: 0,
            printListCount: 0,
            scrollTop: 0
        };
        this.reserveKeys = {
            // 시스템 설정 키들 -- s
            parent_hash: "phash",
            child_hash: "hash",
            sub_list: "list",
            hidden: "_hidden"
        };
        
        this.config.resizeable = true; // 2016-06-12 reisze 안되는 옵션 추가.
        
        this.mobileContextMenu = new AXContextMenuClass();
        
        window.AXGrid_instances = window.AXGrid_instances || [];
        window.AXGrid_instances.push(this);
    },
    /* 공통 영역 */
    defineConfig: function (rewrite, _test) {
        var cfg = this.config;
        if (!cfg.colGroup) return;
        if (cfg.colGroup.length == 0) {
            console.log("colGrpup is empty)");
            return;
        }
        
        /* col너비 합계 구하기 */
        var colWidth = 0;
        var hasHiddenCell = false;
        var showColLen = 0;
        if (!rewrite) this.fixedColSeq = cfg.fixedColSeq;
        var bodyWidth = this.body.width();
        if (bodyWidth == 0) bodyWidth = this.target.innerWidth();
        var astricCount = 0;
        
        for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
            if (CG.colSeq == undefined) CG.colSeq = cidx;
            if (CG.display == undefined) CG.display = true;
            if (CG.display) {
                if (!rewrite) {
                    if (CG.width == "*") {
                        cfg.hasAstricCol = true;
                        CG.width = 0;
                        CG.widthAstric = true;
                        astricCount++;
                    }
                    CG._owidth = CG.width;
                    /* 최초의 너비값 기억 하기 */
                }
                else {
                    if (CG.widthAstric) {
                        CG.width = 0;
                        CG._owidth = CG.width;
                        astricCount++;
                    }
                }
                
                if (typeof CG._owidth == "undefined") CG._owidth = CG.width;
                colWidth += (CG._owidth || 0).number();
                showColLen += 1;
            }
            else {
                hasHiddenCell = true;
                if (!rewrite) {
                    CG._owidth = CG.width;
                    /* 최초의 너비값 기억 하기 */
                }
            }
        }
        
        if (!cfg.fitToWidth) {
            /* width * 예외처리 구문 ------------ s */
            
            if ((bodyWidth - cfg.fitToWidthRightMargin) > (colWidth + 100 * astricCount)) {
                var remainsWidth = (bodyWidth - cfg.fitToWidthRightMargin) - colWidth;
                for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                    if (CG.display && CG.widthAstric) {
                        CG._owidth = (remainsWidth / astricCount).ceil();
                        CG.width = CG._owidth;
                        colWidth += (CG._owidth || 0).number();
                    }
                }
            }
            else {
                for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                    if (CG.display && CG.widthAstric) {
                        CG._owidth = 100;
                        CG.width = 100;
                        colWidth += (CG._owidth || 0).number();
                    }
                }
            }
            /* width * 예외처리 구문 ------------ e */
        }
        else {
            for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                if (CG.display && CG.widthAstric) {
                    CG.width = 100;
                    CG._owidth = 100;
                    colWidth += (CG._owidth || 0).number();
                }
            }
        }
        this.colWidth = colWidth;
        
        if (cfg.fitToWidth) { /*너비 자동 맞춤버전의 경우 */
            if (bodyWidth > this.colWidth) {
                
                var _bodyWidth = bodyWidth - cfg.fitToWidthRightMargin;
                var zoomRatio = bodyWidth / this.colWidth;
                colWidth = 0;
                for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                    if (CG.display) {
                        CG.width = (CG._owidth * zoomRatio).ceil();
                        if (_bodyWidth > CG.width) _bodyWidth -= CG.width;
                        else CG.width = _bodyWidth;
                        colWidth += CG.width.number();
                    }
                }
                this.colWidth = colWidth;
            }
            else {
                
                colWidth = 0;
                for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                    if (CG.display) {
                        if (CG._owidth == undefined) CG._owidth = (CG.width || 0).number();
                        CG.width = CG._owidth.number();
                        colWidth += CG.width.number();
                    }
                }
                this.colWidth = colWidth;
            }
        }
        
        this.showColLen = showColLen;
        /* col너비 합계 구하기 ~~~~~~~~~~~~~~ 구해진 너비합은 그리드 head, body 의 너비로 지정됨. */
        
        if (rewrite && cfg.colHead.rows) cfg._colHead_rows = axf.copyObject(cfg.colHead.rows);
        
        if (!cfg.colHead) cfg.colHead = {};
        if (!cfg.body) cfg.body = {};
        if (!cfg.page) cfg.page = {display: false, paging: false, status: {formatter: null}};
        if (cfg.colHead.rowsEmpty) cfg.colHead.rows = undefined;
        if (cfg.body.rowsEmpty) cfg.body.rows = undefined;
        
        /* colHead rows ----------------------------------------------------------------------------------------------------- */
        if (cfg.colHead.rows) {
            /* colHeadRow 정해진 경우 */
            cfg.colHead._maps = new Array(cfg.colHead.rows.length);
            var colMaxLen = 0;
            for (var r = 0; r < cfg.colHead.rows.length; r++) {
                var colLen = 0;
                for (var CH, CHidx = 0, __arr = cfg.colHead.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                    if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
                    if (CH.colspan == undefined || CH.colspan == null) {
                        CH.colspan = 1;
                        CH._colspan = 1;
                    }
                    else {
                        if (!rewrite) {
                            CH._colspan = CH.colspan;
                        }
                        else {
                            CH.colspan = CH._colspan;
                        }
                    }
                    if (CH.valign == undefined || CH.valign == null) CH.valign = "bottom";
                    if (typeof CH.align == "undefined" && cfg.colHeadAlign) CH.align = cfg.colHeadAlign; // 고정값 아닌 설정 값 가져오기
                    colLen += (CH.colspan || 0).number();
                }
                if (colMaxLen < colLen) colMaxLen = colLen;
            }
            for (var _m = 0; _m < cfg.colHead._maps.length; _m++) {
                cfg.colHead._maps[_m] = new Array(colMaxLen);
            }
            /* colEndPosition 관련 처리 함수 */
            var appendPosToColHeadMap = function (r, c, posR, position) {
                var nC = position.c;
                /*시작 컬럼 위치 */
                var startPosition = null;
                for (var rr = posR; rr < (posR + r); rr++) {
                    if (r > 1) if (rr > 0 && startPosition != null) nC = startPosition;
                    var tC = c;
                    /*컬럼 루프횟수 */
                    var isWhile = true;
                    /* 루프유지변수 */
                    while (isWhile) {
                        try {
                            if (tC == 0) {
                                isWhile = false;
                            }
                            else {
                                if (cfg.colHead._maps[rr][nC] == undefined) {
                                    cfg.colHead._maps[rr][nC] = position;
                                    if (startPosition == null) startPosition = nC;
                                    tC--;
                                }
                                else {
                                    nC++;
                                }
                            }
                        } catch (e) {
                            isWhile = false;
                        }
                    }
                }
                return startPosition;
            };
            for (var r = 0; r < cfg.colHead.rows.length; r++) {
                //var startPosition = null;
                //var isMultiRow = false;
                for (var CH, CHidx = 0, __arr = cfg.colHead.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                    if (CH.colSeq != undefined) {
                        var myCG = cfg.colGroup.getToSeq(CH.colSeq);
                    }
                    else {
                        var myCG = cfg.colGroup.searchObject(function () {
                            return CH.key == this.item.key;
                        }).first();
                    }
                    if (myCG != null) {
                        if (CH.sort != myCG.sort) {
                            //console.log(CH, myCG);
                        }
                        if (rewrite) AXUtil.overwriteObject(CH, myCG, true);
                        else AXUtil.overwriteObject(CH, myCG, false);
                    }
                    else {
                        AXUtil.overwriteObject(CH, {
                            align: "left",
                            valign: "bottom",
                            display: true,
                            rowspan: 1,
                            colspan: 1
                        }, false);
                    }
                    appendPosToColHeadMap(CH.rowspan, CH.colspan, r, {r: r, c: CHidx});
                }
            }
            
            /*colHead._maps 마지막 줄에 해당하는 cfg.colHead.rows 에 속성부여 */
            for (var m, midx = 0, __arr = cfg.colHead._maps.last(); (midx < __arr.length && (m = __arr[midx])); midx++) {
                if (m) cfg.colHead.rows[m.r][m.c].isLastCell = true;
            }
            
            if (hasHiddenCell) { /* colGroup 중에 숨겨진 col 이 존재하는 경우 */
                /* colspan 감소 시키기 */
                for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                    if (!CG.display) {
                        var rowPosition = null;
                        for (var a = 0; a < cfg.colHead._maps.length; a++) {
                            if (rowPosition != cfg.colHead._maps[a][cidx]) {
                                rowPosition = cfg.colHead._maps[a][cidx];
                                cfg.colHead.rows[rowPosition.r][rowPosition.c].colspan--;
                            }
                        }
                    }
                }
            }
            /* colHeadRow 정해진 경우 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
        }
        else {
            // colHeadRow 정해지지 않은 경우
            cfg.colHead._maps = [
                []
            ];
            var colHeadRows = [
                []
            ];
            
            for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                var adder = {
                    key: CG.key,
                    colSeq: CG.colSeq,
                    label: CG.label,
                    align: (cfg.colHeadAlign || CG.align || "left"),
                    rowspan: 1,
                    colspan: 1,
                    valign: "bottom",
                    isLastCell: true,
                    display: CG.display,
                    formatter: CG.formatter,
                    formatterLabel: CG.formatterLabel,
                    checked: CG.checked,
                    disabled: CG.disabled,
                    sort: CG.sort,
                    colHeadTool: ((typeof CG.colHeadTool == "undefined") ? cfg.colHeadTool : CG.colHeadTool ),
                    tooltip: CG.tooltip,
                    displayLabel: (CG.displayLabel || false),
                    addClass: CG.addClass
                };
                if (cfg._colHead_rows) adder.sort = cfg._colHead_rows[0][cidx].sort; // redrawGrid 호출된 경우 예외처리
                colHeadRows[0].push(adder);
                cfg.colHead._maps[0].push({r: 0, c: cidx});
            }
            cfg.colHead.rows = colHeadRows;
            cfg.colHead.rowsEmpty = true;
            // colHeadRow 정해지지 않은 경우 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        }

        for (var mr = 0, mrl = cfg.colHead._maps.length; mr < mrl; mr++) {
            //cfg.colHead.rows[m.r][m.c].isLastCell = true;
            var map_p = cfg.colHead._maps[mr].last();
            cfg.colHead.rows[map_p.r][map_p.c].isTrLastChild = true;
        }

        /* colHead rows ----------------------------------------------------------------------------------------------------- */
        
        /* body rows ------------------------------------------------------------------------------------------------------- */
        if (cfg.body.rows) {
            /* bodyRow 정해진 경우 */
            cfg.body._maps = new Array(cfg.body.rows.length);
            var colMaxLen = 0;
            for (var r = 0; r < cfg.body.rows.length; r++) {
                var colLen = 0;
                for (var CH, CHidx = 0, __arr = cfg.body.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                    if (CH.colspan == undefined || CH.colspan == null) {
                        CH.colspan = 1;
                        CH._colspan = 1;
                    }
                    else {
                        if (!rewrite) CH._colspan = CH.colspan;
                        else CH.colspan = CH._colspan;
                    }
                    if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
                    if (CH.valign == undefined || CH.valign == null) CH.valign = "middle";
                    /* if(CH.align == undefined || CH.align == null) CH.align = "left"; */
                    colLen += CH.colspan.number();
                }
                if (colMaxLen < colLen) colMaxLen = colLen;
            }
            for (var _m = 0; _m < cfg.body._maps.length; _m++) {
                cfg.body._maps[_m] = new Array(colMaxLen);
            }
            /* colEndPosition 관련 처리 함수 */
            var appendPosToBodyMap = function (r, c, posR, position) {
                var nC = position.c;
                /*시작 컬럼 위치 */
                var startPosition = null;
                for (var rr = posR; rr < (posR + r); rr++) {
                    if (r > 1) if (rr > 0 && startPosition != null) nC = startPosition;
                    var tC = c;
                    /*컬럼 루프횟수 */
                    var isWhile = true;
                    /* 루프유지변수 */
                    while (isWhile) {
                        try {
                            if (tC == 0) {
                                isWhile = false;
                            }
                            else {
                                if (cfg.body._maps[rr][nC] == undefined) {
                                    if (rr != posR) position._isRowMerged = true; /// status row merged
                                    cfg.body._maps[rr][nC] = position;
                                    if (startPosition == null) startPosition = nC;
                                    tC--;
                                }
                                else {
                                    nC++;
                                }
                            }
                        } catch (e) {
                            isWhile = false;
                        }
                    }
                }
            };

            for (var r = 0; r < cfg.body.rows.length; r++) {
                for (var CH, CHidx = 0, __arr = cfg.body.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                    if (CH.colSeq != undefined) {
                        var myCG = cfg.colGroup.getToSeq(CH.colSeq);
                    }
                    else {
                        var myCG = cfg.colGroup.searchObject(function () {
                            return this.item.key == CH.key;
                        }).first();
                    }

                    if (myCG != null) {

                        AXUtil.overwriteObject(CH, myCG, false);
                    }
                    else {
                        AXUtil.overwriteObject(CH, {
                            align: "left",
                            valign: "bottom",
                            display: true,
                            rowspan: 1,
                            colspan: 1
                        }, false);
                    }
                    appendPosToBodyMap(CH.rowspan, CH.colspan, r, {r: r, c: CHidx});
                }
            }
            /*body._maps 마지막 줄에 해당하는 cfg.body.rows 에 속성부여 */
            for (var m, midx = 0, __arr = cfg.body._maps.last(); (midx < __arr.length && (m = __arr[midx])); midx++) {
                if (m) cfg.body.rows[m.r][m.c].isLastCell = true;
            }

            if (hasHiddenCell) { /* colGroup 중에 숨겨진 col 이 존재하는 경우 */
                /* colspan 감소 시키기 */
                for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                    if (!CG.display) {
                        for (var a = 0; a < cfg.body._maps.length; a++) {
                            var rowPosition = cfg.body._maps[a][cidx];
                            cfg.body.rows[rowPosition.r][rowPosition.c].colspan--;
                        }
                    }
                }
            }

            /* bodyRow 정해진 경우 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
        }
        else {
            /* bodyRow 정해지지 않은 경우 */
            cfg.body._maps = [
                []
            ];
            var bodyRows = [
                []
            ];
            for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                var adder = {
                    key: CG.key,
                    colSeq: CG.colSeq,
                    label: CG.label,
                    align: (CG.align || "left"),
                    rowspan: 1,
                    colspan: 1,
                    valign: (CG.valign || "middle"),
                    isLastCell: true,
                    display: CG.display,
                    checked: CG.checked,
                    disabled: CG.disabled,
                    formatter: CG.formatter,
                    editor: CG.editor,
                    formatterLabel: CG.formatterLabel,
                    tooltip: CG.tooltip,
                    addClass: CG.addClass
                };
                bodyRows[0].push(adder);
                cfg.body._maps[0].push({r: 0, c: cidx});
            }
            cfg.body.rows = bodyRows;
            cfg.body.rowsEmpty = true;
            /* bodyRow 정해지지 않은 경우 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
        }
        /* body rows ------------------------------------------------------------------------------------------------------- */

        /*marker 관련 데이터 정리 */
        if (cfg.body.marker) {
            cfg.body.marker = [].concat(cfg.body.marker);
            /* colEndPosition 관련 처리 함수 */

            var appendPosToMarkerMap = function (r, c, posR, position, marker) {
                var nC = position.c;
                /*시작 컬럼 위치 */
                var startPosition = null;
                for (var rr = posR; rr < (posR + r); rr++) {
                    if (r > 1) if (rr > 0 && startPosition != null) nC = startPosition;
                    var tC = c;
                    /*컬럼 루프횟수 */
                    var isWhile = true;
                    /* 루프유지변수 */
                    while (isWhile) {
                        try {
                            if (tC == 0) {
                                isWhile = false;
                            }
                            else {
                                if (marker._maps[rr][nC] == undefined) {
                                    marker._maps[rr][nC] = position;
                                    if (startPosition == null) startPosition = nC;
                                    tC--;
                                }
                                else {
                                    nC++;
                                }
                            }
                        } catch (e) {
                            isWhile = false;
                        }
                    }
                }
            };

            for (var m = 0, l = cfg.body.marker.length, marker; m < l; m++) {
                marker = cfg.body.marker[m];

                if (marker.rows) {
                    this.bodyHasMarker = true;
                    marker._maps = new Array(marker.rows.length);
                    colMaxLen = 0;
                    for (var r = 0; r < marker.rows.length; r++) {
                        var colLen = 0;
                        for (var CH, CHidx = 0, __arr = marker.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                            if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
                            if (CH.colspan == undefined || CH.colspan == null) {
                                CH.colspan = 1;
                                CH._colspan = 1;
                            }
                            else {
                                if (!rewrite) CH._colspan = CH.colspan;
                                else CH.colspan = CH._colspan;
                            }
                            if (CH.valign == undefined || CH.valign == null) CH.valign = "bottom";
                            colLen += CH.colspan.number();
                        }
                        if (colMaxLen < colLen) colMaxLen = colLen;
                    }
                    for (var _m = 0; _m < marker._maps.length; _m++) {
                        marker._maps[_m] = new Array(colMaxLen);
                    }

                    for (var r = 0; r < marker.rows.length; r++) {
                        for (var CH, CHidx = 0, __arr = marker.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                            if (CH.colSeq != undefined) {
                                var myCG = cfg.colGroup.getToSeq(CH.colSeq);
                            }
                            else {
                                var myCG = cfg.colGroup.searchObject(function () {
                                    return this.item.key == CH.key;
                                }).first();
                            }

                            if (myCG != null) {
                                AXUtil.overwriteObject(CH, myCG, false);
                            }
                            else {
                                AXUtil.overwriteObject(CH, {
                                    align: "left",
                                    valign: "bottom",
                                    display: true,
                                    rowspan: 1,
                                    colspan: 1
                                }, false);
                            }
                            appendPosToMarkerMap(CH.rowspan, CH.colspan, r, {r: r, c: CHidx}, marker);
                        }

                    }
                    /*colHead._maps 마지막 줄에 해당하는 cfg.colHead.rows 에 속성부여 */

                    for (var rm, midx = 0, __arr = marker._maps.last(); (midx < __arr.length && (rm = __arr[midx])); midx++) {
                        if (rm) marker.rows[rm.r][rm.c].isLastCell = true;
                    }

                    if (hasHiddenCell) { /* colGroup 중에 숨겨진 col 이 존재하는 경우 */
                        /* colspan 감소 시키기 */
                        for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                            if (!CG.display) {
                                for (var a = 0; a < marker._maps.length; a++) {
                                    var rowPosition = marker._maps[a][cidx];
                                    marker.rows[rowPosition.r][rowPosition.c].colspan--;
                                }
                            }
                        }
                    }

                }
            }
        }
        /*marker 관련 데이터 정리 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

        /*head 관련 데이터 정리 */
        if (cfg.head) {
            cfg.head._maps = new Array(cfg.head.rows.length);
            colMaxLen = 0;
            for (var r = 0; r < cfg.head.rows.length; r++) {
                var colLen = 0;
                for (var CH, CHidx = 0, __arr = cfg.head.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                    if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
                    if (CH.colspan == undefined || CH.colspan == null) {
                        CH.colspan = 1;
                        CH._colspan = 1;
                    }
                    else {
                        if (!rewrite) CH._colspan = CH.colspan;
                        else CH.colspan = CH._colspan;
                    }
                    if (CH.valign == undefined || CH.valign == null) CH.valign = "bottom";
                    /*if(CH.align == undefined || CH.align == null) CH.align = "left"; */
                    colLen += CH.colspan.number();
                }

                if (colMaxLen < colLen) colMaxLen = colLen;
            }
            for (var _m = 0; _m < cfg.head._maps.length; _m++) {
                cfg.head._maps[_m] = new Array(colMaxLen);
            }
            /* colEndPosition 관련 처리 함수 */
            var appendPosToHeadMap = function (r, c, posR, position) {
                var nC = position.c;
                /*시작 컬럼 위치 */
                var startPosition = null;
                for (var rr = posR; rr < (posR + r); rr++) {
                    if (r > 1) if (rr > 0 && startPosition != null) nC = startPosition;
                    var tC = c;
                    /*컬럼 루프횟수 */
                    var isWhile = true;
                    /* 루프유지변수 */
                    while (isWhile) {
                        try {
                            if (tC == 0) {
                                isWhile = false;
                            }
                            else {
                                if (cfg.head._maps[rr][nC] == undefined) {
                                    cfg.head._maps[rr][nC] = position;
                                    if (startPosition == null) startPosition = nC;
                                    tC--;
                                }
                                else {
                                    nC++;
                                }
                            }
                        } catch (e) {
                            isWhile = false;
                        }
                    }
                }
            };
            for (var r = 0; r < cfg.head.rows.length; r++) {
                for (var CH, CHidx = 0, __arr = cfg.head.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                    if (CH.colSeq != undefined) {
                        var myCG = cfg.colGroup.getToSeq(CH.colSeq);
                    }
                    else {
                        var myCG = cfg.colGroup.searchObject(function () {
                            return this.item.key == CH.key;
                        }).first();
                    }

                    if (myCG != null) {
                        AXUtil.overwriteObject(CH, myCG, false);
                    }
                    else {
                        AXUtil.overwriteObject(CH, {
                            align: "left",
                            valign: "bottom",
                            display: true,
                            rowspan: 1,
                            colspan: 1
                        }, false);
                    }
                    appendPosToHeadMap(CH.rowspan, CH.colspan, r, {r: r, c: CHidx});
                }

            }

            /*colHead._maps 마지막 줄에 해당하는 cfg.colHead.rows 에 속성부여 */
            for (var m, midx = 0, __arr = cfg.head._maps.last(); (midx < __arr.length && (m = __arr[midx])); midx++) {
                if (m) cfg.head.rows[m.r][m.c].isLastCell = true;
            }

            if (hasHiddenCell) { /* colGroup 중에 숨겨진 col 이 존재하는 경우 */
                /* colspan 감소 시키기 */
                for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                    if (!CG.display) {
                        for (var a = 0; a < cfg.head._maps.length; a++) {
                            var rowPosition = cfg.head._maps[a][cidx];
                            cfg.head.rows[rowPosition.r][rowPosition.c].colspan--;
                        }
                    }
                }
            }
        }
        /*head 관련 데이터 정리 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

        /*foot 관련 데이터 정리 */
        if (cfg.foot) {
            cfg.foot._maps = new Array(cfg.foot.rows.length);
            colMaxLen = 0;
            for (var r = 0; r < cfg.foot.rows.length; r++) {
                var colLen = 0;
                for (var CH, CHidx = 0, __arr = cfg.foot.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                    if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
                    if (CH.colspan == undefined || CH.colspan == null) {
                        CH.colspan = 1;
                        CH._colspan = 1;
                    }
                    else {
                        if (!rewrite) CH._colspan = CH.colspan;
                        else CH.colspan = CH._colspan;
                    }
                    if (CH.valign == undefined || CH.valign == null) CH.valign = "bottom";
                    colLen += CH.colspan.number();
                }

                if (colMaxLen < colLen) colMaxLen = colLen;
            }
            for (var _m = 0; _m < cfg.foot._maps.length; _m++) {
                cfg.foot._maps[_m] = new Array(colMaxLen);
            }
            /* colEndPosition 관련 처리 함수 */
            var appendPosToFootMap = function (r, c, posR, position) {
                var nC = position.c;
                /*시작 컬럼 위치 */
                var startPosition = null;
                for (var rr = posR; rr < (posR + r); rr++) {
                    if (r > 1) if (rr > 0 && startPosition != null) nC = startPosition;
                    var tC = c;
                    var isWhile = true;
                    while (isWhile) {
                        try {
                            if (tC == 0) {
                                isWhile = false;
                            }
                            else {
                                if (cfg.foot._maps[rr][nC] == undefined) {
                                    cfg.foot._maps[rr][nC] = position;
                                    if (startPosition == null) startPosition = nC;
                                    tC--;
                                }
                                else {
                                    nC++;
                                }
                            }
                        } catch (e) {
                            isWhile = false;
                        }
                    }
                }
            };
            for (var r = 0; r < cfg.foot.rows.length; r++) {
                for (var CH, CHidx = 0, __arr = cfg.foot.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                    if (CH.colSeq != undefined) {
                        var myCG = cfg.colGroup.getToSeq(CH.colSeq);
                    }
                    else {
                        var myCG = cfg.colGroup.searchObject(function () {
                            return this.item.key == CH.key;
                        }).first();
                    }

                    if (myCG != null) {
                        AXUtil.overwriteObject(CH, myCG, false);
                    }
                    else {
                        AXUtil.overwriteObject(CH, {
                            align: "left",
                            valign: "bottom",
                            display: true,
                            rowspan: 1,
                            colspan: 1
                        }, false);
                    }

                    appendPosToFootMap((CH.rowspan || 1), (CH.colspan || 1), r, {r: r, c: CHidx});
                }
            }

            /*colHead._maps 마지막 줄에 해당하는 cfg.colHead.rows 에 속성부여 */
            for (var m, midx = 0, __arr = cfg.foot._maps.last(); (midx < __arr.length && (m = __arr[midx])); midx++) {
                if (m) cfg.foot.rows[m.r][m.c].isLastCell = true;
            }

            if (hasHiddenCell) { /* colGroup 중에 숨겨진 col 이 존재하는 경우 */
                for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                    if (!CG.display) {
                        for (var a = 0; a < cfg.foot._maps.length; a++) {
                            var rowPosition = cfg.foot._maps[a][cidx];
                            cfg.foot.rows[rowPosition.r][rowPosition.c].colspan--;
                        }
                    }
                }

            }
        }
        /*foot 관련 데이터 정리 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

        /*editor 관련 데이터 정리 */
        if (cfg.editor) {
            if (cfg.editor.rows) {
                this.hasEditor = true;
                cfg.editor._maps = new Array(cfg.editor.rows.length);
                colMaxLen = 0;
                for (var r = 0; r < cfg.editor.rows.length; r++) {
                    var colLen = 0;
                    for (var CH, CHidx = 0, __arr = cfg.editor.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                        if (CH) {
                            if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
                            if (CH.colspan == undefined || CH.colspan == null) {
                                CH.colspan = 1;
                                CH._colspan = 1;
                            }
                            else {
                                if (!rewrite) CH._colspan = CH.colspan;
                                else CH.colspan = CH._colspan;
                            }
                            if (CH.valign == undefined || CH.valign == null) CH.valign = "bottom";
                            colLen += CH.colspan.number();
                        }
                    }

                    if (colMaxLen < colLen) colMaxLen = colLen;
                }
                for (var _m = 0; _m < cfg.editor._maps.length; _m++) {
                    cfg.editor._maps[_m] = new Array(colMaxLen);
                }
                /* colEndPosition 관련 처리 함수 */
                var appendPosToEditorMap = function (r, c, posR, position) {
                    var nC = position.c;
                    var startPosition = null;
                    for (var rr = posR; rr < (posR + r); rr++) {
                        var tC = c;
                        var isWhile = true;
                        while (isWhile) {
                            try {
                                if (tC == 0) {
                                    isWhile = false;
                                }
                                else {
                                    if (cfg.editor._maps[rr][nC] == undefined) {
                                        cfg.editor._maps[rr][nC] = position;
                                        if (startPosition == null) startPosition = nC;
                                        tC--;
                                    }
                                    else {
                                        nC++;
                                    }
                                }
                            } catch (e) {
                                isWhile = false;
                            }
                        }
                    }
                };
                for (var r = 0; r < cfg.editor.rows.length; r++) {
                    for (var CH, CHidx = 0, __arr = cfg.editor.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                        if (CH) {
                            if (CH.colSeq != undefined) {
                                var myCG = cfg.colGroup.getToSeq(CH.colSeq);
                            }
                            else {
                                var myCG = cfg.colGroup.searchObject(function () {
                                    return this.item.key == CH.key;
                                }).first();
                            }
                            if (myCG != null) {
                                AXUtil.overwriteObject(CH, myCG, false);
                            }
                            else {
                                AXUtil.overwriteObject(CH, {
                                    align: "left",
                                    valign: "bottom",
                                    display: true,
                                    rowspan: 1,
                                    colspan: 1
                                }, false);
                            }
                            appendPosToEditorMap(CH.rowspan, CH.colspan, r, {r: r, c: CHidx});
                        }
                    }

                }

                for (var m, midx = 0, __arr = cfg.editor._maps.last(); (midx < __arr.length && (m = __arr[midx])); midx++) {
                    if (m) cfg.editor.rows[m.r][m.c].isLastCell = true;
                }

                if (hasHiddenCell) {
                    for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                        if (!CG.display) {
                            for (var a = 0; a < cfg.editor._maps.length; a++) {
                                var rowPosition = cfg.editor._maps[a][cidx];
                                cfg.editor.rows[rowPosition.r][rowPosition.c].colspan--;
                            }
                        }
                    }

                }
            }
        }

        /*editor 관련 데이터 정리 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

        /*fixedColSeq가 설정된 경우 */
        if (cfg.fixedColSeq != undefined && cfg.fixedColSeq != null) {

            var fixedColSeq = this.fixedColSeq;

            for (var m, midx = 0, __arr = cfg.colHead._maps; (midx < __arr.length && (m = __arr[midx])); midx++) {
                for (var c, cidx = 0, __arr2 = m; (cidx < __arr2.length && (c = __arr2[cidx])); cidx++) {
                    if (c) {
                        if ((fixedColSeq + 1) > cidx) cfg.colHead.rows[c.r][c.c].isFixedCell = true;
                    }
                }

            }

            for (var m, midx = 0, __arr = cfg.body._maps; (midx < __arr.length && (m = __arr[midx])); midx++) {
                for (var c, cidx = 0, __arr2 = m; (cidx < __arr2.length && (c = __arr2[cidx])); cidx++) {
                    if (c) {
                        if (fixedColSeq == cidx) cfg.body.rows[c.r][c.c].isFixedEndCell = true;
                        if ((fixedColSeq + 1) > cidx) cfg.body.rows[c.r][c.c].isFixedCell = true;
                    }
                }

            }

            if (cfg.head) {
                for (var m, midx = 0, __arr = cfg.head._maps; (midx < __arr.length && (m = __arr[midx])); midx++) {
                    for (var c, cidx = 0, __arr2 = m; (cidx < __arr2.length && (c = __arr2[cidx])); cidx++) {
                        if (c) {
                            if (fixedColSeq == cidx) cfg.head.rows[c.r][c.c].isFixedEndCell = true;
                            if ((fixedColSeq + 1) > cidx) cfg.head.rows[c.r][c.c].isFixedCell = true;
                        }
                    }

                }

            }
            if (cfg.foot) {
                for (var m, midx = 0, __arr = cfg.foot._maps; (midx < __arr.length && (m = __arr[midx])); midx++) {
                    for (var c, cidx = 0, __arr2 = m; (cidx < __arr2.length && (c = __arr2[cidx])); cidx++) {
                        if (c) {
                            if (fixedColSeq == cidx) cfg.foot.rows[c.r][c.c].isFixedEndCell = true;
                            if ((fixedColSeq + 1) > cidx) cfg.foot.rows[c.r][c.c].isFixedCell = true;
                        }
                    }

                }
            }

            if (cfg.body.marker) {
                if (cfg.body.marker.rows) {
                    for (var m, midx = 0, __arr = cfg.body.marker._maps; (midx < __arr.length && (m = __arr[midx])); midx++) {
                        for (var c, cidx = 0, __arr2 = m; (cidx < __arr2.length && (c = __arr2[cidx])); cidx++) {
                            if (c) {
                                if (fixedColSeq == cidx) cfg.body.marker.rows[c.r][c.c].isFixedEndCell = true;
                                if ((fixedColSeq + 1) > cidx) cfg.body.marker.rows[c.r][c.c].isFixedCell = true;
                            }
                        }

                    }

                }
            }

            if (cfg.editor) {
                if (cfg.editor.rows) {
                    for (var m, midx = 0, __arr = cfg.editor._maps; (midx < __arr.length && (m = __arr[midx])); midx++) {
                        for (var c, cidx = 0, __arr2 = m; (cidx < __arr2.length && (c = __arr2[cidx])); cidx++) {
                            if (c) {
                                if (fixedColSeq == cidx) cfg.editor.rows[c.r][c.c].isFixedEndCell = true;
                                if ((fixedColSeq + 1) > cidx) cfg.editor.rows[c.r][c.c].isFixedCell = true;
                            }
                        }

                    }

                }
            }
            this.hasFixed = true;
            if (hasHiddenCell) {
                var minusFixedCol = 0;
                var fixedColSeq = this.fixedColSeq;
                for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                    if (!CG.display) {
                        if ((fixedColSeq + 1) > cidx) minusFixedCol++;
                    }
                }

                cfg.fixedColSeq = this.fixedColSeq - minusFixedCol;
            }
            else {
                cfg.fixedColSeq = this.fixedColSeq;
            }

            if (cfg.fixedColSeq == -1) {
                /*fixed 제거*/
                this.hasFixed = false;
            }

            var fixedColSeq = this.fixedColSeq, fixedColWidth = 0, fixedColLen = 0;
            for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                if (CG.display && cidx < (fixedColSeq + 1)) {
                    fixedColWidth += CG.width.number();
                    fixedColLen++;
                }
            }
            this.showFixedColLen = fixedColLen;
            this.fixedColWidth = fixedColWidth;
        }

        var ri = cfg.body.rows.length;
        while (ri--) {
            var ii = cfg.body.rows[ri].length;
            while (ii--) {
                if (cfg.body.rows[ri][ii].display) {
                    cfg.body.rows[ri][ii].isTdEnd = true;
                    break;
                }
            }
        }
        if (cfg.editor) {
            ri = cfg.editor.rows.length;
            while (ri--) {
                var ii = cfg.editor.rows[ri].length;
                while (ii--) {
                    if (cfg.editor.rows[ri][ii].display) {
                        cfg.editor.rows[ri][ii].isTdEnd = true;
                        break;
                    }
                }
            }
        }
        if (cfg.foot) {
            ri = cfg.foot.rows.length;
            while (ri--) {
                var ii = cfg.foot.rows[ri].length;
                while (ii--) {
                    if (cfg.foot.rows[ri][ii].display) {
                        cfg.foot.rows[ri][ii].isTdEnd = true;
                        break;
                    }
                }
            }
        }
        if (cfg.head) {
            ri = cfg.head.rows.length;
            while (ri--) {
                var ii = cfg.head.rows[ri].length;
                while (ii--) {
                    if (cfg.head.rows[ri][ii].display) {
                        cfg.head.rows[ri][ii].isTdEnd = true;
                        break;
                    }
                }
            }
        }
        if (cfg.body.marker && cfg.body.marker.rows) {
            ri = cfg.body.marker.rows.length;
            while (ri--) {
                var ii = cfg.body.marker.rows[ri].length;
                while (ii--) {
                    if (cfg.body.marker.rows[ri][ii].display) {
                        cfg.body.marker.rows[ri][ii].isTdEnd = true;
                        break;
                    }
                }
            }
        }
    },
    /**
     * @method AXGrid.setConfig
     * @param {Object} config - gridConfig
     * @description 선언된 클래스를 사용하기 위해 속성을 정의합니다.
     * @example
     * ```js
     * myGrid.setConfig({
 *     targetID    : "AXGridTarget", // {String} -- 그리드 div ID
 *     theme       : "AXGrid",       // {String} [AXGrid] -- CSS Class 이름
 *     fixedColSeq : 0,              // {Number} -- 컬럼고정 기능을 사용합니다. 고정할 마지막 컬럼의 인덱스 값입니다. 예제) http://dev.axisj.com/samples/AXGrid/fixedColSeq.html
 *     fitToWidth  : true,           // {Boolean} [false] -- 컬럼 가로 길이를 그리드의 가로 길이에 맞춥니다.
 *     colHeadAlign: "center",       // {String} 헤드의 기본 정렬. "left"|"center"|"right" 값을 사용할 수 있습니다. colHeadAlign 을 지정하면 colGroup 에서 정의한 정렬이 무시되고 colHeadAlign : false 이거나 없으면 colGroup 에서 정의한 속성이 적용됩니다.
 *     mergeCells  : [3,4]           // {Boolean|Array} -- 전체셀병합,병합안함,지정된 인덱스열만 병합 예제) http://dev.axisj.com/samples/AXGrid/mergeCells.html
 *     height      : "auto",         // {Number|String} -- 그리드의 높이를 지정합니다. 숫자를 사용하면 픽셀 단위로, "auto" 값을 사용하면 그리드의 높이가 내용에 맞춰서 늘어납니다. 예제) http://dev.axisj.com/samples/AXGrid/autoHeight.html
 *     sort        : true,           // {Boolean} -- true: 그리드의 헤더를 클릭해서 정렬 할 수 있습니다. false: 정렬 기능을 비활성화 합니다.  이 설정은 colGroup의 sort 보다 우선적으로 적용됩니다.
 *     remoteSort  : true,           // {Boolean} [false] -- 서버에서 정렬을 처리(서버에서 별도 처리 필요)합니다. 헤더 클릭시 'sortBy=cost desc' 형식의 정렬 정보가 ajax 요청에 포함됩니다.
 *     colHeadTool : true,           // {Boolean} -- 컬럼 display 여부를 설정 합니다. 이 설정은 colGroup의 colHeadTool 보다 우선적으로 적용됩니다.
 *     viewMode    : "grid"          // {String} -- 그리드가 보여지는 형태("grid"|"icon"|"mobile")를 지정합니다. viewMode는 mediaQuery에 의해서 자동으로 결정되기도 합니다. 예제) http://localhost/axisj/samples/AXGrid/viewMode.html
 *     reserveKeys : { // reserveKeys는 AXISJ에서 지정한 키를 다른 키로 지정하는 하는 경우 사용합니다. reserveKeys를 사용하면 데이터를 수정없이 바로 사용할 수 있습니다.
 *         parent_hash  : "phash", // {String} 부모해시 키의 이름을 지정합니다.
 *         child_hash   : "hash",  // {String} 자식해시 키의 이름을 지정합니다.
 *         sub_list     : "list",  // {String} 자식 리스트 키의 이름을 지정합니다.
 *         hidden       : "_hidden"// {String} hidden 키의 이름을 지정합니다.
 *     },
 *     colGroup : [ // 데이터 리스트의 컬럼을 정의합니다.
 *         {
 *             key      : "no",        // {String} -- 데이터와 맵핑할 키 입니다. key 명칭은 reservedKey
 *             label    : "번호",      // {String} -- 사용자에게 보여줄 컬럼명입니다.
 *             width    : 50,          // {Number|String} -- 컬럼의 가로길이를 설정합니다. 픽셀단위의 숫자나 "*" 문자를 사용할 수 있습니다. "*"을 사용하는 경우 그리드의 가로 길이에 따라 컬럼의 결이가 가변적으로 변합니다.
 *             align    : "right",     // {String} ["left"] -- 컬럼 내용의 정렬을 설정합니다. "left"|"center"|"right" 값을 사용할 수 있습니다.
 *             sort     : "asc",       // {String|Boolean} [""] -- 컬럼의 정렬을 지정합니다. "asc"|"desc"|false 값을 사용할 수 있습니다. false 값을 사용하면 컬럼의 정렬을 비활성화 합니다.
 *             colHeadTool : true      // {Boolean} -- 컬럼 display 여부를 설정 합니다.
 *             formatter: "money",     // {String|Function} -- 컬럼의 값을 표현하는 방식을 지정합니다. "money", "dec", "html", "checkbox", "radio", function은 아래 formatter 함수를 참고하세요.
 *             tooltip  : "money",     // {String|Function} -- 툴팁의 값을 표현하는 방식을 지정합니다. 툴팁을 지정하면 td div.bodyNode에 title 속성으로 값이 표현됩니다. 위 formatter와 동일한 변수를 사용합니다.
 *             disabled : function(){},// {Boolean|Function} -- formatter가 checkbox, radio인 경우 input의 disabled 값을 지정합니다. disabled(true|flase)를 반환하는 함수를 작성합니다. 아래 disabled 함수를 참고하세요.
 *             checked  : function(){} // {Boolean|Function} -- formatter가 checkbox, radio인 경우 input의 checked 값을 지정합니다. checked(true|flase)를 반환하는 함수를 작성합니다. 아래 checked 함수를 참고하세요.
 *         }
 *     ],
 *     colHead: { // 예제) http://dev.axisj.com/samples/AXGrid/colhead.html
 *         rows: [ // 컬럼 헤더를 병합할 수 있습니다. 사용법은 colGroup과 동일하며 key 대신 colSeq를 사용할 수 있습니다.
 *             [
 *                 {colSeq:0, rowspan:2},
 *                 {colSeq:null, colspan:3, label:"표현식", align:"center"},
 *                 {colSeq:4, rowspan:2, formatter: function(){} },
 *                 {colSeq:5, rowspan:2},
 *                 {colSeq:6, rowspan:2},
 *                 {colSeq:7, rowspan:2},
 *                 {colSeq:8, rowspan:2},
 *                 {colSeq:9, rowspan:2}
 *             ],
 *             [
 *                 {colSeq:1},
 *                 {colSeq:2},
 *                 {colSeq:3}
 *             ]
 *         ],
 *         onclick: function(){} // {Function} -- 그리드의 컬럼 헤드를 클릭시 발생하는 이벤트 입니다. 아래 onclick 함수를 참고하세요.
 *     },
 *     body: {
 *         marker: { // 그리드의 목록의 중간에 소계같은 원하는 데이터를 표현할 수 있습니다. 예제) http://dev.axisj.com/samples/AXGrid/marker.html
 *             display: function(){}, // {Function} -- marker 표시여부(true|flase)를 반환하는 함수를 작성합니다. 아래 display 함수를 참고하세요.
 *             rows: [] // marker를 표시할 형태를 정의 합니다. colHead의 rows와 동일한 형식을 사용합니다.
 *         },
 *         onclick       : function(){}, // 데이터 행의 click 이벤트를 정의합니다. 이벤트 변수 및 this 프로퍼티는 아래 onclick 함수를 참고하세요.
 *         ondblclick    : function(){}, // 데이터 행의 ondblclick 이벤트를 정의합니다. 이벤트 변수 및 this 프로퍼티는 아래 ondblclick 함수를 참고하세요.
 *         oncheck       : function(){}, // 데이터 행의 oncheck 이벤트를 정의합니다. 이벤트 변수 및 this 프로퍼티는 아래 oncheck 함수를 참고하세요.
 *         addClass      : function(){}, // 데이터 행의 사용자 정의 class를 할당할 수 있습니다.. 이벤트 변수 및 this 프로퍼티는 아래 addClass 함수를 참고하세요.
 *         onchangeScroll: function(){}, // 스크롤 변경 이벤트 입니다. 이벤트 변수 및 this 프로퍼티는 아래 onchangeScroll 함수를 참고하세요.
 *         onscrollend   : function(){}  // 그리드내의 스크롤이 마지막 항목까지 도달 하였을때 발생하는 이벤트를 설정할 수 있습니다. 이벤트 변수 및 this 프로퍼티는 아래 onscrollend 함수를 참고하세요.
 *     },
 *     foot: { // 그리드 마지막에 표시하는 행입니다. 예제) http://dev.axisj.com/samples/AXGrid/headfoot.html
 *         rows: [] // foot을 표시할 형태를 정의 합니다. colHead의 rows와 동일한 형식을 사용합니다.
 *     },
 *     page:{
 *         paging  : true, // {Boolean} -- 페이징 사용여부를 설정합니다.
 *         pageNo  : 1,    // {Number} -- 현재 페이지 번호를 설정합니다.
 *         pageSize: 100,  // {Number} -- 한 페이지장 표시할 데이터 수를 설정합니다.
 *         onchange: function(pageNo){} // {Funtion} -- 페이지 변경 이벤트입니다.
 *     },
 *     editor: { // 예제) http://localhost/axisj/samples/AXGrid/passive.html
 *         rows: [
 *             [
 *                 {
 *                     colSeq:0,
 *                     align:"center",
 *                     valign:"middle",
 *                     formatter: function(){},
 *                     form: {
 *                         type    : "readonly",  // {String} -- "hidden"|"text"|"readonly"|"textarea"|"select"|"radio"|"checkbox"
 *                         value   : "itemValue", // {String|Function} -- "itemValue"|"itemText": 해당 아이템의 값을 사용합니다. function을 사용해야 하는 경우 아래 formValue 함수를 참고하세요.
 *                         onClick : formOnClick, // {Function} -- 아래 formOnClick 함수를 참고하세요.
 *                         onBlur  : formOnBlur,  // {Function} -- 아래 formOnBlur  함수를 참고하세요.
 *                         onFocus : formOnFocus  // {Function} -- 아래 formOnFocus 함수를 참고하세요.
 *                         validate: function(formID, value){ // {Function} 입력된 값을 확인합니다.
 *                             //this.formID
 *                             //this.value
 *                             //this.checkedValues
 *                             //this.form
 *
 *                             return true | false;
 *                         }
 *                     },
 *                     AXBind:{
 *                         type  : "selector", // {String} -- form.type == "text"인 경우 "number"|"money"|"selector"|"slider"|"twinSlider"|"date"|"twinDate"|"dateTime"|"switch"를 사용할 수 있습니다. form.type == "select"인 경우 "select"를 사용할 수 있습니다.
 *                         config: {} // {Object} -- API(http://jdoc.axisj.com/jQueryExtends.html)에서 bind + type으로 검색하세요.
 *                     }
 *                 }
 *             ]
 *         ],
 *         request: {
 *             ajaxUrl :"saveGrid.php",
 *             ajaxPars:"param1=1&param2=2"
 *         },
 *         response: function(){ // ajax 응답에 대해 예외 처리 필요시 response 구현
 *             // response에서 처리 할 수 있는 객체 들
 *             //console.log({res:this.res, index:this.index, insertIndex:this.insertIndex, list:this.list, page:this.page});
 *             if(this.error){
 *                 console.log(this);
 *                 return;
 *             }
 *         },
 *         onkeyup: function(event, element){
 *             //this.list
 *             //this.item
 *             //this.element
 *         }
 *     },
 *     contextMenu: {} // API와 예제를 참고하세요. API) http://jdoc.axisj.com/AXContextMenu.html 예제) http://dev.axisj.com/samples/AXCore/AXContextMenu.html
 * });
     *
     * function formatter(itemIndex, item) {
 *     //this.index
 *     //this.list
 *     //this.item
 *     //this.page
 *     //this.key
 *     //this.value
 * }
     *
     * function disabled | checked() {
 *     //index: itemIndex,
 *     //list: this.list,
 *     //item: item,
 *     //page: this.page,
 *     //key: key,
 *     //value: value
 * }
     *
     * function display() {
 *     //this.index
 *     //this.list
 *     //this.item
 *     //this.page
 *
 *     return true | false;
 * }
     *
     * function onclick | ondblclick() {
 *     //this.index
 *     //this.r
 *     //this.c
 *     //this.list
 *     //this.colHead
 *     //this.page
 * }
     *
     * function addClass() {
 *     //this.index
 *     //this.item
 *     //this.list
 *     //this.page
 *
 *     return "red"|"green"|"blue"|"yellow"|"white"|"gray"; // 별도의 색상별 CSS를 추가로 정의해서 사용할 수 있습니다.
 * }
     *
     * function oncheck() {
 *     //this.index
 *     //this.checked
 *     //this.r
 *     //this.c
 *     //this.list
 *     //this.page
 * }
     *
     * function onchangeScroll(virtualScroll) {}
     *
     * function onscrollend() {
 *     //this.list
 *     //this.page
 * }
     *
     * function formOnClick | formOnBlur | formOnFocus() {
 *     //this.key
 *     //this.position
 *     //this.value
 * }
     *
     * function formValue(key, value) {
 *     //this.key
 *     //this.value
 *     //this.list
 *     //this.page
 * }
     *
     * ```
     */
    init: function () {
        var cfg = this.config, _this = this;

        if (Object.isUndefined(cfg.targetID)) {
            console.log("need targetID - setConfig({targetID:''})");
            return;
        }
        if (!cfg.colGroup) {
            console.log("need colGroup - setConfig({colGroup:[]})");
            return;
        }

        this.config.reserveKeys = Object.extend(this.reserveKeys, cfg.reserveKeys, true);

        if (typeof cfg.colHeadAlign == "undefined") {
            cfg.colHeadAlign = AXConfig.AXGrid.colHeadAlign;
        }
        cfg.emptyListMSG = cfg.emptyListMSG || AXConfig.AXGrid.emptyListMSG;
        cfg.listCountMSG = cfg.listCountMSG || AXConfig.AXGrid.listCountMSG || "전체 <b>{listCount}</b>개의 목록이 있습니다.";
        cfg.pageCountMSG = cfg.pageCountMSG || AXConfig.AXGrid.pageCountMSG;

        /*
         cfg.viewMode 결정 구간.
         */

        if (cfg.mediaQuery) {
            var _viewMode = "", clientWidth = axf.clientWidth();
            axf.each(cfg.mediaQuery, function (k, v) {
                if (Object.isObject(v)) {

                    if (v.min != undefined && v.max != undefined) {
                        if (v.min <= clientWidth && clientWidth <= v.max) {
                            _viewMode = (k == "dx") ? "grid" : "mobile";
                            return false;
                        }
                    }
                    else {
                        if (v.min <= clientWidth) {
                            _viewMode = (k == "dx") ? "grid" : "mobile";
                            return false;
                        }
                    }
                }
            });
            if (_viewMode != "") {
                cfg.viewMode = _viewMode;
            }
        }

        if (Object.isObject(cfg.colGroup)) {
            var newColGroup = cfg.colGroup.concat();
            cfg.colGroup = newColGroup;
        }

        this.target = axdom("#" + cfg.targetID);

        var targetInnerHeight = this.target.innerHeight();
        if (targetInnerHeight == 0) targetInnerHeight = (AXConfig.AXGrid.pageHeight.number() || 400);
        this.theme = (cfg.theme) ? cfg.theme : "AXGrid";
        /* 테마기본값 지정*/
        cfg.__height = cfg.height;
        cfg.height = (cfg.height) ? cfg.height : targetInnerHeight.number() + "px";

        /* 그리드 높이 지정 */

        var theme = this.theme;
        var gridCss = [];
        gridCss.push("overflow:hidden;");
        if (cfg.width) gridCss.push("width:" + cfg.width + ";");
        if (cfg.height) gridCss.push("height:" + cfg.height + ";");

        /* grid 뼈대 그리기 ----------------------------------------------------------------------------------------------------- */
        var ol = [];
        ol.push("<a id=\"" + cfg.targetID + "_AX_grid_focus\" href=\"#axtree\" ></a>");
        ol.push("<div class=\"" + theme + "\" id=\"" + cfg.targetID + "_AX_grid\" style=\"" + gridCss.join('') + "\">");
        ol.push("	<div class=\"AXgridScrollBody\" id=\"" + cfg.targetID + "_AX_gridScrollBody\" style=\"z-index:2;\">");
        ol.push("		<div class=\"AXGridColHead AXUserSelectNone\" id=\"" + cfg.targetID + "_AX_gridColHead\" onselectstart=\"return false;\"></div>");
        ol.push("		<div class=\"AXGridToolGroup top\" id=\"" + cfg.targetID + "_AX_gridToolGroupTop\"></div>");
        ol.push("		<div class=\"AXGridBody\" id=\"" + cfg.targetID + "_AX_gridBody\"></div>");
        ol.push("		<div class=\"AXGridToolGroup bottom\" id=\"" + cfg.targetID + "_AX_gridToolGroupBottom\"></div>");

        ol.push("<div id=\"" + cfg.targetID + "_AX_scrollTrackY\" class=\"gridScrollTrackY\">");
        ol.push("<div id=\"" + cfg.targetID + "_AX_scrollYHandle\" class=\"gridScrollHandle\"></div>");
        ol.push("<div id=\"" + cfg.targetID + "_AX_scrollY_AX_tip\" class=\"gridScroll-tip\"><span></span></div>");
        ol.push("</div>");
        ol.push("<div id=\"" + cfg.targetID + "_AX_scrollTrackX\" class=\"gridScrollTrackX\"><div id=\"" + cfg.targetID + "_AX_scrollXHandle\" class=\"gridScrollHandle\"></div></div>");

        ol.push("	</div>");
        ol.push("   <div class=\"AXgridEditor\" id=\"" + cfg.targetID + "_AX_gridEditor\" style=\"z-index:2;\"></div>");

        ol.push("	<div class=\"AXgridPageBody\" id=\"" + cfg.targetID + "_AX_gridPageBody\" style=\"z-index:1;\">");
        ol.push("		<div class=\"AXgridPagingUnit\" id=\"" + cfg.targetID + "_AX_gridPagingUnit\">");
        ol.push("			<a class=\"AXgridPagingPrev\">PREV</a>");
        ol.push("			<div class=\"AXgridPageNumber\"><select id=\"" + cfg.targetID + "_AX_gridPageNo\" class=\"AXgridPageNo\"><option value=\"\">&nbsp;&nbsp;</option></select></div>");
        ol.push("			<div class=\"AXgridPageNumberCount\" id=\"" + cfg.targetID + "_AX_gridPageCount\">/ ...</div>");
        ol.push("			<a class=\"AXgridPagingNext\">NEXT</a>");
        ol.push("		</div>");
        ol.push("		<div class=\"AXgridStatus\" id=\"" + cfg.targetID + "_AX_gridStatus\">");
        ol.push("		" + cfg.listCountMSG.replace("{listCount}", "0"));
        ol.push("		</div>");
        ol.push("	</div>");
        ol.push("</div>");
        this.target.html(ol.join(''));
        /* grid 뼈대 그리기 ----------------------------------------------------------------------------------------------------- */

        /* 주요 타깃 설정 */
        this.gridFocus = axdom("#" + cfg.targetID + "_AX_grid_focus");
        this.gridBody = axdom("#" + cfg.targetID + "_AX_grid");
        this.scrollBody = axdom("#" + cfg.targetID + "_AX_gridScrollBody");
        this.colHead = axdom("#" + cfg.targetID + "_AX_gridColHead");
        this.body = axdom("#" + cfg.targetID + "_AX_gridBody");

        this.scrollTrackY = axdom("#" + cfg.targetID + "_AX_scrollTrackY");
        this.scrollYHandle = axdom("#" + cfg.targetID + "_AX_scrollYHandle");
        this.scrollYTip = axdom("#" + cfg.targetID + "_AX_scrollY_AX_tip");
        this.scrollYTipSpan = axdom("#" + cfg.targetID + "_AX_scrollY_AX_tip").find("span");
        this.scrollTrackX = axdom("#" + cfg.targetID + "_AX_scrollTrackX");
        this.scrollXHandle = axdom("#" + cfg.targetID + "_AX_scrollXHandle");

        this.editor = axdom("#" + cfg.targetID + "_AX_gridEditor");

        this.pageBody = axdom("#" + cfg.targetID + "_AX_gridPageBody");
        this.pageBody.data("display", "show");
        this.pagingUnit = axdom("#" + cfg.targetID + "_AX_gridPagingUnit");
        this.status = axdom("#" + cfg.targetID + "_AX_gridStatus");
        //this.scroller = axdom("#" + cfg.targetID + "_AX_gridScroller");

        /* define part --------------------------------- */
        this.defineConfig();
        /* config object define */
        /* define part --------------------------------- */

        if (cfg.page) {
            this.page.pageNo = (cfg.page.pageNo || 1);
            this.page.pageSize = (cfg.page.pageSize || (AXConfig.AXGrid.pageSize || 100));
            this.page.onchange = cfg.page.onchange || this.page.onChange;
        }

        /*colHead setting */
        this.setColHead();

        /*body setting */
        this.setBody();

        /*editor setting */
        this.editor.hide();

        this.gridTargetSetSize();

        this.contentScrollResize();

        /* body event bind */
        var contentScrollTouchstart = this.contentScrollTouchstart.bind(this);
        this.contentScrollTouchstartBind = function (event) {
            contentScrollTouchstart(event);
        };
        /*
         var contentScrollScrollWheel = this.contentScrollScrollWheel.bind(this);
         this.contentScrollScrollWheelBind = function (event) {
         contentScrollScrollWheel(event);
         };
         */

        var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel";
        if (document.attachEvent) { /*if IE (and Opera depending on user setting) */
            /*axf.getId(cfg.targetID+"_AX_gridBody").detachEvent("on"+mousewheelevt, this.contentScrollScrollWheelBind); */
            if (axf.getId(cfg.targetID + "_AX_gridBody")) axf.getId(cfg.targetID + "_AX_gridBody").attachEvent("on" + mousewheelevt, (function (e) {
                this.contentScrollScrollWheel(e || window.event);
            }).bind(this));
        }
        else if (document.addEventListener) { /*WC3 browsers */
            /*axf.getId(cfg.targetID+"_AX_gridBody").removeEventListener(mousewheelevt, this.contentScrollScrollWheelBind, false); */
            if (axf.getId(cfg.targetID + "_AX_gridBody")) axf.getId(cfg.targetID + "_AX_gridBody").addEventListener(mousewheelevt, (function (e) {
                this.contentScrollScrollWheel(e || window.event);
            }).bind(this), false);
        }

        if (document.addEventListener) {
            /*axf.getId(cfg.targetID+"_AX_gridBody").removeEventListener("touchstart", this.contentScrollTouchstartBind, false); */
            if (axf.getId(cfg.targetID + "_AX_gridBody")) axf.getId(cfg.targetID + "_AX_gridBody").addEventListener("touchstart", contentScrollTouchstart, false);
        }

        //this.target.bind("keydown", this.onKeydown.bind(this));
        //keydown 이벤트 방식 변경
        this.target.bind("click.axgrid", (function (e) {
            if (this.editorOpend || this.inline_edit) return;
            var e = e || window.event;
            if (e.target.tagName == "INPUT" || e.target.tagName == "SELECT" || e.target.tagName == "TEXTAREA" || e.target.tagName == "BUTTON") return;
            this.gridFocus.focus();
        }).bind(this));

        this.gridFocus.unbind("keydown.axgrid").bind("keydown.axgrid", this.onKeydown.bind(this));

        if (cfg.contextMenu) {
            AXContextMenu.bind({
                id: cfg.targetID + "ContextMenu",
                theme: cfg.contextMenu.theme,
                width: cfg.contextMenu.width,
                menu: cfg.contextMenu.menu
            });
            this.target.bind("contextmenu", this.onContextmenu.bind(this));
        }

        /* body event bind */

        /* page event bind */
        var goPageMove = this.goPageMove.bind(this);
        this.pagingUnit.find(".AXgridPagingPrev").bind("click", function (event) {
            goPageMove(-1);
        });
        this.pagingUnit.find(".AXgridPagingNext").bind("click", function (event) {
            goPageMove(1);
        });
        /* page event bind */

        axdom(window).bind("resize", this.windowResizeApply.bind(this));

        //this.printList();  printList는 setBody 에서 자동 실행 됨
    },
    windowResize: function () {
        var windowResizeApply = this.windowResizeApply.bind(this);
        if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
        this.windowResizeObserver = setTimeout(function () {
            windowResizeApply();
        }, 100);
    },
    windowResizeApply: function () {
        var cfg = this.config;

        if (this.config.resizeable === false) return; // 2016-06-12 reisze 안되는 옵션 추가.

        if (cfg.mediaQuery) {
            var _viewMode = "", clientWidth = axf.clientWidth();
            axf.each(cfg.mediaQuery, function (k, v) {
                if (Object.isObject(v)) {

                    if (v.min != undefined && v.max != undefined) {
                        if (v.min <= clientWidth && clientWidth <= v.max) {
                            _viewMode = (k == "dx") ? "grid" : "mobile";
                            return false;
                        }
                    }
                    else {
                        if (v.min <= clientWidth) {
                            _viewMode = (k == "dx") ? "grid" : "mobile";
                            return false;
                        }
                    }
                }
            });
            if (_viewMode != "") {
                cfg.viewMode = _viewMode;
            }
        }
        this.redrawGrid(true);
    },
    gridTargetSetSize: function (react) { /* AXgridScrollBody 안쪽의 높이와 관련된 요소 설정 */
        var cfg = this.config;
        /*cfg.height */

        if (cfg.viewMode == "mobile") {

            this.target.css({height: "auto", "max-height": "auto"});
            this.gridBody.addClass("AXGridMobile");
            this.gridBody.css({height: "auto"});
            this.scrollBody.css({height: "auto"});
            this.body.css({top: "auto", height: "auto"});
            this.pageBody.hide();
            this.setPaging();

        }
        else {

            /*page setting */
            if (!cfg.page) {
                this.pageBody.hide();
                this.pageBody.data("display", "hide");
            }
            else {

                if (cfg.page.display == false) {
                    this.pageBody.hide();
                    this.pageBody.data("display", "hide");
                }
                else {
                    this.pageBody.show();
                    this.pageBody.data("display", "show");

                    if (cfg.page.paging) {
                        this.setPaging();
                    }
                    else {
                        this.pagingUnit.hide();
                    }
                    if (cfg.page.status == false) {
                        this.status.hide();
                    }
                }
            }

            this.gridBody.removeClass("AXGridMobile");

            if (cfg.__height == "auto") {
                var colHeadHeight = this.colHead.outerHeight();
                if (colHeadHeight == 1) colHeadHeight = 0;
                var scrollBodyHeight = this.scrollContent.height();
                this.scrollBody.css({height: scrollBodyHeight + colHeadHeight});
                /*colhead + body height */
                this.body.css({top: colHeadHeight, height: (scrollBodyHeight)});
                /* body Height */
                this.gridBody.css({height: "auto"});
                this.target.css({height: "auto", "max-height": "auto"});
            }
            else {
                if (cfg.height) this.gridBody.css({height: cfg.height});

                /// gridFoot - height 빼기 제거
                var pageBodyHeight = (this.pageBody.data("display") == "show") ? this.pageBody.outerHeight() : 0,
                    gridFootHeight = (cfg.foot) ? this.gridFoot.outerHeight() : 0;
                if (cfg.page.display == false) pageBodyHeight = 0;

                var scrollBodyHeight = cfg.height.number() - pageBodyHeight - 2; /// - gridFootHeight;
                this.scrollBody.css({height: scrollBodyHeight});

                var colHeadHeight = this.colHead.outerHeight();
                if (colHeadHeight == 1) colHeadHeight = 0;

                this.body.css({top: colHeadHeight, height: (scrollBodyHeight - colHeadHeight)});
                /* body Height */
            }
            if (react) this.contentScrollResize(false);
        }
    },
    resetHeight: function () {
        var cfg = this.config;
        var target = axdom("#" + cfg.targetID);

        if (cfg.viewMode != "mobile") {
            var targetInnerHeight = target.innerHeight();
            if (targetInnerHeight == 0) targetInnerHeight = 400;
            cfg.height = targetInnerHeight + "px"; // 그리드 높이 지정

            if (cfg.height && this.gridBody) this.gridBody.css({height: cfg.height});

            if (this.colHead)
            {
                this.redrawGrid();
                this.onevent_grid({type: "resetHeight"});
            }
            /*
             var pageBodyHeight = (this.pageBody.data("display") == "show") ? this.pageBody.outerHeight() : 0;
             if (cfg.page.display == false) pageBodyHeight = 0;
             var scrollBodyHeight = cfg.height.number() - pageBodyHeight - 2;
             this.scrollBody.css({ height: scrollBodyHeight });
             */

            /*
             var colHeadHeight = this.colHead.outerHeight();
             if (colHeadHeight == 1) colHeadHeight = 0;
             this.body.css({ top: colHeadHeight, height: (scrollBodyHeight - colHeadHeight) });

             this.contentScrollResize(false);
             */
        }
    },
    /**
     * @method AXGrid.setHeight
     * @param height {Number} - grid outerHeight
     * @description 그리드의 높이를 설정합니다. viewMode가 "mobile"인 경우는 작동하지 않습니다.
     * @returns {jQueryObject}
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.setHeight(600);
     * ```
     */
    setHeight: function (height) {
        var cfg = this.config;
        var target = axdom("#" + cfg.targetID);

        if (cfg.viewMode != "mobile" && typeof height == "number") {
            target.css({"height": height});
            this.resetHeight();
        }

        return target;
    },
    /**
     * @method AXGrid.getColGroup
     * @param suffix {String} - "CH" ColHead, "CB" ColBody, "EB" EditorBody, "FE" FixedEditorBody,"FB" FixedColBody,"FC" FixedColHead
     * @description ColGroup을 구성 합니다.
     * @returns {String} ColGroup html
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.getColGroup("CB");
     * ```
     */
    getColGroup: function (suffix) {
        var cfg = this.config;
        var fixedColSeq = this.fixedColSeq;
        /*{colID:0, key:"no", label:"번호", width:"100", align:"left", addClassNames:"", style:"", display:true, sort:null} */
        var po = [];
        po.push("<colgroup>");
        if (suffix != "FC" && suffix != "FB" && suffix != "FE") {
            for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                if (CG.display) {
                    po.push("<col width=\"" + CG.width + "\" style=\"\" id=\"" + cfg.targetID + "_AX_col_AX_" + CG.colSeq + "_AX_" + suffix + "\" />");
                }
            }

            if (suffix == "CB") po.push("<col />");
        }
        else {
            /*fixedCol 존재 */
            for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                if (CG.display && cidx < (fixedColSeq + 1)) {
                    po.push("<col width=\"" + CG.width + "\" style=\"\" id=\"" + cfg.targetID + "_AX_col_AX_" + CG.colSeq + "_AX_" + suffix + "\" />");
                }
            }

        }
        po.push("</colgroup>");
        return po.join('');
    },
    /**
     * @method AXGrid.getColSeqToHead
     * @param r {Number} - Row
     * @param c {Number} - Column
     * @description 대상의 colHead 내부 seq 가져옵니다.
     * @returns {Number} colSeq
     * @example
     * ```
     * var myGrid = new AXGrid();
     * var colSeq = myGrid.getColSeqToHead(colHeadR, colHeadC);
     * ```
     */
    getColSeqToHead: function (r, c) {
        /*console.log("getColSeqToHead:"+r+","+c); */
        var cfg = this.config;
        var colSeq = null;
        for (var a = cfg.colHead._maps[r].length - 1; a > -1; a--) {
            if (cfg.colHead._maps[r][a].r == r && cfg.colHead._maps[r][a].c == c) {
                colSeq = a;
                break;
            }
        }
        return colSeq;
    },
    /**
     * @method AXGrid.redrawGrid
     * @param changeGridView {string}
     * @description 그리드의 모든 요소를 재 정렬 해 줍니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.redrawGrid();
     * ```
     */
    redrawGrid: function (changeGridView) {
        var cfg = this.config, _this = this;
        /*
         모바일 모드로 요청 하면 뼈대 변경.
         */
        if (changeGridView) {
            if (cfg.viewMode == "grid") {
                this.pageBody.show();
                this.pageBody.data("display", "show");
            }
            else if (cfg.viewMode == "icon") {
                this.pageBody.show();
                this.pageBody.data("display", "show");
            }
            else if (cfg.viewMode == "mobile") {
                this.scrollTrackX.hide();
                this.scrollTrackY.hide();
                this.pageBody.hide();
                this.pageBody.data("display", "hide");
            }
        }

        if (typeof changeGridView == "undefined" || changeGridView) {
            this.defineConfig(true);
            this.setColHead();

            this.gridTargetSetSize(true);
            this.setBody(undefined, true);

            if (cfg.viewMode == "grid") {
                if (cfg.head) this.printHead();
                if (cfg.foot) {
                    this.printFoot();
                    this.contentScrollResize(false);
                }
            }
        }
        else {
            this.contentScrollResize();
        }

        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 바디 재구성 기능 포함 */
    },
    /**
     * @method AXGrid.checkedColSeq
     * @param {Number} colSeq - 대상 체크박스(formatter:"checkbox" 로 선언된 항목의 순서)
     * @param {Boolean} checked - true면 check , false면 uncheck
     * @param {Number} itemIndex - 대상 열(미 지정시 전체)
     * @description colgroup내 해당 index의 checked 속성을 변경해 줍니다.해당 index의 아이템이 checkbox로 지정되어 있어야 합니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.checkedColSeq(0, true); // 모든 체크박스 속성을 checked로
     * myGrid.checkedColSeq(0, true,0); // 첫번째 열의 체크박스속성을 checked로
     * ```
     */
    checkedColSeq: function (colSeq, checked, itemIndex) {

        var cfg = this.config, _this = this, sendObj;
        var _list = this.list;

        if (typeof itemIndex === "undefined") {
            this.colHead.find(".gridCheckBox_colHead_colSeq" + colSeq).each(function () {
                this.checked = checked;
            });
            axdom("#" + cfg.targetID + "_AX_fixedColHead").find(".gridCheckBox_colHead_colSeq" + colSeq).each(function () {
                this.checked = checked;
            });
            this.body.find(".gridCheckBox_body_colSeq" + colSeq).each(function () {
                if (axdom("#" + this.id).attr("disabled") != "disabled") {
                    this.checked = checked;
                }
            });
            for (var item, itemIndex = 0, __arr = this.list; (itemIndex < __arr.length && (item = __arr[itemIndex])); itemIndex++) {
                if (typeof item.___disabled == "undefined") item.___disabled = {};
                if (typeof item.___checked == "undefined") item.___checked = {};
                //cfg.colGroup[colSeq].checked.call({})
                var disabled = false;
                if (cfg.colGroup[colSeq].disabled) {
                    disabled = cfg.colGroup[colSeq].disabled.call({
                        index: itemIndex,
                        list: this.list,
                        item: item,
                        page: this.page,
                        key: cfg.colGroup[colSeq].key,
                        value: item[cfg.colGroup[colSeq].key]
                    });
                }
                if (!disabled) item.___checked[colSeq] = checked;
            }
            if (cfg.colGroup[colSeq].oncheck) {
                sendObj = {
                    index: colSeq,
                    list: _list
                };
                setTimeout(function () {
                    cfg.colGroup[colSeq].oncheck.call(sendObj, checked);
                }, 1);
            }
            if (cfg.body.oncheck) {
                sendObj = {
                    index: itemIndex,
                    checked: checked,
                    r: 0,
                    c: colSeq,
                    list: this.list,
                    page: this.page
                };
                //setTimeout(function() {
                cfg.body.oncheck.call(sendObj);
                //}, 1);
            }
        }
        else {
            if (cfg.colGroup[colSeq].formatter === "radio") {
                var ii = 0, ll = this.list.length;
                for (; ii < ll; ii++) {
                    if (typeof _this.list[ii].___checked === "undefined") _this.list[ii].___checked = {};
                    _this.list[ii].___checked[colSeq] = false;
                }
            }

            this.body.find(".gridBodyTr_" + itemIndex + " .gridCheckBox_body_colSeq" + colSeq).each(function () {
                if (checked == null) {
                    this.checked = !this.checked;
                }
                else {
                    this.checked = checked;
                }
            });

            var item = this.list[itemIndex];

            if (typeof item.___disabled === "undefined") item.___disabled = {};
            if (typeof item.___checked === "undefined") item.___checked = {};

            if (checked == null) {
                if (cfg.colGroup[colSeq].formatter === "radio") {
                    item.___checked[colSeq] = true;
                }
                else {
                    item.___checked[colSeq] = !(item.___checked[colSeq] == true);
                }
            }
            else {
                item.___checked[colSeq] = checked;
            }

            if (cfg.colGroup[colSeq].oncheck) {
                sendObj = {
                    index: checkboxIndex,
                    list: _list
                };
                //setTimeout(function() {
                cfg.colGroup[colSeq].oncheck.call(sendObj, checked);
                //}, 1);
            }
            if (cfg.body.oncheck) {
                sendObj = {
                    index: itemIndex,
                    checked: checked,
                    r: 0,
                    c: colSeq,
                    list: this.list,
                    item: item,
                    page: this.page
                };
                //setTimeout(function() {
                cfg.body.oncheck.call(sendObj, itemIndex, item);
                //}, 1);
            }
        }
        return this;
    },
    /**
     * @method AXGrid.getCheckedList
     * @param colSeq {Number} -대상 체크박스(formatter:"checkbox" 로 선언된 항목의 순서)
     * @description  Grid list 내의 checked 된 아이템을 반환합니다.해당 colSeq의 아이템이 checkbox|radio로 지정되어 있어야 합니다.
     * @returns {Array} JSObject - 그리드 리스트의 체크된 인덱스 아이템
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.getCheckedList(0);
     * ```
     */
    getCheckedList: function (colSeq) {
        var cfg = this.config;
        var collect = [];
        var list = this.list;

        for (var item, itemIndex = 0, __arr = this.list; (itemIndex < __arr.length && (item = __arr[itemIndex])); itemIndex++) {
            if (!item.___disabled) item.___disabled = {};
            if (!item.___checked) item.___checked = {};
            if (item.___disabled[colSeq] != true && item.___checked[colSeq] == true) {
                collect.push(item);
            }
        }

        return collect;
    },
    /**
     * @method AXGrid.getCheckedListWithIndex
     * @param colSeq {Number} -대상 체크박스(formatter:"checkbox" 로 선언된 항목의 순서)
     * @description  Grid list 내의 checked 된 아이템,index를 반환합니다.해당 colSeq의 아이템이 checkbox로 지정되어 있어야 합니다.
     * @returns {Array} [{index:Number, item:JSObject}] -그리드 리스트의 체크된 인덱스 , 아이템
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.getCheckedListWithIndex(0);
     * ```
     */
    getCheckedListWithIndex: function (colSeq) {
        var cfg = this.config;
        var collect = [];
        var list = this.list;

        for (var item, itemIndex = 0, __arr = this.list; (itemIndex < __arr.length && (item = __arr[itemIndex])); itemIndex++) {
            if (!item.___disabled) item.___disabled = {};
            if (!item.___checked) item.___checked = {};
            if (item.___disabled[colSeq] != true && item.___checked[colSeq] == true) {
                collect.push({index: itemIndex, item: item});
            }
        }
        return collect;
    },
    /**
     * @method AXGrid.onKeydown
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid 내부에서 감지되는 이벤트에 대한 처리를 합니다.(방향키로 포커스 이동등..)
     */
    onKeydown: function (event) {

        if (this.selectedRow.length == 0) return this;
        if (this.editorOpend) return this;
        if (this.inline_edit) return this;

        if (axdom(document.body).data("masked") === "true") return this;
        if (event.target) {
            if (event.target.tagName == "INPUT" || event.target.tagName == "TEXTAREA" || event.target.tagName == "SELECT" || event.target.tagName == "BUTTON") return this;
            if (event.target.id != this.config.targetID + "_AX_grid_focus" && event.target.tagName == "A") return this;
        }

        var _this = this, cfg = this.config, body = this.body,
            li, r, c;

        if (event.keyCode == 67 && event.ctrlKey) {
            // this.copyData();
        }

        if (event.keyCode == axf.Event.KEY_ESC) {
            this.selectClear();
        }
        else if (event.keyCode == axf.Event.KEY_RETURN) {
            li = this.selectedRow.first();
            c = this.selectedCells.first();
            if (cfg.colGroup[c].editor && cfg.control_lock_status < 1) {
                this.editCell(0, c, li);
                this.stopEvent(event);
            }
        }
        else if (event.keyCode == 65 && (event.ctrlKey || event.metaKey)) {

        }
        else if (!event.ctrlKey && !event.metaKey && !event.shiftKey && !event.altKey) {
            if (event.keyCode == axf.Event.KEY_UP) { /* */
                this.focusMove(-1, event);
            }
            else if (event.keyCode == axf.Event.KEY_DOWN) { /* */
                this.focusMove(1, event);
            }
            else if (event.keyCode == axf.Event.KEY_LEFT) { /* */
                this.focusMove("L", event);
            }
            else if (event.keyCode == axf.Event.KEY_RIGHT) { /* */
                this.focusMove("R", event);
            }
        }
        else if (event.shiftKey) {
            if (event.keyCode == axf.Event.KEY_UP) { /* */
                // todo 멀티 셀렉트 기능 작
            }
            else if (event.keyCode == axf.Event.KEY_DOWN) { /* */

            }
        }
    },
    /**
     * @method AXGrid.onContextmenu
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  setConfig에서 설정된 contextMenu에 대한 처리를 합니다.
     * @returns {AXContextMenu}
     * @example // 마우스 오른쪽 버튼 클릭시 메뉴를 호출 합니다.(추가,삭제,수정)
     * ```
     * var myGrid = new AXGrid();
     * myGrid.setConfig({
     *     targetID : "AXGridTarget",
     *     theme : "AXGrid",
     *     mediaQuery: {
     *         mx:{min:0, max:600}, dx:{min:600}
     *     },
     *     colGroup : [
     *         {key:"no", label:"번호", width:"40", align:"center", formatter:"money"}
     *     ],
     * 	    contextMenu: {
     * 		    theme:"AXContextMenu", // 선택항목
     * 		    width:"150", // 선택항목
     * 		    menu:[
     * 		    	{
     * 		    		userType:1, label:"추가하기", className:"plus", onclick:function(){
     * 		    			myGrid.appendList(null);
     * 		    		}
     * 		    	}
     * 		    ]
     * 	    }
     * });
     * ```
     */
    onContextmenu: function (event) {
        var cfg = this.config, body = this.body;

        if (this.readyMoved) return false;

        /* event target search - */
        //if (event.target.id == "") return;

        //console.log(event.target.tagName);

        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        if (eventTarget.tagName.toLowerCase() == "input") return;
        /*input 인 경우 제외 */
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            until: function (evt, evtIDs) {
                return (axdom(evt.parentNode).hasClass("gridBodyTr")) ? true : false;
            },
            find: function (evt, evtIDs) {
                return (axdom(evt).hasClass("bodyTd") || axdom(evt).hasClass("bodyNodeIndent")) ? true : false;
            }
        });

        /**
         * start jglee
         * 2015.12.15
         */
        if (this.isMobile && myTarget == null) {
            myTarget = this.getEventTarget({
                evt: eventTarget, evtIDs: eid,
                until: function (evt, evtIDs) {
                    return (axdom(evt.parentNode).hasClass("gridBodyDiv")) ? true : false;
                },
                find: function (evt, evtIDs) {
                    return (axdom(evt).hasClass("bodyViewMobile")) ? true : false;
                }
            });
        }
        /* end jglee */

        /* event target search ------------------------ */

        if (myTarget) {
            /*colHeadTool ready */
            var targetID = myTarget.id;
            var itemIndex = targetID.split(/_AX_/g).last();
            var ids = targetID.split(/_AX_/g);
            /*
             if (this.selectedCells.length > 0) {
             axf.each(this.selectedCells, function () {
             axdom("#" + this).removeClass("selected");
             });
             this.selectedCells.clear();
             }
             */

            if (this.selectedRow.length < 2) {
                if (this.selectedRow.length > 0) {
                    axf.each(this.selectedRow, function () {
                        body.find(".gridBodyTr_" + this).removeClass("selected");
                    });
                }
                this.selectedRow.clear();
                this.body.find(".gridBodyTr_" + itemIndex).addClass("selected");
                this.selectedRow.push(itemIndex);
            }
            else {
                var hasItem = false;
                axf.each(this.selectedRow, function () {
                    if (this == itemIndex) {
                        hasItem = true;
                    }
                });
                if (!hasItem) {
                    axf.each(this.selectedRow, function () {
                        body.find(".gridBodyTr_" + this).removeClass("selected");
                    });
                    this.selectedRow.clear();
                    this.body.find(".gridBodyTr_" + itemIndex).addClass("selected");
                    this.selectedRow.push(itemIndex);
                }
            }

            var item = this.list[itemIndex];
            AXContextMenu.open({
                id: cfg.targetID + "ContextMenu",
                filter: cfg.contextMenu.filter,
                sendObj: {item: item, index: itemIndex}
            }, event);
            /* event 직접 연결 방식 */
        }
        else {
            AXContextMenu.open({
                id: cfg.targetID + "ContextMenu",
                filter: cfg.contextMenu.filter,
                sendObj: null
            }, event);
            /* event 직접 연결 방식 */
        }
        return false;
    },
    copyData: function () {
        var cfg = this.config;
        var copyOut = [];
        axf.each(this.selectedCells, function (index, n) {
            var html = axdom("#" + n).find(".bodyNode").html();
            copyOut.push(html + '\t');
        });

        if (window.clipboardData) {
            window.clipboardData.setData('Text', copyOut.join(''));
            toast.push("데이터가 복사되었습니다. 원하시는 곳에 붙여넣기 하세요.");
        }
        else {
            dialog.push({title: "Copy Data", body: copyOut.join(''), type: "alert"});
        }
    },
    /* 공통 영역 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

    /* colHead 영역  */
    /**
     * @method AXGrid.getHeadMousePosition
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid head에서 event를 일으킨 마우스의 위치를 캡쳐 합니다.
     * @returns {Object} -(x좌표,y좌표)
     */
    getHeadMousePosition: function (event) {
        var pos = this.colHead.offset();
        var x = (event.pageX - pos.left);
        var y = (event.pageY - pos.top);
        return {x: x, y: y};
    },
    /**
     * @method AXGrid.getColHeadTd
     * @param {Object} arg
     * @description  Grid head를 위한 html을 생성합니다.
     * @returns {String}
     * @example
     * ```
     * // arg
     * {
	 * 	valign: " valign=\"bottom\"",    - td valign option string
	 * 	rowspan: " rowspan=\"2\"",  - rowspan option string
	 * 	colspan: " colspan=\"2\"",  - colspan option string
	 * 	bottomClass: "",  - border-bottom 관련 후처리
	 * 	r: 0, - colhead row index
	 * 	CHidx: 0, -colhead cell index
	 * 	align: "right", - align option string
	 * 	colSeq: 0, - config 에서 지정된 colGroup 내 순서
	 * 	formatter: "checkbox", - html 표시중 checkbox 등 특정 요소 렌더링
	 * 	formatterLabel: "" - checkbox 등 특정 요소를 감쌀 label 태그 내부 출력 내용,
	 * 	sort: "desc", -정렬옵션
	 * 	tdHtml: "blah", - config colGroup 의 label 로 지정된 string
	 * 	ghost: false,  - true 시 비어있는 dummy cell 이 생성됨.
	 * 	displayLabel: false - Label이 지정된 경우 출력 여부. 기본적으로 사용시 false 로 셋팅됨. colgroup 에서 따로 지정하지 않기 때문에,,
	 * }
     * ```
     */
    getColHeadTd: function (arg) {
        var cfg = this.config, po = [], colHeadTdText = " colHeadTdText",
            toolUse = true, sortClass = "";

        if (arg.formatter == "html" || arg.formatter == "checkbox") {
            if (!arg.displayLabel) {
                colHeadTdText = " colHeadTdHtml";
                toolUse = false;
                if (arg.formatter == "checkbox") {
                    colHeadTdText = " colHeadTdCheck";
                    arg.tdHtml = "<label>" +
                        "<input type=\"checkbox\" name=\"checkAll\" class=\"gridCheckBox gridCheckBox_colHead_colSeq" + arg.colSeq + "\" id=\"" + cfg.targetID + "_AX_checkAll_AX_" + arg.r + "_AX_" + arg.CHidx + "\" />" +
                        (arg.formatterLabel || "") +
                        "</label>";
                }
            }
        }

        if (arg.sort) sortClass = (arg.sort == "desc") ? " sortDesc" : " sortAsc";
        if (toolUse) toolUse = arg.colHeadTool;
        po.push("<td" + arg.valign + arg.rowspan + arg.colspan + " ");
        if (!arg.ghost) po.push("id=\"" + cfg.targetID + "_AX_colHead_AX_" + arg.r + "_AX_" + arg.CHidx + "\" ");
        po.push("class=\"colHeadTd" + arg.bottomClass + sortClass + "\" style=\"height:" + arg.tdHeight + "px;\">");
        po.push("<div class=\"tdRelBlock\" style=\"height:" + arg.tdHeight + "px;\">");
        po.push("<div class=\"colHeadNode" + colHeadTdText + "\" align=\"" + arg.align + "\" ");
        if (!arg.ghost) po.push("id=\"" + cfg.targetID + "_AX_colHeadText_AX_" + arg.r + "_AX_" + arg.CHidx + "\" ");
        po.push(">");
        po.push(arg.tdHtml);
        po.push("</div>");
        if (!arg.ghost && toolUse && arg.colSeq != null && arg.colSeq != undefined) po.push("<a href=\"#AXexec\" class=\"colHeadTool\" id=\"" + cfg.targetID + "_AX_colHeadTool_AX_" + arg.r + "_AX_" + arg.CHidx + "\">T</a>");
        if (!arg.ghost) po.push("<div class=\"colHeadResizer\" id=\"" + cfg.targetID + "_AX_colHeadResizer_AX_" + arg.r + "_AX_" + arg.CHidx + "\"></div>");
        po.push("</div>");
        po.push("</td>");

        if (!arg.ghotst && arg.sort) {
            var myColHead = cfg.colHead.rows[arg.r][arg.CHidx];
            var tdID = cfg.targetID + "_AX_colHead_AX_" + arg.r + "_AX_" + arg.CHidx;

            this.nowSortHeadID = tdID;
            this.nowSortHeadObj = myColHead;
        }

        return po.join('');
    },
    /**
     * @method AXGrid.setColHead
     * @description  Grid head를 디바이스(보기설정)에 맞춰 렌더링 합니다.(grid,icon,mobile)
     * @returns {String}
     */
    setColHead: function () {
        var cfg = this.config;
        var po = [];

        if (cfg.viewMode == "grid")
        {
            this.colHead.show();
            var getColHeadTd = this.getColHeadTd.bind(this);
            var _tdHeight = cfg.headTdHeight;

            //console.log(cfg.colHead.rows);

            if (!this.hasFixed)
            {  /* 일반 colHead 구현 */

                var tableWidth = this.colWidth;
                po.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"colHeadTable\" style=\"width:", tableWidth, "px;\">");
                po.push(this.getColGroup("CH"));
                /*colGroup 삽입 */
                po.push("<tbody>");
                for (var r = 0; r < cfg.colHead.rows.length; r++) {
                    var isLastTR = (cfg.colHead.rows.length - 1 == r);
                    po.push("<tr>");
                    for (var CH, CHidx = 0, __arr = cfg.colHead.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                        if (CH.display && CH.colspan > 0) {

                            /*radio, check exception */
                            var tdHtml = CH.label || "untitle";
                            var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                            var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                            var valign = " valign=\"" + CH.valign + "\"";
                            var bottomClass = (CH.isLastCell) ? "" : " colHeadBottomBorder";
                            if (CH.isTrLastChild) bottomClass += " isTrLastChild";

                            po.push(getColHeadTd({
                                valign: valign,
                                rowspan: rowspan,
                                colspan: colspan,
                                bottomClass: bottomClass,
                                r: r,
                                CHidx: CHidx,
                                align: (cfg.colHeadAlign || CH.align || "left"),
                                colSeq: CH.colSeq,
                                formatter: CH.formatter,
                                formatterLabel: CH.formatterLabel,
                                sort: CH.sort,
                                colHeadTool: CH.colHeadTool,
                                tdHtml: tdHtml,
                                ghost: false,
                                displayLabel: CH.displayLabel,
                                tdHeight: (function () {
                                    if (cfg.colHead.heights && cfg.colHead.heights[r]) {
                                        var tdHeight = 0;
                                        for (var i = r; i < r + (CH.rowspan); i++) {
                                            tdHeight += (cfg.colHead.heights[i] || 0);
                                        }
                                        return tdHeight;
                                    }
                                    else {
                                        return _tdHeight * (CH.rowspan || 1) + (CH.rowspan - 1);
                                    }
                                })()
                            }));
                        }
                    }
                    po.push("</tr>");
                }
                po.push("</tbody>");
                po.push("</table>");

            }
            else { /* fixedCol 구현 */

                po.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"colHeadTable\" style=\"width:" + this.colWidth + "px;\">");
                po.push(this.getColGroup("CH"));
                /*colGroup 삽입 */
                po.push("<tbody>");
                for (var r = 0; r < cfg.colHead.rows.length; r++) {
                    var isLastTR = (cfg.colHead.rows.length - 1 == r);
                    po.push("<tr>");
                    var colCount = 0;
                    axf.each(cfg.colHead.rows[r], function (CHidx, CH) {
                        if (CH.display && CH.colspan > 0) {
                            /*radio, check exception */
                            var tdHtml = CH.label || "untitle";
                            var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                            var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                            var valign = " valign=\"" + CH.valign + "\"";
                            var bottomClass = (CH.isLastCell) ? "" : " colHeadBottomBorder";

                            /*
                             po.push(getColHeadTd({
                             valign: valign, rowspan: rowspan, colspan: colspan, bottomClass: bottomClass, r: r, CHidx: CHidx,
                             align: CH.align, colSeq: CH.colSeq, formatter: CH.formatter, sort: CH.sort, tdHtml: tdHtml,
                             ghost: (colCount < (cfg.fixedColSeq + 1))
                             }));
                             */

                            po.push(getColHeadTd({
                                valign: valign,
                                rowspan: rowspan,
                                colspan: colspan,
                                bottomClass: bottomClass,
                                r: r,
                                CHidx: CHidx,
                                align: (cfg.colHeadAlign || CH.align || "left"),
                                colSeq: CH.colSeq,
                                formatter: CH.formatter,
                                formatterLabel: CH.formatterLabel,
                                sort: CH.sort,
                                colHeadTool: CH.colHeadTool,
                                tdHtml: tdHtml,
                                ghost: (colCount < (cfg.fixedColSeq + 1)),
                                tdHeight: (function () {
                                    if (cfg.colHead.heights && cfg.colHead.heights[r]) {
                                        var tdHeight = 0;
                                        for (var i = r; i < r + (CH.rowspan); i++) {
                                            tdHeight += (cfg.colHead.heights[i] || 0);
                                        }
                                        return tdHeight;
                                    }
                                    else {
                                        return _tdHeight * (CH.rowspan || 1) + (CH.rowspan - 1);
                                    }
                                })()
                            }));

                            colCount += CH.colspan;
                        }
                    });
                    po.push("</tr>");
                }
                po.push("</tbody>");
                po.push("</table>");

                var fpo = [];
                fpo.push("<div class=\"AXGridColHead fixedColHead\" id=\"" + cfg.targetID + "_AX_fixedColHead\" style=\"width:" + this.fixedColWidth + "px;\">");
                fpo.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"colHeadTable\" style=\"width:" + this.fixedColWidth + "px;\">");
                fpo.push(this.getColGroup("FC"));
                /*colGroup 삽입 */
                fpo.push("<tbody>");
                for (var r = 0; r < cfg.colHead.rows.length; r++) {
                    var isLastTR = (cfg.colHead.rows.length - 1 == r);
                    fpo.push("<tr>");
                    var colCount = 0;
                    axf.each(cfg.colHead.rows[r], function (CHidx, CH) {
                        if (CH.display && CH.isFixedCell && CH.colspan > 0) {
                            /*console.log({CHidx:CHidx, fixedColSeq:(cfg.fixedColSeq+1)}); */
                            /*radio, check exception */
                            var tdHtml = CH.label || "untitle";
                            var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                            var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                            var valign = " valign=\"" + CH.valign + "\"";
                            var bottomClass = (CH.isLastCell) ? "" : " colHeadBottomBorder";

                            fpo.push(getColHeadTd({
                                valign: valign,
                                rowspan: rowspan,
                                colspan: colspan,
                                bottomClass: bottomClass,
                                r: r,
                                CHidx: CHidx,
                                align: (cfg.colHeadAlign || CH.align || "left"),
                                colSeq: CH.colSeq,
                                formatter: CH.formatter,
                                formatterLabel: CH.formatterLabel,
                                sort: CH.sort,
                                colHeadTool: CH.colHeadTool,
                                tdHtml: tdHtml,
                                ghost: false,
                                tdHeight: (function () {
                                    if (cfg.colHead.heights && cfg.colHead.heights[r]) {
                                        var tdHeight = 0;
                                        for (var i = r; i < r + (CH.rowspan); i++) {
                                            tdHeight += (cfg.colHead.heights[i] || 0);
                                        }
                                        return tdHeight;
                                    }
                                    else {
                                        return _tdHeight * (CH.rowspan || 1) + (CH.rowspan - 1);
                                    }
                                })()
                            }));
                        }
                        colCount += CH.colspan;
                    });
                    fpo.push("</tr>");
                }
                fpo.push("</tbody>");
                fpo.push("</table>");
                fpo.push("</div>");
            }
            /* fixedCol 구현 */

            this.colHead.html(po.join(''));
            axdom("#" + cfg.targetID + "_AX_fixedColHead").remove();
            if (fpo) this.colHead.after(fpo.join(''));

            this.colHead.find(".colHeadResizer").each(function () {
                var resizerID = this.id;

                var tdID = resizerID.replace("colHeadResizer", "colHead");
                var txtID = resizerID.replace("colHeadResizer", "colHeadText");
                var toolID = resizerID.replace("colHeadResizer", "colHeadTool");

                var rowspan = axdom("#" + tdID).attr("rowspan");
                var valign = axdom("#" + tdID).attr("valign");
                var tdHeight = axdom("#" + tdID).height();
                var txtHeight = axdom("#" + txtID).outerHeight();

                axdom(this).css({height: tdHeight});

                var cellMarginTop = 0;
                if (valign == "bottom") cellMarginTop = (tdHeight - txtHeight) + 5;
                if (valign == "middle") cellMarginTop = (tdHeight - txtHeight) / 2 + 5;
                axdom("#" + txtID).css({"padding-top": cellMarginTop + "px"});
                axdom("#" + toolID).css({"top": (cellMarginTop - 5) + "px"});
            });

            if (cfg.hasAstricCol || cfg.fitToWidth) {
                this.colHead.find(".isTrLastChild").css({"background": "none"});
            }

            this.colHead.bind("mouseover", this.colHeadMouseOver.bind(this));
            this.colHead.bind("mouseout", this.colHeadMouseOut.bind(this));
            this.colHead.find(".colHeadNode").bind("click", this.colHeadNodeClick.bind(this));
            this.colHead.find(".colHeadTool").bind("click", this.colHeadToolClick.bind(this));
            this.colHead.find(".colHeadTool").bind("focus", function () {
                this.blur();
            });
            this.colHead.find(".colHeadResizer").bind("mousedown", this.colHeadResizerMouseDown.bind(this));
            this.colHead.find(".gridCheckBox").bind("click", this.colHeadCheckBoxClick.bind(this));

            if (this.hasFixed) { //fixedColHead에 대한 바인딩 및 처리
                this.fixedColHead = axdom("#" + cfg.targetID + "_AX_fixedColHead");
                this.fixedColHead.find(".colHeadResizer").each(function () {

                    var resizerID = this.id;

                    var tdID = resizerID.replace("colHeadResizer", "colHead");
                    var txtID = resizerID.replace("colHeadResizer", "colHeadText");
                    var toolID = resizerID.replace("colHeadResizer", "colHeadTool");

                    var rowspan = axdom("#" + tdID).attr("rowspan");
                    var valign = axdom("#" + tdID).attr("valign");
                    if (!rowspan) rowspan = 1;

                    var tdHeight = axdom("#" + tdID).height();
                    var txtHeight = axdom("#" + txtID).outerHeight();

                    axdom(this).css({height: tdHeight});

                    var cellMarginTop = 0;
                    if (valign == "bottom") cellMarginTop = (tdHeight - txtHeight) + 5;
                    if (valign == "middle") cellMarginTop = (tdHeight - txtHeight) / 2 + 5;
                    axdom("#" + txtID).css({"padding-top": cellMarginTop + "px"});
                    axdom("#" + toolID).css({"top": (cellMarginTop - 5) + "px"});
                });

                this.fixedColHead.bind("mouseover", this.colHeadMouseOver.bind(this));
                this.fixedColHead.bind("mouseout", this.colHeadMouseOut.bind(this));
                this.fixedColHead.find(".colHeadNode").bind("click", this.colHeadNodeClick.bind(this));
                this.fixedColHead.find(".colHeadTool").bind("click", this.colHeadToolClick.bind(this));
                this.fixedColHead.find(".colHeadResizer").bind("mousedown", this.colHeadResizerMouseDown.bind(this));
                this.fixedColHead.find(".gridCheckBox").bind("click", this.colHeadCheckBoxClick.bind(this));
            }

        }
        else if (cfg.viewMode == "icon")
        {
            this.colHead.empty();
            this.colHead.hide();
        }
        else if (cfg.viewMode == "mobile")
        { /* 모바일에서는 헤드 제거 또는 모바일용 헤드 재구성 */
            this.colHead.empty();
            this.colHead.hide();
        }
    },
    /* colHead events */
    /**
     * @method AXGrid.colHeadMouseOver
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid head에 마우스를 올렸을때 후처리를 합니다.(툴 박스 표시등)
     */
    colHeadMouseOver: function (event) {
        var cfg = this.config;
        /* event target search - */
        if (event.target.id == "") return;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            until: function (evt, evtIDs) {
                return (axdom(evt.parentNode).hasClass("AXGridColHead")) ? true : false;
            },
            find: function (evt, evtIDs) {
                return (axdom(evt).hasClass("colHeadTd")) ? true : false;
            }
        });
        /* event target search ------------------------ */

        if (myTarget) {
            /*colHeadTool ready */
            var targetID = myTarget.id;
            var toolID = targetID.replace("colHead", "colHeadTool");
            axdom("#" + toolID).addClass("readyTool");
        }
    },
    /**
     * @method AXGrid.colHeadMouseOut
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid head가 마우스 포커스를 잃었을때의 처리를 합니다.
     */
    colHeadMouseOut: function (event) {
        var cfg = this.config;
        /* event target search - */
        if (event.target.id == "") return;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            until: function (evt, evtIDs) {
                return (axdom(evt.parentNode).hasClass("AXGridColHead")) ? true : false;
            },
            find: function (evt, evtIDs) {
                return (axdom(evt).hasClass("colHeadTd")) ? true : false;
            }
        });
        /* event target search ------------------------ */

        if (myTarget) {
            /*colHeadTool unready */
            var targetID = myTarget.id;
            var toolID = targetID.replace("colHead", "colHeadTool");
            axdom("#" + toolID).removeClass("readyTool");
        }
    },
    /**
     * @method AXGrid.colHeadResizerMouseDown
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid head의 크기 조절 바 (|)를 마우스로 down(누른상태) 했을때의 처리를 합니다.
     */
    colHeadResizerMouseDown: function (event) {
        var cfg = this.config;
        if (event.target.id == "") return;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var lastIdx = eid.length - 1;
        var colHeadR = eid[lastIdx - 1];
        var colHeadC = eid[lastIdx];

        /*console.log({colHeadR:colHeadR, colHeadC:colHeadC}); */

        var colSeq = this.getColSeqToHead(colHeadR, colHeadC);
        if (colSeq == null) return;
        /* 예상할 수 없는 오류 */
        /*resize 상태 해제 */
        if (this.colResizing) {
            this.colHeadResizerEnd();
        }
        var offset = axdom("#" + cfg.targetID + "_AX_colHead_AX_" + colHeadR + "_AX_" + colHeadC).find(".tdRelBlock").position();
        var relBlockWidth = axdom("#" + cfg.targetID + "_AX_colHead_AX_" + colHeadR + "_AX_" + colHeadC).find(".tdRelBlock").width();
        var rightPosition = offset.left.number() + relBlockWidth.number();
        var blockWidth = axdom("#" + cfg.targetID + "_AX_col_AX_" + colSeq + "_AX_CH").attr("width");
        this.colResizeTarget = {
            colSeq: colSeq,
            leftPosition: (rightPosition - blockWidth),
            blockWidth: blockWidth,
            newWidth: blockWidth
        };
        /*console.log(this.colResizeTarget); */

        /* resize event bind */
        var colHeadResizerMouseMove = this.colHeadResizerMouseMove.bind(this);
        this.colHeadResizerMouseMoveBind = function (event) {
            colHeadResizerMouseMove(event);
        };
        var colHeadResizerMouseUp = this.colHeadResizerMouseUp.bind(this);
        this.colHeadResizerMouseUpBind = function (event) {
            colHeadResizerMouseUp(event);
        };
        axdom(document.body).bind("mousemove.AXGrid", this.colHeadResizerMouseMoveBind);
        axdom(document.body).bind("mouseup.AXGrid", this.colHeadResizerMouseUpBind);
        axdom(document.body).bind("mouseleave.AXGrid", this.colHeadResizerMouseUpBind);

        axdom(document.body).attr("onselectstart", "return false");
        //axdom(document.body).addClass("AXUserSelectNone");
        /* resize event bind ~~~~~~~~~~~~~~~~~~~ */

        // inline cell-editor 초기화
        if (this.inline_edit) {
            this.editCellClear();
        }
    },
    /**
     * @method AXGrid.colHeadResizerMouseMove
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid head의 크기 조절 바 (|)를 마우스로 drag(누른상태) 했을때 마우스 감도 처리를 합니다.
     */
    colHeadResizerMouseMove: function (event) {
        if (!event.pageX) return;
        /*드래그 감도 적용 */
        if (this.config.moveSens > this.moveSens) this.moveSens++;
        if (this.moveSens == this.config.moveSens) this.colHeadResizerMove(event);
    },
    /**
     * @method AXGrid.colHeadResizerMove
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid head의 크기 조절 바 (|)를 마우스로 drag(누른상태) 했을때의 처리를 합니다.
     */
    colHeadResizerMove: function (event) {
        var cfg = this.config;
        var mouse = this.getHeadMousePosition(event);
        var newWidth = (this.colResizeTarget.leftPosition - mouse.x).abs();
        if (newWidth < 31) return;

        /* colHead/colBody colGroup width 조정 */
        axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_CH").attr("width", newWidth);
        axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_CB").attr("width", newWidth);
        axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_EB").attr("width", newWidth);
        if (cfg.foot) {
            axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_FH").attr("width", newWidth);
        }

        cfg.colGroup[this.colResizeTarget.colSeq].width = newWidth;
        if (!cfg.colGroup[this.colResizeTarget.colSeq].widthAstric) {
            cfg.colGroup[this.colResizeTarget.colSeq]._owidth = newWidth;
        }

        if (this.hasFixed) {
            var fixedColSeq = this.fixedColSeq;

            axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_FC").attr("width", newWidth);
            axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_FB").attr("width", newWidth);
            axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_FE").attr("width", newWidth);
            if (cfg.foot) {
                axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_FF").attr("width", newWidth);
            }

            /*if(this.colResizeTarget.colSeq < fixedColSeq+1){ */

            var fixedColWidth = 0;
            for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                if (CG.display && cidx < (fixedColSeq + 1)) {
                    fixedColWidth += CG.width.number();
                }
            }

            this.fixedColWidth = fixedColWidth;

            axdom("#" + cfg.targetID + "_AX_fixedColHead").css({width: fixedColWidth});
            axdom("#" + cfg.targetID + "_AX_fixedColHead").find(".colHeadTable").css({width: fixedColWidth});
            this.fixedScrollContent.css({width: fixedColWidth});
            this.fixedScrollContent.find(".gridFixedBodyTable").css({width: fixedColWidth});
            axdom("#" + cfg.targetID + "_AX_fixedEditorContent").css({width: fixedColWidth});
            axdom("#" + cfg.targetID + "_AX_fixedEditorContent").find(".gridFixedBodyTable").css({width: fixedColWidth});
            /*} */

        }

        if (this.editorOpend) {
            var colSeq = this.colResizeTarget.colSeq;
            /* */
            for (var _m = 0; _m < cfg.editor._maps.length; _m++) {
                var rc = cfg.editor._maps[_m][colSeq];
                var CH = cfg.editor.rows[rc.r][rc.c];
                var formID = (CH.form.id) ? CH.form.id : cfg.targetID + "_AX_" + CH.key + "_AX_" + rc.r + "_AX_" + rc.c;
            }
            AXInput.alignAllAnchor();
        }

        /* colHead colGroup width 조정 ------------------------------ */
        this.colResizeTarget.newWidth = newWidth;
        var newColWidth = this.colWidth - (this.colResizeTarget.blockWidth - this.colResizeTarget.newWidth);
        this.colHead.find(".colHeadTable").css({"width": newColWidth + "px"});
        /*this.body.find(".gridBodyTable").css({"width":newColWidth+"px"}); */
    },
    /**
     * @method AXGrid.colHeadResizerMouseUp
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid head의 크기 조절 바 (|)를 마우스로 drag 상태가 해제 되었을때의 처리를 합니다.
     */
    colHeadResizerMouseUp: function (event) {
        if (this.colResizeTarget.blockWidth != this.colResizeTarget.newWidth) {
            this.colWidth = this.colWidth - (this.colResizeTarget.blockWidth - this.colResizeTarget.newWidth);
        }
        this.colHeadResizerEnd();
        this.contentScrollResize(false);
    },
    /**
     * @method AXGrid.colHeadResizerEnd
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid head의 크기 조절 바 (|)를 마우스로 drag 상태가 해제 되었을때의 처리를 합니다.
     */
    colHeadResizerEnd: function () {
        this.moveSens = 0;
        this.colResizing = false;
        axdom(document.body).unbind("mousemove.AXGrid");
        axdom(document.body).unbind("mouseup.AXGrid");
        axdom(document.body).unbind("mouseleave.AXGrid");

        axdom(document.body).removeAttr("onselectstart");
        //axdom(document.body).removeClass("AXUserSelectNone");

        if (window.AXInput) AXInput.alignAllAnchor();
    },
    /**
     * @method AXGrid.colHeadNodeClick
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid head를 클릭 했을때의 처리를 합니다(체크박스처리,정렬등).
     */
    colHeadNodeClick: function (event) {
        var cfg = this.config;
        if (event.target.id == "") return;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;

        if (this.editorOpend) {
            toast.push("Editor 활성화 상태에서는 기능을 사용할 수 없습니다.");
            return;
            /* 에디터가 오픈된 상태이면 비활성화 */
        }

        if (axdom(eventTarget).hasClass("colHeadTdCheck")) {
            this.colHeadCheckBoxClick(event);
            return this;
            /* checkbox block click */
        }
        if (axdom(eventTarget).hasClass("gridCheckBox")) return;
        /* checkbox click */

        var lastIdx = eid.length - 1;
        var colHeadR = eid[lastIdx - 1];
        var colHeadC = eid[lastIdx];

        try {
            var myColHead = cfg.colHead.rows[colHeadR][colHeadC];
        } catch (e) {
            return;
        }

        if (cfg.sort == false || myColHead.sort == false) {
            return;
        }

        var tdID = cfg.targetID + "_AX_colHead_AX_" + colHeadR + "_AX_" + colHeadC;

        if (myColHead.colSeq == undefined || myColHead.colSeq == null) {
            console.log("정렬할 수 없는 컬럼 입니다.");
        }
        else {
            if (this.nowSortHeadID) {
                if (this.nowSortHeadID != tdID) {
                    axdom("#" + this.nowSortHeadID).removeClass("sortDesc");
                    axdom("#" + this.nowSortHeadID).removeClass("sortAsc");
                    this.nowSortHeadObj.sort = undefined;
                }
            }
            if (cfg.colHead.rows[colHeadR][colHeadC].sort == "desc") axdom("#" + tdID).removeClass("sortDesc");
            else axdom("#" + tdID).removeClass("sortAsc");

            var nsort = "";
            if (myColHead.sort == "desc") nsort = "asc";
            else nsort = "desc";
            cfg.colHead.rows[colHeadR][colHeadC].sort = nsort;
            //console.log(colHeadR, colHeadC,  cfg.colHead.rows[colHeadR][colHeadC].sort);
            //sort 처리하기
            if (nsort == "desc") {
                axdom("#" + tdID).addClass("sortDesc");
            }
            else {
                axdom("#" + tdID).addClass("sortAsc");
            }

            this.nowSortHeadID = tdID;
            this.nowSortHeadObj = myColHead;

            var ai = this.ajaxInfo;
            if (ai && cfg.remoteSort) {
                if (!ai.ajaxPars) {
                    ai.ajaxPars = this.getSortParam("one");
                }
                else if (Object.isString(ai.ajaxPars)) {
                    ai.ajaxPars = $.extend(ai.ajaxPars.dec().queryToObject(), this.getSortParam("one").queryToObject());
                }
                else if (Object.isObject(ai.ajaxPars)) {
                    ai.ajaxPars = $.extend(ai.ajaxPars, this.getSortParam("one").queryToObject());
                }

                this.reloadList();
            }
            else {
                this.list = this.sortList(nsort, myColHead, this.list);
                this.printList({sort: true});
                this.contentScrollResize();
            }

        }

        if (cfg.colHead.onclick) { /* onclick    bind */
            var sendObj = {
                index: null,
                r: colHeadR,
                c: colHeadC,
                list: this.list,
                colHead: myColHead,
                page: this.page
            };
            cfg.colHead.onclick.call(sendObj);
        }

    },
    /**
     * @method AXGrid.colHeadToolClick
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid head 우측의 도구 박스를 클릭 했을때의 처리를 합니다(ColGroupListBox 팝업).
     * @returns {String}
     */
    colHeadToolClick: function (event) {
        var cfg = this.config;
        if (event.target.id == "") return;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;

        if (this.editorOpend) {
            toast.push("Editor 활성화 상태에서는 기능을 사용할 수 없습니다.");
            return;
            //에디터가 오픈된 상태이면 비활성화
        }

        var lastIdx = eid.length - 1;
        var colHeadR = eid[lastIdx - 1];
        var colHeadC = eid[lastIdx];
        var myColHead = cfg.colHead.rows[colHeadR][colHeadC];

        axdom("#" + cfg.targetID + "_AX_colHeadMenu").remove();

        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_colHeadMenu\" class=\"AXGridColGroupListBox\">");
        for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
            var addClass = (CG.display) ? " on" : "";
            var lastClass = (cidx == cfg.colGroup.length - 1) ? " last" : "";
            po.push("<a href=\"#AXexec\" class=\"AXGridColGroupListBoxItem" + addClass + lastClass + "\" id=\"" + cfg.targetID + "_AX_colHeadMenu_AX_" + CG.colSeq + "\">");
            po.push(CG.label);
            po.push("</a>");
        }

        po.push("</div>");
        axdom(document.body).append(po.join(''));

        var offset = axdom(eventTarget).offset();
        var css = {};
        css.top = offset.top - 5;
        css.left = offset.left - 20;
        axdom("#" + cfg.targetID + "_AX_colHeadMenu").css(css);

        /* colGroup click event bind */
        var colGroupListClick = this.colGroupListClick.bind(this);
        this.colGroupListClickBind = function (event) {
            colGroupListClick(event);
        };
        axdom(document).bind("click", this.colGroupListClickBind);
        axdom(document).bind("keydown", this.colGroupListClickBind);
        /* colGroup click bind ~~~~~~~~~~~~~~~~~~~ */
    },
    /**
     * @method AXGrid.colGroupListClick
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  colHeadToolClick 에서 호출된 ColGroupListBox의 아이템을 클릭했을때의 처리를 합니다.
     * @returns {String}
     */
    colGroupListClick: function (event) {
        var cfg = this.config;

        if (event.keyCode == AXUtil.Event.KEY_ESC) {
            axdom("#" + cfg.targetID + "_AX_colHeadMenu").remove();
            axdom(document).unbind("keydown", this.colGroupListClickBind);
            axdom(document).unbind("click", this.colGroupListClickBind);
            return;
        }

        // event target search
        if (event.target.id == "") return;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            find: function (evt, evtIDs) {
                return (axdom(evt).hasClass("AXGridColGroupListBoxItem") || axdom(evt).hasClass("colHeadTool")) ? true : false;
            }
        });

        if (myTarget) {
            if (axdom(myTarget).hasClass("colHeadTool")) return;
            //colHeadTool ready
            var targetID = myTarget.id;
            var colSeq = targetID.split(/_AX_/g).last();
            if (cfg.colGroup[colSeq].display) {
                cfg.colGroup[colSeq].display = false;
                axdom("#" + targetID).removeClass("on");
            }
            else {
                cfg.colGroup[colSeq].display = true;
                axdom("#" + targetID).addClass("on");
            }
            if (cfg.editor) {
                for (var r = 0; r < cfg.editor.rows.length; r++) {
                    cfg.editor.rows[r][colSeq].display = !cfg.editor.rows[r][colSeq].display;
                }
            }
            //redraw grid
            this.redrawGrid("all");

        }
        else {

            axdom("#" + cfg.targetID + "_AX_colHeadMenu").remove();
            axdom(document).unbind("keydown", this.colGroupListClickBind);
            axdom(document).unbind("click", this.colGroupListClickBind);
        }
    },
    /**
     * @method AXGrid.colHeadCheckBoxClick
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid head checkbox를 클릭했을때의 처리를 합니다.
     */
    colHeadCheckBoxClick: function (event) {
        var cfg = this.config;
        if (event.target.id == "") return;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;

        if (axdom(eventTarget).hasClass("colHeadTdCheck")) {
            eventTarget = axdom(eventTarget).find("input").get(0);
            eventTarget.checked = !eventTarget.checked;
        }
        var lastIdx = eid.length - 1;
        var colHeadR = eid[lastIdx - 1];
        var colHeadC = eid[lastIdx];
        var myColHead = cfg.colHead.rows[colHeadR][colHeadC];

        this.checkedColSeq(myColHead.colSeq, eventTarget.checked);
    },
    /* colHead events ~~~~~~~~~~~~~~~~~*/
    /* colHead 영역  ~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

    /* body 영역 */
    needBindDBLClick: function () {
        return ((axf.browser.name == "ie") && (axf.docTD === "Q" || axf.browser.version < 9));
    },
    /**
     * @method AXGrid.sortList
     * @param nsort {String} -  "desc","asc"
     * @param myColHead {Object} - cfg.colHead.rows[colHeadR][colHeadC]  대상이 될 Grid head node
     * @param list {Object} - Grid list Object
     * @description  그리드의 리스트를 정렬 합니다.
     * @returns {Object}  - Grid list
     * @example
     * ```
     * var myGrid = new AXGrid();
     * // Array
     * myGrid.setList({Array});
     * ...
     * myGrid.sortList("desc",myGrid.cfg.colHead.rows[0][0],myGrid.list);
     * ```
     */
    sortList: function (nsort, myColHead, list) {
        var cfg = this.config;
        var _this = this;
        var getValueForSort = function (item, itemIndex) {
            if (myColHead.formatter) {
                var result;
                if (myColHead.formatter == "money") {
                    result = item[myColHead.key];
                }
                else if (myColHead.formatter == "dec") {
                    result = (item[myColHead.key] == undefined) ? "" : item[myColHead.key].dec();
                }
                else if (myColHead.formatter == "html") {
                    result = item[myColHead.key];
                }
                else if (myColHead.formatter == "checkbox" || myColHead.formatter == "radio") {
                    result = item[myColHead.key];
                }
                else {
                    var sendObj = {
                        index: itemIndex,
                        list: list,
                        item: item,
                        page: _this.page,
                        key: myColHead.key,
                        value: item[myColHead.key]
                    };
                    result = myColHead.formatter.call(sendObj, itemIndex, item) || "";
                    //result 값이 money 형식인지 체크 합니다.
                    var moneyCheck = (Object.isString(result)) ? result.replace(/,/g, "") : result;
                    if (axdom.isNumeric(moneyCheck)) result = result.number();
                }
                return result;
            }
            else {
                return item[myColHead.key] || "";
            }
        };

        if (nsort == "desc") {
            var listIndex = 0;
            list = list.sort(function (prevItem, nowItem) {
                var v1 = getValueForSort(prevItem, listIndex);
                var v2 = getValueForSort(nowItem, listIndex);
                listIndex++;
                if (v1 < v2) return 1;
                else if (v1 > v2) return -1;
                else if (v1 == v2) return 0;
            });
        }
        else {
            var listIndex = 0;
            list = list.sort(function (prevItem, nowItem) {
                var v1 = getValueForSort(prevItem, listIndex);
                var v2 = getValueForSort(nowItem, listIndex);
                listIndex++;
                if (v1 < v2) return -1;
                else if (v1 > v2) return 1;
                else if (v1 == v2) return 0;
            });
        }

        return list;
    },
    /**
     * @method AXGrid.setBody
     * @param list {Object} - Grid list Object
     * @param rewrite {Boolean} - true or false
     * @description  그리드의 몸통을 렌더링 합니다.
     */
    setBody: function (list, rewrite) {
        var cfg = this.config;
        if (list) {
            this.list = list;
        }
        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_scrollContent\" class=\"gridScrollContent\">");
        if (cfg.viewMode == "grid") {
            po.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"gridBodyTable\"  id=\"" + cfg.targetID + "_AX_gridBodyTable\">");
            po.push(this.getColGroup("CB"));
            /*colGroup 삽입 */
            po.push("<thead id=\"" + cfg.targetID + "_AX_thead\"></thead>");
            po.push("<tbody id=\"" + cfg.targetID + "_AX_hpadding\"><tr class='thpadding'><td colspan=\"" + (this.showColLen.number() + 1) + "\"></td></tr></tbody>");
            po.push("<tbody id=\"" + cfg.targetID + "_AX_tbody\">");
            po.push("<tr class=\"noListTr\">");
            po.push("<td colspan=\"" + (this.showColLen) + "\">");
            po.push("<div class=\"tdRelBlock\">");
            po.push("<div class=\"bodyNode bodyTdText\" align=\"center\">");
            po.push(cfg.emptyListMSG);
            po.push("</div>");
            po.push("</div>");
            po.push("</td>");
            po.push("<td class=\"bodyNullTd\"><div class=\"tdRelBlock\">&nbsp;</div></td>");
            po.push("</tr>");
            po.push("</tbody>");
            po.push("<tbody id=\"" + cfg.targetID + "_AX_tfoot\"></tbody>");
            po.push("<tbody id=\"" + cfg.targetID + "_AX_fpadding\"><tr class='tfpadding'><td colspan=\"" + (this.showColLen.number() + 1) + "\"></td></tr></tbody>");

            po.push("</table>");
        }
        else if (cfg.viewMode == "icon")
        {
            po.push("<div class=\"gridBodyDiv\" id=\"" + cfg.targetID + "_AX_gridBodyDiv\"></div>");
        }
        else if (cfg.viewMode == "mobile")
        {
            po.push("<div class=\"gridBodyDiv\" id=\"" + cfg.targetID + "_AX_gridBodyDiv\"></div>");
        }
        po.push("</div>");

        // trace(cfg.viewMode == "grid", this.hasFixed, (rewrite && this.list.length > 0), rewrite);

        //if (cfg.viewMode == "grid" && this.hasFixed && ((rewrite && this.list.length > 0) || !rewrite)) {
        if (cfg.viewMode == "grid" && this.hasFixed && (rewrite || typeof rewrite === "undefined")) {
            po.push("<div id=\"" + cfg.targetID + "_AX_fixedScrollContent\" class=\"gridFixedScrollContent\" style=\"width:" + this.fixedColWidth + "px;\">");
            po.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"gridFixedBodyTable\" style=\"width:" + this.fixedColWidth + "px;\">");
            po.push(this.getColGroup("FB"));
            /*colGroup 삽입 */
            po.push("<thead id=\"" + cfg.targetID + "_AX_fixedThead\"></thead>");
            po.push("<tbody id=\"" + cfg.targetID + "_AX_fhpadding\"><tr class='thpadding'><td colspan=\"" + (this.showFixedColLen) + "\"></td></tr></tbody>");
            po.push("<tbody id=\"" + cfg.targetID + "_AX_fixedTbody\">");
            po.push("<tr class=\"noListTr\">");
            po.push("<td colspan=\"" + (this.showFixedColLen) + "\"></td>");
            po.push("</tr>");
            po.push("</tbody>");

            po.push("<tbody id=\"" + cfg.targetID + "_AX_fixedTfoot\"></tbody>");
            po.push("<tbody id=\"" + cfg.targetID + "_AX_ffpadding\"><tr class='tfpadding'><td colspan=\"" + (this.showFixedColLen) + "\"></td></tr></tbody>");
            po.push("</table>");
            po.push("</div>");
        }

        if (cfg.viewMode == "grid" || cfg.viewMode == "icon") {
            po.push("<div class=\"AXGridFoot\" id=\"" + cfg.targetID + "_AX_gridFoot\"></div>");
            //po.push("<div id=\"" + cfg.targetID + "_AX_scrollTrackXY\" class=\"gridScrollTrackXY\"></div>");
        }
        this.body.html(po.join(''));

        this.gridFoot = axdom("#" + cfg.targetID + "_AX_gridFoot"); /// gridFoot 위치 변경 및 캐쉬순서 변경
        this.scrollContent = axdom("#" + cfg.targetID + "_AX_scrollContent");

        // tbody, fixedTbody dom cached
        if (cfg.viewMode == "grid") {
            // this.cachedDom.tbody, this.cachedDom.fixed_tbody, this.cachedDom.thpadding, this.cachedDom.tfpadding 윗마진 아래마진
            this.cachedDom.tbody = axdom("#" + cfg.targetID + "_AX_tbody");
            if (this.hasFixed) this.cachedDom.fixed_tbody = axdom("#" + cfg.targetID + "_AX_fixedTbody");
            this.cachedDom.thpadding = axdom("#" + cfg.targetID + "_AX_hpadding").find("td");
            this.cachedDom.tfpadding = axdom("#" + cfg.targetID + "_AX_fpadding").find("td");
            if (this.hasFixed) {
                this.cachedDom.fthpadding = axdom("#" + cfg.targetID + "_AX_fhpadding").find("td");
                this.cachedDom.ftfpadding = axdom("#" + cfg.targetID + "_AX_ffpadding").find("td");
            }
        }

        this.fixedScrollContent = axdom("#" + cfg.targetID + "_AX_fixedScrollContent");
        cfg.scrollContentBottomMargin = 2;

        if (this.list.length > 0) {
            var _this = this;
            if (typeof list === "undefined") {
                _this.setList(_this.list, true, "reload");
            }
            else {
                setTimeout(function () {
                    _this.setList(_this.list);
                }, 100);
            }
        }

        if (cfg.viewMode == "grid" || cfg.viewMode == "icon") {
            /* scroll event bind */
            // bind scroll tip
            this.scrollYHandle.unbind("mouseover").bind("mouseover", this.contentScrollTipOver.bind(this));
            this.scrollYHandle.unbind("mousedown").bind("mousedown", this.contentScrollScrollReady.bind(this));
            this.scrollXHandle.unbind("mousedown").bind("mousedown", this.contentScrollScrollReady.bind(this));
            /* scroll event bind ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
        }
    },
    /**
     * @method AXGrid.listLoadingDisplay
     * @description  그리드의 데이터 처리중 표시를 표현 합니다.
     */
    listLoadingDisplay: function () {
        var cfg = this.config;
        var po = [];

        if (cfg.viewMode != "mobile") {
            po.push("<tr class=\"noListTr\">");
            po.push("<td colspan=\"" + (this.showColLen) + "\">");
            po.push("<div class=\"tdRelBlock\">");
            po.push("<div class=\"bodyNode bodyTdText\" align=\"center\">");
            po.push("	<div class=\"AXLoading\"></div>");
            po.push("</div>");
            po.push("</div>");
            po.push("</td>");
            po.push("<td class=\"bodyNullTd\"><div class=\"tdRelBlock\">&nbsp;</div></td>");
            po.push("</tr>");
            axdom("#" + cfg.targetID + "_AX_tbody").html(po.join(''));
            po = [];
            po.push("<tr class=\"noListTr\">");
            po.push("<td colspan=\"" + (this.showColLen) + "\">");
            po.push("</td>");
            po.push("</tr>");
            axdom("#" + cfg.targetID + "_AX_fixedTbody").html(po.join(''));
        }
        else {
            if (cfg.viewMode == "grid") {
                this.scrollContent.css({top: 0});
                this.contentScrollContentSync({top: 0});
            }
            po.push("	<div class=\"AXLoading\"></div>");
            axdom("#" + cfg.targetID + "_AX_gridBodyDiv").empty();
            axdom("#" + cfg.targetID + "_AX_gridBodyDiv").append(po.join(''));
        }
    },
    /**
     * @method AXGrid.setList
     * @param obj {JSObject}
     * @param sortDisable
     * @param rewrite
     * @param exts
     * @description 그리드에 데이터를 선언하거나 AJAX url 속성을 정의합니다.
     * @example
     * ```
     * // Array
     * myGrid.setList({Array});
     *
     * // AJAX url 속성
     * myGrid.setList({
	 *  //method :
	 *  //contentType :
	 *  //responseType :
	 *  //dataType :
	 *  //headers :
	 *  //debug :
	 *  //ajaxUrl :
	 *  //ajaxPars :
	 *  //onLoad :
	 *  //onError :
	 *  ajaxUrl:"loadGrid.php",
	 *  ajaxPars:"param1=1&param2=2", // {String|Object}
	 *  onLoad:function(){
	 *
	 *  }
     * });
     * ```
     */
    setList: function (obj, sortDisable, rewrite, exts) {
        var cfg = this.config, _this = this;
        var nowSortHeadID = this.nowSortHeadID;
        var nowSortHeadObj = this.nowSortHeadObj;

        this.listLoadingDisplay();

        /*this.selectedCells.clear(); */
        /*this.selectedRow.clear(); */

        if (obj.ajaxUrl) {
            /*console.log("hear");	 */
            this.ajaxInfo = obj;
            this.ajax_sortDisable = sortDisable;
            this.pageActive = true;

            var url = obj.ajaxUrl;
            var appendPars = [
                "pageNo=" + ((exts == "paging") ? this.page.pageNo : 1),
                "pageSize=" + this.page.pageSize
            ];

            // 기본 소팅정보
            if (cfg.remoteSort) {
                var sortParam = this.getSortParam("one");
                if (sortParam) {
                    appendPars.push(sortParam);
                }
            }

            if (Object.isString(obj.ajaxPars)) {
                appendPars.push(obj.ajaxPars);
            }
            else if (Object.isObject(obj.ajaxPars)) {
                appendPars.push(axdom.param(obj.ajaxPars));
            }
            var pars = appendPars.join('&');

            var _method = "post";
            var _contentType = AXConfig.AXReq.contentType;
            var _headers = {};
            var _responseType = AXConfig.AXReq.responseType;
            var _dataType = AXConfig.AXReq.dataType;

            if (obj.method) _method = obj.method;
            if (obj.contentType) _contentType = obj.contentType;
            if (obj.headers) _headers = obj.headers;

            var ajaxGetList = this.ajaxGetList.bind(this);
            new AXReq(url, {
                type: _method,
                contentType: _contentType,
                responseType: _responseType,
                dataType: _dataType,
                headers: _headers,
                debug: obj.debug,
                pars: pars,
                onsucc: function (res) {
                    if ((res.result && res.result == AXConfig.AXReq.okCode) || (res.result == undefined && !res.error)) {
                        res._sortDisable = sortDisable;
                        if (obj.response) {
                            obj.response.call(res);
                        }
                        else {
                            ajaxGetList(res);
                        }
                        if (obj.onLoad) obj.onLoad.call(res);
                    }
                    else {
                        if (obj.onError) obj.onError.call(res);
                        else axf.alert(res);
                    }
                },
                onerr: function (res) {
                    if (obj.onError) obj.onError.call(res);
                    //else axf.alert(res.statusText);
                }
            });

        }
        else {
            if (axdom.isArray(obj)) {
                if (sortDisable || !cfg.sort) {
                    this.list = obj;
                }
                else {
                    if (nowSortHeadID) {
                        this.list = this.sortList(nowSortHeadObj.sort, nowSortHeadObj, obj);
                    }
                    else {
                        this.list = obj;
                    }
                }

                this.removedList = [];
                this.printList({reload: rewrite});
                this.contentScrollResize();
                if (rewrite != "reload") this.scrollTop(0);
                this.setStatus(this.list.length);

                if (!cfg.page.paging) {
                    this.pagingUnit.hide();
                    this.pageActive = false;
                }
            }
        }
    },
    /**
     * @method AXGrid.reloadList
     * @description 그리드리스트를 새로 고침 합니다.(ajax를 통할 경우 다시 가져 옵니다).
     * @example
     * ```
     * myGrid.setList({
     * 	ajaxUrl:"loadGrid.php",
     * 	ajaxPars:"param1=1&param2=2"
     *  });
     * myGrid.reloadList();
     * ```
     */
    reloadList: function () {
        var cfg = this.config;
        var nowSortHeadID = this.nowSortHeadID;
        var nowSortHeadObj = this.nowSortHeadObj;

        this.selectedCells.clear();
        this.selectedRow.clear();

        if (this.ajaxInfo) {
            var obj = this.ajaxInfo;
            var sortDisable = this.ajax_sortDisable;
            this.pageActive = true;

            this.listLoadingDisplay();

            var url = obj.ajaxUrl;
            var appendPars = [
                "pageNo=" + this.page.pageNo,
                "pageSize=" + this.page.pageSize
            ];
            if (Object.isString(obj.ajaxPars)) {
                appendPars.push(obj.ajaxPars);
            }
            else if (Object.isObject(obj.ajaxPars)) {
                appendPars.push(axdom.param(obj.ajaxPars));
            }
            var pars = appendPars.join('&');
            var _method = "post";
            var _contentType = AXConfig.AXReq.contentType;
            var _headers = {};
            var _responseType = AXConfig.AXReq.responseType;
            var _dataType = AXConfig.AXReq.dataType;

            if (obj.method) _method = obj.method;
            if (obj.contentType) _contentType = obj.contentType;
            if (obj.headers) _headers = obj.headers;

            var scrollTop = function () {
                this.scrollTop(0);
            };
            var scrollTopBind = scrollTop.bind(this);
            var ajaxGetList = this.ajaxGetList.bind(this);

            var userResponseSetPaging = function (res) {
                axf.overwriteObject(this.page, res.page, true);
                this.setPaging();
            };
            var userResponse = userResponseSetPaging.bind(this);

            new AXReq(url, {
                type: _method,
                contentType: _contentType,
                responseType: _responseType,
                dataType: _dataType,
                headers: _headers,
                debug: obj.debug,
                pars: pars,
                onsucc: function (res) {
                    //if (res.result == AXConfig.AXReq.okCode) {
                    if ((res.result && res.result == AXConfig.AXReq.okCode) || (res.result == undefined && !res.error)) {
                        res._sortDisable = sortDisable;
                        if (obj.response) {
                            obj.response.call(res);
                            userResponse(res);
                        }
                        else {
                            ajaxGetList(res);
                        }
                        scrollTopBind();
                    }
                    else {
                        AXUtil.alert(res);
                    }
                }
            });

        }
    },
    /**
     * @method AXGrid.ajaxGetList
     * @param res {Object}
     * @description setList 호출시 ajaxUrl에 의해 가져온 데이터를 그리드의 list로 적용 합니다.
     */
    ajaxGetList: function (res) {
        var cfg = this.config;
        var nowSortHeadID = this.nowSortHeadID;
        var nowSortHeadObj = this.nowSortHeadObj;

        if (res._sortDisable || !cfg.sort || cfg.remoteSort) {
            this.list = res[AXConfig.AXGrid.keyList];
        }
        else {
            if (nowSortHeadID) {
                this.list = this.sortList(nowSortHeadObj.sort, nowSortHeadObj, res[AXConfig.AXGrid.keyList]);
            }
            else {
                this.list = res[AXConfig.AXGrid.keyList];
            }
        }
        axf.overwriteObject(this.page, res.page, true);

        this.removedList = [];
        this.printList();
        this.contentScrollResize();
        this.scrollTop(0);
        this.setPaging();
    },

    /**
     * @method AXGrid.setData
     * @param gridData {JSObject} object of grid
     * @description <ko>그리드 데이터를 페이지까지 포함하여 정의해 줍니다. (ajax를 사용하지 않는 방법)</ko>
     * @example
     * ```
     * var gridData = {
     * 	list: _obj.document_list,
     * 	page:{
     * 		pageNo: _obj.page_navigation.cur_page,
     * 		pageSize: 20,
     * 		pageCount: _obj.page_navigation.page_count,
     * 		listCount: _obj.page_navigation.total_count,
     * 		onchange: function(pageNo){
     * 			dialog.push(Object.toJSON(this));
     * 			console.log(this, pageNo);
     * 		}
     * 	}
     * };
     * myGrid.setData(gridData);
     * ```
     */
    setData: function (res) {
        var cfg = this.config;
        var nowSortHeadID = this.nowSortHeadID;
        var nowSortHeadObj = this.nowSortHeadObj;

        if (res._sortDisable || !cfg.sort) {
            this.list = res.list;
        }
        else {
            if (nowSortHeadID) {
                this.list = this.sortList(nowSortHeadObj.sort, nowSortHeadObj, res.list);
            }
            else {
                this.list = res.list;
            }
        }
        if (!this.page.onchange) this.page.onchange = this.page.onChange;
        axf.overwriteObject(this.page, res.page, true);

        this.removedList = [];
        this.selectClear();
        this.printList();
        this.contentScrollResize();
        this.scrollTop(0);
        this.setStatus(this.list.length);

        if (cfg.page.paging) {
            this.setPaging();
        }
    },
    /**
     * @method AXGrid.getFormatterValue
     * @param {String|Function} formatter - config 의 colGroup이나 colHead에서 지정된 formatter
     * @param {Object} item  - 대상 인덱스의 리스트 1개 열
     * @param {Number} itemIndex  - 대상 인덱스
     * @param {String} value - 표현 대상 값.
     * @param {Object} key - config 의 colGroup 내부 key 값
     * @param {Object} CH - 대상 그리드의 [열][행]
     * @param {Number} CHidx - 대상 그리드의 [열][행] 중 행의 index
     * @returns {String}
     * @description 지정된 표현 형식으로 데이터를 HTML String 으로 변환 시킵니다.
     */
    getFormatterValue: function (formatter, item, itemIndex, value, key, CH, CHidx) {
        var cfg = this.config;
        var result;

        if (CH.editor && (CH.editor.type == "checkbox" || CH.editor.type == "radio")) {
            //
            // editCell 처리
            var checkedStr = "", disabled = "",
                that = {
                    index: itemIndex,
                    list: this.list,
                    item: item,
                    page: this.page,
                    key: key,
                    value: value
                };

            if (value == true || value == 1 || value == "1" || value == "Y") checkedStr = ' checked="checked"';
            if (CH.editor.disabled) {
                if (CH.editor.disabled.call(that)) {
                    disabled = ' disabled="disabled"';
                }
            }

            result = '<input type="' + CH.editor.type + '" name="' + key + '" data-editor-key="' + itemIndex + ',' + CHidx + '" class="inline-editor-checkbox" ' +
                checkedStr + disabled + ' onfocus="this.blur();" />';
            //"<input type=\"checkbox\" name=\"" + CH.label + "\" class=\"gridCheckBox_body_colSeq" + CH.colSeq + "\" id=\"" + cfg.targetID + "_AX_checkboxItem_AX_" + CH.colSeq + "_AX_" + itemIndex + "\" value=\"" + value + "\" " + checkedStr + disabled + " onfocus=\"this.blur();\" />";
        }
        else if (Object.isFunction(formatter)) {
            var sendObj = {
                index: itemIndex,
                list: this.list,
                item: item,
                page: this.page,
                key: key,
                value: value
            };
            result = formatter.call(sendObj, itemIndex, item);
        }
        else if (CH.editor && (CH.editor.type in this.formatter)) {
            // 동일한 이름을 가진 formatter와 editor가 있으면 해당 editor의 값을 보여줄 때 동일한 이름을 가진 formatter를 사용한다.
            result = this.formatter[CH.editor.type].call(this, CH.editor.type, item, itemIndex, value, key, CH, CHidx);
        }
        else if (Object.isString(formatter) && (formatter in this.formatter)) {
            result = this.formatter[formatter].call(this, formatter, item, itemIndex, value, key, CH, CHidx);
        }
        else {
            result = ((String(value) == "null") ? "" : value);
        }
        return result;
    },
    /**
     * @method AXGrid.getTooltipValue
     * @param {String|Function} formatter - config 의 colGroup이나 colHead에서 지정된 formatter
     * @param {Object} item - 대상 인덱스의 리스트 1개 열
     * @param {Number} itemIndex - 대상 인덱스
     * @param {String} value - 표현 대상 값.
     * @param {Object} key - config 의 colGroup 내부 key 값
     * @param {Object} CH - 대상 그리드의 [열][행]
     * @returns {String}
     * @description 지정된 표현 형식으로 데이터를 HTML String으로 변환 시킵니다.
     */
    getTooltipValue: function (formatter, item, itemIndex, value, key, CH) {
        var cfg = this.config;
        var result;
        if (formatter == "money") {
            if (value == "" || value == "null") {
                result = "0";
            }
            else {
                result = value.number().money();
            }
        }
        else if (formatter == "dec") {
            result = (value == undefined) ? "" : value.dec();
        }
        else if (formatter == "html") {
            result = value;
        }
        else if (formatter == "checkbox" || formatter == "radio") {
            var checked = "";
            if (CH.checked) {
                var sendObj = {
                    index: itemIndex,
                    list: this.list,
                    item: item,
                    page: this.page,
                    key: key,
                    value: value
                };
                var callResult = CH.checked.call(sendObj);
                if (callResult) {
                    checked = " checked=\"checked\" ";
                }
            }
            result = "<input type=\"" + formatter + "\" name=\"" + CH.label + "\" class=\"gridCheckBox_body_colSeq" + CH.colSeq + "\" id=\"" + cfg.targetID + "_AX_checkboxItem_AX_" + CH.colSeq + "_AX_" + itemIndex + "\" value=\"" + value + "\" " + checked + " />";
        }
        else {
            if (Object.isFunction(formatter)) {
                var sendObj = {
                    index: itemIndex,
                    list: this.list,
                    item: item,
                    page: this.page,
                    key: key,
                    value: value
                };
                result = formatter.call(sendObj, itemIndex, item);
            }
            else {
                result = value;
            }
        }
        return result;
    },

    /**
     * @method AXGrid.getAddingClass
     * @param {String|Function} formatter - config 의 colGroup이나 colHead에서 지정된 formatter
     * @param {Object} item - 대상 인덱스의 리스트 1개 열
     * @param {Number} itemIndex - 대상 인덱스
     * @param {String} value - 표현 대상 값.
     * @param {Object} key - config 의 colGroup 내부 key 값
     * @param {Object} CH - 대상 그리드의 [열][행]
     * @returns {String}
     * @description 해당 컬럼에 추가클래스를 정의 합니다. 문자열 방식과 함수방식을 지원합니다.
     */
    getAddingClass: function (formatter, item, itemIndex, value, key, CH) {
        var cfg = this.config;
        var result = "";

        if (Object.isString(formatter)) {
            result = formatter;

        }
        else if (Object.isFunction(formatter)) {
            var sendObj = {
                index: itemIndex,
                list: this.list,
                item: item,
                page: this.page,
                key: key,
                value: value
            };
            result = formatter.call(sendObj, itemIndex, item);
        }
        else {

        }

        return result;
    },
    /**
     * @method AXGrid.getItem
     * @param itemIndex {Number} - 대상 인덱스
     * @param item {Object} - 대상 인덱스의 리스트 1개 열
     * @param isfix {String} - 고정 높이 사용시 "fix"
     * @param hasTr {String} - tr 표시 여부
     * @returns {String}
     * @description 대상의 데이터를 그리드에 출력되는 html 형태로 변환  합니다.
     */
    getItem: function (itemIndex, item, isfix, hasTr) {
        if (!item) return "";
        var cfg = this.config;
        var tpo = [];
        var evenClassName = "line" + (itemIndex % 2);
        /*
         if(cfg.mergeCells){
         evenClassName = "line1"; // 줄무늬 기능 사용 안함.
         }
         */
        var getFormatterValue = this.getFormatterValue.bind(this);
        var getTooltipValue = this.getTooltipValue.bind(this);
        var getAddingClass = this.getAddingClass.bind(this);

        var hasFixed = this.hasFixed;
        var hasTrValue = (hasTr === undefined);
        var trAddClass = "";
        var lastTdRowspan = "";
        if (cfg.body.addClass) {
            try {
                trAddClass = cfg.body.addClass.call({
                        index: itemIndex,
                        item: item,
                        list: this.list,
                        page: this.page
                    }) || "";
            } catch (e) {
                console.log(e);
            }
        }

        var r = 0, l = cfg.body.rows.length;

        for (; r < l; r++) {
            var isLastTR = (l - 1 == r);
            var trHeight = 0;
            trHeight = this.cachedDom.tbody.find("#" + cfg.targetID + "_AX_tr_" + r + "_AX_n_AX_" + itemIndex + " td").innerHeight();
            if (hasTrValue) {
                if (isfix == "fix") {
                    tpo.push("<tr class=\"gridBodyTr gridBodyTr_" + itemIndex + " " + evenClassName + " " + trAddClass + "\" " +
                        "id=\"" + cfg.targetID + "_AX_tr_" + r + "_AX_fix_AX_" + itemIndex + "\">");
                }
                else {
                    tpo.push("<tr class=\"gridBodyTr gridBodyTr_" + itemIndex + " " + evenClassName + " " + trAddClass + "\" " +
                        "id=\"" + cfg.targetID + "_AX_tr_" + r + "_AX_n_AX_" + itemIndex + "\">");
                }

            }
            var colCount = 0, CH, CHidx = 0, CG, CHLen = cfg.body.rows[r].length;

            for (; CHidx < cfg.body.rows[r].length; CHidx++) {
                CH = cfg.body.rows[r][CHidx];
                CG = cfg.colGroup[CHidx];

                if (CH.display && CH.colspan > 0) {
                    var printOk = false, makeBodyNode = true;
                    if (isfix == "n") {
                        printOk = true;

                        if (typeof CH.colSeq == "undefined") {

                        }
                        else {
                            if (typeof cfg.fixedColSeq != "undefined" && cfg.fixedColSeq > 0 && CH.colSeq < (cfg.fixedColSeq + 1)) {
                                makeBodyNode = false;
                            }
                        }
                    }
                    if (isfix == "fix" && colCount < (cfg.fixedColSeq + 1)) {
                        printOk = true;
                        if (typeof CH.colSeq == "undefined" || CH.colSeq == null) {
                            if (r > 0 && cfg.body._maps[r][CHidx] && cfg.body._maps[r][colCount].r != r) {
                                printOk = false;
                            }
                        }
                        else {
                            var _postion = cfg.body._maps[r][CH.colSeq];
                            if (CH.colSeq > (cfg.fixedColSeq)) {
                                printOk = false;
                            }
                        }

                    }

                    if (printOk) {
                        colCount += CH.colspan;
                        //radio, check exception
                        var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                        var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                        lastTdRowspan = rowspan;
                        var valign = " valign=\"" + CH.valign + "\" ";
                        var bottomClass = (CH.isLastCell) ? "" : " bodyBottomBorder";
                        var fixedClass = (CH.isFixedEndCell) ? " fixedLine" : "";
                        var styles = " style=\"vertical-align:" + CH.valign + ";\"";

                        var tdHeight = (function () {
                            if (cfg.body.heights && cfg.body.heights[r]) {
                                var tdHeight = 0;
                                for (var i = r; i < CH.rowspan; i++) {
                                    tdHeight += (cfg.body.heights[i] || 0);
                                }
                                return tdHeight;
                            }
                            else {
                                return 0;
                            }
                        })();

                        if (tdHeight) {
                            styles = " style=\"vertical-align:" + CH.valign + ";height:" + (tdHeight) + "px;\"";
                        }
                        else if (trHeight && CH.rowspan < 2 && CH.colspan < 2) styles = " style=\"vertical-align:" + CH.valign + ";height:" + trHeight + "px;\"";
                        else if (CH.rowspan > 1) {
                            styles = " style=\"vertical-align:" + CH.valign + ";height:" + (trHeight) + "px;\"";
                        }
                        var bodyNodeClass = "";
                        if (CH.formatter == "checkbox" || CH.formatter == "radio") bodyNodeClass = " bodyTdCheckBox";
                        else if (CH.formatter == "html") bodyNodeClass = " bodyTdHtml";

                        var tooltipValue = "";
                        if (CH.tooltip) tooltipValue = getTooltipValue(CH.tooltip, item, itemIndex, item[CH.key], CH.key, CH);

                        var addClasses = "";
                        if (CH.addClass) addClasses = " " + getAddingClass(CH.addClass, item, itemIndex, item[CH.key], CH.key, CH);
                        var tdEndStyles = "";
                        if (CH.isTdEnd && cfg.hiddenBorder_tdLastChild) {
                            tdEndStyles = "background-image:none;"
                        }
                        tpo.push("<td" + valign + rowspan + colspan + styles + " " +
                            " id=\"" + cfg.targetID + "_AX_" + (isfix || "n") + "body_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\" " +
                            " class=\"bodyTd bodyTd_" + CHidx + " bodyTdr_" + r + " " + bottomClass + fixedClass + "\" style=\"" + tdEndStyles + "\">");

                        if (makeBodyNode) {
                            tpo.push("<div class=\"bodyNode bodyTdText" + bodyNodeClass + addClasses + "\" " +
                                " align=\"" + CH.align + "\" " +
                                " id=\"" + cfg.targetID + "_AX_bodyText_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\" " +
                                " title=\"" + tooltipValue + "\">");

                            if ((hasFixed && !CH.isFixedCell) || !hasFixed || isfix != undefined) {
                                if (CH.formatter) {
                                    tpo.push(getFormatterValue(CH.formatter, item, itemIndex, item[CH.key], CH.key, CH, CHidx));
                                }
                                else if (CH.editor && (CH.editor.type == "checkbox" || CH.editor.type == "radio" || CH.editor.type in this.formatter)) {
                                    // 동일한 이름을 가진 formatter와 editor가 있으면 해당 editor의 값을 보여줄 때 동일한 이름을 가진 formatter를 사용한다.
                                    tpo.push(getFormatterValue("", item, itemIndex, item[CG.key], CH.key, CH, CHidx));
                                }
                                else {
                                    tpo.push((String(item[CH.key]) == "null") ? "" : item[CH.key]);
                                }
                            }
                            else {
                                tpo.push("&nbsp;");
                            }
                            tpo.push("</div>");
                        }

                        tpo.push("</td>");
                    }
                }
            }

            if (r == 0 && isfix == "n") {
                tpo.push("<td class=\"bodyNullTd\" id=\"" + cfg.targetID + "_AX_null_AX_" + itemIndex + "\" rowspan=\"" + cfg.body.rows.length + "\">" +
                    "<div class=\"tdRelBlock\" id=\"" + cfg.targetID + "_AX_tdRelBlock_AX_" + itemIndex + "\">&nbsp;</div>" +
                    "</td>");
            }
            if (hasTrValue) tpo.push("</tr>");
        }
        return tpo.join('');
    },
    /**
     * @method AXGrid.getIconItem
     * @param itemIndex {Number} - 대상 인덱스
     * @param item {Object} - 대상 인덱스의 리스트 1개 열
     * @param viewIconObj {Object} - Config 에서 설정된 view 속성.
     * @param {Object} cssObj
     * @returns {String}
     * @description config 의 viewMode가 icon 일때의 리스트를 구성 합니다.
     * @example
     * ```js
     * cssObj = {
     *     box: "width: ,height:",   - 기타 사용자 지정 스타일 추가 가능
     *     img:  "left:, top: , width:, height:", - 기타 사용자 지정 스타일 추가 가능
     *     label: "left:, top: , width:, height:", - 기타 사용자 지정 스타일 추가 가능
     *     description: "left:, top: , width:, height:", - 기타 사용자 지정 스타일 추가 가능
     *     buttons: "left:, top: , width:, height:", - 기타 사용자 지정 스타일 추가 가능
     * };
     * ```
     */
    getIconItem: function (itemIndex, item, viewIconObj, cssObj) {
        var cfg = this.config;
        var tpo = [];
        var getFormatterValue = this.getFormatterValue.bind(this);
        var getTooltipValue = this.getTooltipValue.bind(this);

        var format;
        try {
            format = viewIconObj.format.call({index: itemIndex, item: item});
        } catch (e) {
            console.log(e);
        }
        tpo.push("<div class=\"viewIcon bodyViewIcon bodyViewIcon_" + itemIndex + " " + (viewIconObj.addClass || "") + "\" style=\"" + cssObj.box + ";\" id=\"" + cfg.targetID + "_AX_viewIcon_AX_" + itemIndex + "\">");

        if (format.imgsrc) {
            tpo.push("<img src=\"");
            tpo.push(format.imgsrc);
            tpo.push("\" align=\"middle\" alt=\"" + format.label + "\" style=\"" + cssObj.img + ";\" class=\"gridViewIconThumbnail\" />");
        }

        if (format.label) {
            tpo.push("<div style=\"" + cssObj.label + ";\" class=\"gridViewIconLabel\">");
            tpo.push(format.label);
            tpo.push("</div>");
        }

        if (format.description) {
            tpo.push("<div style=\"" + cssObj.description + ";\" class=\"gridViewIconDescription\">");
            tpo.push(format.description);
            tpo.push("</div>");
        }
        if (viewIconObj.buttons) {
            if (viewIconObj.buttons.items) {
                tpo.push("<div style=\"" + cssObj.buttons + ";\" class=\"gridViewIconbuttons\">");
                for (var B, bidx = 0; (bidx < viewIconObj.buttons.items.length && (B = viewIconObj.buttons.items[bidx])); bidx++) {
                    tpo.push("<button type=\"button\" class=\"viewIconButtonsItem " + B.addClass + "\" id=\"" + cfg.targetID + "_AX_viewIcon_AX_" + itemIndex + "_AX_" + bidx + "\">");
                    tpo.push(B.label);
                    tpo.push("</button> ");
                }
                ;
                tpo.push("</div>");
            }
        }

        tpo.push("</div>");

        return tpo.join('');
    },
    /**
     * @method AXGrid.getMobileItem
     * @param itemIndex {Number} - 대상 인덱스
     * @param item {Object} - 대상 인덱스의 리스트 1개 열
     * @param mobileView {Object} - Config 에서 설정된 view 속성.
     * @returns {String}
     * @description config 의 viewMode가 mobile 일때의 리스트를 구성 합니다.
     */
    getMobileItem: function (itemIndex, item, mobileView) {
        var cfg = this.config;
        var tpo = [];
        var evenClassName = "line" + (itemIndex % 2);
        var getFormatterValue = this.getFormatterValue.bind(this);
        var getTooltipValue = this.getTooltipValue.bind(this);
        var trAddClass = "";
        if (cfg.body.addClass) {
            try {
                trAddClass = cfg.body.addClass.call({
                        index: itemIndex,
                        item: item,
                        list: this.list,
                        page: this.page
                    }) || "";
            } catch (e) {
                console.log(e);
            }
        }

        tpo.push("<section class=\"bodyViewMobile bodyViewMobile_" + itemIndex + " " + " " + evenClassName + " " + (mobileView.addClass || "") + "\" id=\"" + cfg.targetID + "_AX_viewMobile_AX_" + itemIndex + "\">");

        var __memoCol = null, displayColumnCount = 0;
        for (var CN, cidx = 0, __arr = mobileView.column; (cidx < __arr.length && (CN = __arr[cidx])); cidx++) {
            if (CN.display == true || CN.display == undefined) displayColumnCount++;
        }
        for (var CN, cidx = 0, __arr = mobileView.column; (cidx < __arr.length && (CN = __arr[cidx])); cidx++) {
            if (CN.display == true || CN.display == undefined) {
                var colClass = "", colAddClass = (CN.addClass || "");
                if (displayColumnCount === 1) colAddClass = ""; // show column 1
                if (CN.col) colClass = "col" + CN.col;
                else  colClass = "colNone";

                if (__memoCol != null && !CN.col) tpo.push("<div style='clear:both;'></div>");

                tpo.push("<div class='column " + colClass + " " + trAddClass + " " + colAddClass + "'>");
                if (mobileView.label != false) {
                    tpo.push("<span class='label'>" + CN.label + "</span>");
                    tpo.push("<span class='content'>");
                }
                else {
                    tpo.push("<span class='content solid'>");
                }
                if (CN.formatter) {
                    //formatter, item, itemIndex, value, key, CH, CHidx
                    for (var colSeq = 0; colSeq < cfg.colGroup.length; colSeq++) {
                        if (cfg.colGroup[colSeq].key == CN.key) {
                            CN.colSeq = colSeq;
                            break;
                        }
                    }
                    tpo.push(getFormatterValue(CN.formatter, item, itemIndex, item[CN.key], CN.key, CN));
                }
                else {
                    tpo.push(item[CN.key]);
                }
                tpo.push("</span>");
                tpo.push("</div>");
                __memoCol = CN.col;
            }
        }

        tpo.push("<div class='columnClear'></div>");
        tpo.push("<div class='buttonGroup'>");
        if (mobileView.buttons) {
            for (var B, bidx = 0, __arr = mobileView.buttons; (bidx < __arr.length && (B = __arr[bidx])); bidx++) {
                tpo.push("<a class='buttonGroupItem " + B.addClass + "' id='" + cfg.targetID + "_AX_mobileViewButton_AX_" + itemIndex + "_AX_" + bidx + "'>");
                tpo.push("</a>");
            }
        }
        tpo.push("</div>");
        tpo.push("</section>");

        return tpo.join('');
    },
    /**
     * @method AXGrid.getItemMarker
     * @param itemIndex {Number} - 대상 인덱스
     * @param item {Object} - 대상 인덱스의 리스트 1개 열
     * @param isfix {String} - 고정 높이 사용시 "fix"
     * @returns {String}
     * @description body(list) 구성시 marker row 가 존재할경우 처리 합니다.
     */
    getItemMarker: function (itemIndex, item, isfix, markerIndexs) {
        var cfg = this.config;
        var tpo = [];
        var evenClassName = "gridBodyMarker";
        var getFormatterValue = this.getFormatterValue.bind(this);
        var hasFixed = this.hasFixed;
        var trAddClass = "";

        for (var mi = 0, l = markerIndexs.length, markerIndex; mi < l; mi++) {
            var marker = cfg.body.marker[markerIndexs[mi]];
            if (marker.addClass) {
                try {
                    trAddClass = marker.addClass.call({
                            index: itemIndex,
                            item: item,
                            list: this.list,
                            page: this.page
                        }) || "";
                } catch (e) {
                    console.log(e);
                }
            }
            for (var r = 0; r < marker.rows.length; r++) {
                var isLastTR = (marker.rows.length - 1 == r);
                tpo.push("<tr class=\"gridBodyTr gridBodyMarkerTr_" + itemIndex + " " + evenClassName + " " + trAddClass + "\" id=\"" + cfg.targetID + "_AX_marker_" + r + "_AX_" + (isfix || "n") + "_AX_" + itemIndex + "\">");
                var colCount = 0;
                for (var CH, CHidx = 0, __arr = marker.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                    if (CH.display && CH.colspan > 0) {

                        if (isfix == "n" || (isfix != undefined && colCount < (cfg.fixedColSeq + 1))) {

                            colCount += CH.colspan;

                            /*radio, check exception */
                            var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                            var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                            var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";
                            var bottomClass = (CH.isLastCell) ? "" : " bodyBottomBorder";
                            var fixedClass = (CH.isFixedEndCell) ? " fixedLine" : "";

                            /*console.log({r:r, CHidx:CHifixedColSeq:cfg.fixedColSeq, colCount:colCount}); */

                            var bodyNodeClass = "";
                            if (CH.formatter == "checkbox" || CH.formatter == "radio") bodyNodeClass = " bodyTdCheckBox";
                            else if (CH.formatter == "html") bodyNodeClass = " bodyTdHtml";

                            tpo.push("<td" + valign + rowspan + colspan + " id=\"" + cfg.targetID + "_AX_" + (isfix || "n") + "bodyMarker_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\" class=\"bodyTd" + bottomClass + fixedClass + "\">");
                            /*tpo.push("<div class=\"tdRelBlock\">");*/
                            tpo.push("<div class=\"bodyNode bodyTdText" + bodyNodeClass + "\" align=\"" + CH.align + "\" id=\"" + cfg.targetID + "_AX_bodyMarkerText_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\">");
                            if ((hasFixed && !CH.isFixedCell) || !hasFixed || isfix != undefined) {
                                if (CH.formatter) {
                                    tpo.push(getFormatterValue(CH.formatter, item, itemIndex, item[CH.key], CH.key, CH));
                                }
                                else {
                                    tpo.push(item[CH.key]);
                                }
                            }
                            else {
                                tpo.push("&nbsp;");
                            }
                            tpo.push("</div>");
                            /*tpo.push("</div>");*/
                            tpo.push("</td>");
                        }
                    }
                }
                ;
                if (r == 0 && isfix == "n") {
                    tpo.push("<td class=\"bodyNullTd\" id=\"" + cfg.targetID + "_AX_nullMarker_AX_" + itemIndex + "\" rowspan=\"" + marker.rows.length + "\"><div class=\"tdRelBlock\" id=\"" + cfg.targetID + "_AX_tdRelBlockMarker_AX_" + itemIndex + "\">&nbsp;</div></td>");
                }
                tpo.push("</tr>");
            }

        }

        return tpo.join('');
    },
    /**
     * @method AXGrid.getMarkerDisplay
     * @param itemIndex {Number} - 대상 인덱스
     * @param item {Object} - 대상 인덱스의 리스트 1개 열
     * @returns {Boolean}
     * @description config 내의 marker row 를 출력할지 여부를 판단하는 사용자 함수를 호출 합니다.
     */
    getMarkerDisplay: function (itemIndex, item) {
        var cfg = this.config;
        var bodyHasMarker = this.bodyHasMarker;

        if (!bodyHasMarker) return [];
        var sendObj = {
            index: itemIndex,
            list: this.list,
            item: item,
            page: this.page
        };

        var markerDisplay = [];
        try {
            for (var m = 0, l = cfg.body.marker.length, marker; m < l; m++) {
                marker = cfg.body.marker[m];
                if (marker.display.call(sendObj, itemIndex, item)) {
                    markerDisplay.push(m);
                }
            }
        } catch (e) {
            console.log(e);
        }
        return markerDisplay;
    },
    /**
     * @method AXGrid.printList
     * @param args {Object} - 출력 옵션  {sort:true}
     * @returns {String}
     * @description grid list 의 전체 출력을 처리 합니다.
     */
    printList: function (args) {
        if (!args) args = {};
        var cfg = this.config, _this = this;
        var bodyHasMarker = this.bodyHasMarker;
        var getItem = this.getItem.bind(this);
        var getItemMarker = this.getItemMarker.bind(this);
        var getMarkerDisplay = this.getMarkerDisplay.bind(this);
        var markerIndex;
        if (this.editorOpend) this.cancelEditor();
        var getIconItem = this.getIconItem.bind(this);
        // --------------------------- icon view
        var getMobileItem = this.getMobileItem.bind(this);
        // --------------------------- mobile view

        var po = [];
        // view mode 가 grid 인경우만 유효
        if (cfg.viewMode == "grid") {
            if (cfg.__height == "auto") {
                for (var item, itemIndex = 0, __arr = this.list; (itemIndex < __arr.length && (item = __arr[itemIndex])); itemIndex++) {
                    po.push(getItem(itemIndex, item, "n"));
                    if (bodyHasMarker && (markerIndex = getMarkerDisplay(itemIndex, item)).length > 0) {
                        po.push(getItemMarker(itemIndex, item, "n", markerIndex));
                    }
                }
            }
            else {
                if (this.list.length > 0) {
                    var firstItem = this.list[0];
                    po.push(getItem(0, firstItem, "n"));
                    /* firstItem 예외처리
                     if (bodyHasMarker && getMarkerDisplay(0, firstItem)) {
                     po.push(getItemMarker(0, firstItem, "n"));
                     }
                     */
                }
            }

            if (this.list.length == 0) { // empty list
                po.push("<tr class=\"noListTr\">");
                po.push("<td colspan=\"" + (this.showColLen) + "\">");
                po.push("<div class=\"tdRelBlock\">");
                po.push("<div class=\"bodyNode bodyTdText\" align=\"center\">");
                po.push(cfg.emptyListMSG);
                po.push("</div>");
                po.push("</div>");
                po.push("</td>");
                po.push("<td class=\"bodyNullTd\"><div class=\"tdRelBlock\">&nbsp;</div></td>");
                po.push("</tr>");
            }

            this.cachedDom.tbody.empty();
            this.cachedDom.tbody.append(po.join(''));

            if (this.hasFixed) {
                po = [];
                if (cfg.__height == "auto") {
                    for (var item, itemIndex = 0, __arr = this.list; (itemIndex < __arr.length && (item = __arr[itemIndex])); itemIndex++) {
                        po.push(getItem(itemIndex, item, "fix"));
                        if (bodyHasMarker && (markerIndex = getMarkerDisplay(itemIndex, item)).length > 0) {
                            po.push(getItemMarker(itemIndex, item, "fix", markerIndex));
                        }
                    }
                }
                else {
                    if (this.list.length > 0) {
                        po.push(getItem(0, firstItem, "fix"));
                        /* firstItem 예외처리
                         if (bodyHasMarker && getMarkerDisplay(0, firstItem)) {
                         po.push(getItemMarker(itemIndex, firstItem, "fix"));
                         }
                         */
                    }
                }

                this.cachedDom.fixed_tbody.empty();
                this.cachedDom.fixed_tbody.append(po.join(''));
                if (this.list.length == 0) {
                    this.fixedScrollContent.hide();
                }
                else {
                    this.fixedScrollContent.show();
                }
            }

            /// console.log(cfg.height, this.list.length);

            if (cfg.__height != "auto" && this.list.length > 0) {

                //아이템 한줄의 높이는?
                var
                    $itemTr = this.cachedDom.tbody.find("#" + cfg.targetID + "_AX_null_AX_0"),
                    itemTrHeight,
                    printListCount
                    ;

                if(!$itemTr.get(0)) return; // viewMode grid가 아닌 상황

                itemTrHeight = $itemTr.outerHeight().number();
                this.scrollContent.css({"padding-bottom": itemTrHeight});
                // 추가로 출력할 목록 선정
                po = [];
                printListCount = (this.body.height() / itemTrHeight).ceil();

                if (this.list.length > (printListCount + cfg.listCountMargin)) printListCount += cfg.listCountMargin;
                else printListCount = this.list.length;
                for (var item, itemIndex = 0, __arr = this.list; (itemIndex < printListCount && (item = __arr[itemIndex])); itemIndex++) {
                    po.push(getItem(itemIndex, item, "n"));
                    if (bodyHasMarker && (markerIndex = getMarkerDisplay(itemIndex, item)).length > 0) {
                        po.push(getItemMarker(itemIndex, item, "n", markerIndex));
                    }
                }
                this.cachedDom.tbody.empty();
                this.cachedDom.tbody.append(po.join(''));

                if (this.hasFixed) {
                    po = [];
                    for (var item, itemIndex = 0, __arr = this.list; (itemIndex < printListCount && (item = __arr[itemIndex])); itemIndex++) {
                        po.push(getItem(itemIndex, item, "fix"));
                        if (bodyHasMarker && (markerIndex = getMarkerDisplay(itemIndex, item)).length > 0) {
                            po.push(getItemMarker(itemIndex, item, "fix", markerIndex));
                        }
                    }
                    this.cachedDom.fixed_tbody.empty();
                    this.cachedDom.fixed_tbody.append(po.join(''));
                }

                // init virtualScroll & control height thpadding
                this.virtualScroll = {
                    startIndex: 0,
                    endIndex: printListCount - 1,
                    itemTrHeight: itemTrHeight,
                    printListCount: printListCount,
                    scrollTop: 0
                };

                // 출력된 테이블에 mergeCells 호출
                if (cfg.mergeCells) {
                    this.mergeCells(this.cachedDom.tbody, "n");
                    if (this.hasFixed) {
                        this.mergeCells(this.cachedDom.fixed_tbody, "f");
                    }
                }

                this.cachedDom.thpadding.css({height: 0});
                this.cachedDom.tfpadding.css({height: cfg.scrollContentBottomMargin.number() + (this.list.length - printListCount) * (itemTrHeight)});
                if (this.hasFixed) {
                    this.cachedDom.fthpadding.css({height: 0});
                    this.cachedDom.ftfpadding.css({height: cfg.scrollContentBottomMargin.number() + (this.list.length - printListCount) * (itemTrHeight)});
                }

                // 스크롤 y 포지션 초기화
                this.scrollContent.css({top: 0});
                this.contentScrollContentSync({top: 0});

            }
            else if (cfg.__height == "auto" && this.list.length > 0) {

                this.virtualScroll = {
                    startIndex: 0,
                    endIndex: this.list.length,
                    itemTrHeight: this.cachedDom.tbody.find("#" + cfg.targetID + "_AX_null_AX_0").outerHeight().number(),
                    printListCount: this.list.length,
                    scrollTop: 0
                };

                if (!cfg.foot) {
                    this.cachedDom.thpadding.css({height: 0});
                    this.cachedDom.tfpadding.css({height: cfg.scrollContentBottomMargin.number()});
                    if (this.hasFixed) {
                        this.cachedDom.fthpadding.css({height: 0});
                        this.cachedDom.ftfpadding.css({height: cfg.scrollContentBottomMargin.number()});
                    }
                }
                else {
                    this.cachedDom.thpadding.css({height: 0});
                    this.cachedDom.tfpadding.css({height: cfg.scrollContentBottomMargin.number()});
                    if (this.hasFixed) {
                        this.cachedDom.fthpadding.css({height: 0});
                        this.cachedDom.ftfpadding.css({height: cfg.scrollContentBottomMargin.number()});
                    }
                }

                if (cfg.mergeCells) {
                    this.mergeCells(this.cachedDom.tbody, "n");
                    if (this.hasFixed) {
                        this.mergeCells(this.cachedDom.fixed_tbody, "f");
                    }
                }

                this.scrollContent.css({top: 0});
                this.contentScrollContentSync({top: 0});
                this.gridTargetSetSize();
            }
            else {

                this.virtualScroll = {
                    startIndex: 0,
                    endIndex: 0,
                    itemTrHeight: 0,
                    printListCount: 0,
                    scrollTop: 0
                };
                this.cachedDom.thpadding.css({height: 0});
                this.cachedDom.tfpadding.css({height: cfg.scrollContentBottomMargin.number()});
                if (this.hasFixed) {
                    this.cachedDom.fthpadding.css({height: 0});
                    this.cachedDom.ftfpadding.css({height: cfg.scrollContentBottomMargin.number()});
                }
                this.scrollContent.css({top: 0});
                this.contentScrollContentSync({top: 0});

            }

            this.body.find(".gridBodyTr").bind("mouseover", this.gridBodyOver.bind(this));
            this.body.find(".gridBodyTr").bind("mouseout", this.gridBodyOut.bind(this));
            this.body.find(".gridBodyTr:not(.gridBodyMarker)").bind("click", this.gridBodyClick.bind(this));
            if (this.needBindDBLClick()) this.body.find(".gridBodyTr").bind("dblclick", this.gridBodyDBLClick.bind(this));

            if (this.selectedRow && this.selectedRow.length > 0) {

                for (var itemIndex = 0, __arr = this.selectedRow; itemIndex < __arr.length; itemIndex++) {
                    this.body.find(".gridBodyTr_" + __arr[itemIndex]).addClass("selected");
                }
                var itemIndex = this.selectedRow.last();
                var itemDom = this.body.find(".gridBodyTr_" + itemIndex);
                if (itemDom[0]) {
                    var trTop = itemDom.position().top;
                    var scrollHeight = this.scrollContent.height();
                    var bodyHeight = this.body.height();

                    var
                        $itemTr = this.cachedDom.tbody.find("#" + cfg.targetID + "_AX_null_AX_0"),
                        trHeight;

                    if(!$itemTr.get(0)) return; // viewMode grid가 아닌 상황
                    trHeight = $itemTr.outerHeight().number();
                    if (trTop.number() + trHeight.number() > bodyHeight) {
                        var scrollTop = bodyHeight - (trTop.number() + itemTrHeight.number());
                        this.scrollContent.css({top: (scrollTop - cfg.listCountMargin)});
                        this.contentScrollContentSync({top: (scrollTop - cfg.listCountMargin)}, null, args.reload);
                    }
                    else {
                        if (trTop.number() == 0) {
                            var scrollTop = 0;
                            this.scrollContent.css({top: scrollTop});
                            this.contentScrollContentSync({top: scrollTop}, null, args.reload);
                        }
                    }
                    this.bigDataSync("reload");
                }
            }

            // printList then body.onchangeScroll
            if (cfg.body.onchangeScroll) {
                var sendObj = axf.copyObject(this.virtualScroll);
                cfg.body.onchangeScroll.call(sendObj, sendObj);
            }

        }
        else if (cfg.viewMode == "icon") {

            var viewIconObj = cfg.view;

            var viewIconCss = [];
            viewIconCss.push("width:" + viewIconObj.width.number() + "px");
            viewIconCss.push("height:" + viewIconObj.height.number() + "px");
            if (viewIconObj.style) viewIconCss.push(viewIconObj.style);

            var viewIconImgCss = [];
            viewIconImgCss.push("left:" + viewIconObj.img.left.number() + "px");
            viewIconImgCss.push("top:" + viewIconObj.img.top.number() + "px");
            viewIconImgCss.push("width:" + viewIconObj.img.width.number() + "px");
            viewIconImgCss.push("height:" + viewIconObj.img.height.number() + "px");
            if (viewIconObj.img.style) viewIconImgCss.push(viewIconObj.img.style);

            var viewIconLabelCss = [];
            viewIconLabelCss.push("left:" + viewIconObj.label.left.number() + "px");
            viewIconLabelCss.push("top:" + viewIconObj.label.top.number() + "px");
            viewIconLabelCss.push("width:" + viewIconObj.label.width.number() + "px");
            viewIconLabelCss.push("height:" + viewIconObj.label.height.number() + "px");
            if (viewIconObj.label.style) viewIconLabelCss.push(viewIconObj.label.style);

            var viewIconDescriptionCss = [];
            viewIconDescriptionCss.push("left:" + viewIconObj.description.left.number() + "px");
            viewIconDescriptionCss.push("top:" + viewIconObj.description.top.number() + "px");
            viewIconDescriptionCss.push("width:" + viewIconObj.description.width.number() + "px");
            viewIconDescriptionCss.push("height:" + viewIconObj.description.height.number() + "px");
            if (viewIconObj.description.style) viewIconDescriptionCss.push(viewIconObj.description.style);

            var viewIconButtonsCss = [];
            if (viewIconObj.buttons) {
                viewIconButtonsCss.push("left:" + viewIconObj.buttons.left.number() + "px");
                viewIconButtonsCss.push("top:" + viewIconObj.buttons.top.number() + "px");
                viewIconButtonsCss.push("width:" + viewIconObj.buttons.width.number() + "px");
                viewIconButtonsCss.push("height:" + viewIconObj.buttons.height.number() + "px");
                if (viewIconObj.buttons.style) viewIconButtonsCss.push(viewIconObj.buttons.style);
            }

            var cssObj = {
                box: viewIconCss.join(";"),
                img: viewIconImgCss.join(";"),
                label: viewIconLabelCss.join(";"),
                description: viewIconDescriptionCss.join(";"),
                buttons: viewIconButtonsCss.join(";")
            };

            for (var item, itemIndex = 0, __arr = this.list; (itemIndex < __arr.length && (item = __arr[itemIndex])); itemIndex++) {
                po.push(getIconItem(itemIndex, item, viewIconObj, cssObj));
            }

            po.push("<div style='clear:both;'></div>");

            var gridBodyDiv = axdom("#" + cfg.targetID + "_AX_gridBodyDiv");
            gridBodyDiv.empty();
            gridBodyDiv.append(po.join(''));

            this.body.find(".bodyViewIcon").bind("click", this.gridBodyClick.bind(this));
            if (this.needBindDBLClick()) this.body.find(".bodyViewIcon").bind("dblclick", this.gridBodyDBLClick.bind(this));

            if (this.selectedRow && this.selectedRow.length > 0) {
                var body = this.body;
                for (var item, itemIndex = 0, __arr = this.selectedRow; (itemIndex < __arr.length && (item = __arr[itemIndex])); itemIndex++) {
                    body.find(".bodyViewIcon_" + item).addClass("selected");
                }
            }

            var _list = this.list;
            var iconButtonClick = function (event) {
                var ids = event.target.id.split(/_AX_/g);
                var itemIndex = ids[ids.length - 2];
                var buttonIndex = ids[ids.length - 1];

                if (viewIconObj.buttons.items[buttonIndex].onclick) {
                    viewIconObj.buttons.items[buttonIndex].onclick.call({
                        index: itemIndex,
                        list: _list,
                        item: _list[itemIndex],
                        buttonItem: viewIconObj.buttons.items[buttonIndex]
                    });
                }
            };
            var iconButtonClickBind = iconButtonClick.bind(this);

            this.body.find(".bodyViewIcon .viewIconButtonsItem").bind("click", function (event) {
                iconButtonClickBind(event);
            });

        }
        else if (cfg.viewMode == "mobile") {

            var mobileView = cfg.view;
            if (mobileView == undefined) {
                var columns = [];
                for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                    var col = null, addClass = "";
                    if (CG.widthAstric || CG.width.number() >= 200) {
                        col = 4;
                        addClass = "underLine";
                    }
                    else if (CG.width.number() >= 100) {
                        col = 2;
                    }
                    else if (CG.width.number() >= 40) {
                        //col = 1;
                    }
                    columns.push(
                        {
                            key: CG.key,
                            label: CG.label,
                            col: col,
                            formatter: CG.formatter,
                            addClass: addClass,
                            sort: (CG.sort || ""),
                            display: (CG.display || true)
                        }
                    );
                }
                columns = columns.sort(function (pItem, nItem) {
                    var v1 = pItem.col;
                    var v2 = nItem.col;
                    if (v1 < v2) return 1;
                    else if (v1 > v2) return -1;
                    else if (v1 == v2) return 0;
                });
                mobileView = {
                    labelView: true,
                    column: columns
                };
            }

            for (var item, itemIndex = 0, __arr = this.list; (itemIndex < __arr.length && (item = __arr[itemIndex])); itemIndex++) {
                po.push(getMobileItem(itemIndex, item, mobileView));
            }

            if (this.list.length == 0) { /* empty tags */
                po.push("<div class=\"bodyViewMobile\" align=\"center\">");
                po.push(cfg.emptyListMSG);
                po.push("</div>");
            }

            axdom("#" + cfg.targetID + "_AX_gridBodyDiv").empty();
            axdom("#" + cfg.targetID + "_AX_gridBodyDiv").append(po.join(''));

            this.body.find(".bodyViewMobile").bind("click", this.gridBodyClick.bind(this));
            if (this.needBindDBLClick()) this.body.find(".bodyViewMobile").bind("dblclick", this.gridBodyDBLClick.bind(this));

            if (this.selectedRow && this.selectedRow.length > 0) {
                var body = this.body;
                for (var item, itemIndex = 0, __arr = this.selectedRow; (itemIndex < __arr.length && (item = __arr[itemIndex])); itemIndex++) {
                    body.find(".bodyViewMobile_" + item).addClass("selected");
                }
            }

            var _list = this.list;
            var mobileButtonClick = function (event) {
                var ids = event.target.id.split(/_AX_/g);
                var itemIndex = ids[ids.length - 2];
                var buttonIndex = ids[ids.length - 1];

                if (mobileView.buttons[buttonIndex].onclick) {
                    mobileView.buttons[buttonIndex].onclick.call({
                        index: itemIndex,
                        list: _list,
                        item: _list[itemIndex],
                        buttonItem: mobileView.buttons[buttonIndex]
                    });
                }
            };
            var mobileButtonClickBind = mobileButtonClick.bind(this);

            this.body.find(".bodyViewMobile").find(".buttonGroupItem").bind("click", function (event) {
                mobileButtonClick(event);
            });
        }

        this.selectedCells.clear();
        // selectedCells clear

        if (typeof args == "undefined") {
            this.contentScrollResize();
        }
        else if (typeof args != "undefined" && args.sort)
        {
            this.contentScrollResize(false);
        }

        this.contentScrollXAttr = null;
        this.contentScrollYAttr = null;
    },
    /**
     * @method AXGrid.updateList
     * @param itemIndex {Number} - 대상 인덱스
     * @param item {Object} - 대상 인덱스의 리스트 아이템.
     * @returns {AXGrid}
     * @description body(list) 구성시 marker row 가 존재할경우 처리 합니다.
     * @example
     * ```
     *  var item = {
     * 	a: "a",
     * 	b: "b",
     * 	c: "c",
     * 	d: "d",
     * 	e: 14350
     *  };
     *      myGrid.updateList(0,item);
     * ```
     */
    updateList: function (itemIndex, item) {
        var cfg = this.config;
        this.cancelEditor();

        if (item._CUD == "C") {

        }
        else if (item._CUD == "D") {
            toast.push("삭제된 아이템 입니다. 수정할 수 없습니다.");
            return;
            /*삭제된 개체 수정 금지 */
        }
        else {
            item._CUD = "U";
        }

        this.list[itemIndex] = item;

        var npo = this.getItem(itemIndex, item, "n", "notr");
        if (this.hasFixed) {
            var fpo = this.getItem(itemIndex, item, "fix", "notr");
        }

        axdom("#" + cfg.targetID + "_AX_tbody").find(".gridBodyTr_" + itemIndex).html(npo);
        if (this.hasFixed) {
            axdom("#" + cfg.targetID + "_AX_fixedTbody").find(".gridBodyTr_" + itemIndex).html(fpo);
        }

        var trAddClass = "";
        if (cfg.body.addClass) {
            try {
                trAddClass = cfg.body.addClass.call({
                        index: itemIndex,
                        item: item,
                        list: this.list
                    }) || "";
            } catch (e) {
                console.log(e);
            }
        }

        axdom("#" + cfg.targetID + "_AX_tbody").find(".gridBodyTr_" + itemIndex).addClass(trAddClass);
        if (this.hasFixed) {
            axdom("#" + cfg.targetID + "_AX_fixedTbody").find(".gridBodyTr_" + itemIndex).addClass(trAddClass);
        }
        this.redrawDataSet();
    },
    /**
     * @method AXGrid.pushList
     * @param {Object|Array} pushItem
     * @param {Number} [insertIndex] - 삽입위치 인덱스 <en>Index of Insert Position</en>
     * @returns {AXGrid}
     * @description 그리드에 데이터를 삽입합니다. <en>push to Grid.list</en>
     * @example
     * ```
     *  myGrid.pushList([item Array]);
     *  myGrid.pushList([item Array], 1);
     *  myGrid.pushList([item]);
     * ```
     */
    pushList: function (pushItem, insertIndex) {
        var cfg = this.config;

        if (this.inline_edit) {
            setTimeout((function () {
                this.pushList(pushItem, insertIndex);
            }).bind(this), 300);
            return this;
        }
        this.cancelEditor();
        var pushData = [];
        // 오브젝트 또는 Array를 처리 할 수 있도록 변경
        if (Object.isArray(pushItem)) {
            pushData = pushItem;
        }
        else {
            pushData = [pushItem];
        }

        pushItem._CUD = "C";
        if (insertIndex != null && typeof insertIndex != "undefined") {
            if (insertIndex > this.list.length) {
                insertIndex = this.list.length;
            }
            var itemIndex = insertIndex;
            var newList = [];
            for (var L, listIndex = 0, __arr = this.list; (listIndex < __arr.length && (L = __arr[listIndex])); listIndex++) {
                if (listIndex == itemIndex) {
                    for (var li = 0; li < pushData.length; li++) {
                        newList.push(pushData[li]);
                    }
                }
                newList.push(L);
            }

            if (listIndex == itemIndex) {
                for (var li = 0; li < pushData.length; li++) {
                    newList.push(pushData[li]);
                }
            }

            this.list = newList;

            /*
             var item = this.list[itemIndex];
             var npo = this.getItem(itemIndex, item, "n");
             if (this.hasFixed) {
             var fpo = this.getItem(itemIndex, item, "fix");
             }
             */

            this.printList();
            //this.bigDataSyncApply();
            this.contentScrollResize(false);
            this.setFocus(itemIndex);

        }
        else {
            for (var li = 0; li < pushData.length; li++) {
                this.list.push(pushData[li]);
            }
            this.printList();
            //this.bigDataSyncApply();
            this.contentScrollResize(false);
            //this.setFocus(this.list.length-1); insertIndex 가 없으면 focus 실행 안함.
        }

        this.setStatus(this.list.length);
        this.redrawDataSet();

        return this;
    },
    /**
     * @method AXGrid.fetchList
     * @param list {Array} - 추가될 list item Array
     * @returns {AXGrid}
     * @description grid의 리스트에 아이템을 추가 합니다.(배열)
     * @example
     * ```
     *  var list = [
     *      {no:1, title:"AXGrid 첫번째 줄 입니다.", writer:"장기영", regDate:"2013-01-18", desc:"myGrid.setList 의 첫번째 사용법 list json 직접 지정 법", price:123000, amount:10},
     *      {no:2, title:"AXGrid 두번째 줄 입니다.", writer:"장기영", regDate:"2013-01-18", desc:"myGrid.setList 의 첫번째 사용법 list json 직접 지정 법", price:12300, amount:7},
     *      {no:3, title:"AXGrid 세번째 줄 입니다.", writer:"장기영", regDate:"2013-01-18", desc:"myGrid.setList 의 첫번째 사용법 list json 직접 지정 법", price:12000, amount:5}
     *  ];
     *  myGrid.fetchList(list);
     * ```
     */
    fetchList: function (list) {
        var cfg = this.config, VS = this.virtualScroll;
        this.list = this.list.concat(list);

        this.cachedDom.tfpadding.css({height: cfg.scrollContentBottomMargin.number() + (this.list.length - VS.startIndex - 1) * (VS.itemTrHeight)});
        if (this.hasFixed) {
            this.cachedDom.ftfpadding.css({height: cfg.scrollContentBottomMargin.number() + (this.list.length - VS.endIndex - 1) * (VS.itemTrHeight)});
        }

        if (!cfg.page.paging) {
            this.setStatus(this.list.length);
        }
        this.contentScrollResize(false);
    },
    /**
     * @method AXGrid.removeList
     * @param removeList {Array} - 키값 배열
     * @returns {AXGrid}
     * @description removeList의 전달된 키값 과 일치하는 대상을 삭제 합니다.이때 고유한 값이 아닌 항목을 전달 할 때에는 에러가 발생 할 수 있습니다.
     * @example
     * ```
     * var checkedList = myGrid.getCheckedList(0);// colSeq
     * var removeList = [];
     * $.each(checkedList, function(){
     * 	removeList.push({no:this.no});
     * });
     * myGrid.removeList(removeList);
     * ```
     */
    removeList: function (removeList) {
        var cfg = this.config;
        if (cfg.passiveMode) {

            var _list = this.list;
            var collect = [];
            axf.each(removeList, function (ridx, r) {
                axf.each(_list, function (lidx, l) {
                    var isDel = false;
                    axf.each(r, function (k, v) {
                        if (l[k] == v) {
                            isDel = true;
                        }
                        else {
                            isDel = false;
                            return false;
                        }
                    });
                    if (isDel) {
                        if (cfg.passiveRemoveHide) {
                            l._isDel = true;
                        }
                        else {
                            if (l._CUD != "C") {
                                l._CUD = "D";
                            }
                            else {
                                l._isDel = true;
                            }
                        }
                        collect.push(l);
                    }
                    else {
                        collect.push(l);
                    }
                });
            });
            this.list = collect;
        }
        else {
            var collect = [];
            axf.each(this.list, function (lidx, l) {
                var isPush = true;
                axf.each(removeList, function (ridx, r) {
                    axf.each(r, function (k, v) {
                        if (l[k] == v) {
                            isPush = false;
                            return false;
                        }
                    });
                    if (!isPush) return false;
                });
                if (isPush) collect.push(l);
            });

            this.list = collect;
        }

        if (cfg.viewMode == "grid" && cfg.height != "auto") {
            this.bigDataSync(true);
        }
        else {
            this.printList();
            this.contentScrollResize();
        }
        this.setStatus(this.list.length);
        this.redrawDataSet();
    },
    /**
     * @method AXGrid.removeListIndex
     * @param removeList {Array} - index 배열 (key value "index" 가 있어야 함)
     * @returns {AXGrid}
     * @description removeList의 index에 해당하는 항목을 제거 합니다..
     * @example
     * ```
     *  var removeList = [{index:0},{index:1},{index:2}];
     *  myGrid.removeListIndex(removeList);
     * ```
     */
    removeListIndex: function (removeList) {
        var cfg = this.config;

        var _list = this.list;

        if (cfg.passiveMode) {

            axf.each(removeList, function (ridx, r) {
                if (_list[r.index]) {
                    if (cfg.passiveRemoveHide) {
                        _list[r.index]._isDel = true;
                    }
                    else {
                        if (_list[r.index]._CUD != "C") {
                            _list[r.index]._CUD = "D";
                        }
                        else {
                            _list[r.index]._isDel = true;
                        }
                    }
                }
            });

            var collect = [];
            var removeCollect = this.removedList;
            axf.each(_list, function () {
                if (!this._isDel) collect.push(this);
                else {
                    if (this._CUD != "C") {
                        removeCollect.push(this);
                    }
                }
            });
            this.list = collect;
            this.removedList = removeCollect;

        }
        else {

            var collect = [];
            axf.each(removeList, function (ridx, r) {
                if (_list[r.index]) {
                    _list[r.index]._isDel = true;
                }
            });

            var collect = [];
            var removeCollect = this.removedList;
            axf.each(_list, function () {
                if (!this._isDel) collect.push(this);
                else removeCollect.push(this);
            });
            this.list = collect;
            this.removedList = removeCollect;
        }

        this.selectedCells.clear();
        this.selectedRow.clear();

        if (cfg.viewMode == "grid" && cfg.height != "auto") {
            this.bigDataSync(true);
        }
        else {
            this.printList();
            this.contentScrollResize();
        }

        this.setStatus(this.list.length);
        this.redrawDataSet();
    },
    /**
     * @method AXGrid.restoreList
     * @param removeList {Array} - 키값 배열
     * @returns {AXGrid}
     * @description restoreList 전달된 키값 과 일치하는 대상의 삭제 표시를 제거 합니다.이때 고유한 값이 아닌 항목을 전달 할 때에는 에러가 발생 할 수 있습니다.(passive)
     * @example
     * ```
     *  var myGrid = new AXGrid();
     *  myGrid.setConfig({passiveMode:true});
     *  var checkedList = myGrid.getCheckedList(0);// colSeq
     *  var removeList = [];
     *  $.each(checkedList, function(){
     * 	removeList.push({no:this.no});
     *  });
     *  myGrid.restoreList(removeList);
     * ```
     */
    restoreList: function (restoreList) {
        var cfg = this.config;
        var collect = [];

        for (var lidx = 0; lidx < this.list.length; lidx++) {
            var isDel = false, l = this.list[lidx];
            for (var ridx = 0; ridx < restoreList.length; ridx++) {
                var r = restoreList[ridx];
                axf.each(r, function (k, v) {
                    if (l[k] == v) {
                        isDel = true;
                    }
                    else {
                        isDel = false;
                        return false;
                    }
                });
                if (isDel) break;
            }
            if (isDel) {
                if (l._CUD == "D") {
                    l._CUD = "";
                }
                collect.push(l);
            }
            else {
                collect.push(l);
            }
        }

        this.list = collect;
        if (cfg.viewMode == "grid" && cfg.height != "auto") {
            this.bigDataSync(true);
        }
        else {
            this.printList();
            this.contentScrollResize();
        }
        this.setStatus(this.list.length);
        this.redrawDataSet();
    },
    /**
     * @method AXGrid.gridBodyOver
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  Grid 리스트(body)에 대한 mouseover 이벤트 처리를 합니다.
     */
    gridBodyOver: function (event) {
        var cfg = this.config;

        if (this.overedItemIndex) {
            this.body.find(".gridBodyTr_" + this.overedItemIndex).removeClass("hover");
        }
        var itemIndex = (event.target.id).split(/_AX_/g).last();
        if (itemIndex != "") {
            this.body.find(".gridBodyTr_" + itemIndex).addClass("hover");
            this.overedItemIndex = itemIndex;
        }

        this.onevent_grid({type: "grid-list-over"});
    },
    /**
     * @method AXGrid.gridBodyOut
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  Grid 리스트(body)에 대한 mouseout 이벤트 처리를 합니다.
     */
    gridBodyOut: function (event) {
        var cfg = this.config;

        if (this.overedItemIndex) {
            this.body.find(".gridBodyTr_" + this.overedItemIndex).removeClass("hover");
        }

    },
    /**
     * @method AXGrid.gridBodyClick
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  Grid 리스트(body)에 대한 click 이벤트 처리를 합니다.
     */
    gridBodyClick: function (event) {
        var cfg = this.config;

        if (event.target.tagName.toLowerCase() == "input" && (
                event.target.type == "radio" || event.target.type == "checkbox"
            ))
        {
            this.gridBodyClickAct(event);
        }
        else if (cfg.body.ondblclick && !event.shiftKey && !(event.metaKey || event.ctrlKey)) {
            if (this.needBindDBLClick()) {
                clearTimeout(this.bodyClickObserver);
                this.gridBodyClickAct(event);
            }
            else {
                if (this.bodyClickObserver) {
                    clearTimeout(this.bodyClickObserver);
                    this.gridBodyDBLClick(event);
                    this.bodyClickObserver = null;
                    return;
                }
                var gridBodyClickAct = this.gridBodyClickAct.bind(this);
                this.bodyClickObserver = setTimeout(function () {
                    gridBodyClickAct(event);
                }, 400);
            }
        }
        else {
            this.gridBodyClickAct(event);
        }
    },
    /**
     * @method AXGrid.gridBodyClickAct
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  Grid 리스트(body)내부 요소에 대한 클릭 후 처리를 합니다(checkbox,radio).
     */
    gridBodyClickAct: function (event) {
        this.bodyClickObserver = null;
        var cfg = this.config;
        var eventTarget = event.target;

        if (event.target.id != "") {
            //var eid = event.target.id.split(/_AX_/g);
            var isoncheck = false, checkedValue;
            if (eventTarget.tagName.toLowerCase() == "input") {
                if (!eventTarget.disabled) {
                    if (eventTarget.type.toLowerCase() == "checkbox" || eventTarget.type.toLowerCase() == "radio") {

                        isoncheck = true;
                        checkedValue = eventTarget.checked;

                        var ieid = event.target.id.split(/_AX_/g);
                        var checkboxColSeq = ieid[ieid.length - 2];
                        var checkboxIndex = ieid[ieid.length - 1];
                        if (cfg.colGroup[checkboxColSeq] && cfg.colGroup[checkboxColSeq].oncheck) {
                            var sendObj = {
                                index: checkboxIndex,
                                list: this.list,
                                item: this.list[checkboxIndex]
                            };
                            try {
                                cfg.colGroup[checkboxColSeq].oncheck.call(sendObj, event.target.checked);
                            } catch (e) {
                                console.log(e);
                            }
                        }
                    }
                }
            }
        }

        if (isoncheck)
        { /*체크박스 구현 */
            var targetID = event.target.id;
            var itemIndex = targetID.split(/_AX_/g).last();
            var ids = targetID.split(/_AX_/g);
            if (ids.length < 4) return; //  약속된 아이디 형식이 아님.
            var item = this.list[itemIndex], r = ids[ids.length - 3], c = ids[ids.length - 2];

            if (cfg.colGroup[c].formatter === "radio") {
                var ii = 0, ll = this.list.length;
                for (; ii < ll; ii++) {
                    if (typeof this.list[ii].___checked === "undefined") this.list[ii].___checked = {};
                    this.list[ii].___checked[c] = false;
                }
            }

            if (typeof this.list[itemIndex].___checked === "undefined") this.list[itemIndex].___checked = {};
            this.list[itemIndex].___checked[c] = checkedValue;
            //console.log(this.list[itemIndex].___checked[c]);

            var target = event.target;
            var checked = event.target.checked;
            var sendObj = {
                index: itemIndex,
                target: event.target,
                checked: event.target.checked,
                r: r,
                c: c,
                list: this.list,
                item: item,
                page: this.page
            };
            try {
                if (cfg.body.oncheck) cfg.body.oncheck.call(sendObj, itemIndex, item);
            } catch (e) {
                console.log(e);
            }
        }
        else {
            var myTarget = axf.get_event_target(eventTarget, function (el) {
                var edom = axdom(el);
                return (!edom.hasClass("buttonGroupItem") && (edom.hasClass("bodyTd") || edom.hasClass("bodyViewIcon") || edom.hasClass("bodyViewMobile")));
            });

            /* event target search ------------------------ */

            if (cfg.viewMode == "grid") {
                if (myTarget) {

                    var body = this.body,
                        targetID = myTarget.id,
                        itemIndex = targetID.split(/_AX_/g).last(),
                        ids = targetID.split(/_AX_/g),
                        len = this.selectedRow.length, _selectedRow = [], hasItem = false,
                        r = ids[ids.length - 3], c = ids[ids.length - 2],
                        CG = cfg.colGroup[(cfg.body.rowsEmpty) ? c : (cfg.body.rows[r][c].colSeq || c)],
                        i = 0;

                    this._focusedItemIndex = itemIndex;
                    if (this.editCellClear(r, c, itemIndex) === false) {

                        if (CG.editor) return this; // 현재 에디팅 중인 셀이 클릭 되었을 때는 아무런 클릭 이벤트를 발생 시키지 않습니다.
                    }

                    if (event.shiftKey) {
                        if (this.selectedCells.length > 0) { // 셀선택 클리어
                            axf.each(this.selectedCells, function () {
                                body.find(".bodyTd_" + this).removeClass("selected");
                            });
                            this.selectedCells.clear();
                        }

                        if (len > 0) {
                            var l_itemIndex = this.selectedRow.last().number(), itemIndex = itemIndex.number(), st_index, ed_index;
                            if (l_itemIndex < itemIndex) {
                                st_index = l_itemIndex + 1;
                                ed_index = itemIndex;
                            }
                            else {
                                st_index = itemIndex;
                                ed_index = l_itemIndex;
                            }

                            for (var k = st_index; k < (ed_index + 1); k++) {
                                hasItem = false;
                                i = 0;
                                for (; i < len; i++) {
                                    if (k == this.selectedRow[i].number()) {
                                        hasItem = true;
                                        break;
                                    }
                                }
                                if (!hasItem) {
                                    this.body.find(".gridBodyTr_" + k).addClass("selected");
                                    this.selectedRow.push(k);
                                }
                            }
                        }
                        else {
                            this.body.find(".gridBodyTr_" + itemIndex).addClass("selected");
                            this.selectedRow.push(itemIndex.number());
                        }
                        this.clearRange();
                    }
                    else if (event.metaKey || event.ctrlKey)
                    {
                        if (this.selectedCells.length > 0) { // 셀선택 클리어
                            axf.each(this.selectedCells, function () {
                                body.find(".bodyTd_" + this).removeClass("selected");
                            });
                            this.selectedCells.clear();
                        }

                        for (; i < len; i++) {
                            if (this.selectedRow[i] == itemIndex.number()) {
                                body.find(".gridBodyTr_" + itemIndex).removeClass("selected");
                                hasItem = true;
                            }
                            else {
                                _selectedRow.push(this.selectedRow[i]);
                            }
                        }
                        this.selectedRow = _selectedRow;

                        if (!hasItem) {
                            body.find(".gridBodyTr_" + itemIndex).addClass("selected");
                            this.selectedRow.push(itemIndex.number());
                        }

                        // 셀 선택 기능 : 비활성처리
                        /*
                         if(false) {
                         var hasID = false;
                         var collect = [];
                         axf.each(this.selectedCells, function () {
                         if (this == targetID) {
                         hasID = true;
                         } else {
                         collect.push(this);
                         }
                         });
                         if (hasID) {
                         axdom("#" + targetID).removeClass("selected");
                         this.selectedCells = collect;
                         } else {
                         axdom("#" + targetID).addClass("selected");
                         this.selectedCells.push(targetID);
                         }
                         }
                         */

                        this.clearRange();
                    }
                    else {
                        if (this.selectedCells.length > 0) { // 셀선택 클리어
                            axf.each(this.selectedCells, function () {
                                body.find(".bodyTd_" + this).removeClass("selected");
                            });
                            this.selectedCells.clear();
                        }

                        if (CG.editor && (CG.editor.type == "checkbox" || CG.editor.type == "radio" || CG.editor.type == "select" || CG.editor.type == "AXSelect")) {
                            this.editCell(r, c, itemIndex, 0, event);
                        }
                        else if (this.selectedRow.length > 0)
                        {
                            // colGroup 에 editor이 있는지 파악

                            if (CG.editor && cfg.control_lock_status < 1) {
                                for (; i < len; i++) {
                                    if (this.selectedRow[i] == itemIndex) {
                                        hasItem = true;
                                        break;
                                    }
                                }
                                if (hasItem) { // inline 에디트가 발생할 수 있는 상황
                                    this.editCell(r, c, itemIndex);
                                }
                            }

                            if (!hasItem) {
                                for (i = 0; i < len; i++) {
                                    body.find(".gridBodyTr_" + this.selectedRow[i]).removeClass("selected");
                                }
                            }
                        }
                        this.selectedRow.clear();
                        this.body.find(".gridBodyTr_" + itemIndex).addClass("selected");
                        this.selectedRow.push(itemIndex.number());

                        if (cfg.mergeCells) { /// mergeCells 이 있는 경우 함께 선택 표시해야할 대상이 있는지 판단 후 처리

                            (function () {
                                var colGroupLen = 0, nowTrTd = this.body.find(".gridBodyTable .gridBodyTr_" + itemIndex).find("td");
                                for (var i = 0, l = cfg.colGroup.length; i < l; i++) {
                                    if (cfg.colGroup[i].display) colGroupLen++;
                                }
                                if (colGroupLen == nowTrTd.length - 1) {
                                    // td중에 rowspan이 있는 컬럼이 있는지 체크
                                    for (var i = 0, l = nowTrTd.length; i < l; i++) {
                                        if (nowTrTd[i].getAttribute("rowspan") > 1) {
                                            for (var ai = 0; ai < nowTrTd[i].getAttribute("rowspan") - 1; ai++) {
                                                this.body.find(".gridBodyTr_" + (Number(itemIndex) + ai + 1)).addClass("selected");
                                                this.selectedRow.push((Number(itemIndex) + ai + 1));
                                            }
                                            break;
                                        }
                                    }
                                }
                                else {
                                    this.selectedRow.clear();
                                    // 이가 빠졌음 머지된 컬럼을 검색 (위로 탐색 나올때까지)
                                    var finding = true, parentItemIndex = itemIndex, safeLoop = 0;
                                    do {
                                        parentItemIndex = parentItemIndex - 1;
                                        var _nowTrTd = this.body.find(".gridBodyTable .gridBodyTr_" + (parentItemIndex)).find("td");
                                        //console.log(colGroupLen, (_nowTrTd.length - 1), parentItemIndex);
                                        if (colGroupLen == _nowTrTd.length - 1) {
                                            for (var i = 0, l = _nowTrTd.length; i < l; i++) {

                                                if (_nowTrTd[i].getAttribute("rowspan") > 1) {
                                                    //console.log(_nowTrTd[i].getAttribute("rowspan"));
                                                    for (var ai = 0; ai < _nowTrTd[i].getAttribute("rowspan"); ai++) {
                                                        this.body.find(".gridBodyTr_" + (Number(parentItemIndex) + ai)).addClass("selected");
                                                        this.selectedRow.push((Number(parentItemIndex) + ai));
                                                    }
                                                    break;
                                                }
                                            }
                                            finding = false;
                                        }
                                        safeLoop++;
                                        if (safeLoop > 1000) finding = false;
                                    } while (finding)

                                }
                            }).call(this);
                        }

                        this.body.find(".gridBodyTr_" + itemIndex).find(".bodyTd_" + c + ".bodyTdr_" + r).addClass("selected");
                        this.selectedCells.push(c);

                        var item = this.list[itemIndex];

                        if (!hasItem && cfg.body.onclick) {

                            var sendObj = {
                                index: itemIndex,
                                r: r,
                                c: c,
                                list: this.list,
                                item: item,
                                page: this.page
                            };
                            try {
                                cfg.body.onclick.call(sendObj, itemIndex, item);
                            } catch (e) {
                                console.log(e);
                            }
                        }
                        /*if(this.hasEditor) this.setEditor(item, itemIndex); */
                    }
                }
            }
            else if (cfg.viewMode == "icon") {
                if (myTarget) {
                    var targetID = myTarget.id;
                    var itemIndex = targetID.split(/_AX_/g).last();
                    this._focusedItemIndex = itemIndex;

                    if (event.shiftKey) {

                    }
                    else if (!(event.metaKey || event.ctrlKey)) {

                        if (this.selectedRow.length > 0) {
                            var body = this.body;
                            axf.each(this.selectedRow, function () {
                                body.find(".bodyViewIcon_" + this).removeClass("selected");
                            });
                        }

                        this.selectedRow.clear();
                        this.body.find(".bodyViewIcon_" + itemIndex).addClass("selected");
                        this.selectedRow.push(itemIndex);

                        var item = this.list[itemIndex];

                        if (cfg.body.onclick) {
                            var sendObj = {
                                index: itemIndex,
                                list: this.list,
                                item: item,
                                page: this.page
                            };
                            try {
                                cfg.body.onclick.call(sendObj, itemIndex, item);
                            } catch (e) {
                                console.log(e);
                            }
                        }
                    }
                }
            }
            else if (cfg.viewMode == "mobile") {
                if (myTarget) {
                    var targetID = myTarget.id;
                    var itemIndex = targetID.split(/_AX_/g).last();
                    this._focusedItemIndex = itemIndex;

                    if (event.shiftKey) {

                    }
                    else if (event.metaKey || event.ctrlKey) {

                    }
                    else {

                        if (this.selectedRow.length > 0) {
                            var body = this.body;
                            axf.each(this.selectedRow, function () {
                                body.find(".bodyViewMobile_" + this).removeClass("selected");
                            });
                        }

                        this.selectedRow.clear();
                        this.body.find(".bodyViewMobile_" + itemIndex).addClass("selected");
                        this.selectedRow.push(itemIndex);

                        var item = this.list[itemIndex];

                        if (cfg.body.onclick) {
                            var sendObj = {
                                index: itemIndex,
                                list: this.list,
                                item: item,
                                page: this.page
                            };
                            try {
                                cfg.body.onclick.call(sendObj, itemIndex, item);
                            } catch (e) {
                                console.log(e);
                            }
                        }
                    }
                }
            }

            this.onevent_grid({type: "grid-list-click"});
        }

    },
    /**
     * @method AXGrid.gridBodyDBLClick
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  Grid 리스트(body)에 대한 doubleclick 이벤트 처리를 합니다.
     */
    gridBodyDBLClick: function (event) {
        var cfg = this.config;
        var eventTarget = event.target;
        if (eventTarget.tagName.toLowerCase() == "input" || eventTarget.tagName.toLowerCase() == "button") return;
        /*input, button 인 경우 제외 */

        var myTarget = axf.get_event_target(eventTarget, function (el) {
            var edom = axdom(el);
            return (!edom.hasClass("buttonGroupItem") && (edom.hasClass("bodyTd") || edom.hasClass("bodyViewIcon") || edom.hasClass("bodyViewMobile")));
        });

        /* event target search ------------------------ */
        if (cfg.viewMode == "grid") {
            if (myTarget) {
                /*colHeadTool ready */
                /*console.log({tagName:myTarget.tagName, id:myTarget.id}); */
                var targetID = myTarget.id;
                var itemIndex = targetID.split(/_AX_/g).last();
                var ids = targetID.split(/_AX_/g);

                if (this.selectedRow.length > 0) {
                    var body = this.body;
                    axf.each(this.selectedRow, function () {
                        body.find(".gridBodyTr_" + this).removeClass("selected");
                    });
                }
                this.selectedRow.clear();
                this.body.find(".gridBodyTr_" + itemIndex).addClass("selected");
                this.selectedRow.push(itemIndex);

                if (cfg.body.ondblclick) {
                    var r = ids[ids.length - 3];
                    var c = ids[ids.length - 2];
                    var item = this.list[itemIndex];
                    var sendObj = {
                        index: itemIndex,
                        r: r,
                        c: c,
                        list: this.list,
                        item: item,
                        page: this.page
                    };
                    try {
                        cfg.body.ondblclick.call(sendObj, itemIndex, item);
                    } catch (e) {
                        console.log(e);
                    }
                }
            }
        }
        else if (cfg.viewMode == "icon") {
            if (myTarget) {
                /*colHeadTool ready */
                /*console.log({tagName:myTarget.tagName, id:myTarget.id}); */
                var targetID = myTarget.id;
                var itemIndex = targetID.split(/_AX_/g).last();

                if (this.selectedRow.length > 0) {
                    var body = this.body;
                    axf.each(this.selectedRow, function () {
                        body.find(".bodyViewIcon_" + this).removeClass("selected");
                    });
                }
                this.selectedRow.clear();
                this.body.find(".bodyViewIcon_" + itemIndex).addClass("selected");
                this.selectedRow.push(itemIndex);

                if (cfg.body.ondblclick) {
                    var item = this.list[itemIndex];
                    var sendObj = {
                        index: itemIndex,
                        list: this.list,
                        item: item,
                        page: this.page
                    };
                    try {
                        cfg.body.ondblclick.call(sendObj, itemIndex, item);
                    } catch (e) {
                        console.log(e);
                    }
                }
            }
        }
        else if (cfg.viewMode == "mobile") {
            if (myTarget) {
                /*colHeadTool ready */
                /*console.log({tagName:myTarget.tagName, id:myTarget.id}); */
                var targetID = myTarget.id;
                var itemIndex = targetID.split(/_AX_/g).last();

                if (this.selectedRow.length > 0) {
                    var body = this.body;
                    axf.each(this.selectedRow, function () {
                        body.find(".bodyViewMobile_" + this).removeClass("selected");
                    });
                }
                this.selectedRow.clear();
                this.body.find(".bodyViewMobile_" + itemIndex).addClass("selected");
                this.selectedRow.push(itemIndex);

                if (cfg.body.ondblclick) {
                    var item = this.list[itemIndex];
                    var sendObj = {
                        index: itemIndex,
                        list: this.list,
                        item: item,
                        page: this.page
                    };
                    try {
                        cfg.body.ondblclick.call(sendObj, itemIndex, item);
                    } catch (e) {
                        console.log(e);
                    }
                }
            }
        }

        this.stopEvent(event);
        this.clearRange();
    },
    /**
     * 그리드 셀 인라인 에디트
     * @method AXGrid.editCell
     * @param {Number} r - index of body.rows
     * @param {Number} c - index of colGroup
     * @param {Number} itemIndex - index of this.list
     * @returns {AXGrid}
     */
    editCell: function (r, c, ii, times, event) {

        this.setFocus(ii);
        var get_editor;
        // todo : 바디아이템으로 부터 colGroup 정확히 구하기
        var _this = this, cfg = this.config, CG = cfg.colGroup[(cfg.body.rowsEmpty) ? c : (cfg.body.rows[r][c].colSeq || c)],
            po = [], that = {item: this.list[ii], index: ii, CG: CG, r: r, c: c};

        //td : div 의 부모TD 태그, parent_type : nbody|fixedbody 로 결정되어 위치를 판단하는데 쓰임.
        //po : 태그 생성 배열, inline_editor_id : 인라인 에디터의 아이디
        // todo : 틀고정 영역이 있을 때 인라인 에디팅 테스트

        // disabled 체크
        if (CG.editor.disabled) {
            if (CG.editor.disabled.call(that)) {
                return this;
            }
        }

        // 2015-06-04 신규 , 수정시 필드  시작
        if (CG.editor.createEdit === false && that.item['_CUD'] == 'C') {
            return this;
        }

        if (CG.editor.updateEdit === false && that.item['_CUD'] != 'C') {
            return this;
        }
        // 2015-06-04 신규 , 수정시 필드  끝

        // 2015-06-09 edit 활성화시 스크롤 이동하게 처리.
        var trackX = _this.scrollTrackX;

        if (trackX.is(':visible')) {
            var _r = r, _c = c;
            var colHeadRows = cfg.colHead.rows;
            if (colHeadRows.length > 1) {
                if (!this.config.colHead._headerRow) {
                    this.config.colHead._headerRow = {};

                    for (var i = 0; i < colHeadRows.length; i++) {
                        for (var j = 0; j < colHeadRows[i].length; j++) {
                            this.config.colHead._headerRow[colHeadRows[i][j].key] = {r: i, c: j};
                        }
                    }
                }
                _r = this.config.colHead._headerRow[that.CG.key].r;
                _c = this.config.colHead._headerRow[that.CG.key].c;
            }

            var selColHeader = jQuery("#" + cfg.targetID + "_AX_colHead_AX_" + _r + "_AX_" + _c)
                , scrollXW = _this.scrollXHandle.width()
                , trackXW = trackX.width()
                , editHeaderLW = (selColHeader.position().left + selColHeader.width())
                , absEditHeaderLW = editHeaderLW - Math.abs(_this.colHead.position().left);

            var _leftval = 0, scrollSyncFlag = false;
            if (absEditHeaderLW > 0 && absEditHeaderLW < trackXW * 2) {
                if (absEditHeaderLW > trackXW) {
                    scrollSyncFlag = true;
                    _leftval = _this.scrollXHandle.position().left + ((absEditHeaderLW - trackXW) / (_this.colHead.width() / trackXW));
                    _leftval = _leftval + 10;
                }
                else {
                    if (selColHeader.width() > absEditHeaderLW) {
                        scrollSyncFlag = true;
                        _leftval = _this.scrollXHandle.position().left - ((selColHeader.width() - absEditHeaderLW) / (_this.colHead.width() / trackXW));
                        _leftval = _leftval - 10;
                    }
                }
            }
            else {
                scrollSyncFlag = true;
                _leftval = editHeaderLW / (_this.colHead.width() / trackXW) - (scrollXW / 2);
            }

            if (scrollSyncFlag) {
                _leftval = _leftval < 0 ? 0 : ( _leftval > trackXW - scrollXW ? trackXW - scrollXW : _leftval );

                _this.contentScrollScrollSync({left: _leftval});
                _this.scrollXHandle.css('left', (_leftval) + 'px');
            }
        }
        // 2015-06-09 edit 활성화시 스크롤 이동하게 처리.

        this.editCellClear();

        if (CG.editor.type == "checkbox" || CG.editor.type == "radio") {
            if (CG.editor.type == "radio") {
                var _i = 0, _l = this.list.length;
                for (; _i < _l; _i++) this.list[_i][CG.key] = false;
            }
            var checkbox_els = _this.body.find('[data-editor-key="' + ii + ',' + c + '"]').get(0);
            if (event && event.target.tagName != "INPUT" && CG.editor.type == "checkbox") {
                _this.updateItem(r, c, ii, !checkbox_els.checked);
            }
            else if (event && event.target.tagName != "INPUT" && CG.editor.type == "radio") {
                _this.updateItem(r, c, ii, true);
            }
            else {
                _this.updateItem(r, c, ii, checkbox_els.checked);
            }
            return this;
        }

        // 타입이 finder 이면 토스~
        if (CG.editor.type == "finder") {
            CG.editor.finder.onclick.call({
                id: cfg.targetID + '_inline_editor',
                value: jQuery('#' + cfg.targetID + '_inline_editor').val(),
                r: r, c: c, index: ii, item: _this.list[ii]
            });
            return this;
        }

        setTimeout(function () {
            var div = _this.body.find("#" + cfg.targetID + "_AX_bodyText_AX_" + r + "_AX_" + c + "_AX_" + ii),
                td, td_ids, td_val, parent_type, inline_editor_id, inline_editor, inline_css, AXBindConfig = {};

            if (!div.get(0)) {
                if ((times | 0) < 3) _this.editCell(r, c, ii, (times | 0) + 1); // 3번시도후 포기 합니다.
                else console.log("에디팅 타겟을 찾을 수 없습니다. AXGrid.editCell");
                // call again
                return false;
            }

            td = div.parent(), td_ids = td.get(0).id.split(/_AX_/g),
                td_val = _this.list[ii][CG.key],
                parent_type = td_ids[td_ids.length - 4],
                inline_editor_id = cfg.targetID + "_AX_inline_editor_AX_" + r + "_AX_" + c + "_AX_" + ii;

            td_val = _this.getFormatterValue(CG.editor.formatter, _this.list[ii], ii, td_val, CG.key, {}, 0);

            po.push('<div class="inline-editor" id="' + inline_editor_id + '">');
            po.push(get_editor(CG.editor, td_val));
            po.push('</div>');
            div.after(po.join(''));

            inline_editor = jQuery("#" + inline_editor_id);

            inline_css = div.position();
            inline_css.width = div.width();
            inline_editor.css(inline_css).find("input").select();
            _this.inline_edit = {editor: inline_editor, r: r, c: c, ii: ii, cell: div};

            if (inline_editor.find("input").get(0) && CG.editor.type != "calendar" && CG.editor.type != "AXSelector") {
                jQuery(document.body).unbind("click.axgrid").bind("click.axgrid", function (e) {
                    var target = axf.get_event_target(e.target, {id: inline_editor_id});
                    if (!target) {
                        _this.updateItem(r, c, ii, inline_editor.find("input").val());
                        jQuery(document.body).unbind("click.axgrid");
                        _this.gridFocus.focus();
                    }
                });
            }

            // AXBind 연결
            jQuery.extend(AXBindConfig, CG.editor.config);

            if (CG.editor.type in _this.inlineEditor) {
                _this.inlineEditor[CG.editor.type].init.call(_this, inline_editor, AXBindConfig, CG, r, c, ii);
            }

            inline_editor.bind("keydown", function (e) {
                if (!e) e = window.event;
                if ((e.keyCode == axf.Event.KEY_RETURN || e.keyCode == axf.Event.KEY_TAB) && (!e.altKey)) {
                    try {
                        if (e.preventDefault) event.preventDefault();
                        if (e.stopPropagation) event.stopPropagation();
                        e.cancelBubble = true;
                    } catch (err) {

                    }
                }
                setTimeout(function () {
                    if (
                        (
                            e.keyCode == axf.Event.KEY_DOWN || e.keyCode == axf.Event.KEY_UP ||
                            e.keyCode == axf.Event.KEY_RETURN || e.keyCode == axf.Event.KEY_TAB
                        ) && (!e.altKey)
                    )
                    {
                        if (e.keyCode == axf.Event.KEY_RETURN || e.keyCode == axf.Event.KEY_TAB) {
                            //_this.updateItem(r, c, ii, e.target.value);
                            jQuery(document.body).trigger('click.axgrid'); //2015-06-12 탭키 눌렀을때 select box 값이 object가 아닌 value로 들어와서 trigger 처리.
                            _this.gridFocus.focus();
                        }

                        if (e.keyCode == axf.Event.KEY_RETURN || e.keyCode == axf.Event.KEY_UP || e.keyCode == axf.Event.KEY_DOWN) {
                            var new_ii;
                            if (e.shiftKey && e.keyCode == axf.Event.KEY_RETURN || e.keyCode == axf.Event.KEY_UP) {
                                new_ii = ii.number() - 1;
                            }
                            else {
                                new_ii = ii.number() + 1;
                            }
                            if (new_ii < 0) new_ii = _this.list.length - 1;
                            if (_this.list.length > new_ii) _this.editCell(r, c, new_ii);

                            //else if (_this.list.length <= new_ii) new_ii = 0;

                        }
                        else if (e.keyCode == axf.Event.KEY_TAB) {
                            var new_c, ci, cl;
                            ci = 0, cl = cfg.colGroup.length;
                            if (e.shiftKey && e.keyCode == axf.Event.KEY_TAB) {
                                for (ci = cl - 1; ci > -1; ci--) {
                                    if (cfg.colGroup[ci].editor && cfg.colGroup[ci].editor.type != "finder") {
                                        if (typeof new_c == "undefined") {
                                            new_c = ci;
                                        }
                                        else if (ci < c) {
                                            new_c = ci;
                                            break;
                                        }
                                    }
                                }
                            }
                            else {
                                for (; ci < cl; ci++) {
                                    if (cfg.colGroup[ci].editor && cfg.colGroup[ci].editor.type != "finder") {
                                        if (typeof new_c == "undefined") {
                                            new_c = ci;
                                        }
                                        else if (ci > c) {
                                            new_c = ci;
                                            break;
                                        }
                                    }
                                }
                            }
                            _this.editCell(r, new_c, ii);
                        }
                        _this.stopEvent(e);
                    }
                    else if (e.keyCode == axf.Event.KEY_ESC) {
                        _this.editCellClear();
                    }
                }, 10);
            });
        }, 10);

        get_editor = function (cond, val) {
            if (typeof val == "undefined") val = "";
            // text, number, money, calendar, select, selector, switch, segment, slider, finder
            var po = [], _val, maxLength = "";
            if (cond.maxLength) maxLength = ' maxLength="' + cond.maxLength + '"';

            if (cond.type === "select" || cond.type === "AXSelect") {

                if (typeof val === "string" || typeof val === "number" || typeof val === "boolean") {
                    _val = val;
                }
                else {
                    _val = val[cond.optionValue || "optionValue"];
                }
                po.push('<select name="inline_editor_item" id="' + cfg.targetID + '_inline_editor" class="inline_editor_select ' + cond.type + '">');
                if (cond.options) {
                    for (var oi = 0; oi < cond.options.length; oi++) {
                        var value, text;
                        value = cond.options[oi][cond.optionValue || "optionValue"], text = cond.options[oi][cond.optionText || "optionText"];
                        //obj[cond.optionValue||"optionValue"] = sdom.options[sdom.selectedIndex].value;

                        po.push('<option value="' + value + '"');
                        if (value == _val) {
                            po.push(' selected="selected"');
                        }
                        po.push('>' + text + '</option>');
                    }
                }
                po.push('</select>');
            }
            else if (cond.type === "AXSelector") {
                //console.log(cond.config.reserveKeys);
                if (typeof val === "string" || typeof val === "number" || typeof val === "boolean") {
                    _val = val;
                }
                else if (cond.config.reserveKeys) {
                    _val = val[cond.config.reserveKeys.optionText];
                }
                else {
                    _val = val["optionText"];
                }

                po.push('<input type="text" name="inline_editor_item" id="' + cfg.targetID + '_inline_editor" value="' + _val + '" class="inline_editor_input ' + cond.type + '" ' + (cond.readonly ? 'readonly="readonly"' : '') + ' />');
            }
            else {
                if (cond.type == "finder") {
                    po.push('<input type="text" name="inline_editor_item" id="' + cfg.targetID + '_inline_editor"' + maxLength + ' value="' + val + '" ');

                    if (cond.readonly) {
                        po.push(' class="inline_editor_input ' + cond.type + '" ');
                        po.push(' readonly="readonly" ');
                    }
                    else {
                        po.push(' class="inline_editor_input ' + cond.type + '" ');
                    }
                    po.push(' />');
                    po.push('<a class="finder-handle"></a>');
                }
                else {
                    po.push('<input type="' + (cond.textType || "text") + '" name="inline_editor_item" id="' + cfg.targetID + '_inline_editor"' + maxLength + ' value="' + val + '" class="inline_editor_input ' + cond.type + '" ' + (cond.readonly ? 'readonly="readonly"' : '') + ' />');
                }
            }
            return po.join('');
        };

        return this;
    },
    /**
     * 셀 인라인 에디트 상태 해제
     * @method AXGrid.editCellClear
     * @param {Number} [r] - index of config.body.rows
     * @param {Number} [c] - index of colGrop
     * @param {Number} [itemIndex] - index of data
     * @returns {AXGrid|false}
     * @example
     * ```
     * mygrid.editCellClear(); // 셀 에디트 상태 해제
     * mygrid.editCellClear(0, 1, 1); // 셀 에디트 해제 하려는 위치가 값을 현재 위치와 비교 하여 false가 리턴되면 현재 위치
     * ```
     */
    editCellClear: function () {
        if (this.inline_edit) {
            if (this.inline_edit.r == arguments[0] && this.inline_edit.c == arguments[1] && this.inline_edit.ii == arguments[2]) {
                return false;
            }
            else if (typeof arguments[2] != "undefined" && this.inline_edit && this.inline_edit.editor.find("input").get(0)) {
                var ids = this.inline_edit.editor.get(0).id.split(/_AX_/g);
                var r, c, ii;
                r = ids[ids.length - 3], c = ids[ids.length - 2], ii = ids[ids.length - 1];
                this.updateItem(r, c, ii, this.inline_edit.editor.find("input").val());
            }
            else {
                try {
                    this.inline_edit.editor.find("input").unbindInput();
                } catch (e) {
                }
                this.inline_edit.editor.remove();
                this.inline_edit = null;
            }
        }
        jQuery(document.body).unbind("click.axgrid");
        return this;
    },
    /**
     * 현재 활성화된 인라인 에디트 input에 값을 지정합니다.
     * @method AXGrid.setEditCellValue
     * @param {String} val
     * @returns {AXGrid}
     * @example
     * ```
     * mygrid.setEditCellValue("123");
     * ```
     */
    setEditCellValue: function (val) {
        if (this.inline_edit) {
            this.inline_edit.editor.find("input, select, textarea").val(val);
        }
        return this;
    },
    /**
     * 리스트데이터의 특정 아이템값을 변경합니다.
     * @method AXGrid.updateItem
     * @param {Number} rowsIndex - 바디의 한아이템의 줄 대게 0 body안에 rows를 구성하는 경우에 사용
     * @param {Number} colsIndex - 컬럼 위치
     * @param {Number} itemIndex - 아이템의 인덱스 <en>index of item<en>
     * @param {String|Number} value - 변경하려는 값
     * @returns {AXGrid}
     * @example
     * ```
     * myGrid.updateItem(0, 2, 1, "AXISJ");
     * ```
     */
    updateItem: function (r, c, itemIndex, value) {
        var _this = this, cfg = this.config,
            CH = cfg.body.rows[r][c], item = this.list[itemIndex],
            CG = cfg.colGroup[c],
            that = {grid: this, item: item, index: itemIndex, CG: CG, r: r, c: c};

        if (cfg.control_lock_status > 1) {
            return this;
        }

        var beforeValue = _this.list[itemIndex][CH.key];

        if (CG.editor) {
            if (CG.editor.type in _this.inlineEditor) {
                value = _this.inlineEditor[CG.editor.type].getValue.call(that, value);
            }

            if (CG.editor.beforeUpdate) {
                value = CG.editor.beforeUpdate.call(that, value);
            }
        }

        _this.list[itemIndex][CH.key] = value;

        // ._CUD 값 조정
        if (_this.list[itemIndex]._CUD != "C" && _this.list[itemIndex]._CUD != "D") {
            var isChanged = false;
            if (Object.isObject(beforeValue)) {
                var beforeValueString = Object.values(beforeValue).join("_");
                var valueString = Object.values(value).join("_");
                isChanged = (beforeValueString != valueString);
            }
            else {
                isChanged = (beforeValue != value);
            }

            if (isChanged) {
                _this.list[itemIndex]._CUD = "U";
            }
        }

        if (this.inline_edit && CG.editor) {
            function cellUpdate() {
                _this.inline_edit.cell.html(_this.getFormatterValue(CH.formatter, item, itemIndex, item[CH.key], CH.key, CH, c));
                if (CG.editor.updateWith) {
                    var i = 0, l = CG.editor.updateWith.length;
                    for (; i < l; i++) {
                        var v = CG.editor.updateWith[i], wCH, wc;
                        // 컬럼 인덱스 찾기
                        axf.each(cfg.colGroup, function (cidx, C) {
                            if (C.key == v) {
                                wc = cidx;
                                return false;
                            }
                        });
                        if (typeof(wc) === "number") {
                            wCH = cfg.body.rows[r][wc];
                            //console.log(v, wCH, r, wc);
                            _this.body.find("#" + cfg.targetID + "_AX_bodyText_AX_" + r + "_AX_" + wc + "_AX_" + itemIndex).html(_this.getFormatterValue(wCH.formatter, item, itemIndex, item[v], v, wCH, wc));
                        }
                    }
                }
            }

            cellUpdate();

            // 2015-06-08 column 별 수정 관련해서 수정 여부 추가. start
            if (_this.list[itemIndex][CH.key + '_VAL']) {
                _this.list[itemIndex][CH.key + '_VAL']['_modify'] = true;
            }
            //end

            if (CG.editor.afterUpdate) {
                CG.editor.afterUpdate.call(that, value);
            }
            _this.editCellClear();
        }
        else {
            //console.log("bigDataSyncApply");
            this.bigDataSyncApply("reload");
        }
        return this;
    },
    /**
     * @method AXGrid.contentScrollResize
     * @param resetLeft {Boolean} - false 시 가로 스크롤은 초기화 하지 않습니다.
     * @description  Grid의 화면에 맞게 스크롤을 생성 합니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.contentScrollResize(false);
     * ```
     */
    contentScrollResize: function (resetLeft) {
        var cfg = this.config, _this = this;
        if (cfg.viewMode == "mobile") return; // 모바일이면 scroll이 없음.

        var bodyHeight = _this.body.height();
        var scrollHeight = _this.scrollContent.height();

        var bodyWidth = _this.body.width();
        var _colWidth = (_this.colWidth.number() + cfg.fitToWidthRightMargin);
        var scrollWidth = (_colWidth > bodyWidth) ? _colWidth : bodyWidth;

        _this.scrollContent.css({width: scrollWidth});
        _this.colHead.css({width: scrollWidth});

        /* colHead width 재정의 */
        if (_this.hasEditor) _this.editor.css({width: bodyWidth});
        if (_this.hasFoot) {
            if (this.cachedDom) {
                (function () {
                    if (!this.cachedDom.tbody.find("#" + cfg.targetID + "_AX_null_AX_0").outerHeight()) return;
                    var itemTrHeight = this.cachedDom.tbody.find("#" + cfg.targetID + "_AX_null_AX_0").outerHeight().number();
                    var printListCount = (this.body.height() / itemTrHeight).ceil();
                    var _count = 0;
                    if (printListCount < this.list.length) {
                        _count = this.list.length - printListCount;
                    }
                    //console.log(cfg.scrollContentBottomMargin, _count, itemTrHeight, this.body.height());

                    this.cachedDom.tfpadding.css({height: cfg.scrollContentBottomMargin.number() + (_count * itemTrHeight)});
                    if (this.hasFixed) {
                        this.cachedDom.ftfpadding.css({height: cfg.scrollContentBottomMargin.number() + (_count * itemTrHeight)});
                    }
                }).call(this);
            }
            _this.gridFoot.css({width: bodyWidth});
        }
        /// 가로 스크롤 포지션 초기화 처리 여부
        if (resetLeft != false || (_this.scrollContent.width() + _this.scrollContent.position().left) < _this.body.width()) {
            _this.scrollContent.css({left: 0});
            _this.colHead.css({left: 0});
            _this.scrollXHandle.css({left: 0});
            if (_this.hasEditor) _this.editor.css({left: 0});
        }

        var show_scroll_x = false,
            show_scroll_y = false,
            scrollContentAdjust = 0
            ;

        if ("수평스크롤 생성 조건 체크") {
            if (scrollWidth > (bodyWidth + 4) && cfg.xscroll) {
                show_scroll_x = true;
            }

            if (show_scroll_x) {
                _this.scrollTrackX.show();
                _this.scrollTrackX.css({width: bodyWidth});
                scrollContentAdjust = _this.scrollTrackX.outerHeight();

                var scrollXHandleWidth = (bodyWidth * bodyWidth) / scrollWidth;
                // 바디너비 트랙너비 , 스크롤 너비
                _this.scrollXHandle.data("width", scrollXHandleWidth);
                if (scrollXHandleWidth < 30) scrollXHandleWidth = 30;
                _this.scrollXHandle.css({width: scrollXHandleWidth});
            }
            else {
                _this.scrollTrackX.hide();
            }

            if (cfg.__height == "auto") {
                // Foot의 높이 만큼 body를 늘려주어야 함.
                _this.scrollBody.css({
                    height: (
                        _this.colHead.outerHeight() +
                        _this.scrollContent.height() +
                        scrollContentAdjust
                    )
                });
                _this.body.css({
                    top: _this.colHead.outerHeight(), height: (
                        _this.scrollContent.height()
                    )
                });
            }
            else {
                _this.body.css({
                    height: (
                        cfg.height.number() -
                        ((this.pageBody.data("display") == "show") ? this.pageBody.outerHeight() : 0) -
                        2 -
                        this.colHead.outerHeight() -
                        scrollContentAdjust
                    )
                });
                _this.scrollTrackY.css({top: _this.colHead.outerHeight(), height: bodyHeight});
            }

            // bodyHeight 재정의
            bodyHeight = _this.body.height();
            scrollHeight = _this.scrollContent.height();
        }

        if ("수직스크롤 생성 조건 체크") {
            if (cfg.__height == "auto") {
                show_scroll_y = false;
            }
            else {
                if (bodyHeight < scrollHeight) {
                    show_scroll_y = true;
                }
            }

            if (show_scroll_y) {
                _this.scrollTrackY.show();
                _this.scrollTrackY.css({top: _this.colHead.outerHeight(), height: bodyHeight});

                var scrollYHandleHeight = (bodyHeight * bodyHeight) / scrollHeight;
                // scrollYHandleHeight 최소 사이즈 예외 처리 최소 높이 = 30
                _this.scrollYHandle.data("height", scrollYHandleHeight);
                if (scrollYHandleHeight < 30) scrollYHandleHeight = 30;
                _this.scrollYHandle.css({height: scrollYHandleHeight});
            }
            else {
                _this.scrollTrackY.hide();
            }
        }

        _this.onevent_grid({type: "scroll-resize"});

        return this;
    },
    /**
     * @method AXGrid.contentScrollScrollSync
     * @param pos {Object} - top, left.
     * @description  top, left에 맞게 스크롤을 이동 합니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.contentScrollScrollSync({left: myGrid.scrollXHandle.position().left});
     * ```
     */
    contentScrollScrollSync: function (pos) {  // move scrollContent
        var cfg = this.config, _this = this;
        // if(_this.colWidth != _this.prev_colWidth) return; // 이전스크롤과 비교

        if (pos.left != undefined) {

            if (!this.contentScrollXAttr) {
                var scrollWidth = (this.colWidth > this.colHead.width()) ? this.colWidth : this.colHead.width();
                this.contentScrollXAttr = {
                    bodyWidth: this.body.width(),
                    scrollWidth: scrollWidth,
                    scrollTrackXWidth: this.scrollTrackX.width(),
                    scrollXHandleWidth: this.scrollXHandle.outerHeight()
                };
            }
            var L = (function (D) {
                //return ((D.scrollWidth - D.bodyWidth) * pos.left / (D.scrollTrackXWidth - D.scrollXHandleWidth)).round();
                return ((D.scrollWidth) * pos.left / (D.scrollTrackXWidth - D.scrollXHandleWidth)).round();
            })(this.contentScrollXAttr);

            // 범위를 넘어서는 경우 체크
            if (this.contentScrollXAttr.scrollWidth - L < this.body.width()) {
                L = this.contentScrollXAttr.scrollWidth - this.body.width();
            }

            this.scrollContent.css({left: -L});
            this.colHead.css({left: -L});

            if (this.hasFoot) {
                this.gridFoot_content.css({left: -L});
            }
            if (this.hasEditor) axdom("#" + cfg.targetID + "_AX_editorContent").css({left: -L});

        }
        else {
            if (cfg.__height == "auto") return;
            if (!this.contentScrollYAttr) {
                this.contentScrollYAttr = {
                    bodyHeight: this.body.height(),
                    scrollHeight: this.scrollContent.outerHeight(),
                    scrollTrackYHeight: this.scrollTrackY.height(),
                    scrollYHandleHeight: this.scrollYHandle.outerHeight()
                };
            }
            else {
                // scrollContent height update
                this.contentScrollYAttr.bodyHeight = this.body.height();
                this.contentScrollYAttr.scrollHeight = this.scrollContent.height();
                this.contentScrollYAttr.scrollTrackYHeight = this.scrollTrackY.height();
                this.contentScrollYAttr.scrollYHandleHeight = this.scrollYHandle.outerHeight();
            }

            //trace(this.contentScrollYAttr);

            var _sh = this.contentScrollYAttr.scrollHeight, _bh = this.contentScrollYAttr.bodyHeight, _th = this.contentScrollYAttr.scrollTrackYHeight, _hh = this.contentScrollYAttr.scrollYHandleHeight;
            var T = pos.top * (_sh - _bh) / (_th - _hh);
            //var T = (this.contentScrollYAttr.scrollHeight * (pos.top) / this.contentScrollYAttr.scrollTrackYHeight).floor();
            //var T = (this.contentScrollYAttr.scrollHeight - this.contentScrollYAttr.bodyHeight) * ( (pos.top) / (this.contentScrollYAttr.scrollTrackYHeight - this.contentScrollYAttr.scrollYHandleHeight) ).number();

            this.scrollContent.css({top: -T});
            if (axf.getId(cfg.targetID + "_AX_fixedScrollContent")) this.fixedScrollContent.css({top: -T});
            if (this.editorOpend) {
                this.editor.css({top: -T + this.editorOpenTop + this.body.position().top});
            }
            this.bigDataSyncApply();
        }
    },
    /**
     * @method AXGrid.contentScrollContentSync
     * @param pos {Object} - top, left
     * @param touch {String} - "touch"
     * @description  top, left에 맞게 그리드 내용을 이동 합니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.contentScrollContentSync({top: 0}, "touch");
     * ```
     */
    contentScrollContentSync: function (pos, touch, reload) { // move scrollHandle
        var cfg = this.config;
        if (typeof pos.left !== "undefined") {

            if (!this.contentScrollXAttr) {
                var scrollWidth = (this.colWidth > this.body.width()) ? this.colWidth : this.body.width();
                this.contentScrollXAttr = {
                    bodyWidth: this.body.width(),
                    scrollWidth: scrollWidth,
                    scrollTrackXWidth: this.scrollTrackX.width(),
                    scrollXHandleWidth: this.scrollXHandle.outerWidth()
                };
            }

            var L = (this.contentScrollXAttr.scrollTrackXWidth - this.contentScrollXAttr.scrollXHandleWidth) *
                ((pos.left) / (this.contentScrollXAttr.scrollWidth - this.contentScrollXAttr.bodyWidth));
            this.scrollXHandle.css({left: -L});
            this.colHead.css({left: pos.left});

            if (this.hasFoot) {
                this.gridFoot_content.css({left: pos.left});
            }
            if (this.hasEditor) {
                axdom("#" + cfg.targetID + "_AX_editorContent").css({left: pos.left});
            }

        }
        else {
            if (cfg.__height == "auto") return;
            if (!this.contentScrollYAttr) {
                this.contentScrollYAttr = {
                    bodyHeight: this.body.height(),
                    scrollHeight: this.scrollContent.height(),
                    scrollTrackYHeight: this.scrollTrackY.height(),
                    scrollYHandleHeight: this.scrollYHandle.outerHeight()
                };
            }
            else {
                // scrollContent height update
                this.contentScrollYAttr.bodyHeight = this.body.height();
                this.contentScrollYAttr.scrollHeight = this.scrollContent.height();
                this.contentScrollYAttr.scrollTrackYHeight = this.scrollTrackY.height();
                this.contentScrollYAttr.scrollYHandleHeight = this.scrollYHandle.outerHeight();
            }
            var _sh = this.contentScrollYAttr.scrollHeight, _bh = this.contentScrollYAttr.bodyHeight, _th = this.contentScrollYAttr.scrollTrackYHeight, _hh = this.contentScrollYAttr.scrollYHandleHeight;
            var T = pos.top * (_th - _hh) / (_sh - _bh);

            this.scrollYHandle.css({top: -T});
            if (axf.getId(cfg.targetID + "_AX_fixedScrollContent")) this.fixedScrollContent.css({top: pos.top});
            if (this.editorOpend) {
                this.editor.css({top: pos.top + this.editorOpenTop + this.body.position().top});
            }
        }

        if (!reload) {
            if (typeof touch == "undefined") this.bigDataSync();
            if (touch == "direct")  this.bigDataSyncApply();
        }
    },
    /**
     * @method AXGrid.getMousePositionToContentScroll
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @param contentScrollID {String} - Event가 일어난 스크롤 객체 ID
     * @description  스크롤이 발생된 마우스 위치를 반환합니다.
     * @returns {Object} ({x,y})
     */
    getMousePositionToContentScroll: function (event, contentScrollID) {
        var pos = axdom("#" + contentScrollID).offset();
        var x = (event.pageX - pos.left);
        var y = (event.pageY - pos.top);
        return {x: x, y: y};
    },
    /**
     * @method AXGrid.getTouchPositionToContentScroll
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  터치 이벤트가 일어난 위치를 반환 합니다.
     * @returns {Object} ({x,y})
     */
    getTouchPositionToContentScroll: function (event) {
        var cfg = this.config;
        var touch = event.touches[0], x, y;

        if (cfg.touchDirection) {
            x = touch.pageX.round(10);
            y = touch.pageY.round(10);
        }
        else {
            x = -touch.pageX.round(10);
            y = -touch.pageY.round(10);
        }

        return {x: x, y: y};
    },
    /**
     * @method AXGrid.contentScrollScrollReady
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  스크롤에 대한 기본 속성/이벤트를 지정합니다.
     */
    contentScrollScrollReady: function (event) {
        var cfg = this.config;
        var handleName = (event.target.id).split(/_AX_/).last();
        /*console.log(handleName); */
        this.contentScrollAttrs = {handleName: handleName};
        this.contentScrollXAttr = null;
        this.contentScrollYAttr = null;

        if (handleName == "scrollYHandle") {
            this.contentScrollAttrs.scrollTrack = cfg.targetID + "_AX_scrollTrackY";
        }
        else {
            this.contentScrollAttrs.scrollTrack = cfg.targetID + "_AX_scrollTrackX";
        }
        axdom(event.target).addClass("hover");

        var pos = this.getMousePositionToContentScroll(event, this.contentScrollAttrs.scrollTrack);
        this.contentScrollAttrs.x = axdom(event.target).position().left - pos.x;
        this.contentScrollAttrs.y = axdom(event.target).position().top - pos.y;
        this.contentScrollAttrs.handleWidth = axdom(event.target).outerWidth();
        this.contentScrollAttrs.handleHeight = axdom(event.target).outerHeight();
        this.contentScrollAttrs.trackWidth = this.scrollTrackX.width();
        this.contentScrollAttrs.trackHeight = this.scrollTrackY.height();

        if (!this.contentScrollYAttr) {
            this.contentScrollYAttr = {
                bodyHeight: this.body.height(),
                scrollHeight: this.scrollContent.outerHeight(),
                scrollTrackYHeight: this.scrollTrackY.height(),
                scrollYHandleHeight: this.scrollYHandle.outerHeight()
            };
        }
        else {
            // scrollContent height update
            this.contentScrollYAttr.scrollHeight = this.scrollContent.height();
            this.contentScrollYAttr.scrollTrackYHeight = this.scrollTrackY.height();
            this.contentScrollYAttr.scrollYHandleHeight = this.scrollYHandle.outerHeight();
        }

        /* srcoll event bind */
        var contentScrollScrollMove = this.contentScrollScrollMove.bind(this);
        this.contentScrollScrollMoveBind = function (event) {
            contentScrollScrollMove(event);
        };
        var contentScrollScrollEnd = this.contentScrollScrollEnd.bind(this);
        this.contentScrollScrollEndBind = function (event) {
            contentScrollScrollEnd(event);
        };

        if (handleName == "scrollYHandle") {
            this.scrollYTip.show();
            this.contentScrollTipOverMove();
        }

        axdom(document.body).bind("mousemove.AXGrid", this.contentScrollScrollMoveBind);
        axdom(document.body).bind("mouseup.AXGrid", this.contentScrollScrollEndBind);
        axdom(document.body).bind("mouseleave.AXGrid", this.contentScrollScrollEndBind);

        axdom(document.body).attr("onselectstart", "return false");
        //axdom(document.body).addClass("AXUserSelectNone");

        this.contentScrollScrolling = true;
        /* scroll event bind ~~~~~~~~~~~~~~~~~~~ */
    },
    /**
     * @method AXGrid.contentScrollScrollMove
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  스크롤바가 스크롤 될때 내부 처리를 합니다.
     */
    contentScrollScrollMove: function (event) {
        var cfg = this.config;
        var pos = this.getMousePositionToContentScroll(event, this.contentScrollAttrs.scrollTrack);
        var handleName = this.contentScrollAttrs.handleName;
        /*console.log(this.contentScrollAttrs); */
        var handleTop = 0;
        var handleLeft = 0;
        if (handleName == "scrollYHandle") {
            handleTop = (pos.y + this.contentScrollAttrs.y);
            if (handleTop < 0) handleTop = 0;
            if ((handleTop + this.contentScrollAttrs.handleHeight) > this.contentScrollAttrs.trackHeight) {
                handleTop = this.contentScrollAttrs.trackHeight - this.contentScrollAttrs.handleHeight;
            }
            this.scrollYHandle.css({top: handleTop});
            this.scrollYHandle.data("top", handleTop);
            this.contentScrollScrollSync({top: handleTop});
            this.contentScrollTipOverMove(handleTop);
        }
        else {
            handleLeft = pos.x + this.contentScrollAttrs.x;
            if (handleLeft < 0) handleLeft = 0;
            if ((handleLeft + this.contentScrollAttrs.handleWidth) > this.contentScrollAttrs.trackWidth)
                handleLeft = this.contentScrollAttrs.trackWidth - this.contentScrollAttrs.handleWidth;
            this.scrollXHandle.css({left: handleLeft});
            // 스크롤 X 예외 처리
            this.contentScrollScrollSync({left: handleLeft});
        }
        this.onevent_grid({type: "onscroll"});
    },
    /**
     * @method AXGrid.contentScrollScrollEnd
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  스크롤바의 스크롤이 끝났을때의 처리를 합니다.
     */
    contentScrollScrollEnd: function (event) {
        var cfg = this.config;
        axdom(document.body).unbind("mousemove.AXGrid");
        axdom(document.body).unbind("mouseup.AXGrid");
        axdom(document.body).unbind("mouseleave.AXGrid");

        axdom(document.body).removeAttr("onselectstart");
        //axdom(document.body).removeClass("AXUserSelectNone");
        axdom("#" + cfg.targetID + "_AX_" + this.contentScrollAttrs.handleName).removeClass("hover");
        this.contentScrollScrolling = false;

        if (this.contentScrollAttrs.handleName == "scrollYHandle") {
            this.contentScrollScrollSync({top: this.scrollYHandle.position().top});
            if (this.contentScrollAttrs.trackHeight - this.contentScrollAttrs.handleHeight == this.scrollYHandle.data("top")) {
                this.contentScrollEnd();
            }
            this.scrollYTip.hide();
        }
        else {
            this.contentScrollScrollSync({left: this.scrollXHandle.position().left});
        }
    },
    /**
     * @method AXGrid.contentScrollScrollWheel
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  그리드 몸통에서 일어나는 마우스 휠 이벤트 처리를 합니다.
     */
    contentScrollScrollWheel: function (e) {
        var cfg = this.config,
            scrollTop = this.scrollContent.position().top,
            scrollLeft = this.scrollContent.position().left,
            eventCancle = false,
            event = e || window.event, deltaX = 0, deltaY = 0, attr;

        if (cfg.__height == "auto") return;

        attr = {
            bodyHeight: this.body.height(),
            bodyWidth: this.body.width()
        };
        attr.scrollHeight = this.scrollContent.height();
        attr.scrollWidth = this.scrollContent.width();
        attr.scrollTrackYHeight = this.scrollTrackY.height();
        attr.scrollYHandleHeight = this.scrollYHandle.outerHeight();
        attr.scrollTrackYWidth = this.scrollTrackY.width();
        attr.scrollYHandleWidth = this.scrollYHandle.outerWidth();

        if (event.wheelDeltaX) {
            deltaX = (event.wheelDeltaX / 2).ceil();
            deltaY = (event.wheelDeltaY / 2).ceil();
        }
        else {
            deltaY = (event.detail ? event.detail * (-20) : event.wheelDelta / 2).ceil();
        }
        /*check for detail first so Opera uses that instead of wheelDelta */

        // 아무일도 하지 말기
        if (deltaX == 0 && deltaY == 0) return true;

        if (deltaY.abs() > deltaX.abs() && deltaY.abs() > 0) {
            if (attr.scrollHeight < attr.bodyHeight) return;
            scrollTop += deltaY;

            if (scrollTop > 0) {
                scrollTop = 0;
                eventCancle = true;
            }
            else if (scrollTop.abs() + attr.bodyHeight > attr.scrollHeight) {
                scrollTop = attr.bodyHeight - attr.scrollHeight;
                eventCancle = true;
            }
            else if (scrollTop == 0) {
                scrollTop = 0;
                eventCancle = true;
            }
            this.scrollContent.css({top: scrollTop});
            this.contentScrollContentSync({top: scrollTop}, "direct");
            this.onevent_grid({type: "onscroll"});
        }
        else if (deltaX.abs() > deltaY.abs() && deltaX.abs() > 0) {
            scrollLeft += deltaX;

            if (scrollLeft > 0) {
                scrollLeft = 0;
                eventCancle = true;
            }
            else if (scrollLeft.abs() + attr.bodyWidth > attr.scrollWidth) {
                scrollLeft = attr.bodyWidth - attr.scrollWidth;
                eventCancle = true;
            }
            else if (scrollLeft == 0) {
                scrollLeft = 0;
                eventCancle = true;
            }
            this.scrollContent.css({left: scrollLeft});
            this.contentScrollContentSync({left: scrollLeft}, "direct");
            this.onevent_grid({type: "onscroll"});
        }

        if (!eventCancle) {
            if (event.preventDefault) event.preventDefault();
            if (event.stopPropagation) event.stopPropagation();
            event.cancelBubble = true;
            return false;
        }
        else {
            if (scrollTop != 0) {
                var contentScrollEnd = this.contentScrollEnd.bind(this);
                if (this.contentScrollEndObserver) clearTimeout(this.contentScrollEndObserver);
                this.contentScrollEndObserver = setTimeout(function () {
                    contentScrollEnd();
                }, 100);
            }
        }

    },
    /**
     * @method AXGrid.contentScrollTouchstart
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  그리드 스크롤바에 대한 터치 이벤트를 처리 합니다.
     */
    contentScrollTouchstart: function (e) {
        var cfg = this.config;
        var event = window.event || e;

        if (cfg.viewMode == "mobile") return;

        this.contentScrollTouchMoved = true;
        this.contentScrollIDOffset = this.scrollContent.offset();
        this.contentScrollXAttr = null;
        this.contentScrollYAttr = null;

        var pos = this.getTouchPositionToContentScroll(event);

        this.scrollYHandle.addClass("hover");
        this.scrollXHandle.addClass("hover");

        this.scrollTouchAttr = {
            y: pos.y,
            h: this.body.outerHeight(),
            th: this.scrollContent.height(),
            nt: this.scrollContent.position().top,
            x: pos.x,
            w: this.body.outerWidth(),
            tw: this.scrollContent.width(),
            nl: this.scrollContent.position().left
        };

        var contentScrollTouchEnd = this.contentScrollTouchEnd.bind(this);
        this.contentScrollTouchEndBind = function () {
            contentScrollTouchEnd(event);
        };

        var contentScrollTouchMove = this.contentScrollTouchMove.bind(this);
        this.contentScrollTouchMoveBind = function () {
            contentScrollTouchMove(event);
        };

        if (document.addEventListener) {
            document.addEventListener("touchend", this.contentScrollTouchEndBind, false);
            document.addEventListener("touchmove", this.contentScrollTouchMoveBind, false);
        }
    },
    /**
     * @method AXGrid.contentScrollTouchMove
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  그리드내의 터치에 의한 화면 이동을 처리 합니다..
     */
    contentScrollTouchMove: function (e) {
        var cfg = this.config;
        var event = window.event || e;
        if (this.contentScrollTouchMoved) {

            var pos = this.getTouchPositionToContentScroll(event);
            var scrollTouchAttr = this.scrollTouchAttr;

            var eventCancle = false;

            if (scrollTouchAttr.th > scrollTouchAttr.h && cfg.height != "auto") {
                var scrollTop = scrollTouchAttr.nt - (pos.y - scrollTouchAttr.y);
                //console.log(scrollTop);
                if (scrollTop > 0) {
                    scrollTop = 0;
                    eventCancle = true;
                }
                else if (scrollTop.abs() + scrollTouchAttr.h > scrollTouchAttr.th) {
                    scrollTop = scrollTouchAttr.h - scrollTouchAttr.th;
                    eventCancle = true;
                }
                else if (scrollTop == 0) {
                    scrollTop = 0;
                    eventCancle = true;
                }

                this.scrollContent.css({top: scrollTop});
                this.contentScrollContentSync({top: scrollTop}, "touch");
            }
            else {
                eventCancle = true;
            }

            if (this.show_scrollTrackX && (pos.x - scrollTouchAttr.x).abs() > 8) {
                eventCancle = false;
                var scrollLeft = scrollTouchAttr.nl - (pos.x - scrollTouchAttr.x);

                if (scrollLeft > 0) {
                    scrollLeft = 0;
                    eventCancle = true;
                }
                else if (scrollLeft.abs() + scrollTouchAttr.w > scrollTouchAttr.tw) {
                    scrollLeft = scrollTouchAttr.w - scrollTouchAttr.tw;
                    eventCancle = true;
                }
                else if (scrollLeft == 0) {
                    scrollLeft = 0;
                    eventCancle = true;
                }
                this.scrollContent.css({left: scrollLeft});
                this.contentScrollContentSync({left: scrollLeft}, "touch");
            }

            if (!eventCancle) {
                if (event.preventDefault) event.preventDefault();
                //if (event.stopPropagation) event.stopPropagation();
                //event.cancelBubble = true;
                //return false;
            }
            else {
                if (scrollTop != 0) {
                    var contentScrollEnd = this.contentScrollEnd.bind(this);
                    if (this.contentScrollEndObserver) clearTimeout(this.contentScrollEndObserver);
                    this.contentScrollEndObserver = setTimeout(function () {
                        contentScrollEnd();
                    }, 100);
                }
            }
        }
    },
    /**
     * @method AXGrid.contentScrollTouchEnd
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  그리드내의 터치(point)가 끝났을때의 처리를 합니다.
     */
    contentScrollTouchEnd: function (e) {
        var cfg = this.config;
        var event = window.event || e;
        if (this.contentScrollTouchMoved) {

            if (cfg.height != "auto") this.bigDataSync();

            // 관성법칙 적용 해야함.
            this.scrollXHandle.removeClass("hover");
            this.scrollYHandle.removeClass("hover");

            if (document.removeEventListener) {
                document.removeEventListener("touchend", this.contentScrollTouchEndBind, false);
                document.removeEventListener("touchmove", this.contentScrollTouchMoveBind, false);
            }
            this.contentScrollTouchMoved = false;
        }
    },
    /**
     * @method AXGrid.contentScrollEnd
     * @description  그리드내의 스크롤이 마지막 항목까지 도달 하였을때의 처리를 합니다. config에서 설정한 onscrollend 지정 함수도 이때 발생됩니다.
     */
    contentScrollEnd: function () {
        if (this.contentScrollEndObserver) clearTimeout(this.contentScrollEndObserver);
        var cfg = this.config;
        if (cfg.body.onscrollend) {
            try {
                cfg.body.onscrollend.call({list: this.list, page: this.page});
            } catch (e) {
                console.log(e);
            }
        }
    },
    /**
     * @method AXGrid.contentScrollTipOver
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     */
    contentScrollTipOver: function (event) {
        // contentScrollTopOver
        /*
         var cfg = this.config;
         this.scrollYHandle.bind("mousemove");
         this.scrollYHandle.bind("mouseout");
         */
    },
    /**
     * @method AXGrid.contentScrollTipOverMove
     * @param handleTop {Number} - 툴팁 출력위치의 상단 offset
     * @description - Grid의 스크롤바를 움직일때 현레코드/전체레코드의 툴팁을 출력합니다.
     */
    contentScrollTipOverMove: function (handleTop) {
        var cfg = this.config;
        /*
         if (!this.contentScrollYAttr) {
         this.contentScrollYAttr = {
         bodyHeight: this.body.height(),
         scrollHeight: this.scrollContent.outerHeight(),
         scrollTrackYHeight: this.scrollTrackY.height(),
         scrollYHandleHeight: this.scrollYHandle.outerHeight()
         };
         }else{
         // scrollContent height update
         this.contentScrollYAttr.scrollHeight = this.scrollContent.height();
         this.contentScrollYAttr.scrollTrackYHeight = this.scrollTrackY.height();
         this.contentScrollYAttr.scrollYHandleHeight = this.scrollYHandle.outerHeight();
         }
         */
        var hTop = handleTop || this.scrollYHandle.position().top;
        var T = (this.contentScrollYAttr.scrollHeight - this.contentScrollYAttr.bodyHeight) * ( (hTop) / (this.contentScrollYAttr.scrollTrackYHeight - this.contentScrollYAttr.scrollYHandleHeight) ).number();
        this.scrollYTipSpan.empty();
        this.scrollYTipSpan.append(((T.abs() / this.virtualScroll.itemTrHeight)).floor().money() + "/" + this.list.length.money());
        this.scrollYTip.css({top: hTop});
    },
    /**
     * @method AXGrid.contentScrollTipOverOut
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description - Grid의 스크롤바에 대한 이동 이벤트가 끝났을때 툴팁을 해제합니다.
     */
    contentScrollTipOverOut: function (event) {
        var cfg = this.config;
        this.scrollYHandle.unbind("mousemove");
        this.scrollYHandle.unbind("mouseout");
        this.scrollYTip.hide();
    },
    /**
     * @method AXGrid.dataSync
     * @description - 그리드 데이터를 조작후 그리드에 현재 위치된 아이템을 다시 생성합니다.
     * @returns {AXGrid}
     * @example
     * ```
     * myGrid.list[0].id = 12;
     * myGrid.dataSync();
     * ```
     */
    dataSync: function () {
        this.bigDataSync(true);
        return this;
    },
    /**
     * @method AXGrid.bigDataSync
     * @description - bigDataSyncApply를 호출 합니다.(grid에서만 동작, mobile,icon등의 모드에서는 동장 안함)
     */
    bigDataSync: function (reload) {
        var cfg = this.config, _this = this;
        if (cfg.viewMode == "grid") {
            if (this.bigDataSyncObserver) clearTimeout(this.bigDataSyncObserver);
            this.bigDataSyncObserver = setTimeout(function () {
                _this.bigDataSyncApply(reload);
            }, 10);
        }
    },
    /**
     * @method AXGrid.bigDataSyncApply
     * @param {Boolean} reload - 현재 그리드 스크롤된 컨텐츠를 다시 출력합니다.
     * @description - Grid의 리스트 내부 인덱스가 변경되거나 포커싱 대상 인덱스가 스크롤을 벗어나 있을경우 그리드를 재구성 합니다.
     */
    bigDataSyncApply: function (reload) {
        var cfg = this.config;
        var bodyHasMarker = this.bodyHasMarker;
        var getItem = this.getItem.bind(this);
        var getItemMarker = this.getItemMarker.bind(this);
        var getMarkerDisplay = this.getMarkerDisplay.bind(this);
        var markerIndex = 0;
        // bigDataSyncApply
        var scrollContentScrollTop, VS = this.virtualScroll, po = [], item;

        if (VS.scrollTop != (scrollContentScrollTop = this.scrollContent.position().top) || reload) {
            var newStartIndex = (scrollContentScrollTop.abs() / VS.itemTrHeight).ceil() - 6;
            if (newStartIndex < 0) newStartIndex = 0;
            var newEndIndex = newStartIndex + VS.printListCount;
            if (newEndIndex > this.list.length) {
                newEndIndex = this.list.length;
                //newStartIndex = newEndIndex - VS.printListCount - 6; 스크롤 이상발생 포인트
            }

            if (VS.startIndex != newStartIndex || reload) {

                //그리드 내용 다시 구성
                po = [];
                for (var itemIndex = newStartIndex; itemIndex < newEndIndex; itemIndex++) {

                    item = this.list[itemIndex];
                    po.push(getItem(itemIndex, item, "n"));

                    if (bodyHasMarker && (markerIndex = getMarkerDisplay(itemIndex, item)).length > 0) {
                        po.push(getItemMarker(itemIndex, item, "n", markerIndex));
                    }
                }
                this.cachedDom.tbody.empty();
                this.cachedDom.tbody.append(po.join(''));

                // 현재 표시할 아이템 범위 설정
                VS.startIndex = newStartIndex;
                VS.endIndex = newEndIndex;
                VS.scrollTop = scrollContentScrollTop;

                // 셀머지
                if (cfg.mergeCells) {
                    this.mergeCells(this.cachedDom.tbody, "n");
                }

                if (this.hasFixed) {
                    po = [];
                    for (var itemIndex = newStartIndex; itemIndex < newEndIndex; itemIndex++) {
                        item = this.list[itemIndex];
                        po.push(getItem(itemIndex, item, "fix"));
                        if (bodyHasMarker && (markerIndex = getMarkerDisplay(itemIndex, item)).length > 0) {
                            po.push(getItemMarker(itemIndex, item, "fix", markerIndex));
                        }
                    }
                    this.cachedDom.fixed_tbody.empty();
                    this.cachedDom.fixed_tbody.append(po.join(''));
                    //셀머지
                    if (cfg.mergeCells) {
                        this.mergeCells(this.cachedDom.fixed_tbody, "f");
                    }
                }

                this.cachedDom.thpadding.css({height: (newStartIndex) * VS.itemTrHeight}); // 상단패딩증가

                var tfpaddingHeight = cfg.scrollContentBottomMargin.number() + (this.list.length - newEndIndex - 1) * (VS.itemTrHeight);
                if (tfpaddingHeight < cfg.scrollContentBottomMargin.number()) tfpaddingHeight = cfg.scrollContentBottomMargin.number();

                this.cachedDom.tfpadding.css({height: tfpaddingHeight});
                if (this.hasFixed) {
                    this.cachedDom.fthpadding.css({height: (newStartIndex) * VS.itemTrHeight}); // 상단패딩증가
                    this.cachedDom.ftfpadding.css({height: tfpaddingHeight});
                }

                this.body.find(".gridBodyTr").bind("mouseover", this.gridBodyOver.bind(this));
                this.body.find(".gridBodyTr").bind("mouseout", this.gridBodyOut.bind(this));
                this.body.find(".gridBodyTr").bind("click", this.gridBodyClick.bind(this));

                if (this.needBindDBLClick()) this.body.find(".gridBodyTr").bind("dblclick", this.gridBodyDBLClick.bind(this));

                // body.onchangeScroll
                if (cfg.body.onchangeScroll) {
                    var sendObj = axf.copyObject(this.virtualScroll);
                    cfg.body.onchangeScroll.call(sendObj, sendObj);
                }
                this.editCellClear();

                if (typeof this.selectedRow != "undefined" && this.selectedRow.length > 0) {
                    var body = this.body;
                    for (var ri = 0; ri < this.selectedRow.length; ri++) {
                        body.find(".gridBodyTr_" + this.selectedRow[ri]).addClass("selected");
                        //body.find(".gridBodyTr_" + this.selectedRow[ri]).find(".bodyTd_" + this.selectedCells[0]).addClass("selected");
                        body.find(".gridBodyTr_" + this.selectedRow[ri]).find(".bodyTd_" + this.selectedCells[0] + ".bodyTdr_0").addClass("selected");
                    }

                    if (typeof reload != "undefined") {
                        var itemIndex = this.selectedRow.last();
                        var itemDom = this.body.find(".gridBodyTr_" + itemIndex);
                        if (itemDom[0]) {
                            var trTop = itemDom.position().top;
                            var scrollHeight = this.scrollContent.height();
                            var bodyHeight = this.body.height();

                            var trHeight = this.body.find(".bodyNullTd").outerHeight().number();

                            if (trTop.number() + trHeight.number() > bodyHeight) {
                                var scrollTop = bodyHeight - (trTop.number() + trHeight.number());
                                this.scrollContent.css({top: (scrollTop - cfg.listCountMargin)});
                                this.contentScrollContentSync({top: (scrollTop - cfg.listCountMargin)});
                            }
                            else {
                                if (trTop.number() == 0) {
                                    var scrollTop = 0;
                                    this.scrollContent.css({top: scrollTop});
                                    this.contentScrollContentSync({top: scrollTop});
                                }
                            }
                        }
                    }
                }
            }
        }
    },
    /**
     * @method AXGrid.scrollTop
     * @param itemIndex {Number} - 스크롤될 아이템 인덱스
     * @description - itemIndex에 스크롤을 이동시킵니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.scrollTop(0);
     * ```
     */
    scrollTop: function (itemIndex) {
        var cfg = this.config;
        if (cfg.__height == "auto") return;
        try {
            var trTop = this.body.find(".gridBodyTr_" + itemIndex).position().top;
            var trHeight = this.body.find(".gridBodyTr_" + itemIndex).height();

            var scrollHeight = this.scrollContent.height();
            var bodyHeight = this.body.height();
            var handleHeight = this.scrollYHandle.outerHeight();
            var trackHeight = this.scrollTrackY.height();

            if (trTop.number() + trHeight.number() > bodyHeight) {
                var scrollTop = bodyHeight - (trTop.number() + trHeight.number());
                if (this.body.height() < scrollHeight) {
                    this.scrollContent.css({top: scrollTop});
                    this.contentScrollContentSync({top: scrollTop});
                }
            }
            else {
                if (trTop.number() == 0) {
                    var scrollTop = 0;
                    this.scrollContent.css({top: scrollTop});
                    this.contentScrollContentSync({top: scrollTop});
                }
            }
        } catch (e) {
            var scrollTop = 0;
            this.scrollContent.css({top: scrollTop});
            this.contentScrollContentSync({top: scrollTop});
        }
    },
    /**
     * @method AXGrid.setFocus
     * @param itemIndex {Number} - 선택될 아이템 인덱스
     * @description - itemIndex에 해당하는 열을 선택 합니다..
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.setFocus(0);
     * ```
     */
    setFocus: function (itemIndex) {
        var cfg = this.config, _this = this;

        if (cfg.viewMode == "grid") {

            var c_index = this.selectedCells.first();
            if (this.selectedRow.length > 0) {
                var body = this.body;
                axf.each(this.selectedRow, function (ridx, Row) {
                    body.find(".gridBodyTr_" + Row).removeClass("selected");
                    if (_this.selectedCells.length > 0) {
                        axf.each(_this.selectedCells, function () {
                            body.find(".gridBodyTr_" + Row).find(".bodyTd_" + this).removeClass("selected");
                        });
                    }
                });
            }

            //console.log(this.virtualScroll.startIndex, this.virtualScroll.endIndex, itemIndex);
            this._focusedItemIndex = itemIndex;
            if (this.virtualScroll.startIndex <= itemIndex && this.virtualScroll.endIndex >= itemIndex) {
                this.selectedRow.clear();
                if (itemIndex == 0) itemIndex = '' + itemIndex;

                this.body.find(".gridBodyTr_" + itemIndex).addClass("selected");
                this.selectedRow.push(itemIndex);

                if (cfg.mergeCells) { /// mergeCells 이 있는 경우 함께 선택 표시해야할 대상이 있는지 판단 후 처리

                    (function () {
                        var colGroupLen = 0, nowTrTd = this.body.find(".gridBodyTr_" + itemIndex).find("td");
                        for (var i = 0, l = cfg.colGroup.length; i < l; i++) {
                            if (cfg.colGroup[i].display) colGroupLen++;
                        }
                        if (colGroupLen == nowTrTd.length - 1) {
                            // td중에 rowspan이 있는 컬럼이 있는지 체크
                            for (var i = 0, l = nowTrTd.length; i < l; i++) {
                                if (nowTrTd[i].getAttribute("rowspan") > 1) {
                                    for (var ai = 0; ai < nowTrTd[i].getAttribute("rowspan") - 1; ai++) {
                                        this.body.find(".gridBodyTr_" + (Number(itemIndex) + ai + 1)).addClass("selected");
                                        this.selectedRow.push((Number(itemIndex) + ai + 1));
                                    }
                                    break;
                                }
                            }
                        }
                        else {
                            this.selectedRow.clear();
                            // 이가 빠졌음 머지된 컬럼을 검색 (위로 탐색 나올때까지)
                            var finding = true, parentItemIndex = itemIndex, safeLoop = 0;
                            do {
                                parentItemIndex = parentItemIndex - 1;
                                var _nowTrTd = this.body.find(".gridBodyTr_" + (parentItemIndex)).find("td");
                                //console.log(colGroupLen, (_nowTrTd.length - 1), parentItemIndex);
                                if (colGroupLen == _nowTrTd.length - 1) {
                                    for (var i = 0, l = _nowTrTd.length; i < l; i++) {

                                        if (_nowTrTd[i].getAttribute("rowspan") > 1) {
                                            //console.log(_nowTrTd[i].getAttribute("rowspan"));
                                            for (var ai = 0; ai < _nowTrTd[i].getAttribute("rowspan"); ai++) {
                                                this.body.find(".gridBodyTr_" + (Number(parentItemIndex) + ai)).addClass("selected");
                                                this.selectedRow.push((Number(parentItemIndex) + ai));
                                            }
                                            break;
                                        }
                                    }
                                    finding = false;
                                }
                                safeLoop++;
                                if (safeLoop > 1000) finding = false;
                            } while (finding)

                        }
                    }).call(this);
                }

                this.body.find(".gridBodyTr_" + itemIndex).find(".bodyTd_" + c_index + ".bodyTdr_0").addClass("selected");

                var trTop = this.body.find(".gridBodyTr_" + itemIndex).position().top,
                    trHeight = this.body.find(".gridBodyTr_" + itemIndex).height(),
                    scrollHeight = this.scrollContent.height(),
                    bodyHeight = this.body.height(),
                    handleHeight = this.scrollYHandle.outerHeight(),
                    trackHeight = this.scrollTrackY.height(),
                    scrollContentTop = this.scrollContent.position().top, scrollTop;

                if (_this.hasFoot) {
                    bodyHeight -= this.gridFoot.height();
                }

                if (!cfg.body.rowsEmpty) trHeight = cfg.body.rows.length * trHeight;

                //console.log(trTop, scrollContentTop, bodyHeight);
                if (trTop.number() + scrollContentTop < 0) { // 아래에서 위로 포커스 이동
                    scrollTop = -trTop.number();
                    this.scrollContent.css({top: scrollTop});
                    this.contentScrollContentSync({top: scrollTop});
                }
                else if (trTop.number() + trHeight.number() + scrollContentTop > bodyHeight) { // 위에서 아래로 이동
                    scrollTop = bodyHeight - (trTop.number() + trHeight.number());
                    this.scrollContent.css({top: scrollTop});
                    this.contentScrollContentSync({top: scrollTop});
                }
                else { // 예외처리
                    if (trTop.number() == 0) {
                        scrollTop = 0;
                        this.scrollContent.css({top: scrollTop});
                        this.contentScrollContentSync({top: scrollTop});
                    }
                }

            }
            else {
                if (this.list.length > itemIndex && itemIndex > -1) {

                    if (itemIndex == 0) itemIndex = '' + itemIndex;

                    var scrollHeight = this.scrollContent.height();
                    var bodyHeight = this.body.height();
                    var handleHeight = this.scrollYHandle.outerHeight();
                    var trackHeight = this.scrollTrackY.height();

                    //var scrollTop = bodyHeight - scrollHeight;
                    // itemIndex 에 맞는 scrollTop 구하기
                    var scrollTop = this.virtualScroll.itemTrHeight * itemIndex;
                    if (bodyHeight >= scrollHeight) {
                        scrollTop = 0;
                    }
                    this.scrollContent.css({top: scrollTop});
                    this.contentScrollContentSync({top: scrollTop}, "direct");

                    setTimeout(function () {
                        if (_this.body.find(".gridBodyTr_" + itemIndex).get(0)) {
                            var trTop = _this.body.find(".gridBodyTr_" + itemIndex).position().top;
                            var trHeight = _this.body.find(".gridBodyTr_" + itemIndex).height();

                            if (trTop.number() + trHeight.number() > bodyHeight) {
                                scrollTop = bodyHeight - (trTop.number() + trHeight.number());
                                if (itemIndex == _this.list.length - 1) scrollTop -= 10;
                                _this.scrollContent.css({top: scrollTop});
                                _this.contentScrollContentSync({top: scrollTop}, "direct");
                            }
                            else {
                                if (trTop.number() == 0) {
                                    scrollTop = 0;
                                    _this.scrollContent.css({top: scrollTop});
                                    _this.contentScrollContentSync({top: scrollTop}, "direct");
                                }
                            }

                            _this.selectedRow.clear();
                            _this.selectedRow.push(itemIndex);
                            _this.body.find(".gridBodyTr_" + itemIndex).addClass("selected");

                            if (cfg.mergeCells) { /// mergeCells 이 있는 경우 함께 선택 표시해야할 대상이 있는지 판단 후 처리

                                (function () {
                                    var colGroupLen = 0, nowTrTd = this.body.find(".gridBodyTr_" + itemIndex).find("td");
                                    for (var i = 0, l = cfg.colGroup.length; i < l; i++) {
                                        if (cfg.colGroup[i].display) colGroupLen++;
                                    }
                                    if (colGroupLen == nowTrTd.length - 1) {
                                        // td중에 rowspan이 있는 컬럼이 있는지 체크
                                        for (var i = 0, l = nowTrTd.length; i < l; i++) {
                                            if (nowTrTd[i].getAttribute("rowspan") > 1) {
                                                for (var ai = 0; ai < nowTrTd[i].getAttribute("rowspan") - 1; ai++) {
                                                    this.body.find(".gridBodyTr_" + (Number(itemIndex) + ai + 1)).addClass("selected");
                                                    this.selectedRow.push((Number(itemIndex) + ai + 1));
                                                }
                                                break;
                                            }
                                        }
                                    }
                                    else {
                                        this.selectedRow.clear();
                                        // 이가 빠졌음 머지된 컬럼을 검색 (위로 탐색 나올때까지)
                                        var finding = true, parentItemIndex = itemIndex, safeLoop = 0;
                                        do {
                                            parentItemIndex = parentItemIndex - 1;
                                            var _nowTrTd = this.body.find(".gridBodyTr_" + (parentItemIndex)).find("td");
                                            //console.log(colGroupLen, (_nowTrTd.length - 1), parentItemIndex);
                                            if (colGroupLen == _nowTrTd.length - 1) {
                                                for (var i = 0, l = _nowTrTd.length; i < l; i++) {

                                                    if (_nowTrTd[i].getAttribute("rowspan") > 1) {
                                                        //console.log(_nowTrTd[i].getAttribute("rowspan"));
                                                        for (var ai = 0; ai < _nowTrTd[i].getAttribute("rowspan"); ai++) {
                                                            this.body.find(".gridBodyTr_" + (Number(parentItemIndex) + ai)).addClass("selected");
                                                            this.selectedRow.push((Number(parentItemIndex) + ai));
                                                        }
                                                        break;
                                                    }
                                                }
                                                finding = false;
                                            }
                                            safeLoop++;
                                            if (safeLoop > 1000) finding = false;
                                        } while (finding)

                                    }
                                }).call(_this);
                            }
                        }
                    });

                }
                else {
                    //console.log("out of index");
                    this._focusedItemIndex = undefined;
                }
            }
            this.onevent_grid({type: "grid-list-focus"});
        }
        else if (cfg.viewMode == "icon") {

        }
        else if (cfg.viewMode == "mobile") {

            if (this.selectedCells.length > 0) {
                axf.each(this.selectedCells, function () {
                    axdom("#" + this).removeClass("selected");
                });
                this.selectedCells.clear();
            }
            if (this.selectedRow.length > 0) {
                var body = this.body;
                axf.each(this.selectedRow, function () {
                    body.find(".bodyViewMobile_" + this).removeClass("selected");
                });
            }

            this.selectedRow.clear();
            this.body.find(".bodyViewMobile_" + itemIndex).addClass("selected");
            this.selectedRow.push(itemIndex);

            this.body.find(".bodyViewMobile_" + itemIndex).focus();
        }
    },
    /**
     * @method AXGrid.focusMove
     * @param direction {Number|String} - 정수/음수 또는 L/R
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description - direction 만큼 포커스를 이동 합니다.
     */
    focusMove: function (direction, event) {
        var cfg = this.config, body = this.body;
        var myIndex, my_c, itemIndex;

        if (direction == "L" || direction == "R") {
            if (this.selectedCells.length > 0) {
                myIndex = this.selectedRow.first();
                my_c = this.selectedCells.first();

                if (direction == "L") {
                    my_c = my_c - 1;
                    if (my_c < 0) my_c = 0;
                }
                else {
                    my_c = my_c.number() + 1;
                    if (my_c >= cfg.colGroup.length) my_c = cfg.colGroup.length - 1;
                }

                axf.each(this.selectedCells, function () {
                    body.find(".gridBodyTr_" + myIndex).find(".bodyTd_" + this).removeClass("selected");
                });
                this.selectedCells.clear();

                this.body.find(".gridBodyTr_" + myIndex).find(".bodyTd_" + my_c + ".bodyTdr_0").addClass("selected");
                this.selectedCells.push(my_c);

                this.stopEvent(event);
            }
        }
        else {
            myIndex = this.selectedRow.first();
            if (cfg.mergeCells && this.selectedRow.length > 1 && direction > 0) {
                if (Math.abs(this.selectedRow[0] - this.selectedRow[1]) == 1) { // 인점 선택인 경우
                    myIndex = this.selectedRow.last();
                }
            }
            itemIndex = myIndex.number() + direction;
            /*
             if (itemIndex < 0) itemIndex = this.list.length - 1;
             else if (itemIndex > this.list.length - 1) itemIndex = 0;
             */
            if (itemIndex < 0) itemIndex = 0;
            else if (itemIndex > this.list.length - 1) itemIndex = this.list.length - 1;
            // 사용 할 수 있는 itemIndex를 찾아라

            while (this.list[itemIndex][cfg.reserveKeys.hidden]) {
                if (direction < 0) {
                    itemIndex--;
                    // if (itemIndex < 0) itemIndex = this.list.length - 1;
                    if (itemIndex < 0) itemIndex = 0;
                }
                else {
                    itemIndex++;
                    // if (itemIndex > this.list.length - 1) itemIndex = 0;
                    if (itemIndex > this.list.length - 1) itemIndex = this.list.length - 1;
                }
            }

            this.setFocus(itemIndex);
            this.stopEvent(event);
        }
        return false;
    },
    /**
     * @method AXGrid.getSelectedItem
     * @description - 선택된 행의 index, item 을 가져 옵니다.선택된 행이 없으면 에러 객체를 전달 합니다.
     * @returns {Object} - {index,item} , exception no item selected {error,description}
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.getSelectedItem();
     * ```
     */
    getSelectedItem: function () {
        var cfg = this.config;
        if (this.selectedRow != undefined && this.selectedRow != null && this.selectedRow.length > 0) {
            if (this.selectedRow.length == 1) {
                return {index: this.selectedRow.first().number(), item: this.list[this.selectedRow.first()]};
            }
            else {
                var selectedList = [], len = this.selectedRow.length;
                for (var i = 0; i < len; i++) {
                    selectedList.push(this.list[this.selectedRow[i]]);
                }
                return {index: this.selectedRow, item: selectedList};
            }
        }
        else {
            return {error: "noselected", description: "선택된 item이 없습니다."};
        }
    },
    /**
     * @method AXGrid.click
     * @param itemIndex {Number} - 선택될 그리드 아이템 인덱스
     * @description - 인덱스에 해당하는 행을 클릭 한 효과를 발생 시킵니다.config 에 body항목의 onclick 지정함수가 있다면 호출 됩니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.click(0);
     * ```
     */
    click: function (itemIndex) {
        var cfg = this.config;
        this.setFocus(itemIndex);

        var item = this.list[itemIndex];

        if (cfg.body.onclick) {

            var sendObj = {
                index: itemIndex,
                list: this.list,
                item: item,
                page: this.page
            };

            try {
                cfg.body.onclick.call(sendObj, itemIndex, item);
            } catch (e) {
                console.log(e);
            }
        }

        // this.stopEvent(event);
    },
    /**
     * @method AXGrid.mergeCells
     * @param tgDom {Object} - 그리드 몸통 객체
     * @param typ {String} - 표현 형식 ("n" normal, "f" fixed)
     * @description - config 내의 옵션에 따라 셀 병합을 실행 합니다.
     */
    mergeCells: function (tgDom, typ) {
        var cfg = this.config;
        // 중복된 셀 머지 함수
        // 1 셀정보 수집
        var rows = [];
        var typn = typ == 'f' ? 'fix' : 'n';
        // 마지막 한줄이 빠지는 경우 발생됨.
        for (var tri = this.virtualScroll.startIndex; tri <= this.virtualScroll.endIndex; tri++) {
            var row = [];
            if (this.list[tri]) {
                for (var tdi = 0; tdi < cfg.colGroup.length; tdi++) {
                    var tdn = cfg.colGroup[tdi].key; //Column Name Variable
                    var item = {
                        tdom: tgDom.find("#" + cfg.targetID + "_AX_" + typn + "body_AX_0_AX_" + tdi + "_AX_" + tri),
                        rowspan: 1
                    };
                    if (cfg.colGroup[tdi] && cfg.colGroup[tdi].display && item.tdom.length == 0) {
                        break; // end loop
                    }
                    else if (!item.tdom.hasClass("bodyNullTd")) {
                        item.html = this.list[tri][tdn];
                        item.tri = tri;
                        item.tdi = tdi;
                        row.push(item);
                    }
                }
                rows.push(row);
            }
        }
        var _val = {};
        if (Object.isArray(cfg.mergeCells)) {
            for (var tri = 0; tri < rows.length; tri++) {
                var isMerge = true;
                for (var mci = 0; mci < cfg.mergeCells.length; mci++) {
                    var tdi;
                    if (rows[tri][(tdi = cfg.mergeCells[mci])]) {
                        if (_val["td_" + tdi]) {
                            if (_val["td_" + tdi].html == rows[tri][tdi].html && isMerge) {
                                rows[_val["td_" + tdi].tri][tdi].rowspan++;
                                rows[tri][tdi].rowspan = 0;
                                isMerge = true;
                            }
                            else {
                                _val["td_" + tdi] = {
                                    tri: tri,
                                    tdi: tdi,
                                    rowspan: 1,
                                    html: rows[tri][tdi].html
                                };
                                isMerge = false;
                            }
                        }
                        else {
                            _val["td_" + tdi] = {
                                tri: tri,
                                tdi: tdi,
                                rowspan: 1,
                                html: rows[tri][tdi].html
                            };
                            isMerge = false;
                        }
                    }
                }
            }
        }
        else {
            for (var tri = 0; tri < rows.length; tri++) {
                for (var tdi = 0; tdi < rows[tri].length; tdi++) {
                    if (_val["td_" + tdi]) {
                        if (_val["td_" + tdi].html == rows[tri][tdi].html) {
                            rows[_val["td_" + tdi].tri][tdi].rowspan++;
                            rows[tri][tdi].rowspan = 0;
                        }
                        else {
                            _val["td_" + tdi] = {
                                tri: tri,
                                tdi: tdi,
                                rowspan: 1,
                                html: rows[tri][tdi].html
                            };
                        }
                    }
                    else {
                        _val["td_" + tdi] = {
                            tri: tri,
                            tdi: tdi,
                            rowspan: 1,
                            html: rows[tri][tdi].html
                        };
                    }
                }
            }
        }
        _val = null;

        if (typ == "n") {
            for (var tri = 0; tri < rows.length; tri++) {
                for (var tdi = 0; tdi < rows[tri].length; tdi++) {
                    if (rows[tri][tdi].rowspan == 0) {
                        rows[tri][tdi].tdom.remove();
                    }
                    else {
                        rows[tri][tdi].tdom.attr("rowspan", rows[tri][tdi].rowspan);
                        //tgDom.find(".gridBodyTr_" + tri).removeAttr("data-mergedBy");
                    }
                }
            }
        }
        else if (typ == "f") {
            for (var tri = 0; tri < rows.length; tri++) {
                for (var tdi = 0; tdi < rows[tri].length; tdi++) {
                    if (rows[tri][tdi].rowspan == 0) {
                        rows[tri][tdi].tdom.remove();
                    }
                    else {
                        rows[tri][tdi].tdom.attr("rowspan", rows[tri][tdi].rowspan);
                        //tgDom.find(".gridBodyTr_" + tri).removeAttr("data-mergedBy");
                        if (tdi > 0 || cfg.fixedColSeq == 0)
                            rows[tri][tdi].tdom.css({height: (this.virtualScroll.itemTrHeight) * rows[tri][tdi].rowspan - 1});
                    }
                }
            }
        }
        rows = null;
        return this;
    },
    // body 영역 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ head & foot 영역
    /**
     * @method AXGrid.getDataSetFormatterValue
     * @param {String} formatter - formatter - config 에서 지정된 표현 형식
     * @param {Object} dataSet - setDataSet 메소드에 전달된 데이터 객체
     * @param {String} value - dataSet 객체 가 지니고 있는 값
     * @param {String} key - config colgroup의 key
     * @param {String} CH - config colgroup의 컬럼 객체
     * @description - dataSet의 값을 지정된  formatter에 맞게 가공합니다.
     * @returns {String} result
     */
    getDataSetFormatterValue: function (formatter, dataSet, value, key, CH) {
        var cfg = this.config;
        var result;
        if (formatter == "money") {
            if (value == "" || value == "null" || value == undefined) {
                result = "0";
            }
            else {
                result = value.number().money();
            }
        }
        else if (formatter == "dec") {
            result = (value == undefined) ? "" : value.dec();
        }
        else if (formatter == "html") {
            result = value;
        }
        else if (formatter == "checkbox" || formatter == "radio") {
            result = value;
        }
        else {
            var sendObj = {
                index: null,
                list: this.list,
                item: dataSet,
                dataSet: dataSet,
                page: this.page,
                key: key,
                value: value
            };
            try {
                result = formatter.call(sendObj);
            } catch (e) {
                console.log(e);
            }
        }
        return result;
    },
    /**
     * @method AXGrid.getHeadDataSet
     * @param {Object} dataSet - setDataSet 메소드에 전달된 데이터 객체
     * @param {String} isfix - "fix","n" 고정 형태
     * @description - 그리드의 header를 생성 합니다.
     * @returns {String}
     */
    getHeadDataSet: function (dataSet, isfix) {
        var cfg = this.config;
        if (dataSet == undefined) return;
        var tpo = [];
        var getDataSetFormatterValue = this.getDataSetFormatterValue.bind(this);
        /*dataSet 빈 Key 채우기 */
        axf.each(cfg.colGroup, function () {
            if (dataSet[this.key] == undefined) dataSet[this.key] = "";
        });
        /*dataSet 빈 Key 채우기 ~~~~~~~~~~~~~~~~ */
        var hasFixed = this.hasFixed;

        for (var r = 0; r < cfg.head.rows.length; r++) {
            var isLastTR = (cfg.head.rows.length - 1 == r);
            tpo.push("<tr class=\"gridBodyTr gridBodyTr_foot\" id=\"" + cfg.targetID + "_AX_head_" + r + "_AX_" + (isfix || "n") + "\">");
            var colCount = 0;

            axf.each(cfg.head.rows[r], function (CHidx, CH) {
                if (CH.display && CH.colspan > 0) {

                    if (isfix == undefined || (isfix != undefined && colCount < (cfg.fixedColSeq + 1))) {

                        colCount += CH.colspan;

                        /*radio, check exception */
                        var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                        var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                        var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";
                        var bottomClass = (CH.isLastCell) ? "" : " bodyBottomBorder";
                        var fixedClass = (CH.isFixedEndCell) ? " fixedLine" : "";

                        /*console.log({r:r, CHidx:CHifixedColSeq:cfg.fixedColSeq, colCount:colCount}); */

                        var bodyNodeClass = "";
                        if (CH.formatter == "checkbox" || CH.formatter == "radio") bodyNodeClass = " bodyTdCheckBox";
                        else if (CH.formatter == "html") bodyNodeClass = " bodyTdHtml";

                        tpo.push("<td" + valign + rowspan + colspan + " id=\"" + cfg.targetID + "_AX_" + (isfix || "n") + "head_AX_" + r + "_AX_" + CHidx + "\" class=\"bodyTd" + bottomClass + fixedClass + "\">");
                        /*tpo.push("<div class=\"tdRelBlock\">");*/
                        tpo.push("<div class=\"bodyNode bodyTdText" + bodyNodeClass + "\" align=\"" + CH.align + "\" id=\"" + cfg.targetID + "_AX_headText_AX_" + r + "_AX_" + CHidx + "\">");
                        if ((hasFixed && !CH.isFixedCell) || !hasFixed || isfix != undefined) {
                            if (CH.formatter) {
                                tpo.push(getDataSetFormatterValue(CH.formatter, dataSet, dataSet[CH.key], CH.key, CH));
                            }
                            else {
                                tpo.push(dataSet[CH.key]);
                            }
                        }
                        else {
                            tpo.push("&nbsp;");
                        }
                        tpo.push("</div>");
                        /*tpo.push("</div>");*/
                        tpo.push("</td>");
                    }
                }
            });
            if (r == 0 && isfix == undefined) {
                tpo.push("<td class=\"bodyNullTd\" id=\"" + cfg.targetID + "_AX_headnull\" rowspan=\"" + cfg.head.rows.length + "\"><div class=\"tdRelBlock\">&nbsp;</div></td>");
            }
            tpo.push("</tr>");
        }
        return tpo.join('');
    },
    /**
     * @method AXGrid.getFootDataSet
     * @param {Object} dataSet - setDataSet 메소드에 전달된 데이터 객체
     * @param {String} isfix - "fix","n" 고정 형태
     * @description - 그리드의 footer 생성 합니다.
     * @returns {String}
     */
    getFootDataSet: function (dataSet, isfix) {
        var cfg = this.config;
        if (dataSet == undefined) return;
        var tpo = [];
        var getDataSetFormatterValue = this.getDataSetFormatterValue.bind(this);
        /*dataSet 빈 Key 채우기 */
        axf.each(cfg.colGroup, function () {
            if (dataSet[this.key] == undefined) dataSet[this.key] = "";
        });
        /*dataSet 빈 Key 채우기 ~~~~~~~~~~~~~~~~ */
        var hasFixed = this.hasFixed;

        for (var r = 0; r < cfg.foot.rows.length; r++) {
            var isLastTR = (cfg.foot.rows.length - 1 == r);
            tpo.push("<tr class=\"gridBodyTr gridBodyTr_foot\" id=\"" + cfg.targetID + "_AX_foot_" + r + "_AX_" + (isfix || "n") + "\">");
            var colCount = 0;

            axf.each(cfg.foot.rows[r], function (CHidx, CH) {
                if (CH.display && CH.colspan > 0) {
                    if (typeof isfix == "undefined" || (typeof isfix != "undefined" && CH.isFixedEndCell)) {

                        colCount += CH.colspan;

                        /*radio, check exception */
                        var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                        var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                        var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";
                        var bottomClass = (CH.isLastCell) ? "" : " bodyBottomBorder";
                        var fixedClass = (CH.isFixedEndCell) ? " fixedLine" : "";

                        /*console.log({r:r, CHidx:CHifixedColSeq:cfg.fixedColSeq, colCount:colCount}); */
                        var bodyNodeClass = "";
                        if (CH.formatter == "checkbox" || CH.formatter == "radio") bodyNodeClass = " bodyTdCheckBox";
                        else if (CH.formatter == "html") bodyNodeClass = " bodyTdHtml";

                        tpo.push("<td" + valign + rowspan + colspan + " id=\"" + cfg.targetID + "_AX_" + (isfix || "n") + "foot_AX_" + r + "_AX_" + CHidx + "\" class=\"bodyTd" + bottomClass + fixedClass + "\">");
                        /*tpo.push("<div class=\"tdRelBlock\">");*/
                        tpo.push("<div class=\"bodyNode bodyTdText" + bodyNodeClass + "\" align=\"" + CH.align + "\" id=\"" + cfg.targetID + "_AX_footText_AX_" + r + "_AX_" + CHidx + "\">");
                        if ((hasFixed && !CH.isFixedCell) || !hasFixed || isfix != undefined) {
                            if (CH.formatter) {
                                tpo.push(getDataSetFormatterValue(CH.formatter, dataSet, dataSet[CH.key], CH.key, CH));
                            }
                            else {
                                tpo.push(dataSet[CH.key]);
                            }
                        }
                        else {
                            tpo.push("&nbsp;");
                        }
                        tpo.push("</div>");
                        /*tpo.push("</div>");*/
                        tpo.push("</td>");
                    }
                }
            });
            if (r == 0 && isfix == undefined) {
                tpo.push("<td class=\"bodyNullTd\" id=\"" + cfg.targetID + "_AX_footnull\" rowspan=\"" + cfg.foot.rows.length + "\"><div class=\"tdRelBlock\">&nbsp;</div></td>");
            }
            tpo.push("</tr>");
        }
        return tpo.join('');
    },
    /**
     * @method AXGrid.setDataSet
     * @param {Object} obj - ({key:value})
     * @description - head, foot 속성을 정의한 경우 head, foot 에 값을 표시합니다. 비어있는 객체를 전달할 경우 formatter 연결된 함수에 의해 값이 계산됩니다.
     * @example
     * ```
     *  var myGrid = new AXGrid();
     *  myGrid.setDataSet({price:123000, amount:10});
     *  myGrid.setDataSet({});
     * ```
     */
    setDataSet: function (obj) {
        var cfg = this.config;
        if (obj.ajaxUrl) {

        }
        else {
            if (axdom.isPlainObject(obj)) {
                this.dataSet = obj;
                if (cfg.head) this.printHead();
                if (cfg.foot) {
                    this.printFoot();
                }
                this.contentScrollResize(false);
            }
        }
    },
    /**
     * @method AXGrid.redrawDataSet
     * @description - setDataSet애 의해 dataSet 객체가 변경된 경우 header나 footer를 다시 렌더링 합니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.setDataSet({price:123000, amount:10});
     * myGrid.redrawDataSet();
     * ```
     */
    redrawDataSet: function () {
        var cfg = this.config;
        if (this.dataSet) {
            if (cfg.head) this.printHead();
            if (cfg.foot) this.printFoot();
        }
    },
    /**
     * @method AXGrid.printHead
     * @description - grid의 header를 구성합니다 . (getDataSet)
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.setDataSet({price:123000, amount:10});
     * myGrid.printHead();
     * ```
     */
    printHead: function () {
        var cfg = this.config;
        var getDataSet = this.getHeadDataSet.bind(this);
        var po = [];
        po.push(getDataSet(this.dataSet));
        axdom("#" + cfg.targetID + "_AX_thead").html(po.join(''));
        if (this.hasFixed) {
            po = [];
            po.push(getDataSet(this.dataSet, "fix"));
            axdom("#" + cfg.targetID + "_AX_fixedThead").html(po.join(''));
        }
    },
    /**
     * @method AXGrid.printFoot
     * @description - grid의 footer를 구성합니다 . (getDataSet)
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.setDataSet({price:123000, amount:10});
     * myGrid.printFoot();
     * ```
     */
    printFoot: function () {
        // todo : foot 출력 방식 변경
        var cfg = this.config,
            tableWidth = this.colWidth,
            getDataSet = this.getFootDataSet.bind(this),
            _tdHeight,
            po = [];
        
        this.hasFoot = true;

        po.push('<div class="gridFootContent">');
        po.push('<table cellpadding="0" cellspacing="0" class="gridFootTable" style="width:', tableWidth, 'px;">');
        po.push(this.getColGroup("FH"));
        po.push('<tbody>');
        po.push(getDataSet(this.dataSet));
        po.push('</tbody>');
        po.push('</table>');
        po.push('</div>');
        if (this.hasFixed) {
            po.push('<div class="gridFootfixedContent" style="width:' + this.fixedColWidth + 'px;">');
            po.push('<table cellpadding="0" cellspacing="0" class="gridFootTable" style="width:', this.fixedColWidth, 'px;">');
            po.push(this.getColGroup("FF"));
            po.push('<tbody>');
            po.push(getDataSet(this.dataSet, "fix"));
            po.push('</tbody>');
            po.push('</table>');
            po.push('</div>');
        }

        this.gridFoot.html(po.join(''));
        this.gridFoot.show(); // cfg.foot 활성화
        this.gridFoot_content = this.gridFoot.find(".gridFootContent");
        this.gridFoot.css({height: this.gridFoot_content.height()});

        _tdHeight = undefined;
        
        this.gridFoot.find(".bodyTd").each(function () {
            var td_dom = $(this),
                rowspan = td_dom.attr("rowspan"),
                valign = td_dom.attr("valign"),
                tdHeight;

            if (!rowspan) rowspan = 1;
            if (typeof _tdHeight === "undefined") {
                _tdHeight = td_dom.height() / rowspan;
            }
            tdHeight = _tdHeight * rowspan;

            if (rowspan > 1) {
                td_dom.css({height: tdHeight + 1});
            }
        });

        /// gridFoot 위치 변경으로 gridTargetSetSize 호출 불필요해 짐
        /// this.gridTargetSetSize();
        cfg.scrollContentBottomMargin = this.gridFoot_content.height();
    },
    /* head & foot 영역 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

    /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ editor 영역  */
    /**
     * @method AXGrid.getEditorFormatterValue
     * @param {String} formatter - config editor 에서 지정된 표현 형식
     * @param {Object} dataSet - 데이터 객체
     * @param {String} value - dataSet 객체 가 지니고 있는 값
     * @param {String} key - config colgroup의 key
     * @param {String} CH - config colgroup의 컬럼 객체
     * @param {String} idAttr - Editor 타겟 구분 값
     * @description - Editor의 데이터를 formatter에 맞게 가공하여 반환 합니다.
     * @returns {Object|String}
     */
    getEditorFormatterValue: function (formatter, dataSet, value, key, CH, idAttr) {
        var cfg = this.config,
            result, sendObj;

        if (formatter == "money") {
            if (value == "" || value == "null" || value == undefined) {
                result = "0";
            }
            else {
                result = value.number().money();
            }
        }
        else if (formatter == "dec") {
            result = (value == undefined) ? "" : value.dec();
        }
        else if (formatter == "html") {
            result = value;
        }
        else if (formatter == "checkbox" || formatter == "radio") {
            result = value;
        }
        else {
            sendObj = {
                index: null,
                list: this.list,
                item: dataSet,
                dataSet: dataSet,
                page: this.page,
                key: key,
                value: value
            };
            try {
                result = formatter.call(sendObj);
            } catch (e) {
                console.log(e);
            }
        }

        return result;
    },
    /**
     * @method AXGrid.getEditorFormValue
     * @param {Object} form -  config editor rows form에서 지정된 객체
     * @param {Object} dataSet - 데이터 객체
     * @param {String} value - dataSet 객체 가 지니고 있는 값
     * @param {String} key - config colgroup의 key
     * @param {String} CH - config colgroup의 컬럼 객체
     * @param {String} idAttr - Editor 타겟 구분 값
     * @description - Editor의 데이터를 config editor rows form에 정의된 형식에 맞게 반환 합니다.
     * @returns {String}
     */
    getEditorFormValue: function (form, dataSet, value, key, CH, idAttr) {
        var cfg = this.config;
        var paddingRight = cfg.formPaddingRight;
        var result = [];

        var formClass = (form.addClass) ? " " + form.addClass : "";
        var formWidth = (form.width) ? "width:" + form.width + ";" : "width:100%;";
        var formHeight = (form.height) ? "height:" + form.height + ";" : "";
        var formStyle = (form.style) ? form.style : "";
        var formID = (form.id) ? form.id : cfg.targetID + "_AX_" + key + "_AX_" + idAttr;

        var getFormValue = function (formvalue, value) {
            if (formvalue == "itemValue" || formvalue == "itemText") {
                if (typeof value != "undefined" && axdom.isArray(value)) {
                    return value;
                }
                else if (typeof value == "boolean") {
                    return value;
                }
                else if (typeof value == "string") {
                    return value.dec();
                }
                else {
                    return value;
                }
            }
            else if (axdom.isFunction(formvalue)) {
                var sendObj = {
                    key: key,
                    value: value,
                    list: this.list,
                    page: this.page
                };
                return formvalue.call(sendObj, key, value);
            }
            else {
                return formvalue;
            }
        };

        if (form.type == "hidden") {
            /*result.push("<div style=\"padding-right:"+paddingRight+";\">"); */
            result.push("&nbsp;");
            result.push("<input type=\"hidden\" id=\"" + formID + "\" name=\"" + key + "\" value=\"" + getFormValue(form.value, dataSet[key]) + "\" class=\"AXInput" + formClass + "\" style=\"" + formWidth + formHeight + formStyle + "\" />");
            /*result.push("</div>"); */
        }
        else if (form.type == "text") {
            result.push("<div style=\"padding-right:" + paddingRight + ";\">");
            result.push("<input type=\"text\" id=\"" + formID + "\" name=\"" + key + "\" value=\"" + getFormValue(form.value, dataSet[key]) + "\" class=\"AXInput" + formClass + "\" style=\"" + formWidth + formHeight + formStyle + "\" />");
            result.push("</div>");
        }
        else if (form.type == "readonly") {
            result.push("<div style=\"padding-right:" + paddingRight + ";\">");
            result.push("<input type=\"text\" readonly=\"readonly\" id=\"" + formID + "\" name=\"" + key + "\" value=\"" + getFormValue(form.value, dataSet[key]) + "\" class=\"AXInput" + formClass + "\" style=\"" + formWidth + formHeight + formStyle + "\" />");
            result.push("</div>");
        }
        else if (form.type == "textarea") {
            result.push("<div style=\"padding-right:" + paddingRight + ";\">");
            result.push("<textarea id=\"" + formID + "\" name=\"" + key + "\" class=\"AXTextarea" + formClass + "\" style=\"" + formWidth + formHeight + formStyle + "\" >" + getFormValue(form.value, dataSet[key]) + "</textarea>");
            result.push("</div>");
        }
        else if (form.type == "select") {
            var formValue = getFormValue(form.value, dataSet[key]);
            /*console.log({key:key, dataSet_key:dataSet[key], formValue:formValue}); */
            result.push("<div style=\"padding-right:1px;\">");
            result.push("<select id=\"" + formID + "\" name=\"" + key + "\" class=\"AXSelect" + formClass + "\" style=\"" + formWidth + formHeight + formStyle + "\" >");
            if (form.isspace) result.push("<option value=\"\">", (form.isspaceTitle || "").dec(), "</option>");
            axf.each(form.options, function () {
                result.push("<option value=\"" + (this.value || this.optionValue) + "\"");
                if (form.value == "itemText") {
                    if (formValue == (this.text || this.optionText).dec()) result.push(" selected=\"selected\"");
                }
                else {
                    if (formValue == (this.value || this.optionValue)) result.push(" selected=\"selected\"");
                }
                result.push(">" + (this.text || this.optionText).dec() + "</option>");
            });
            result.push("</select>");
            result.push("</div>");
        }
        else if (form.type == "radio") {
            var formValue = getFormValue(form.value, dataSet[key]);
            axf.each(form.options, function (oidx, opt) {
                result.push("<input type=\"radio\" id=\"" + formID + "_AX_" + oidx + "\" name=\"" + key + "\" value=\"" + this.value + "\"");
                if (formValue == this.value) result.push(" checked=\"checked\"");
                result.push("><label for=\"" + formID + "_AX_" + oidx + "\">" + this.text.dec() + "</label><br/>");
            });
        }
        else if (form.type == "checkbox") {
            var formValue = getFormValue(form.value, dataSet[key]);
            axf.each(form.options, function (oidx, opt) {
                result.push("<input type=\"checkbox\" id=\"" + formID + "_AX_" + oidx + "\" name=\"" + key + "\" value=\"" + this.value + "\"");
                if (axdom.isArray(formValue)) {
                    var isChecked = false;
                    var _value = this.value;
                    axf.each(formValue, function () {
                        if (this == _value) {
                            isChecked = true;
                            return false;
                        }
                    });
                    if (isChecked) result.push(" checked=\"checked\"");
                }
                else {
                    if (formValue == this.value) result.push(" checked=\"checked\"");
                }
                result.push("><label for=\"" + formID + "_AX_" + oidx + "\">" + this.text.dec() + "</label><br/>");
            });
        }
        return result.join('');
    },
    /**
     * @method AXGrid.getEditorBody
     * @param {Object} dataSet - 데이터 객체
     * @param {String} isfix - fix option . (AXGrid.hasFixed == true) "fix"
     * @description - 에디터를 생성 합니다.
     * @returns {String}
     */
    getEditorBody: function (dataSet, isfix) {
        var cfg = this.config;
        var getEditorFormatterValue = this.getEditorFormatterValue.bind(this);
        var getEditorFormValue = this.getEditorFormValue.bind(this);
        var tpo = [];
        var hasFixed = this.hasFixed;

        for (var r = 0; r < cfg.editor.rows.length; r++) {
            var isLastTR = (cfg.editor.rows.length - 1 == r);
            tpo.push("<tr class=\"gridBodyTr gridBodyTr_editor\" id=\"" + cfg.targetID + "_AX_editor_" + r + "_AX_" + (isfix || "n") + "\">");
            var colCount = 0;

            axf.each(cfg.editor.rows[r], function (CHidx, CH) {
                if (CH.display && CH.colspan > 0) {
                    if (isfix == undefined || (isfix != undefined && colCount < (cfg.fixedColSeq + 1))) {
                        colCount += CH.colspan;

                        /*radio, check exception */
                        var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                        var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                        var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";
                        var bottomClass = (CH.isLastCell) ? "" : " bodyBottomBorder";
                        var fixedClass = (CH.isFixedEndCell) ? " fixedLine" : "";

                        var bodyNodeClass = "";
                        if (CH.formatter == "checkbox") bodyNodeClass = " bodyTdCheckBox";
                        else if (CH.formatter == "html") bodyNodeClass = " bodyTdHtml";

                        tpo.push("<td" + valign + rowspan + colspan + " id=\"" + cfg.targetID + "_AX_" + (isfix || "n") + "editor_AX_" + r + "_AX_" + CHidx + "\" class=\"bodyTd" + bottomClass + fixedClass + "\">");
                        /*tpo.push("<div class=\"tdRelBlock\">");*/
                        tpo.push("<div class=\"bodyNode bodyTdText" + bodyNodeClass + "\" align=\"" + CH.align + "\" id=\"" + cfg.targetID + "_AX_editorText_AX_" + r + "_AX_" + CHidx + "\">");
                        if ((hasFixed && !CH.isFixedCell) || !hasFixed || isfix != undefined) {
                            if (CH.form) {
                                tpo.push(getEditorFormValue(CH.form, dataSet, dataSet[CH.key], CH.key, CH, r + "_AX_" + CHidx));
                            }
                            else if (CH.formatter) {
                                tpo.push(getEditorFormatterValue(CH.formatter, dataSet, dataSet[CH.key], CH.key, CH, r + "_AX_" + CHidx, CH.form));
                            }
                            else {
                                tpo.push(dataSet[CH.key]);
                            }
                        }
                        else {
                            tpo.push("&nbsp;");
                        }
                        tpo.push("</div>");
                        /*tpo.push("</div>");*/
                        tpo.push("</td>");
                    }
                }
                else {
                    tpo.push("<td style=\"display:none\">");
                    if (CH.form) {
                        tpo.push(getEditorFormValue(CH.form, dataSet, dataSet[CH.key], CH.key, CH, r + "_AX_" + CHidx));
                    }
                    else if (CH.formatter) {
                        tpo.push(getEditorFormatterValue(CH.formatter, dataSet, dataSet[CH.key], CH.key, CH, r + "_AX_" + CHidx, CH.form));
                    }
                    else {
                        tpo.push(dataSet[CH.key]);
                    }
                    tpo.push("</td>");
                }
            });
            if (r == 0 && isfix == undefined) {
                tpo.push("<td class=\"bodyNullTd\" id=\"" + cfg.targetID + "_AX_editornull\" rowspan=\"" + cfg.editor.rows.length + "\"><div class=\"tdRelBlock\">&nbsp;</div></td>");
            }
            tpo.push("</tr>");
        }
        return tpo.join('');
    },
    /**
     * @method AXGrid.setEditor
     * @param {Array} item - 삽입될 아이템 데이터
     * @param {Number} itemIndex - 에디터가 가져올 아이템 인덱스
     * @param {Number} insertIndex - 에디터가 삽입될 위치 인덱스
     * @description - 해당하는 인덱스에 에디터를 활성화 합니다.config 내에 editor 관련 항목이 없다면 작동하지 않습니다.
     * @example
     * ```
     *  var myGrid = new AXGrid();
     *  myGrid.setEditor({}, 1);
     *  myGrid.setEditor(null, null, 1);
     * ```
     */
    setEditor: function (item, itemIndex, insertIndex) {
        var cfg = this.config, _this = this, itemTrHeight;

        this.editorItemIndex = null;
        if (!this.hasEditor) {
            alert("setConfig 에 editor 가 설정 되지 않아 요청을 처리 할 수 없습니다.");
            return;
        }
        this.unbindAXbind();
        this.editorButtonPosition = "bottom";

        var dataSet = {};
        if (item) {
            dataSet = item;
        }
        /*dataSet 빈 Key 채우기 */
        axf.each(cfg.colGroup, function () {
            if (dataSet[this.key] == undefined) dataSet[this.key] = "";
        });
        /*dataSet 빈 Key 채우기 ~~~~~~~~~~~~~~~~ */

        /*setEditor */
        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_editorContent\" class=\"editorContent\" style=\"padding-left:1px;\">");
        po.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"gridBodyTable\" style=\"\">");
        po.push(this.getColGroup("EB"));
        /*colGroup 삽입 */
        po.push("<tbody id=\"" + cfg.targetID + "_AX_editor_AX_tbody\">");
        po.push(this.getEditorBody(dataSet));
        po.push("</tbody>");
        po.push("</table>");
        po.push("</div>");
        if (this.hasFixed) {
            po.push("<div id=\"" + cfg.targetID + "_AX_fixedEditorContent\" class=\"fixedEditorContent\" style=\"width:" + this.fixedColWidth + "px;padding-left:1px;\">");
            po.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"gridFixedBodyTable\" style=\"width:" + this.fixedColWidth + "px;\">");
            po.push(this.getColGroup("FE"));
            /*colGroup 삽입 */
            po.push("<tbody id=\"" + cfg.targetID + "_AX_editor__AX_fixedTbody\">");
            po.push(this.getEditorBody(dataSet, "fix"));
            po.push("</tbody>");
            po.push("</table>");
            po.push("</div>");
        }
        po.push("<div id=\"" + cfg.targetID + "_AX_editorButtons\" class=\"editorButtons\">");
        po.push("	<input type=\"button\" id=\"" + cfg.targetID + "_AX_editorButtons_AX_save\" value=\"Save\" class=\"AXButtonSmall Classic\" />");
        po.push("	<input type=\"button\" id=\"" + cfg.targetID + "_AX_editorButtons_AX_cancel\" value=\"Cancel\" class=\"AXButtonSmall\" />");
        po.push("</div>");
        this.editor.html(po.join(''));

        if (typeof itemIndex !== "undefined")
        {

            var scrollTop = this.scrollContent.position().top, list = this.list;

            if (cfg.__height == "auto")
            {
                var editorTop = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + itemIndex).position().top;
                itemTrHeight = (function () {
                    if (list.length == 0) {
                        return 0;
                    }
                    else if (list.length == 1) {
                        var p2 = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + itemIndex).height();
                        return p2;
                    }
                    else if ((list.length - 1) == itemIndex) {
                        var p1 = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + (itemIndex - 1)).position().top;
                        var p2 = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + itemIndex).position().top;
                        return p2 - p1;
                    }
                    else {
                        var p1 = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + (itemIndex)).position().top;
                        var p2 = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + (itemIndex.number() + 1)).position().top;
                        return p2 - p1;
                    }
                })();
            }
            else {
                var editorTop = itemIndex * (itemTrHeight = this.virtualScroll.itemTrHeight);
            }

            this.editor.css({top: editorTop + scrollTop + this.body.position().top});
            this.editorOpend = true;
            this.editorOpenTop = editorTop + this.body.position().top;
            this.editorItemIndex = itemIndex;
            this.editorButtonPosition = "bottom";

            var trTop = -editorTop;

            if (
                editorTop + scrollTop + this.body.position().top > this.body.height() - this.body.position().top &&
                ( this.scrollContent.height() + this.editor.height() - 31 > this.body.height() ) &&
                this.list.length != 0
            )
            {
                trTop = this.body.height() - this.scrollContent.height();
                // 에디터 위로 들기
                this.editorButtonPosition = "top";
            }

        }
        else if (typeof insertIndex !== "undefined")
        {

            var scrollTop = this.scrollContent.position().top, list = this.list;
            ;

            if (cfg.__height == "auto") {
                var editorTop = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + insertIndex).position().top;
                var trHeight = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + insertIndex).outerHeight();
                itemTrHeight = (function () {
                    if (list.length == 0) {
                        return 0;
                    }
                    else if (list.length == 1) {
                        var p2 = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + insertIndex).height();
                        return p2;
                    }
                    else if ((list.length - 1) == itemIndex) {
                        var p1 = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + (insertIndex - 1)).position().top;
                        var p2 = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + insertIndex).position().top;
                        return p2 - p1;
                    }
                    else {
                        var p1 = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + (insertIndex)).position().top;
                        var p2 = (axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + (insertIndex.number() + 1)).position() || 0).top;
                        return p2 - p1;
                    }
                })();
                editorTop += trHeight;
            }
            else {
                var editorTop = insertIndex * (itemTrHeight = this.virtualScroll.itemTrHeight);
            }

            this.editor.css({top: editorTop + this.body.position().top});
            this.editorOpend = true;
            this.editorOpenTop = editorTop;
            this.editorInsertIndex = insertIndex;
            this.editorButtonPosition = "bottom";

            var trTop = -editorTop;

            if (
                trTop.abs() + this.body.height() > this.scrollContent.height() &&
                (this.scrollContent.height() + this.editor.height() - 31 > this.body.height()) &&
                this.list.length > 0
            )
            {
                trTop = this.body.height() - this.scrollContent.height();
                // 에디터 위로 들기
                this.editorButtonPosition = "top";
            }

            if (this.body.height() < this.scrollContent.height()) {
                this.scrollContent.css({top: trTop});
                this.contentScrollContentSync({top: trTop});
            }

        }
        else {
            var editorTop = 0, itemTrHeight = this.virtualScroll.itemTrHeight;

            this.editor.css({top: editorTop + this.body.position().top});
            this.editorOpend = true;
            this.editorOpenTop = editorTop;
            this.editorItemIndex = null;
            this.editorButtonPosition = "bottom";
            if (this.body.height() < this.scrollContent.height()) {
                this.scrollContent.css({top: 0});
                this.contentScrollContentSync({top: 0});
            }
        }

        //this.scrollTrackY.before(this.editor); 위치이동 안함. input focus할 때 스크롤 오버 버그 발생
        this.editor.show();
        this.editor.find("input[type=text],textarea").bind("mousedown.AXGrid", function () {
            this.focus();
        });
        this.editor.find("input,textarea,select").bind("focus.AXGrid", function () {
            //console.log("editor focus");
            //console.log(axdom(this).position().left);
        });

        if (cfg.editor.onkeyup) {
            this.editor.find("input[type=text],textarea").unbind("keyup.AXGrid").bind("keyup.AXGrid", function (event) {
                cfg.editor.onkeyup.call({
                    list: _this.list,
                    item: item,
                    element: this
                }, event, this);
            });
        }

        /* form item bind AX */
        for (var r = 0; r < cfg.editor.rows.length; r++) {
            axf.each(cfg.editor.rows[r], function (CHidx, CH) {
                if (CH.display && CH.colspan > 0) {
                    var formID = "";
                    if (CH.AXBind) {
                        formID = (CH.form.id) ? CH.form.id : cfg.targetID + "_AX_" + CH.key + "_AX_" + r + "_AX_" + CHidx;
                        if (CH.AXBind.type == "number" && CH.form.type == "text") {
                            /*axdom("#"+formID).unbindInput(); */
                            axdom("#" + formID).bindNumber((CH.AXBind.config || {}));
                        }
                        else if (CH.AXBind.type == "money" && CH.form.type == "text") {
                            /*axdom("#"+formID).unbindInput(); */
                            axdom("#" + formID).bindMoney((CH.AXBind.config || {}));
                        }
                        else if (CH.AXBind.type == "selector" && CH.form.type == "text") {
                            /*axdom("#"+formID).unbindInput(); */
                            axdom("#" + formID).bindSelector((CH.AXBind.config || {}));
                        }
                        else if (CH.AXBind.type == "slider" && CH.form.type == "text") {
                            /*axdom("#"+formID).unbindInput(); */
                            axdom("#" + formID).bindSlider((CH.AXBind.config || {}));
                        }
                        else if (CH.AXBind.type == "twinSlider" && CH.form.type == "text") {
                            /*axdom("#"+formID).unbindInput(); */
                            axdom("#" + formID).bindTwinSlider((CH.AXBind.config || {}));
                        }
                        else if (CH.AXBind.type == "date" && CH.form.type == "text") {
                            /*axdom("#"+formID).unbindInput(); */
                            axdom("#" + formID).bindDate((CH.AXBind.config || {}));
                        }
                        else if (CH.AXBind.type == "twinDate" && CH.form.type == "text") {
                            /*axdom("#"+formID).unbindInput(); */
                            axdom("#" + formID).bindTwinDate((CH.AXBind.config || {}));
                        }
                        else if (CH.AXBind.type == "dateTime" && CH.form.type == "text") {
                            /*axdom("#"+formID).unbindInput(); */
                            axdom("#" + formID).bindDateTime((CH.AXBind.config || {}));
                        }
                        else if (CH.AXBind.type == "switch" && CH.form.type == "text") {
                            /*axdom("#"+formID).unbindInput(); */
                            axdom("#" + formID).bindSwitch((CH.AXBind.config || {}));
                        }
                        else if (CH.AXBind.type == "select" && CH.form.type == "select") {
                            /*axdom("#"+formID).unbindSelect(); */
                            axdom("#" + formID).bindSelect((CH.AXBind.config || {}));
                        }
                    }
                    if (CH.form) {
                        formID = (CH.form.id) ? CH.form.id : cfg.targetID + "_AX_" + CH.key + "_AX_" + r + "_AX_" + CHidx;
                        if (CH.form.onChange) {
                            axdom("#" + formID).bind("change", function () {
                                CH.form.onChange.call({
                                    key: CH.key,
                                    position: CHidx,
                                    value: axdom("#" + formID).val(),
                                    text: axf.getId(formID).options[axf.getId(formID).options.selectedIndex].text
                                });
                            });
                        }
                        if (CH.form.onClick) {
                            axdom("#" + formID).bind("click", function () {
                                CH.form.onClick.call({
                                    key: CH.key,
                                    position: CHidx,
                                    value: axdom("#" + formID).val()
                                });
                            });
                        }
                        if (CH.form.onBlur) {
                            axdom("#" + formID).bind("blur", function () {
                                CH.form.onBlur.call({
                                    key: CH.key,
                                    position: CHidx,
                                    value: axdom("#" + formID).val()
                                });
                            });
                        }
                        if (CH.form.onFocus) {
                            axdom("#" + formID).bind("focus", function () {
                                CH.form.onFocus.call({
                                    key: CH.key,
                                    position: CHidx,
                                    value: axdom("#" + formID).val()
                                });
                            });
                        }
                    }
                }
            });
        }

        var editorContent = axdom("#" + cfg.targetID + "_AX_editorContent"),
            fixedEditorContent = axdom("#" + cfg.targetID + "_AX_fixedEditorContent"),
            editorButtons = axdom("#" + cfg.targetID + "_AX_editorButtons");
        var editorContentHeight = editorContent.height();
        var fixedEditorContentHeight = fixedEditorContent.height();
        if (editorContentHeight < fixedEditorContentHeight) {
            editorContentHeight = fixedEditorContentHeight;
            editorContent.find(".gridBodyTable").css({height: editorContentHeight});
        }
        else {
            fixedEditorContent.find(".gridFixedBodyTable").css({height: editorContentHeight});
        }

        editorButtons.css({top: editorContentHeight});
        var editorBoxHeight = editorContentHeight.number();

        if (itemTrHeight > editorContentHeight)
        {
            editorContentHeight = itemTrHeight;
            editorContent.find(".gridBodyTable").css({height: editorContentHeight});
            fixedEditorContent.find(".gridFixedBodyTable").css({height: editorContentHeight});
            this.editor.css({height: (editorContentHeight.number())});
            editorButtons.css({top: editorContentHeight});
        }

        var scrollLeft = this.scrollContent.position().left;
        editorContent.css({left: scrollLeft});

        if (this.editorButtonPosition == "top")
        {
            if (insertIndex != undefined) this.editor.css({top: this.editor.position().top - editorContentHeight});
            else this.editor.css({top: this.editor.position().top - editorContentHeight + itemTrHeight});
            editorButtons.addClass("top");
            editorButtons.css({top: -editorButtons.outerHeight() + 1});
        }

        axdom("#" + cfg.targetID + "_AX_editorButtons_AX_save").bind("click", this.saveEditor.bind(this));
        axdom("#" + cfg.targetID + "_AX_editorButtons_AX_cancel").bind("click", this.cancelEditor.bind(this));
    },
    /**
     * @method AXGrid.setEditorForm
     * @param {Object} obj - 삽입될 아이템 데이터
     * @description - 활성화된 에디터에 특정 값을 전달 합니다.
     * @example
     * ```
     * var obj = {
     * 	key : , colgroup 컬럼 key
     * 	position :, 적용될 대상의 배열 순서 [0,0]
     * 	value : , 넘겨줄 값 {String}
     * }
     *
     * var myGrid = new AXGrid();
     *      myGrid.setEditorForm({
     * 	key:"title",
     * 	position:[0,2],
     * 	value:"가나다라"
     * });
     * ```
     */
    setEditorForm: function (obj) {
        var cfg = this.config;
        var formID = cfg.targetID + "_AX_" + obj.key + "_AX_" + obj.position.join("_AX_");
        if (!axf.getId(formID)) alert(formID + "로 Element를 찾을 수 없습니다.");
        axdom("#" + formID).val(obj.value);
    },
    /**
     * @method AXGrid.focusEditorForm
     * @param {String} key - colgroup 컬럼 key
     * @description - 활성화된 에디터의 특정 key 값과 매칭되는 요소를 활성화 합니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.focusEditorForm("regDate");
     * ```
     */
    focusEditorForm: function (key) { /* editor 활성화 된 폼의 특정 요소에 포커스 주기 */
        var cfg = this.config;
        this.editor.find("input[type=text],textarea").each(function () {
            if (this.name == key) {
                this.focus();
                return false;
            }
        });
    },
    /**
     * @method AXGrid.saveEditor
     * @description - 에디터의 내용을 저장하고 리스트에 반영 합니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.saveEditor();
     * ```
     */
    saveEditor: function () {
        var cfg = this.config;

        var editorFormItem = {};
        if (this.editorItemIndex == null) {
            editorFormItem.requestType = "new";
        }
        else {
            editorFormItem.requestType = "edit";
        }

        var setEditorFormItemValue = function (k, v, type) {
            if (editorFormItem[k]) {
                if (type == "checkbox") {
                    if (Object.isArray(editorFormItem[k])) {
                        editorFormItem[k].push(v);
                    }
                    else {
                        editorFormItem[k] = [editorFormItem[k]];
                        editorFormItem[k].push(v);
                    }
                }
                else {
                    editorFormItem[k] = v;
                }
            }
            else {
                editorFormItem[k] = v;
            }
        };

        for (var r = 0; r < cfg.editor.rows.length; r++) {
            axf.each(cfg.editor.rows[r], function (CHidx, CH) {
                if (CH.form) {
                    var formID = (CH.form.id) ? CH.form.id : cfg.targetID + "_AX_" + CH.key + "_AX_" + r + "_AX_" + CHidx;
                    if (CH.form.type == "radio") {
                        var checkedValue = [];
                        axf.each(CH.form.options, function (oidx, opt) {
                            var opt_formID = formID + "_AX_" + oidx;
                            if (axdom("#" + opt_formID).get(0).checked) setEditorFormItemValue(CH.key, axdom("#" + opt_formID).val(), "radio");
                            //editorFormItem.push(CH.key + "=" + axdom("#" + opt_formID).val().enc());
                        });
                    }
                    else if (CH.form.type == "checkbox") {
                        var checkedValue = [];
                        axf.each(CH.form.options, function (oidx, opt) {
                            var opt_formID = formID + "_AX_" + oidx;
                            if (axdom("#" + opt_formID).get(0).checked) setEditorFormItemValue(CH.key, axdom("#" + opt_formID).val(), "checkbox");
                            else setEditorFormItemValue(CH.key, "", "checkbox");
                        });
                    }
                    else if (CH.form.type == "select") {
                        if (CH.form.value == "itemText") {
                            setEditorFormItemValue(CH.key, axf.getId(formID).options[axf.getId(formID).options.selectedIndex].text, "select");
                        }
                        else {
                            setEditorFormItemValue(CH.key, axdom("#" + formID).val(), "select");
                        }
                    }
                    else {
                        setEditorFormItemValue(CH.key, axdom("#" + formID).val(), "text");
                    }
                }
                else {
                    var formID = cfg.targetID + "_AX_" + CH.key + "_AX_" + r + "_AX_" + CHidx;
                    if (axf.getId(formID)) {
                        setEditorFormItemValue(CH.key, axdom("#" + formID).val(), "text");
                    }
                }
            });
        }

        /* form validate -- s */
        var validate = function (formID, CH) {
            var checkedValues = [];
            var value;

            if (CH.form.type == "radio") {
                axf.each(CH.form.options, function (oidx, opt) {
                    var opt_formID = formID + "_AX_" + oidx;
                    if (axdom("#" + opt_formID).get(0).checked) checkedValues.push(axdom("#" + opt_formID).val());
                });
                value = checkedValues.join(",");
            }
            else if (CH.form.type == "checkbox") {
                axf.each(CH.form.options, function (oidx, opt) {
                    var opt_formID = formID + "_AX_" + oidx;
                    if (axdom("#" + opt_formID).get(0).checked) checkedValues.push(axdom("#" + opt_formID).val());
                    else checkedValues.push(CH.key + "=");
                });
                value = checkedValues.join(",");
            }
            else if (CH.form.type == "select") {
                if (CH.form.value == "itemText") {
                    value = axf.getId(formID).options[axf.getId(formID).options.selectedIndex].text;
                }
                else {
                    value = axdom("#" + formID).val();
                }
            }
            else {
                value = axdom("#" + formID).val().trim();
            }
            var sendObj = {
                formID: formID,
                value: value,
                checkedValues: checkedValues,
                form: CH.form
            };
            return CH.form.validate.call(sendObj, formID, value);
        };

        var validateError = false;
        for (var r = 0; r < cfg.editor.rows.length; r++) {
            /*console.log(cfg.editor.rows[r]);*/
            axf.each(cfg.editor.rows[r], function (CHidx, CH) {
                if (CH.form) {
                    if (CH.form.validate) {
                        var formID = (CH.form.id) ? CH.form.id : cfg.targetID + "_AX_" + CH.key + "_AX_" + r + "_AX_" + CHidx;
                        var result = validate(formID, CH);
                        if (!result) {
                            validateError = true;
                            axdom("#" + formID).focus();
                        }
                    }
                }
            });
        }

        if (validateError) {
            return;
        }
        /* form validate -- e */

        if (cfg.editor.request) {
            this.unbindAXbind();

            var po = [];
            po.push("<div class=\"editorContent\" style=\"background:#fff;\">");
            po.push("<div class=\"AXLoading\"></div>");
            po.push("</div>");
            this.editor.html(po.join(''));

            var saveEditorRequest = this.saveEditorRequest.bind(this);
            var cancelEditor = this.cancelEditor.bind(this);
            var ajax = cfg.editor.request, url = ajax.ajaxUrl;
            var formPars = [];
            axf.each(editorFormItem, function (k, v) {
                formPars.push(k + "=" + v.enc());
            });
            if (Object.isString(obj.ajaxPars)) {
                formPars.push(obj.ajaxPars);
            }
            else if (Object.isObject(obj.ajaxPars)) {
                formPars.push(axdom.param(obj.ajaxPars));
            }
            var pars = formPars.join('&');

            var _method = "post";
            var _contentType = AXConfig.AXReq.contentType;
            var _headers = {};
            var _responseType = AXConfig.AXReq.responseType;
            var _dataType = AXConfig.AXReq.dataType;

            if (ajax.method) _method = ajax.method;
            if (ajax.contentType) _contentType = ajax.contentType;
            if (ajax.headers) _headers = ajax.headers;

            new AXReq(url, {
                type: _method,
                contentType: _contentType,
                responseType: _responseType,
                dataType: _dataType,
                headers: _headers,
                debug: ajax.debug,
                pars: pars,
                onsucc: function (res) {
                    if ((res.result && res.result == AXConfig.AXReq.okCode) || (res.result == undefined && !res.error)) {
                        saveEditorRequest(res);
                    }
                    else {
                        toast.push({body: res.msg.dec(), type: "Caution"});
                        cancelEditor();
                    }
                },
                onerr: function (res) {
                    //toast.push({ body: res.msg.dec(), type: "Caution" });
                    if (cfg.editor.response) { /*  */
                        var sendObj = {
                            error: true,
                            res: res,
                            index: this.editorItemIndex,
                            insertIndex: this.editorInsertIndex,
                            list: this.list,
                            page: this.page
                        };
                        cfg.editor.response.call(sendObj, this.editorItemIndex);
                    }
                    cancelEditor();
                }
            });

            return true;

        }
        else {

            /*
             var po = [];
             po.push("<div class=\"editorContent\" id=\"\" style=\"background:#fff;\">");
             po.push("<div class=\"editorContent AXLoading\"></div>");
             po.push("</div>");
             this.editor.append(po.join(''));
             */

            // -------------- editor response 에서 return false 가 오는 상황을 고려 하면 사용
            //this.editor.hide();
            //this.editorOpend = false;

            var saveEditorRequest = this.saveEditorRequest.bind(this);
            var cancelEditor = this.cancelEditor.bind(this);
            saveEditorRequest({item: editorFormItem});

        }
    },
    /**
     * @method AXGrid.saveEditorRequest
     * @param {Object} res - editorFormItem
     * @description - config editor 항목에 request가 설정 되었을경우 서버 연동 처리를 합니다 response설정으로 예외 처리를 합니다.
     */
    saveEditorRequest: function (res) {
        var cfg = this.config;

        if (this.editorOpend) {
            /*this.editorItemIndex */
            /* this.list[n] 에 서버로 부터 받은 값 덮어쓰기 */
            if (cfg.editor.response) { /*  */

                var sendObj = {
                    res: res,
                    index: this.editorItemIndex,
                    insertIndex: this.editorInsertIndex,
                    list: this.list,
                    page: this.page
                };
                var callResult = cfg.editor.response.call(sendObj, this.editorItemIndex);

                /*
                 // -------------- editor response 에서 return false 가 오는 상황을 고려 하면 사용
                 if(callResult === true){
                 this.editorOpend = false;
                 this.unbindAXbind();
                 }else{
                 this.editor.show();
                 this.editorOpend = true;
                 }
                 */

            }
            else {

                this.unbindAXbind();
                if (this.editorItemIndex != null && this.editorItemIndex != undefined) {
                    AXUtil.overwriteObject(this.list[this.editorItemIndex], res.item, true);
                    this.updateList(this.editorItemIndex, this.list[this.editorItemIndex]);
                }
                else if (this.editorInsertIndex != null && this.editorInsertIndex != undefined) {
                    this.pushList(res.item, this.editorInsertIndex);
                }
                else {
                    this.pushList(res.item);
                }
                this.editorItemIndex = null;
                this.editorInsertIndex = null;
                this.editor.hide();
                this.editorOpend = false;
            }

        }
    },
    /**
     * @method AXGrid.cancelEditor
     * @description - 활성화된 에디터를 해제 합니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.cancelEditor();
     * ```
     */
    cancelEditor: function () {
        this.editor.hide();
        this.editorOpend = false;
        this.unbindAXbind();
    },
    /**
     * @method AXGrid.unbindAXbind
     * @description - 에디터내부 요소에 부여된 특성을 해제 합니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.unbindAXbind();
     * ```
     */
    unbindAXbind: function () {
        var cfg = this.config;
        try {
            if (cfg.editor && cfg.editor.rows) {
                for (var r = 0; r < cfg.editor.rows.length; r++) {
                    axf.each(cfg.editor.rows[r], function (CHidx, CH) {
                        if (CH.display && CH.colspan > 0) {

                            if (CH.AXBind) {
                                var formID = (CH.form.id) ? CH.form.id : cfg.targetID + "_AX_" + CH.key + "_AX_" + r + "_AX_" + CHidx;
                                /*console.log(formID); */
                                if (CH.AXBind.type == "number" && CH.form.type == "text") {
                                    axdom("#" + formID).unbindInput();
                                }
                                else if (CH.AXBind.type == "money" && CH.form.type == "text") {
                                    axdom("#" + formID).unbindInput();
                                }
                                else if (CH.AXBind.type == "selector" && CH.form.type == "text") {
                                    axdom("#" + formID).unbindInput();
                                }
                                else if (CH.AXBind.type == "slider" && CH.form.type == "text") {
                                    axdom("#" + formID).unbindInput();
                                }
                                else if (CH.AXBind.type == "twinSlider" && CH.form.type == "text") {
                                    axdom("#" + formID).unbindInput();
                                }
                                else if (CH.AXBind.type == "date" && CH.form.type == "text") {
                                    axdom("#" + formID).unbindInput();
                                }
                                else if (CH.AXBind.type == "twinDate" && CH.form.type == "text") {
                                    axdom("#" + formID).unbindInput();
                                }
                                else if (CH.AXBind.type == "dateTime" && CH.form.type == "text") {
                                    axdom("#" + formID).unbindInput();
                                }
                                else if (CH.AXBind.type == "switch" && CH.form.type == "text") {
                                    axdom("#" + formID).unbindInput();
                                }
                                else if (CH.AXBind.type == "select" && CH.form.type == "select") {
                                    axdom("#" + formID).unbindSelect();
                                }
                            }
                        }
                    });
                }
            }
        } catch (e) {
            console.log(e);
        }
    },
    /**
     * @method AXGrid.appendList
     * @param {Object} item - item dataset
     * @param {Number} insertIndex - 삽입 대상 index
     * @description - 그리드에 신규 데이터를 삽입하기 위해 삽입용 에디터를 활성화 하여 줍니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * var item = {};
     * myGrid.appendList(item);
     * myGrid.appendList(item, 3);
     * ```
     */
    appendList: function (item, insertIndex) {
        if (insertIndex >= this.list.length) insertIndex = this.list.length;
        this.setEditor(item, undefined, insertIndex);
    },
    /* editor 영역 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    /**
     * @method AXGrid.setMobileTool
     * @description - 출력 대상이 모바일일 경우 모바일용 page indicator를 생성합니다.
     * @returns {String}
     */
    setMobileTool: function () {
        var cfg = this.config, _this = this;

        var toolGroupTop = axdom("#" + cfg.targetID + "_AX_gridToolGroupTop");
        var toolGroupBottom = axdom("#" + cfg.targetID + "_AX_gridToolGroupBottom");

        var po = [];
        po.push('<a name="' + cfg.targetID + '_AX_top"></a>');
        po.push('<a class="tool-config"><span class="displayNone">congif</span></a>');
        if (cfg.page) {
            if (cfg.page.paging) {
                po.push('<div class="tool-pageGroup">');
                po.push('<a class="tool-prevPage"><span class="displayNone">prev</span></a>');
                po.push('<div class="tool-pageNo"><span id="' + cfg.targetID + '_AX_gridToolTopPageNoDisplay"></span><select id="' + cfg.targetID + '_AX_gridToolTopPageNo"></select></div>');
                po.push('<a class="tool-nextPage"><span class="displayNone">next</span></a>');
                po.push('</div>');
            }
        }
        po.push('<a href="#' + cfg.targetID + '_AX_bottom" class="tool-gotoTop"><span class="displayNone">top</span></a>');
        toolGroupTop.empty();
        toolGroupTop.append(po.join(''));

        po = [];
        po.push('<a name="' + cfg.targetID + '_AX_bottom"></a>');
        po.push('<a class="tool-config"><span class="displayNone">congif</span></a>');
        if (cfg.page) {
            if (cfg.page.paging) {
                po.push('<div class="tool-pageGroup">');
                po.push('<a class="tool-prevPage"><span class="displayNone">prev</span></a>');
                po.push('<div class="tool-pageNo"><span id="' + cfg.targetID + '_AX_gridToolBottomPageNoDisplay"></span><select id="' + cfg.targetID + '_AX_gridToolBottomPageNo"></select></div>');
                po.push('<a class="tool-nextPage"><span class="displayNone">next</span></a>');
                po.push('</div>');
            }
        }
        po.push('<a href="#' + cfg.targetID + '_AX_top" class="tool-gotoBottom"><span class="displayNone">bottom</span></a>');
        toolGroupBottom.empty();
        toolGroupBottom.append(po.join(''));

        var pgCount = this.page.pageCount.number();
        var pageNo = this.page.pageNo.number();

        if (cfg.page) {
            if (cfg.page.paging) {
                if (pgCount == 0) {
                    po = [];
                    po.push("<option value=\"\">..</option>");
                    axdom("#" + cfg.targetID + "_AX_gridToolTopPageNo").html(po.join(''));
                    axdom("#" + cfg.targetID + "_AX_gridToolTopPageNoDisplay").html(po.join(''));
                    axdom("#" + cfg.targetID + "_AX_gridToolBottomPageNo").html(po.join(''));
                    axdom("#" + cfg.targetID + "_AX_gridToolBottomPageNoDisplay").html(po.join(''));
                }
                else {
                    axdom("#" + cfg.targetID + "_AX_gridToolTopPageNo").html("");
                    axdom("#" + cfg.targetID + "_AX_gridToolTopPageNoDisplay").html(pageNo);
                    var mySelect = axf.getId(cfg.targetID + "_AX_gridToolTopPageNo");
                    axdom("#" + cfg.targetID + "_AX_gridToolBottomPageNo").html("");
                    axdom("#" + cfg.targetID + "_AX_gridToolBottomPageNoDisplay").html(pageNo);
                    var mySelectBottom = axf.getId(cfg.targetID + "_AX_gridToolBottomPageNo");
                    var oi = 0;
                    for (var p = 1; p < pgCount + 1; p++) {
                        mySelect.options[oi] = new Option(p, p.money());
                        mySelectBottom.options[oi] = new Option(p, p.money());
                        if (pageNo == p) {
                            mySelect.options[oi].selected = true;
                            mySelectBottom.options[oi].selected = true;
                        }
                        oi++;
                    }
                }

                axdom("#" + cfg.targetID + "_AX_gridToolTopPageNo").bind("change", this.onPageChange.bind(this));
                axdom("#" + cfg.targetID + "_AX_gridToolBottomPageNo").bind("change", this.onPageChange.bind(this));

                /* page event bind */
                var goPageMove = this.goPageMove.bind(this);
                toolGroupTop.find(".tool-prevPage").bind("click", function (event) {
                    goPageMove(-1);
                });
                toolGroupBottom.find(".tool-prevPage").bind("click", function (event) {
                    goPageMove(-1);
                });
                toolGroupTop.find(".tool-nextPage").bind("click", function (event) {
                    goPageMove(1);
                });
                toolGroupBottom.find(".tool-nextPage").bind("click", function (event) {
                    goPageMove(1);
                });
                /* page event bind */

            }

            var openMobileConfig = this.openMobileConfig.bind(this);
            toolGroupTop.find(".tool-config").bind("click", function (event) {
                openMobileConfig(event);
            });
            toolGroupBottom.find(".tool-config").bind("click", function (event) {
                openMobileConfig(event);
            });
        }
    },
    /**
     * @method AXGrid.setPaging
     * @description - 그리드 하단 page indicator를 생성합니다.
     * @returns {String}
     */
    setPaging: function () {
        var cfg = this.config;
        if (cfg.viewMode == "mobile") {
            this.setMobileTool();
            return this;
        }
        else {
            axdom("#" + cfg.targetID + "_AX_gridToolGroupTop").empty();
            axdom("#" + cfg.targetID + "_AX_gridToolGroupBottom").empty();
        }

        /* apply page vars */
        var pageNos = axf.getId(cfg.targetID + "_AX_gridPageNo");
        var pgCount = this.page.pageCount.number();
        var pageNo = this.page.pageNo.number();

        if (pgCount === 0) {
            var po = [];
            po.push("<option value=\"\">..</option>");
            axdom("#" + cfg.targetID + "_AX_gridPageNo").html(po.join(''));
        }
        else {
            axdom("#" + cfg.targetID + "_AX_gridPageNo").html("");
            var mySelect = axf.getId(cfg.targetID + "_AX_gridPageNo");
            if (pgCount > 1000) {
                var oi = 0;
                var pageStart = 1;
                var pageEnd = pageNo + 49;
                if (pageNo > 50) pageStart = pageNo - 50;
                if (pageEnd > pgCount) pageEnd = pgCount;
                for (var p = pageStart; p < pageEnd + 1; p++) {
                    mySelect.options[oi] = new Option(p, p.money());
                    if (pageNo == p) mySelect.options[oi].selected = true;
                    oi++;
                }
            }
            else {
                var oi = 0;
                for (var p = 1; p < pgCount + 1; p++) {
                    mySelect.options[oi] = new Option(p, p.money());
                    if (pageNo == p) mySelect.options[oi].selected = true;
                    oi++;
                }
            }
            /*alert(axf.getId(cfg.targetID + "_AX_gridPageNo").options[axf.getId(cfg.targetID + "_AX_gridPageNo").options.selectedIndex].value); */
        }
        axdom("#" + cfg.targetID + "_AX_gridPageCount").html("/ " + pgCount.money() + " " + cfg.pageCountMSG);

        if (this.page.listCount.number() == 0) this.page.listCount = this.list.length;
        axdom("#" + cfg.targetID + "_AX_gridStatus").html(cfg.listCountMSG.replace("{listCount}", this.page.listCount.number().money()));

        if (this.isMobile) {
            axdom("#" + cfg.targetID + "_AX_gridPageNo").bind("change", this.onPageChange.bind(this));
        }
        else {
            var onPageChange = this.onPageChange.bind(this);
            axdom("#" + cfg.targetID + "_AX_gridPageNo").bindSelect({
                onchange: function (arg) {
                    onPageChange();
                }
            });
        }
    },
    /**
     * @method AXGrid.goPageMove
     * @param pageAdd {Number} - 이동할 페이지 증/감(-) 수
     * @description - pageAdd 만큼 페이지를 이동합니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.goPageMove(-1);
     * ```
     */
    goPageMove: function (pageAdd) {
        var cfg = this.config;

        if (this.page.pageCount.number() > 0) {
            var pgCount = this.page.pageCount.number();
            var pageNo = this.page.pageNo.number();

            if (pageNo + pageAdd < 1) pageNo = 1;
            else if (pageNo + pageAdd > pgCount) pageNo = pgCount;
            else pageNo += pageAdd;

            if (cfg.viewMode == "mobile") {
                axdom("#" + cfg.targetID + "_AX_gridToolTopPageNo").val(pageNo);
                axdom("#" + cfg.targetID + "_AX_gridToolBottomPageNo").val(pageNo);
                this.onPageChange();
            }
            else {
                axdom("#" + cfg.targetID + "_AX_gridPageNo").setValueSelect(pageNo);
            }
        }
        /*this.page.pageNo = pageNo; */
        /*this.onPageChange(); bindSelectSetValue 시 자동 호출되는 구조 */
    },
    /**
     * @method AXGrid.onPageChange
     * @param e {Event} - change 이벤트
     * @description - 페이지 이동시 호출 됩니다.
     */
    onPageChange: function (e) {
        var cfg = this.config;
        var pgCount, pageNo, npageNo;
        pgCount = this.page.pageCount.number();
        pageNo = this.page.pageNo.number();

        if (cfg.viewMode == "mobile") {
            npageNo = (e) ? e.target.value : axdom("#" + cfg.targetID + "_AX_gridToolTopPageNo").val();
        }
        else {
            npageNo = axdom("#" + cfg.targetID + "_AX_gridPageNo").val();
        }
        this.page.pageNo = npageNo;

        if (this.page.onchange) {
            this.page.onchange.call(this.page, npageNo);
        }
        else {

            /*스크롤 위치 변경 */
            if (cfg.viewMode != "mobile") {

                var scrollTop = 0;
                this.scrollContent.css({top: scrollTop});
                this.contentScrollContentSync({top: scrollTop});

                if (this.pageActive && this.ajaxInfo) {
                    this.setList(this.ajaxInfo, this.ajax_sortDisable, null, "paging");
                    this.contentScrollResize();
                }
            }
            else {
                if (this.pageActive && this.ajaxInfo) {
                    this.setList(this.ajaxInfo, this.ajax_sortDisable, null, "paging");
                }
            }
        }
    },
    /**
     * @method AXGrid.setStatus
     * @param listLength {Number} - 그리드 리스트 아이템 갯수(length)
     * @description - 그리드 리스트 아이템 갯수(length)를 표시 합니다.
     * @returns {String}
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.setStatus(myGrid.list.length);
     * ```
     */
    setStatus: function (listLength) {
        var cfg = this.config, listCount;

        if (typeof listLength !== "undefined") {
            listCount = listLength;
        }
        else {
            var page;
            if (this.page) page = this.page;
            listCount = (page.listCount || 0);
        }

        axdom("#" + cfg.targetID + "_AX_gridStatus").html(cfg.listCountMSG.replace("{listCount}", listCount.number().money()));
    },
    /**
     * @method AXGrid.getSortParam
     * @param {String} ty - 출력옵션 "one" 으로 요청시 String 형태로, 미 지정시 Object 형태로 반환
     * @description - 정렬옵션을 반환 합니다.
     * @returns {String|Object}
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.getSortParam();
     *
     * // return value
     * {
	 * sortKey:"" , -  정렬 기준 key
	 * sortWay:""   -  정렬 방법 "asc" or "desc"
	 * }
     * ```
     */
    getSortParam: function (ty) {
        var cfg = this.config;
        var sortObj = this.nowSortHeadObj;
        if (sortObj) {
            if (ty == "one") {
                return "sortBy=" + sortObj.key + " " + sortObj.sort;
            }
            else {
                return axdom.param({sortKey: sortObj.key, sortWay: sortObj.sort});
            }
        }
        else {
            return "";
        }
    },
    /**
     * @method AXGrid.getExcelColHeadTd
     * @param {Object} arg
     * @description - 그리드 내용을 엑셀 포맷(html)으로 변환시 컬럼 해더를 생성 합니다.
     * @returns {String}
     * @example
     *```
     * var arg = {
     *     valign,  - valign 옵션
     *     rowspan, - rowspan 옵션
     *     colspan, - colspan 옵션
     *     align,   - align 옵션
     *     colSeq,  - config colgroup 내부 순서
     *     formatter, - config colgroup에서 지정된 formatter
     *     sort,  - 정렬 옵션
     *     tdHtml, - config colgroup 지정된 label
     *     displayLabel - Label이 지정된 경우 출력 여부. 기본적으로 사용시 false 로 셋팅됨. colgroup 에서 따로 지정하지 않기 때문에,,
     * }
     *```
     */
    getExcelColHeadTd: function (arg, filter) {
        var cfg = this.config;
        var po = [];

        if (filter) {
            if (!filter.call(cfg.colGroup[arg.colSeq])) return '';
        }
        if (arg.formatter == "html" || arg.formatter == "checkbox") {
            if (!arg.displayLabel) {
                colHeadTdText = " colHeadTdHtml";
                toolUse = false;
                if (arg.formatter == "checkbox") {
                    colHeadTdText = " colHeadTdCheck";
                    arg.tdHtml = "<input type=\"checkbox\" name=\"checkAll\" />";
                }
            }
        }

        po.push("<td" + arg.valign + arg.rowspan + arg.colspan + ">");
        po.push(arg.tdHtml);
        po.push("</td>");

        return po.join('');
    },
    /**
     * @method AXGrid.getExcelItem
     * @param {Number} itemIndex - 그리드 리스트중 대상 index
     * @param {Object} item - 그리드 리스트중 index 데이타
     * @description - 그리드 내용을 엑셀 포맷(html)으로 변환시 리스트 데이터를 변환 합니다.
     * @returns {String}
     */
    getExcelItem: function (itemIndex, item, filter) {
        var cfg = this.config;
        var tpo = [];
        var evenClassName = "line" + (itemIndex % 2);
        var getFormatterValue = this.getFormatterValue.bind(this);
        var getTooltipValue = this.getTooltipValue.bind(this);
        var trAddClass = "";

        for (var r = 0; r < cfg.body.rows.length; r++) {
            tpo.push("<tr>");
            axf.each(cfg.body.rows[r], function (CHidx, CH) {
                if (CH.display && CH.colspan > 0) {
                    if (filter && !filter.call(CH)) {

                    }
                    else {
                        /*radio, check exception */
                        var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                        var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                        var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";

                        var bodyNodeClass = "";

                        var tooltipValue = "";
                        if (CH.tooltip) {
                            tooltipValue = getTooltipValue(CH.tooltip, item, itemIndex, item[CH.key], CH.key, CH);
                        }

                        tpo.push("<td" + valign + rowspan + colspan + ">");
                        if (CH.formatter) {
                            tpo.push(getFormatterValue(CH.formatter, item, itemIndex, item[CH.key], CH.key, CH));
                        }
                        else {
                            tpo.push(item[CH.key]);
                        }
                        tpo.push("</td>");
                    }
                }
            });
            tpo.push("</tr>");
        }
        return tpo.join('');
    },
    /**
     * @method AXGrid.getExcelItemMarker
     * @param {Number} itemIndex - 그리드 리스트중 대상 index
     * @param {Object} item - 그리드 리스트중 index 데이타
     * @param {String} isfix - isfix {String} - fix option .
     * @description - 그리드 내용을 엑셀 포맷(html)으로 변환시 maker 데이터가 존재시 처리 합니다.
     * @returns {String}
     */
    getExcelItemMarker: function (itemIndex, item, isfix, filter, markerIndexs) {
        var cfg = this.config;
        var tpo = [];
        var evenClassName = "gridBodyMarker";
        var getFormatterValue = this.getFormatterValue.bind(this);

        for (var mi = 0, l = markerIndexs.length, markerIndex; mi < l; mi++) {
            var marker = cfg.body.marker[markerIndexs[mi]];
            for (var r = 0; r < marker.rows.length; r++) {
                var isLastTR = (marker.rows.length - 1 == r);
                tpo.push("<tr>");
                axf.each(marker.rows[r], function (CHidx, CH) {
                    if (CH.display && CH.colspan > 0) {
                        if (filter && !filter.call(CH)) {

                        }
                        else {
                            /*radio, check exception */
                            var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                            var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                            var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";

                            tpo.push("<td" + valign + rowspan + colspan + ">");
                            if (CH.formatter) {
                                tpo.push(getFormatterValue(CH.formatter, item, itemIndex, item[CH.key], CH.key, CH));
                            }
                            else {
                                tpo.push(item[CH.key]);
                            }
                            tpo.push("</td>");
                        }
                    }
                });
                tpo.push("</tr>");
            }
        }

        return tpo.join('');
    },

    /**
     * @method AXGrid.getExcelHeadDataSet
     * @param {Object} dataSet - setDataSet 메소드에 전달된 데이터 객체
     * @param {String} isfix - "fix","n" 고정 형태
     * @description - 그리드 내용을 엑셀 포맷(html)으로 변환시 header 데이터가 존재시 처리 합니다.
     * @returns {String}
     */
    getExcelHeadDataSet: function (dataSet, isfix, filter) {
        var cfg = this.config;
        if (dataSet == undefined) return;
        var tpo = [];
        var getDataSetFormatterValue = this.getDataSetFormatterValue.bind(this);
        /*dataSet 빈 Key 채우기 */
        axf.each(cfg.colGroup, function () {
            if (dataSet[this.key] == undefined) dataSet[this.key] = "";
        });
        /*dataSet 빈 Key 채우기 ~~~~~~~~~~~~~~~~ */

        for (var r = 0; r < cfg.head.rows.length; r++) {
            var isLastTR = (cfg.head.rows.length - 1 == r);
            tpo.push("<tr>");
            var colCount = 0;

            axf.each(cfg.head.rows[r], function (CHidx, CH) {
                if (CH.display && CH.colspan > 0) {
                    if (filter && !filter.call(CH)) {

                    }
                    else {
                        /*radio, check exception */
                        var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                        var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                        var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";

                        var bodyNodeClass = "";
                        if (CH.formatter == "checkbox" || CH.formatter == "radio") bodyNodeClass = " bodyTdCheckBox";
                        else if (CH.formatter == "html") bodyNodeClass = " bodyTdHtml";

                        tpo.push("<td" + valign + rowspan + colspan + ">");
                        if (CH.formatter) {
                            tpo.push(getDataSetFormatterValue(CH.formatter, dataSet, dataSet[CH.key], CH.key, CH));
                        }
                        else {
                            tpo.push(dataSet[CH.key]);
                        }
                        tpo.push("</td>");
                    }
                }
            });
            tpo.push("</tr>");
        }
        return tpo.join('');
    },
    /**
     * @method AXGrid.getExcelFootDataSet
     * @param {Object} dataSet - setDataSet 메소드에 전달된 데이터 객체
     * @param {String} isfix - "fix","n" 고정 형태
     * @description - 그리드 내용을 엑셀 포맷(html)으로 변환시 footer 데이터가 존재시 처리 합니다.
     * @returns {String}
     */
    getExcelFootDataSet: function (dataSet, isfix, filter) {
        var cfg = this.config;
        if (dataSet == undefined) return;
        var tpo = [];
        var getDataSetFormatterValue = this.getDataSetFormatterValue.bind(this);
        /*dataSet 빈 Key 채우기 */
        axf.each(cfg.colGroup, function () {
            if (dataSet[this.key] == undefined) dataSet[this.key] = "";
        });
        /*dataSet 빈 Key 채우기 ~~~~~~~~~~~~~~~~ */
        var hasFixed = this.hasFixed;

        for (var r = 0; r < cfg.foot.rows.length; r++) {
            var isLastTR = (cfg.foot.rows.length - 1 == r);
            tpo.push("<tr>");
            axf.each(cfg.foot.rows[r], function (CHidx, CH) {
                if (CH.display && CH.colspan > 0) {
                    if (filter && !filter.call(CH)) {

                    }
                    else {
                        /*radio, check exception */
                        var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                        var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                        var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";
                        var bottomClass = (CH.isLastCell) ? "" : " bodyBottomBorder";
                        var fixedClass = (CH.isFixedEndCell) ? " fixedLine" : "";

                        var bodyNodeClass = "";
                        if (CH.formatter == "checkbox" || CH.formatter == "radio") bodyNodeClass = " bodyTdCheckBox";
                        else if (CH.formatter == "html") bodyNodeClass = " bodyTdHtml";

                        tpo.push("<td" + valign + rowspan + colspan + ">");
                        if (CH.formatter) {
                            tpo.push(getDataSetFormatterValue(CH.formatter, dataSet, dataSet[CH.key], CH.key, CH));
                        }
                        else {
                            tpo.push(dataSet[CH.key]);
                        }
                        tpo.push("</td>");
                    }
                }
            });
            tpo.push("</tr>");
        }
        return tpo.join('');
    },
    /**
     * @method AXGrid.getExcelFormat
     * @param {String} format - "html","json" 변환 옵션
     * @param {Function} [filter] - "html" 인 경우 filter 옵션으로 표현하고 싶은 열을 선택할 수 있습니다.
     * @description -  format에 맞춰 그리드의 내용을 엑셀 포맷으로 변환 합니다.
     * @returns {String|Object}
     * @example
     * ```
     * var txt = myGrid.getExcelFormat("html");
     * var txt = myGrid.getExcelFormat("html", function(){
     *  // colGroup item => this
     *  return this.key != 'no'; // key가 no가 아님 컬럼만 출력
     * );
     * var json = myGrid.getExcelFormat("json");
     * ```
     */
    getExcelFormat: function (format, filter) {
        var cfg = this.config;
        var getExcelColHeadTd = this.getExcelColHeadTd.bind(this);

        var bodyHasMarker = this.bodyHasMarker;
        var getExcelItem = this.getExcelItem.bind(this);
        var getExcelItemMarker = this.getExcelItemMarker.bind(this);
        var getMarkerDisplay = this.getMarkerDisplay.bind(this);
        var markerIndex;
        var getHeadDataSet = this.getExcelHeadDataSet.bind(this);
        var getFootDataSet = this.getExcelFootDataSet.bind(this);

        var po = [];

        if (format == "html") {

            po.push("<table border='1'>");
            po.push("	<thead>");
            for (var r = 0; r < cfg.colHead.rows.length; r++) {
                var isLastTR = (cfg.colHead.rows.length - 1 == r);
                po.push("<tr>");
                axf.each(cfg.colHead.rows[r], function (CHidx, CH) {
                    if (CH.display && CH.colspan > 0) {

                        var tdHtml = CH.label || "untitle";
                        var rowspan = (CH.rowspan > 1) ? " rowspan='" + CH.rowspan + "'" : "";
                        var colspan = (CH.colspan > 1) ? " colspan='" + CH.colspan + "'" : "";
                        var valign = " valign='" + CH.valign + "'";

                        po.push(getExcelColHeadTd({
                            valign: valign,
                            rowspan: rowspan,
                            colspan: colspan,
                            align: CH.align,
                            colSeq: CH.colSeq,
                            formatter: CH.formatter,
                            sort: CH.sort,
                            tdHtml: tdHtml,
                            displayLabel: CH.displayLabel
                        }, filter));
                    }
                });
                po.push("</tr>");
            }
            po.push("	</thead>");
            po.push("	<tbody>");

            if (cfg.head) po.push(getHeadDataSet(this.dataSet, false, filter));

            axf.each(this.list, function (itemIndex, item) {
                po.push(getExcelItem(itemIndex, item, filter));
                if (bodyHasMarker && (markerIndex = getMarkerDisplay(itemIndex, item)).length > 0) {
                    po.push(getExcelItemMarker(itemIndex, item, 'n', filter, markerIndex));
                }
            });

            if (cfg.foot) po.push(getFootDataSet(this.dataSet, false, filter));

            po.push("	</tbody>");
            po.push("</table>");

            return po.join('');

        }
        else if (format == "json") {
            return {
                colGroup: cfg.colGroup,
                list: this.list
            }
        }

    },

    /**
     * @method AXGrid.changeGridView
     * @param {JSONObject} obj
     * @description - 그리드의 뷰모드를 체인지 합니다.
     * @example
     * ```
     * myGrid.changeGridView({
     *     viewMode:"grid"
     * });
     * myGrid.changeGridView({
     *     viewMode:"icon",
     *     view: {
     *         width:"200",
     *         // icon width
     *         height:"300",
     *         // icon height
     *         img: {
     *             left:"10",
     *             top:"10",
     *             width:"179",
     *             height:"180",
     *             style:"border:1px solid #ccc;"
     *         },
     *         label:{
     *             left:"10",
     *             top:"200",
     *             width:"180",
     *             height:"20"
     *         },
     *         description: {
     *             left:"10",
     *             top:"225",
     *             width:"180",
     *             height:"65",
     *             style:"color:#888;"
     *         },
     *         buttons: {
     *             left:"5",
     *             top:"5",
     *             width:"180",
     *             height:"20",
     *             style:"",
     *             items:[
     *                 {
     *                     label:"but1",
     *                     style:"",
     *                     addClass:"AXButton Green",
     *                     onclick:function(){
     *                         fnObj.otherFunction(this);
     *                     }
     *                 },
     *                 {
     *                     label:"but2",
     *                     style:"",
     *                     addClass:"AXButton",
     *                     onclick:function(){
     *                         fnObj.otherFunction(this);
     *                     }
     *                 }
     *             ]
     *         },
     *         format: function(){
     *             return {
     *                 imgsrc : this.item.img,
     *                 label : this.item.title,
     *                 description : this.item.writer+", "+this.item.no+" / " + (this.item.desc || "")
     *             }
     *         }
     *     }
     * });
     * myGrid.changeGridView({
     *     viewMode:"mobile"
     * });
     *
     * ```
     */
    changeGridView: function (JSObject) {
        var cfg = this.config;

        if (cfg.viewMode != JSObject.viewMode) {
            cfg.viewMode = JSObject.viewMode;
            if (JSObject.viewMode == "icon") {
                if (JSObject.view) cfg.view = JSObject.view;
                this.redrawGrid("changeGridView");
            }
            else if (JSObject.viewMode == "grid") {
                //if(JSObject.view) cfg.view = JSObject.view;
                this.redrawGrid("changeGridView");
            }
            else if (JSObject.viewMode == "mobile") {
                if (JSObject.view) cfg.view = JSObject.view;
                this.redrawGrid("changeGridView");

            }
        }
    },
    /**
     * @method AXGrid.openMobileConfig
     * @param {event} event
     * @description - 모바일 툴바가 클릭되었을 때 툴바 박스 호출 이벤트 함수
     */
    openMobileConfig: function (event) {
        var cfg = this.config, _this = this;
        //console.log(cfg.view.column);

        var mobileView = cfg.view;
        if (mobileView == undefined) {
            var columns = [];
            for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                var col = null, addClass = "";
                if (CG.widthAstric || CG.width.number() >= 200) {
                    col = 4;
                    addClass = "underLine";
                }
                else if (CG.width.number() >= 100) {
                    col = 2;
                }
                else if (CG.width.number() >= 40) {
                    //col = 1;
                }
                columns.push(
                    {
                        key: CG.key,
                        label: CG.label,
                        col: col,
                        formatter: CG.formatter,
                        addClass: addClass,
                        sort: (CG.sort || ""),
                        display: (CG.display || true)
                    }
                );
            }
            columns = columns.sort(function (pItem, nItem) {
                var v1 = pItem.col;
                var v2 = nItem.col;
                if (v1 < v2) return 1;
                else if (v1 > v2) return -1;
                else if (v1 == v2) return 0;
            });
            mobileView = {
                labelView: true,
                column: columns
            };
            cfg.view = mobileView;
        }

        for (var CN, cidx = 0, __arr = mobileView.column; (cidx < __arr.length && (CN = __arr[cidx])); cidx++) {
            if (CN.display == undefined || CN.display == true) {
                CN.display = true;
                CN.checked = true;
            }
        }

        var contextMenu = mobileView.column.concat();
        this.mobileContextMenu.setConfig({responsiveMobile: 900000});
        this.mobileContextMenu.bind({
            id: cfg.targetID + "myContextMenu",
            theme: "AXContextMenu", // 선택항목
            width: "150", // 선택항목
            checkbox: "checkbox", // [checkbox|radio]
            sortbox: true,
            menu: contextMenu,
            onchange: function () { // 체크박스 선택값이 변경 된 경우 호출 됩니다.
                for (var CN, cidx = 0, __arr = this.menu; (cidx < __arr.length && (CN = __arr[cidx])); cidx++) {
                    CN.display = CN.checked;
                }
                cfg.view.column = axf.copyObject(this.menu);
                _this.printList();
                this.contentScrollResize();
            },
            onsort: function () { // 정렬이 변경 된 경우 호출 됩니다.
                //console.log(this.sortMenu);
                _this.list = _this.sortList(this.sortMenu.sort, this.sortMenu, _this.list);
                _this.printList();
                this.contentScrollResize();

                return true;// 메뉴 창이 닫히지 않게 합니다.
            }
        });
        this.mobileContextMenu.open({id: cfg.targetID + "myContextMenu"}, event);
    },
    /**
     *
     * @method AXGrid.clipBoardClear
     * @returns {AXGrid}
     */
    clipBoardClear: function () {
        var body = this.body;
        axf.each(this.copiedRow, function () {
            body.find(".gridBodyTr_" + this).removeClass("copied");
        });
        this.copiedRow.clear();
        this.clipBoard.type = "";
        this.clipBoard.list = [];

        return this;
    },
    /**
     *
     * @method AXGrid.selectClear
     * @returns {AXGrid}
     */
    selectClear: function () {
        var body = this.body;

        if (this.selectedCells.length > 0) { // 셀선택 클리어
            axf.each(this.selectedCells, function () {
                body.find(".bodyTd_" + this).removeClass("selected");
            });
            this.selectedCells.clear();
        }
        if (this.selectedRow.length > 0) { // 로우선택 클리어
            axf.each(this.selectedRow, function () {
                body.find(".gridBodyTr_" + this).removeClass("selected");
            });
            this.selectedRow.clear();
        }
        if (this.copiedRow.length > 0) {
            axf.each(this.copiedRow, function () {
                body.find(".gridBodyTr_" + this).removeClass("copied");
            });
            this.copiedRow.clear();
        }
        this.clipBoard.type = "";
        this.clipBoard.list = [];

        return this;
    },

    /**
     * AXGrid의 checked 값을 jQuery.param 메서드에서 사용 가능한 배열로 반환합니다.
     * @method AXGrid.getCheckedParams
     * @param colSeq {Number} -대상 체크박스(formatter:"checkbox" 로 선언된 항목의 순서)
     * @param traditional {Boolean} [false] 반환 형태 지정
     * @return {Array} traditional[false]: [ { name: 'no', value: 1 }, { name: 'no', value: 2 } ], traditional[true]: [ { 'no': 1 }, { 'no': 2 } ]
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.getCheckedParams(0); // -> [ { name: 'no', value: 1 }, { name: 'no', value: 2 } ]
     * myGrid.getCheckedParams(0); // -> [ { 'no': 1 }, { 'no': 2 } ]
     * ```
     */
    getCheckedParams: function (colSeq, traditional) {
        var colName = this.config.colGroup[colSeq].key;
        var checkedList = this.getCheckedList(colSeq);
        var params = [];

        if (!colName) {
            console.log("colSeq invalid. Please check the colSeq value.");
            return params;
        }
        if (!checkedList || checkedList.length === 0) {
            return params;
        }

        $.each(checkedList, function (idx, item) {
            if (traditional) {
                var p = {};
                p[colName] = (item[colName] || '');
                params.push(p);
            }
            else {
                params.push({"name": colName, "value": (item[colName] || "")});
            }
        });

        return params;
    },

    /**
     * 그리드의 데이터를 조건에 따라 반환하며 clone 옵션을 사용해서 복사된 값을 받을 수 있다.
     * @method AXGrid.getList
     * @param filter {String|Function|Boolean} [undefined] - String: "C,U,D" 추가,수정,삭제. Function: true/false를 반환하는 함수를 사용한다. Boolean: filter 조건을 생략하고 바로 clone 옵션을 사용할 수 있다.
     * @param clone {Boolean} [false] true: referance 데이터를 반환 받는다. false: clone 데이터를 반환받는다.
     * @returns {Array}
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.getList(); // 전체 데이터(referance) 배열 반환
     * myGrid.getList(true); // 전체 데이터(clone) 배열 반환
     * myGrid.getList("C,U"); // 추가,수정된 데이터(referance) 배열 반환
     * myGrid.getList("C,U", true); // 추가,수정된 데이터(clone) 배열 반환
     * function fnFilter(idx, item) { return (idx % 2) === 0; }
     * myGrid.getList(fnFilter); // 함수에서 true를 반환한 데이터(referance) 배열 반환
     * myGrid.getList(fnFilter, true); // 함수에서 true를 반환한 데이터(clone) 배열 반환
     * ```
     */
    getList: function (filter, clone) {
        var filteredList = [];
        if (filter === false || Object.isUndefined(filter)) {
            filteredList = this.list;
            clone = false;
        }
        else if (filter === true) {
            filteredList = this.list;
            clone = true;
        }
        else if (Object.isString(filter)) {
            axf.each(this.list, function (idx, item) {
                if (filter.indexOf(item._CUD) > -1) {
                    filteredList.push(item);
                }
            });
            if (filter.indexOf("D") > -1) {
                axf.each(this.removedList, function (idx, item) {
                    filteredList.push(item);
                });
            }
        }
        else if (Object.isFunction(filter)) {
            var fnFilter = filter.bind(this);
            axf.each(this.list, function (idx, item) {
                if (fnFilter(idx, item)) {
                    filteredList.push(item);
                }
            });
        }

        if (clone) {
            var clonedList = [];
            axf.each(filteredList, function (idx, item) {
                clonedList.push(Object.clone(item));
            });
            return clonedList;
        }
        else {
            return filteredList;
        }
    },
    /**
     * 그리드 추가 , 수정시 validation 체크 메소드
     * @method AXGrid.validateCheck
     * @param filter {String} [undefined] - String: "C,U,D" 추가,수정,삭제
     * @returns boolean
     * @example
     * ```
     *
     * colGroup : [{
	    "key": "date",
	    "label": "date",
	    "width": 95,
	    "sort": false,
	    "align": "center",
	    "editor": {
	        "type": "calendar",
	        "config": {
	            "valueFormat": "yyyymmdd",
	            "separator": "-"
	        },
	        "updateWith": ["_CUD"],
	        "maxLength": 8
	    },
	}, {
	    "key": "string",
	    "label": "string",
	    "width": 95,
	    "sort": false,
	    "align": "center",
	    "editor": {
	    	"updateEdit": true,  // 필드 없데이트시  default true, false 수정안됨.
	        "createEdit": true,  // 필드 신규추가시  default true, false 추가시 입력안됨.
	        "notEmpty": true, // 필수 입력 여부 default false, true or string  빈 항목일 경우 보여줄 메시지 .
	        "type": "text",
	        "updateWith": ["_CUD"],
	        "maxLength": 40
	    }
	}, {
	    "key": "number",
	    "label": "number",
	    "width": 95,
	    "sort": false,
	    "align": "right",
	    "formatter": "money",
	    "editor": {
	        "type": "money",
	        "updateWith": ["_CUD"],
	        "maxLength": 12,
	        "range": { // 숫자일 경우 숫자자릿수와 소수점 자릿수 지정
	            "val": "9,3"
	            ,msg : '' // 자릿수를 초과 했을대 보여줄 메시지.
	        }
	    },
	}]
     * var myGrid = new AXGrid();
     * AXGrid.validateCheck('C'); // 추가시 validation check
     * AXGrid.validateCheck('U'); // 수정시 validation check
     * ```
     */
    validateCheck: function (filter) {
        var cfg = this.config;
        var _self = this;

        if (Object.isString(filter)) {
            if (!cfg.colGroup) return false;

            var __arr = cfg.colGroup, arrKeyEditor = {}, item, editorItem;

            for (var i in __arr) {
                item = __arr[i];
                editorItem = item.editor;

                if (Object.isObject(editorItem)) {
                    var validateflag = false;
                    if (!Object.isUndefined(editorItem.notEmpty)) {
                        validateflag = true;
                        item.editor.notEmpty = editorItem.notEmpty === true ? (item.label + ' 필수 입력항목입니다.') : ( Object.isString(editorItem.notEmpty) ? editorItem.notEmpty : false);
                    }

                    if (!Object.isUndefined(editorItem.range)) {
                        validateflag = true;
                        item.editor.range.msg = Object.isUndefined(item.editor.range.msg) ? (item.label + ' 입력 값을 초과 하였습니다.') : item.editor.range.msg;
                    }

                    if (validateflag) {
                        arrKeyEditor[i] = {};
                        arrKeyEditor[i].editor = item.editor;
                        arrKeyEditor[i].key = item.key;
                    }
                }
            }
            var reval = true, _colseq, _idx;
            axf.each(this.list, function (idx, item) {
                if (filter.indexOf(item._CUD) > -1) {
                    var itemval;

                    for (var colseq in arrKeyEditor) {
                        editorItem = arrKeyEditor[colseq].editor;

                        itemval = item[arrKeyEditor[colseq].key];

                        _colseq = colseq;
                        _idx = idx;

                        if (editorItem.notEmpty) {
                            if ($.trim(itemval) == '') {
                                if (editorItem.notEmpty) alert(editorItem.notEmpty);

                                reval = false;
                                return false;
                            }
                        }
                        itemval = itemval ? itemval + '' : (editorItem.type != 'money' ? '' : '0');

                        if (editorItem.type != 'money') continue;

                        if (editorItem.range) {
                            var rangeval = editorItem.range.val;
                            var rangeArr = rangeval.split(',');

                            var decimalNum = rangeArr[0]
                                , decimalPoint = rangeArr.length > 1 ? rangeArr[1] : 0
                                , numval = '', pointval = '';

                            decimalNum = isNaN(decimalNum) ? 0 : parseInt(decimalNum, 10);
                            decimalPoint = isNaN(decimalPoint) ? 0 : parseInt(decimalPoint, 10);

                            numval = itemval.replace(/[$,]+/g, '');

                            if (isNaN(numval)) {
                                alert('숫자만 입력가능합니다.');
                                reval = false;
                                return false;
                            }

                            if (itemval.indexOf('.') > -1) {
                                var valArr = itemval.split('.');
                                numval = valArr[0];
                                pointval = valArr[1];
                            }

                            if (numval.length > decimalNum || pointval.length > decimalPoint) {
                                if (editorItem.range.msg) {
                                    if (editorItem.range.msg)  alert(editorItem.range.msg + '\n' + itemval);

                                    reval = false;
                                    return false;
                                }
                            }
                        }
                    }
                }
            });

            if (reval === false) {
                _self.editCell(0, _colseq, _idx);
                _self.setFocus(_idx);
                _self.scrollTop(_idx);
            }
        }

        return reval;
    },
    onevent_grid: function () {

    },

    /**
     * @method AXGrid.clearSort
     * @description - 그리드의 소트관련 설정 데이터 및 소트표현 클래스를 삭제합니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.clearSort();
     * ```
     */
    clearSort: function () {
        var cfg = this.config
            , _this = this
            , rows = cfg.colHead.rows
            , sort = ''
            , removeTg = '';

        $.each(rows, function (idx, o) {
            if (sort == '') {
                $.each(o, function (idx_idx, o_o) {
                    if (o_o.sort != undefined) {
                        sort = o_o.sort;
                        delete o_o.sort;

                        return false;
                    }
                });
            }
        });

        if (sort != '') {
            if (sort == 'desc') {
                removeTg = 'sortDesc';
            }
            else if (sort == 'asc') {
                removeTg = 'sortAsc';
            }

            document.getElementById(this.nowSortHeadID).classList.remove(removeTg);
            this.nowSortHeadObj = undefined;
            this.nowSortHeadID = undefined;
        }
    },

    /**
     * @method AXGrid.reorderColgroup
     * @param {Array} rColgroupreorderColGroup
     *
     */
    reorderColGroup: function (rColgroup) {
        var
            cfg = this.config,
            oldColGroup = [].concat(cfg.colGroup),
            newColGroup = []
            ;

        if (rColgroup) {
            // colGroup
            rColgroup.forEach(function (c) {
                jQuery.each(oldColGroup, function (idx, oc) {
                    if (oc.key == c.key) {
                        delete oc.colSeq;
                        newColGroup.push(oc);
                        oldColGroup.splice(idx, 1);
                        return false;
                    }
                });
            });
            cfg.colGroup = newColGroup.concat(oldColGroup);

            // body
            (function(){
                var
                    oldBodyRows = []
                    ;

                for (var r = 0; r < cfg.body.rows.length; r++) {
                    oldBodyRows.push([].concat(cfg.body.rows[r]));
                }

                for (var r = 0; r < oldBodyRows.length; r++) {
                    oldBodyRows[r].forEach(function (c, cidx) {
                        var matchIdx = cidx;
                        jQuery.each(cfg.colGroup, function (idx, cg) {
                            if (cg.key == c.key) {
                                matchIdx = idx;
                                return false;
                            }
                        });
                        oldBodyRows[r][cidx].matchIdx = matchIdx;
                    });
                    oldBodyRows[r].sort(function (a, b) {
                        return a.matchIdx - b.matchIdx;
                    });
                    oldBodyRows[r].forEach(function(c){
                        delete c.matchIdx;
                        delete c.colSeq;
                    });
                }

                cfg.body.rows = [];
                for (var r = 0; r < oldBodyRows.length; r++) {
                    cfg.body.rows.push(oldBodyRows[r]);
                }
            }).call(this);

            // marker
            (function () {
                if (!cfg.body.marker) return;

                function convertMarker(marker){
                    if(!marker.rows) return;
                    var oldMarkerRows = [];
                    for (var r = 0; r < marker.rows.length; r++) {
                        oldMarkerRows.push([].concat(marker.rows[r]));
                    }

                    for (var r = 0; r < oldMarkerRows.length; r++) {
                        oldMarkerRows[r].forEach(function (c, cidx) {
                            var matchIdx = cidx;
                            jQuery.each(cfg.colGroup, function (idx, cg) {
                                if (cg.key == c.key) {
                                    matchIdx = idx;
                                    return false;
                                }
                            });
                            oldMarkerRows[r][cidx].matchIdx = matchIdx;
                        });
                        oldMarkerRows[r].sort(function (a, b) {
                            return a.matchIdx - b.matchIdx;
                        });
                        oldMarkerRows[r].forEach(function (c) {
                            delete c.matchIdx;
                            delete c.colSeq;
                        });
                    }

                    marker.rows = [];
                    for (var r = 0; r < oldMarkerRows.length; r++) {
                        marker.rows.push(oldMarkerRows[r]);
                    }
                }

                if (Object.isArray(cfg.body.marker)){
                    for (var m = 0, l = cfg.body.marker.length; m < l; m++) {
                        convertMarker(cfg.body.marker[m]);
                    }
                }else{
                    convertMarker(cfg.body.marker);
                }

            }).call(this);

            // foot
            (function(){
                if (!cfg.foot) return;

                var
                    oldFootRows = []
                    ;
                for (var r = 0; r < cfg.foot.rows.length; r++) {
                    oldFootRows.push([].concat(cfg.foot.rows[r]));
                }

                for (var r = 0; r < oldFootRows.length; r++) {
                    oldFootRows[r].forEach(function (c, cidx) {
                        var matchIdx = cidx;
                        jQuery.each(cfg.colGroup, function (idx, cg) {
                            if (cg.key == c.key) {
                                matchIdx = idx;
                                return false;
                            }
                        });
                        oldFootRows[r][cidx].matchIdx = matchIdx;
                    });
                    oldFootRows[r].sort(function (a, b) {
                        return a.matchIdx - b.matchIdx;
                    });
                    oldFootRows[r].forEach(function(c){
                        delete c.matchIdx;
                        delete c.colSeq;
                    });
                }


                cfg.foot.rows = [];
                for (var r = 0; r < oldFootRows.length; r++) {
                    cfg.foot.rows.push(oldFootRows[r]);
                }
            }).call(this);

            this.defineConfig(false, true);
            this.redrawGrid();
        }

        return this;

        /*
         console.log(cfg.colGroup);
         console.log(cfg.colHead);
         console.log(cfg.body);
         console.log(cfg.head);
         console.log(cfg.foot);
         console.log(cfg.editor);
         */
    }
});

/**
 * @method AXGrid.prototype.formatter
 * @description - 그리드의 formatter 입니다. 사용자 정의 formatter를 추가할 수 있습니다.
 * @example
 * ```js
 * Object.extend(AXGrid.prototype.formatter, {
 *     link: function(formatter, item, itemIndex, value, key, CH, CHidx){
 *         return '<a href="https://www.axisj.com">www.axisj.com</a>';
 *     }
 * });
 * ```
 */
AXGrid.prototype.formatter = (function () {
    // checkbox, radiobox formatter
    function boxFormatter(formatter, item, itemIndex, value, key, CH, CHidx) {
        var cfg = this.config;
        var checkedStr = "";
        var disabled = "";
        var sendObj = {
            index: itemIndex,
            list: this.list,
            item: item,
            page: this.page,
            key: key,
            value: value
        };

        if (this.list[itemIndex].___checked && this.list[itemIndex].___checked[CHidx]) {
            if (this.list[itemIndex].___checked[CHidx]) checkedStr = " checked=\"checked\" ";
            //if(itemIndex == 0) console.log(this.list[itemIndex].___checked[CHidx], checkedStr);
        }
        else if (Object.isFunction(CH.checked)) {
            if (CH.checked.call(sendObj)) {
                checkedStr = " checked=\"checked\" ";
                if (!this.list[itemIndex].___checked) this.list[itemIndex].___checked = {};
                this.list[itemIndex].___checked[CHidx] = true;
            }
        }

        if (CH.disabled) {
            if (CH.disabled.call(sendObj)) {
                disabled = " disabled=\"disabled\" ";
                if (!this.list[itemIndex].___checked) this.list[itemIndex].___disabled = {};
                this.list[itemIndex].___disabled[CHidx] = true;
            }
        }
        /*
         return "<label class=\"gridCheckboxLabel\">" +
         "<input type=\"" + formatter + "\" name=\"" + CH.label + "\" class=\"gridCheckBox_body_colSeq" + CH.colSeq + "\" id=\"" + cfg.targetID + "_AX_checkboxItem_AX_" + CH.colSeq + "_AX_" + itemIndex + "\" value=\"" + value + "\" " + checkedStr + disabled + " onfocus=\"this.blur();\" />" +
         "</label>";
         */
        return "<input type=\"" + formatter + "\" name=\"" + CH.label + "\" class=\"gridCheckBox_body_colSeq" + CH.colSeq + "\" id=\"" + cfg.targetID + "_AX_checkboxItem_AX_" + CH.colSeq + "_AX_" + itemIndex + "\" value=\"" + value + "\" " + checkedStr + disabled + " onfocus=\"this.blur();\" />";
    }

    return {
        "wordwrap": function (formatter, item, itemIndex, value, key, CH, CHidx) {
            if (!value) {
                return "";
            }

            return '<span class="AXWordwrap">' + value.dec().crlf().replace(/ /g, '&nbsp;') + '</span>';
        },
        "money": function (formatter, item, itemIndex, value, key, CH, CHidx) {
            if (value == "" || value == "null" || value == null || value == undefined) {
                return "0";
            }
            else {
                return (value || 0).number().money();
            }
            return result;
        },
        "dec": function (formatter, item, itemIndex, value, key, CH, CHidx) {
            return (value == undefined) ? "" : value.toString().dec();
        },
        "html": function (formatter, item, itemIndex, value, key, CH, CHidx) {
            return value;
        },
        "checkbox": boxFormatter,
        "radio": boxFormatter,
        "select": function (formatter, item, itemIndex, value, key, CH, CHidx) {
            var txtKey = CH.editor.optionText;
            var valKey = CH.editor.optionValue;
            var options = CH.editor.options || [];
            var text = "";

            if (!txtKey && AXConfig && AXConfig.AXSelect && AXConfig.AXSelect.keyOptionText) {
                txtKey = AXConfig.AXSelect.keyOptionText || "optionText";
            }
            if (!valKey && AXConfig && AXConfig.AXSelect && AXConfig.AXSelect.keyOptionValue) {
                valKey = AXConfig.AXSelect.keyOptionValue || "optionValue";
            }

            if (options.length === 0) {
                return text;
            }

            var isObjectVal = Object.isObject(value);
            var optionVal = isObjectVal ? value[valKey] : value;
            for (var i = 0; i < options.length; i++) {
                if (options[i][valKey] == optionVal) {
                    text = options[i][txtKey];
                    break;
                }
            }
            return text;
            //},
            //"AXSelect": function(formatter, item, itemIndex, value, key, CH, CHidx){
            //    // TODO ajax를 매번 호출 할수는 없다. 한번 호출해서 caching 해야 하는데... cache 다시 로드 하는 기능이나 시점도 필요하다. HJ.Park 2015-08-05
            //    return "";
        }
    };
})();

/**
 * @method AXGrid.prototype.inlineEditor
 * @description - 그리드의 inline editor 입니다. 사용자 정의 editor를 추가할 수 있습니다.
 * @example
 * ```js
 * Object.extend(AXGrid.prototype.inlineEditor, {
 *     switch: {
 *         init: function(inline_editor, AXBindConfig, CG, r, c, ii){
 *             inline_editor.find("input").bindSwitch(AXBindConfig);
 *         },
 *         getValue: function(value) {
 *             // this: {item:item, index:itemIndex, CG:CG, r:r, c:c}
 *             return value;
 *         }
 *     }
 * });
 * ```
 */
AXGrid.prototype.inlineEditor = (function () {
    var getOptionValueKey = function getOptionValueKey(AXBindConfig) {
        if (AXBindConfig && AXBindConfig.reserveKeys && AXBindConfig.reserveKeys.optionValue) {
            return AXBindConfig.reserveKeys.optionValue;
        }
        else if (AXConfig && AXConfig.AXSelect && AXConfig.AXSelect.keyOptionValue) {
            return AXConfig.AXSelect.keyOptionValue;
        }
        else {
            return "optionValue";
        }
    };

    var getOptionTextKey = function getOptionTextKey(AXBindConfig) {
        if (AXBindConfig && AXBindConfig.reserveKeys && AXBindConfig.reserveKeys.optionText) {
            return AXBindConfig.reserveKeys.optionText;
        }
        else if (AXConfig && AXConfig.AXSelect && AXConfig.AXSelect.keyOptionText) {
            return AXConfig.AXSelect.keyOptionText;
        }
        else {
            return "optionValue";
        }
    };

    // getValue -> this: {item:item, index:itemIndex, CG:CG, r:r, c:c}
    return {
        "number": {
            init: function (inline_editor, AXBindConfig, CG, r, c, ii) {
                inline_editor.find("input").bindNumber(AXBindConfig).select();
            },
            getValue: function (value) {
                return String(value || "").number();
            }
        },
        "money": {
            init: function (inline_editor, AXBindConfig, CG, r, c, ii) {
                inline_editor.find("input").bindMoney(AXBindConfig);
                setTimeout(function () {
                    inline_editor.find("input").select();
                }, 100);
            },
            getValue: function (value) {
                return String(value || "").money();
            }
        },
        "calendar": {
            init: function (inline_editor, AXBindConfig, CG, r, c, ii) {
                var _this = this;
                AXBindConfig.expand = true;
                jQuery.extend(AXBindConfig, CG.editor.config, true);

                AXBindConfig.onchange = function () {
                    _this.updateItem(r, c, ii, this.value);
                };

                inline_editor.find("input").bindDate(AXBindConfig);
            },
            getValue: function (value) {
                return value || "";
            }
        },
        "select": {
            init: function (inline_editor, AXBindConfig, CG, r, c, ii) {
                var _this = this;
                var cfg_key_value = getOptionValueKey(AXBindConfig);
                var cfg_key_text = getOptionTextKey(AXBindConfig);

                inline_editor.find("select").bind("change", function () {
                    var sdom = inline_editor.find("select").get(0);
                    var obj = {};
                    obj[cfg_key_value] = sdom.options[sdom.selectedIndex].value;
                    obj[cfg_key_text] = sdom.options[sdom.selectedIndex].text;
                    _this.updateItem(r, c, ii, obj);
                });
                setTimeout(function () {
                    inline_editor.find("select").focus();
                }, 100);

                jQuery(document.body).unbind("click.axgrid").bind("click.axgrid", function (e) {
                    var target = axf.get_event_target(e.target, {id: inline_editor.attr("id")});
                    if (!target) {
                        var sdom = inline_editor.find("select").get(0);
                        if (sdom.options[sdom.selectedIndex]) {
                            var obj = {};
                            obj[cfg_key_value] = sdom.options[sdom.selectedIndex].value;
                            obj[cfg_key_text] = sdom.options[sdom.selectedIndex].text;

                            _this.updateItem(r, c, ii, obj);
                        }
                        else {
                            _this.editCellClear();
                        }
                        _this.gridFocus.focus();
                        jQuery(document.body).unbind("click.axgrid");
                    }
                });
            },
            getValue: function (value) {
                if (typeof(value) === "string") return value;
                return value[getOptionValueKey(this.CG.editor.config)];
            }
        },
        "AXSelect": {
            init: function (inline_editor, AXBindConfig, CG, r, c, ii) {
                var _this = this;
                var cfg = this.config;
                var cfg_key_value = getOptionValueKey(AXBindConfig);
                var cfg_key_text = getOptionTextKey(AXBindConfig);

                // todo : inline_editor.config에 onchange함수 재 정의
                AXBindConfig.onchange = function () {
                    var obj = {};
                    obj[cfg_key_value] = this.value;
                    obj[cfg_key_text] = this.text;
                    setTimeout(function () {
                        _this.updateItem(r, c, ii, obj);
                    }, 100);
                };
                var td_val = _this.list[ii][CG.key];
                AXBindConfig.setValue = td_val[cfg_key_value];
                inline_editor.find("select").bindSelect(AXBindConfig);
                setTimeout(function () {
                    inline_editor.find("select").focus();
                }, 100);

                jQuery(document.body).unbind("click.axgrid").bind("click.axgrid", function (e) {
                    var select_id = (cfg.targetID + '_inline_editor').lcase();
                    var target = axf.get_event_target(e.target, function (el) {
                        if (!el.id) return false;
                        return ((el.id.split(/_AX_/g)[1] || "").lcase() == select_id);
                    });
                    if (!target) {
                        var sdom = inline_editor.find("select").get(0);
                        if (sdom.options[sdom.selectedIndex]) {
                            var obj = {};
                            obj[cfg_key_value] = sdom.options[sdom.selectedIndex].value;
                            obj[cfg_key_text] = sdom.options[sdom.selectedIndex].text;

                            _this.updateItem(r, c, ii, obj);
                        }
                        else {
                            _this.editCellClear();
                        }
                        _this.gridFocus.focus();
                        jQuery(document.body).unbind("click.axgrid");
                    }
                });
            },
            getValue: function (value) {
                return value;
            }
        },
        "AXSelector": {
            init: function (inline_editor, AXBindConfig, CG, r, c, ii) {
                var _this = this;
                var cfg = this.config;
                var cfg_key_value = getOptionValueKey(AXBindConfig);
                var cfg_key_text = getOptionTextKey(AXBindConfig);

                // todo : inline_editor.config에 onchange함수 재 정의
                AXBindConfig.onchange = function () {
                    var obj = {};
                    if (this.selectedOption) {
                        obj[cfg_key_value] = this.selectedOption[cfg_key_value];
                        obj[cfg_key_text] = this.selectedOption[cfg_key_text];
                    }
                    else {
                        obj[cfg_key_value] = "";
                        obj[cfg_key_text] = "";
                    }
                    setTimeout(function () {
                        _this.updateItem(r, c, ii, obj);
                    }, 100);
                };

                var td_val = _this.list[ii][CG.key];
                if (typeof td_val === "undefined") AXBindConfig.setValue = "";
                else if (typeof td_val === "string" || typeof td_val === "number" || typeof td_val === "boolean") {
                    AXBindConfig.setValue = td_val;
                }
                else {
                    AXBindConfig.setValue = td_val[cfg_key_value];
                }

                inline_editor.find("input").bindSelector(AXBindConfig);
                setTimeout(function () {
                    inline_editor.find("input").focus();
                }, 100);

            },
            getValue: function (value) {
                return value;
            }
        }
    };
})();

/* ---------------------------- */
/* http://www.axisj.com, license : http://www.axisj.com/license */
 
 
axdom.fn.loadHtmlElement = function(arg) {
	if(arg == undefined) arg = {}
	var varObj = new AXHtmlElement();
	arg.target = this.get(0).id;
	varObj.setConfig(arg);
    return this;
};

var AXHtmlElement = Class.create(AXJ, {

    version: "AXHtmlElement V1.0",
    author: "tom@axisj.com",
    logs: [
        "2013-04-17 - mods에서 변환했음 - json@axisj.com"
    ],
    initialize: function(AXJ_super) {
        AXJ_super();
        this.config.defaultValue = "";
        this.config.firstEmpty = false;
        this.config.firstChecked = true;
    },
    init: function() {
        var config = this.config;

        if (config.loadUrl) {
            var url = config.loadUrl;
            var qs = config.loadPars;
            var pars =  qs;
            var onLoad = this.onLoad.bind(this);
            new AXReq(url, { pars: pars, onsucc: function(res) {
                if (res.result == "00") {
                    onLoad(res);
                } else {
                    alert(res.msg.dec());
                }
            }
            });
        } else if (config.options) {
            this.onLoad({ ds: config.options });
        }
    },
    onLoad: function(res) {
        var config = this.config;
        if (config.displayType == "select") {
            // firstItemName 추가했음 by raniel, 2013-04-30 
            this.setSelectOption(
    			{ tg: axdom("#" + config.target)[0], ds: res.ds }, config.defaultValue, config.firstEmpty, config.firstEmptyItemName
    		);
            axdom("#" + config.target).unbind("change", this.onchange.bind(this));
            axdom("#" + config.target).bind("change", this.onchange.bind(this));
        }
        if (config.displayType == "radio") {
            this.setInputOption(
    			{ tg: axdom("#" + config.target), ds: res.ds }, config.defaultValue
    		);
        }
        if (config.displayType == "checkbox") {
            this.setInputOption(
    			{ tg: axdom("#" + config.target), ds: res.ds }, config.defaultValue
    		);
        }
    },
    setSelectOption: function (obj, selectValue, firstEmpty, firstEmptyItemName) {
        var config = this.config;

        /*
        for (var a = obj.tg.length - 1; a > -1; a--) {
        //obj.tg.options[a] = null;
        alert(a);
        }
        */
		try{
	        obj.tg.innerHTML = "";
		}catch(e){
			return;
		}


        if (firstEmpty) {
            var opts = document.createElement('option');
            opts.value = "";
            if (firstEmptyItemName) {
                opts.text = firstEmptyItemName;
            } else {
                opts.text = "모두";
            }
            obj.tg.appendChild(opts);
        }
        axdom.each(obj.ds, function(index, n) {
            if (n.optgroup) {

                var oGroup = document.createElement('optgroup');
                oGroup.label = n.optgroup.dec();

                axdom.each(n.option, function() {
                  if ( this.value != null ) {
                      var opts = document.createElement('option');
                      opts.value = this.value.dec();
                      opts.innerText = this.text.dec();
                      if (selectValue != undefined) if (selectValue == this.value.dec()) opts.selected = true;
                      oGroup.appendChild(opts);
                    }
                });

                obj.tg.appendChild(oGroup);

            } else {

                var opts = document.createElement('option');
                opts.value = n.value.dec();
                opts.innerText = n.text.dec();
                if (selectValue != undefined) if (selectValue == n.value.dec()) opts.selected = true;
                obj.tg.appendChild(opts);

            }
        });

        var robj = (obj.tg.selectedIndex > -1) ? { value: obj.tg.options[obj.tg.selectedIndex].value, text: obj.tg.options[obj.tg.selectedIndex].text} : { value: "", text: "" };
        this.loadSucc(robj);

    },
    setInputOption: function(obj, selectValue) {
        var config = this.config;
        obj.tg.empty(); //타켓 초기화

        var po = [];
        var robj = { value: "", text: "" };
        this.ids = obj.ds;
        axdom.each(obj.ds, function(index, n) {
            //alert(Object.toJSON(n));

            if (config.title) {
                po.push("<input type=\"" + config.displayType + "\" name=\"" + config.name + "\" value=\"" + n.value.dec() + "\" title=\"" + config.title.dec() + "\" class=\"" + config.className + "\" ");
            } else {
                po.push("<input type=\"" + config.displayType + "\" name=\"" + config.name + "\" value=\"" + n.value.dec() + "\" class=\"" + config.className + "\" ");
            }

            if (selectValue != "" && selectValue == n.value.dec()) {
                po.push(" checked=\"checked\" ");
                robj.value = n.value.dec();
                robj.text = n.text.dec();
            }
            else if (selectValue == "" && config.firstChecked == true && index == 0) {
                po.push(" checked=\"checked\" ");
                robj.value = n.value.dec();
                robj.text = n.text.dec();
            }
            po.push("/>");

            po.push(n.text.dec() + "&nbsp;");
        });
        obj.tg.html(po.join(''));

        this.loadSucc(robj);

        axdom("#" + config.target).find("input").unbind("click", this.onchange2.bind(this));
        axdom("#" + config.target).find("input").bind("click", this.onchange2.bind(this));
    },
    loadSucc: function(obj) {
        var config = this.config;
        if (config.onLoad) {
            config.onLoad({
                target: config.target,
                value: obj.value,
                text: obj.text
            });
        }
    },
    onchange: function(event) {
        var tg = event.target;
        var config = this.config;
        if (config.onChange) {
            config.onChange({
                target: config.target,
                value: tg.options[tg.selectedIndex].value,
                text: tg.options[tg.selectedIndex].text
            });
        }
    },
    onchange2: function(event) {
        var tg = event.target;
        var config = this.config;

        var myText = "";
        axdom.each(this.ids, function(idx, D) {
            if (D.value.dec() == tg.value) {
                myText = D.text.dec();
            }
        });

        if (config.onChange) {
            config.onChange({
                target: config.target,
                value: tg.value,
                text: myText
            });
        }
    }
});
/* ---------------------------- */
var AXInputConverter = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();
        this.objects = [];
        this.inputTypes = [
            {type: "search"}, {type: "number"}, {type: "money"}, {type: "slider"}, {type: "twinSlider"},
            {type: "selector"}, {type: "switch"}, {type: "segment"},
            {type: "date"}, {type: "dateTime"}, {type: "twinDate"}, {type: "twinDateTime"},
            {type: "checked"}, {type: "pattern"}
        ];
        this.config.anchorClassName = "AXanchor";
        this.config.anchorPlaceHolderClassName = "AXanchorPlaceHolder";
        this.config.anchorSearchClassName = "AXanchorSearch";
        this.config.anchorNumberContainerClassName = "AXanchorNumberContainer";
        this.config.anchorIncreaseClassName = "AXanchorIncrease";
        this.config.anchorDecreaseClassName = "AXanchorDecrease";
        this.config.anchorSelectorHandleContainerClassName = "AXanchorSelectorHandleContainer";
        this.config.anchorSelectorFinderContainerClassName = "AXanchorSelectorFinderContainer";
        this.config.anchorSelectorHandleClassName = "AXanchorSelectorHandle";
        this.config.anchorSelectorFinderClassName = "AXanchorSelectorFinder";
        this.config.anchorSelectorExpandBoxClassName = "AXanchorSelectorExpandBox";
        this.config.anchorSelectorExpandScrollClassName = "AXanchorSelectorExpandScroll"
        this.config.anchorSliderBoxClassName = "AXanchorSliderBox";
        this.config.anchorSwitchBoxClassName = "AXanchorSwitchBox";
        this.config.anchorSegmentBoxClassName = "AXanchorSegmentBox";
        this.config.anchorDateHandleClassName = "AXanchorDateHandle";
        this.config.bindDateExpandBoxClassName = "AXbindDateExpandBox";
        this.config.bindTwinDateExpandBoxClassName = "AXbindTwinDateExpandBox";
        this.config.anchorCheckedContainerClassName = "AXbindCheckedHandle";
        /* 모바일 반응 너비 */
        this.config.responsiveMobile = AXConfig.mobile.responsiveWidth;
        
        this.config.reserveKeys = {
            options: (AXConfig.AXSelect && AXConfig.AXSelect.keyOptions) || "options",
            optionValue: (AXConfig.AXSelect && AXConfig.AXSelect.keyOptionValue) || "optionValue",
            optionText: (AXConfig.AXSelect && AXConfig.AXSelect.keyOptionText) || "optionText",
            optionData: (AXConfig.AXSelect && AXConfig.AXSelect.keyOptionData) || "optionData"
        };
    },
    init: function () {
        axdom(window).resize(this.alignAllAnchor.bind(this));
        
        // 예약어 초기화
        this.config.reserveKeys = {
            options: (AXConfig.AXInput && AXConfig.AXInput.keyOptions) || "options",
            optionValue: (AXConfig.AXInput && AXConfig.AXInput.keyOptionValue) || "optionValue",
            optionText: (AXConfig.AXInput && AXConfig.AXInput.keyOptionText) || "optionText"
        };
    },
    windowResize: function () {
        // 사용안함
        var windowResizeApply = this.windowResizeApply.bind(this);
        if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
        this.windowResizeObserver = setTimeout(function () {
            windowResizeApply();
        }, 1);
    },
    windowResizeApply: function () {
        // 사용안함
        if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
        this.alignAllAnchor();
    },
    alignAllAnchor: function () {
        for (var i = 0; i < this.objects.length; i++) {
            this.alignAnchor(this.objects[i].id, i);
        }
    },
    msgAlert: function (msg) {
        var errorPrintType = "toast";
        if (AXConfig.AXInput) {
            errorPrintType = (AXConfig.AXInput.errorPrintType || "toast");
        }
        if (errorPrintType == "toast") toast.push(msg);
        else if (errorPrintType == "dialog") dialog.push(msg);
        else if (errorPrintType == "alert") AXUtil.alert(msg);
    },
    bindSetConfig: function (objID, configs) {
        var findIndex = null;
        axf.each(this.objects, function (index, O) {
            if (O.id == objID) {
                findIndex = index;
                return false;
            }
        });
        if (findIndex == null) {
            //trace("바인드 된 오브젝트를 찾을 수 없습니다.");
            return;
        }
        else {
            var _self = this.objects[findIndex];
            axf.each(configs, function (k, v) {
                _self.config[k] = v;
            });
        }
    },
    bind: function (obj) {
        var cfg = this.config;
        if (!AXgetId(obj.id)) {
            trace("bind 대상이 없어 bind 처리할 수 없습니다.");
            return;
        }
        
        if (obj.reserveKeys) cfg.reserveKeys = jQuery.extend(cfg.reserveKeys, obj.reserveKeys, true);
        var objID = obj.id;
        var objSeq = null;
        
        axf.each(this.objects, function (idx, O) {
            //if (this.id == objID && this.isDel == true) objSeq = idx;
            if (this.id == objID) {
                objSeq = idx;
                return false;
            }
        });
        
        if (obj.href == undefined) obj.href = cfg.href;
        
        if (objSeq == null) {
            objSeq = this.objects.length;
            this.objects.push({
                id: objID,
                anchorID: cfg.targetID + "_AX_" + objID,
                config: obj,
                bindType: obj.bindType
            });
        }
        else {
            this.objects[objSeq].isDel = undefined;
            this.objects[objSeq].config = obj;
        }
        
        //if (obj.bindType != "checked") {
        //	this.appendAnchor(objID, objSeq, obj.bindType);
        //}
        // bind checked anchor 연결
        this.appendAnchor(objID, objSeq, obj.bindType);
        
        if (obj.bindType == "placeHolder") {
            this.bindPlaceHolder(objID, objSeq);
        }
        else if (obj.bindType == "search") {
            this.bindSearch(objID, objSeq);
        }
        else if (obj.bindType == "number") {
            this.bindNumber(objID, objSeq);
        }
        else if (obj.bindType == "money") {
            this.bindMoney(objID, objSeq);
        }
        else if (obj.bindType == "selector") {
            this.bindSelector(objID, objSeq);
        }
        else if (obj.bindType == "slider") {
            this.bindSlider(objID, objSeq);
        }
        else if (obj.bindType == "twinSlider") {
            this.bindTwinSlider(objID, objSeq);
        }
        else if (obj.bindType == "switch") {
            this.bindSwitch(objID, objSeq);
        }
        else if (obj.bindType == "segment") {
            this.bindSegment(objID, objSeq);
        }
        else if (obj.bindType == "date") {
            this.bindDate(objID, objSeq);
        }
        else if (obj.bindType == "twinDate") {
            this.bindTwinDate(objID, objSeq);
        }
        else if (obj.bindType == "twinDateTime") {
            this.bindTwinDate(objID, objSeq, "time");
        }
        else if (obj.bindType == "checked") {
            this.bindChecked(objID, objSeq);
        }
        else if (obj.bindType == "pattern") {
            this.bindPattern(objID, objSeq);
        }
    },
    unbind: function (obj) {
        var cfg = this.config;
        var removeAnchorId;
        var removeIdx;
        axf.each(this.objects, function (idx, O) {
            if (O.id != obj.id) {
                // collect.push(this);
            }
            else {
                if (O.isDel != true) {
                    removeAnchorId = this.anchorID;
                    removeIdx = idx;
                }
            }
        });
        
        var objID = obj.id;
        var obj = this.objects[removeIdx];
        if (obj) {
            if (obj.documentclickEvent) axdom(document).unbind("click.AXInput", obj.documentclickEvent);
            var objDom = axdom("#" + objID);
            objDom.unbind("keydown.AXInput");
            objDom.unbind("keydown.AXInputCheck");
            objDom.unbind("change.AXInput");
            objDom.unbind("focus.AXInput");
            objDom.unbind("blur.AXInput");
        }
        
        if (removeAnchorId) {
            this.objects[removeIdx].isDel = true;
            axdom("#" + obj.id).removeAttr("data-axbind");
            axdom("#" + removeAnchorId).remove();
            
            if (obj.bindSliderMouseMove) axdom(document.body).unbind("mousemove.AXInput", obj.bindSliderMouseMove);
            if (obj.bindSliderMouseUp) axdom(document.body).unbind("mouseup.AXInput", obj.bindSliderMouseUp);
            if (obj.bindSliderTouchMove) document.removeEventListener("touchmove.AXInput", obj.bindSliderTouchMove, false);
            if (obj.bindSliderTouchEnd) document.removeEventListener("touchend.AXInput", obj.bindSliderTouchEnd, false);
            if (obj.bindTwinSliderMouseMove) axdom(document.body).unbind("mousemove.AXInput", obj.bindTwinSliderMouseMove);
            if (obj.bindTwinSliderMouseUp) axdom(document.body).unbind("mouseup.AXInput", obj.bindTwinSliderMouseUp);
            
            if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Handle").removeClass("on");
            }
        }
    },
    bindInputDisabled: function (objID, _disabled) {
        var findIndex = null;
        for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
            if (O.id == objID && O.isDel != true) {
                findIndex = index;
                break;
            }
        }
        ;
        
        if (findIndex == null) {
            //trace("바인드 된 오브젝트를 찾을 수 없습니다.");
            return;
        }
        else {
            var obj = this.objects[findIndex];
            var cfg = this.config;
            
            if (typeof _disabled == "boolean") {
                axf.getId(objID).disabled = _disabled;
            }
            else {
                axf.getId(objID).disabled = !AXgetId(objID).disabled;
            }
            
            obj.bindAnchorTarget.data("disabled", axf.getId(objID).disabled);
            if (axf.getId(objID).disabled) {
                obj.bindAnchorTarget.addClass("disable");
                obj.bindAnchorTarget.attr("disable", "disable");
                
                obj.bindAnchorTarget.find("a").bind("mousedown.AXInputDisabled", function (e) {
                    //alert("block");
                    var event = window.event || e;
                    if (event.preventDefault) event.preventDefault();
                    if (event.stopPropagation) event.stopPropagation();
                    event.cancelBubble = true;
                    return false;
                });
            }
            else {
                obj.bindAnchorTarget.removeClass("disable");
                obj.bindAnchorTarget.removeAttr("disable");
                
                obj.bindAnchorTarget.find("a").unbind("mousedown.AXInputDisabled");
            }
        }
    },
    appendAnchor: function (objID, objSeq, bindType) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        //trace("appendAnchor");
        axdom("#" + cfg.targetID + "_AX_" + objID).remove();
        var anchorNode = axdom("<div id=\"" + cfg.targetID + "_AX_" + objID + "\" class=\"" + cfg.anchorClassName + "\" style=\"display:none;\"></div>");
        var iobj = axdom("#" + objID);
        iobj.attr("data-axbind", bindType);
        iobj.after(anchorNode);
        
        obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
        obj.bindTarget = iobj;
        
        //var offSetParent = iobj.offsetParent();
        var iobjPosition = iobj.position();
        var l = iobjPosition.left, t = iobjPosition.top, w = 0, h = 0;
        
        var borderW = iobj.css("border-left-width").number();
        var borderH = iobj.css("border-top-width").number();
        var marginW = iobj.css("margin-left").number();
        var marginH = iobj.css("margin-top").number();
        l = l + marginW;
        /*t = t;*/
        w = iobj.outerWidth();
        h = iobj.outerHeight();
        
        var css = {left: l, top: t, width: w, height: 0};
        //trace(css);
        obj.bindAnchorTarget.css(css);
        obj.bindAnchorTarget.data("height", h);
        
        var _this = this;
        setTimeout(function () {
            _this.alignAnchor(objID, objSeq);
        });
        setTimeout(function () {
            _this.alignAnchor(objID, objSeq);
        }, 500);
    },
    alignAnchor: function (objID, objSeq) {
        var cfg = this.config;
        
        if (typeof objSeq == "undefined") {
            for (var i = 0; i < this.objects.length; i++) {
                if (this.objects[i].id == objID && !this.objects[i].isDel) {
                    objSeq = i;
                    break;
                }
            }
        }
        
        var obj = this.objects[objSeq];
        
        if (!AXgetId(objID)) return;
        /* 엘리먼트 존재 여부 확인 */
        
        if (!obj.bindTarget) {
            obj.bindTarget = axdom("#" + objID);
            obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
        }
        
        var iobjPosition = obj.bindTarget.position();
        var l = iobjPosition.left, t = iobjPosition.top;
        var w = obj.bindTarget.outerWidth();
        var h = obj.bindTarget.outerHeight();
        if (obj.bindTarget.css("display") == "none") {
            h = obj.bindAnchorTarget.data("height");
            var css = {width: w};
        }
        else {
            var css = {left: l, top: t, width: w, height: 0};
        }
        //trace(css);
        if (!obj.bindAnchorTarget) {
            obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
            obj.bindTarget = axdom("#" + objID);
        }
        if (obj.bindAnchorTarget) {
            obj.bindAnchorTarget.css(css);
            obj.bindAnchorTarget.data("height", h);
        }
        
        if (obj.bindType == "placeHolder") {
            
        }
        else if (obj.bindType == "search") {
            
        }
        else if (obj.bindType == "number") {
            var UPh = parseInt((h - 2) / 2) - 1;
            var DNh = parseInt((h - 2) / 2) - 2;
            var handleWidth = h - 2;
            if (handleWidth > 20) handleWidth = 20;
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_HandleContainer").css({width: handleWidth, height: h - 2});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_increase").css({width: handleWidth, height: UPh});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_decrease").css({
                top: (UPh + 1),
                width: handleWidth,
                height: DNh
            });
            //trace({top:(UPh+1), width:h, height:DNh});
        }
        else if (obj.bindType == "money") {
            
        }
        else if (obj.bindType == "selector") {
            h -= 2;
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_HandleContainer").css({width: h, height: h});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Handle").css({width: h, height: h});
            
            if (obj.config.finder) {
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_FinderContainer").css({right: h, width: h, height: h});
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Finder").css({width: h, height: h});
            }
        }
        else if (obj.bindType == "slider") {
            
        }
        else if (obj.bindType == "twinSlider") {
            
        }
        else if (obj.bindType == "switch") {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SwitchBox").css({width: w, height: h});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SwitchDisplay").css({height: h, "line-height": h + "px"});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SwitchHandle").css({height: h});
            obj.bindAnchorTarget.css({height: h});
        }
        else if (obj.bindType == "segment") {
            obj.bindAnchorTarget.css({
                height: h + "px",
                "position": "relative",
                display: "inline-block",
                left: "auto",
                top: "auto"
            });
            var borderTop = obj.bindAnchorTarget.find(".AXanchorSegmentHandle").css("border-top-width").number();
            var borderBot = obj.bindAnchorTarget.find(".AXanchorSegmentHandle").css("border-bottom-width").number();
            obj.bindAnchorTarget.find(".AXanchorSegmentHandle").css({
                height: (obj.bindAnchorTarget.innerHeight() - borderTop - borderBot) + "px",
                "line-height": (obj.bindAnchorTarget.innerHeight() - borderTop - borderBot) + "px"
            });
        }
        else if (obj.bindType == "date") {
            var handleWidth = h - 2;
            if (handleWidth > 20) handleWidth = 20;
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle").css({width: h, height: h});
        }
        else if (obj.bindType == "twinDate") {
            
        }
        else if (obj.bindType == "twinDateTime") {
            
        }
        else if (obj.bindType == "checked") {
            
        }
    },
    bindSetValue: function (objID, value) {
        var cfg = this.config;
        var objSeq = null;
        axf.each(this.objects, function (index, O) {
            if (O.id == objID) {
                objSeq = index;
                return false;
            }
        });
        if (objSeq == null) {
            //trace("바인드 된 오브젝트를 찾을 수 없습니다.");
            return;
        }
        else {
            var obj = this.objects[objSeq];
            
            if (obj.bindType == "search") {
                //	this.bindSearch(objID, objSeq);
            }
            else if (obj.bindType == "number") {
                //	this.bindNumber(objID, objSeq);
            }
            else if (obj.bindType == "money") {
                //	this.bindMoney(objID, objSeq);
            }
            else if (obj.bindType == "selector") {
                this.bindSelectorSetValue(objID, objSeq, value);
            }
            else if (obj.bindType == "slider") {
                this.bindSliderSetValue(objID, objSeq, value);
            }
            else if (obj.bindType == "twinSlider") {
                this.bindTwinSliderSetValue(objID, objSeq, value);
            }
            else if (obj.bindType == "switch") {
                this.bindSwitchSetValue(objID, objSeq, value);
            }
            else if (obj.bindType == "segment") {
                this.bindSegmentSetValue(objID, objSeq, value);
            }
            else if (obj.bindType == "date") {
                //	this.bindDate(objID, objSeq);
            }
            else if (obj.bindType == "twinDate") {
                //	this.bindTwinDate(objID, objSeq);
            }
        }
    },
    
    // onlyHolder ~~~~~~~~~~~~~~~
    bindPlaceHolder: function (objID, objSeq) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        // 브라우저 체크
        if (AXUtil.browser.name != "ie") return;
        if (AXUtil.browser.name == "ie" && AXUtil.browser.version > 9) return;
        
        var w = axdom("#" + cfg.targetID + "_AX_" + objID).width();
        var h = axdom("#" + cfg.targetID + "_AX_" + objID).data("height");
        
        var placeholder = axdom("#" + objID).attr("placeholder");
        if (placeholder == "undefined") placeholder = "";
        
        var po = ["<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_PlaceHolder\" class=\"" + cfg.anchorPlaceHolderClassName + "\" style=\"left:0px;top:0px;width:" + w + "px;height:" + h + "px;line-height:" + h + "px;\">" + placeholder + "</a>"];
        //append to anchor
        axdom("#" + cfg.targetID + "_AX_" + objID).append(po.join(''));
        //bind handle
        var bindPlaceHolderKeyup = this.bindPlaceHolderSyncAnchor.bind(this);
        axdom("#" + objID).unbind("keyup.AXInput").bind("keyup.AXInput", function () {
            bindPlaceHolderKeyup(objID, objSeq);
        });
        bindPlaceHolderKeyup(objID, objSeq);
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_PlaceHolder").unbind("click.AXInput").bind("click.AXInput", function () {
            //axdom("#"+objID).val("");
            axdom("#" + objID).focus();
            bindPlaceHolderKeyup(objID, objSeq);
        });
        //------------------------------------
    },
    bindPlaceHolderSyncAnchor: function (objID, objSeq) {
        var cfg = this.config;
        if (axdom("#" + objID).val().trim() == "") {
            //if(AXgetId(cfg.targetID+"_AX_"+objID).style.display == "none") 
            axdom("#" + cfg.targetID + "_AX_" + objID).show();
        }
        else {
            //if(AXgetId(cfg.targetID+"_AX_"+objID).style.display != "none") 
            axdom("#" + cfg.targetID + "_AX_" + objID).hide();
        }
    },
    // onlyHolder ~~~~~~~~~~~~~~
    
    // search
    bindSearch: function (objID, objSeq) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        var w = axdom("#" + cfg.targetID + "_AX_" + objID).width();
        var h = axdom("#" + cfg.targetID + "_AX_" + objID).data("height");
        var placeholder = axdom("#" + objID).attr("placeholder");
        if (placeholder == undefined) placeholder = "";
        var po = [];
        
        if (AXUtil.browser.name == "ie" && AXUtil.browser.version < 10 && placeholder != "") {
            po.push("<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_PlaceHolder\" class=\"" + cfg.anchorPlaceHolderClassName + "\" ");
            po.push(" style=\"left:0px;top:0px;width:" + w + "px;height:" + h + "px;line-height:" + h + "px;\">" + placeholder + "</a>");
        }
        po.push("<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_Search\" class=\"" + cfg.anchorSearchClassName + "\" ");
        po.push(" style=\"right:0px;top:0px;width:" + h + "px;height:" + h + "px;\">Search</a>");
        //append to anchor
        axdom("#" + cfg.targetID + "_AX_" + objID).append(po.join(''));
        //bind handle
        var bindSearchKeyup = this.bindSearchSyncAnchor.bind(this);
        axdom("#" + objID).unbind("keydown.AXInput").bind("keydown.AXInput", function () {
            bindSearchKeyup(objID, objSeq);
        });
        bindSearchKeyup(objID, objSeq);
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Search").unbind("click.AXInput").bind("click.AXInput", function () {
            axdom("#" + objID).val("");
            axdom("#" + objID).focus();
            bindSearchKeyup(objID, objSeq);
        });
        //------------------------------------
    },
    bindSearchSyncAnchor: function (objID, objSeq) {
        var cfg = this.config;
        axdom("#" + cfg.targetID + "_AX_" + objID).show();
        
        if (axdom("#" + objID).val() == "") {
            //if(AXgetId(cfg.targetID+"_AX_"+objID).style.display != "none") axdom("#"+cfg.targetID+"_AX_"+objID).hide();
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Search").hide();
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_PlaceHolder").show();
        }
        else {
            //if(AXgetId(cfg.targetID+"_AX_"+objID).style.display == "none") axdom("#"+cfg.targetID+"_AX_"+objID).fadeIn();
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Search").show();
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_PlaceHolder").hide();
        }
    },
    
    // number
    bindNumber: function (objID, objSeq) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        if (!obj.bindAnchorTarget) obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        
        var h = obj.bindAnchorTarget.data("height");
        //trace(objID+"//"+h);
        var po = [];
        var UPh = parseInt((h - 2) / 2) - 1;
        var DNh = parseInt((h - 2) / 2) - 2;
        //trace(UPh+"//"+DNh);
        var handleWidth = h - 2;
        if (handleWidth > 20) handleWidth = 20;
        
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_HandleContainer\" class=\"" + cfg.anchorNumberContainerClassName + "\" style=\"right:0px;top:0px;width:" + handleWidth + "px;height:" + (h - 2) + "px;\" onselectstart=\"return false;\">");
        po.push("	<a id=\"" + cfg.targetID + "_AX_" + objID + "_AX_increase\" class=\"" + cfg.anchorIncreaseClassName + "\" style=\"right:0px;top:0px;width:" + handleWidth + "px;height:" + UPh + "px;\">increase</a>");
        po.push("	<a id=\"" + cfg.targetID + "_AX_" + objID + "_AX_decrease\" class=\"" + cfg.anchorDecreaseClassName + "\" style=\"right:0px;top:" + (UPh + 1) + "px;width:" + handleWidth + "px;height:" + DNh + "px;\">decrease</a>");
        po.push("</div>");
        obj.bindAnchorTarget.append(po.join(''));
        obj.bindAnchorTarget.show();
        //alert("show");
        
        var bindNumberAdd = this.bindNumberAdd.bind(this);
        var bindNumberCheck = this.bindNumberCheck.bind(this);
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_increase").unbind("mousedown.AXInput").bind("mousedown.AXInput", function (event) {
            bindNumberAdd(objID, 1, objSeq);
            bindNumberCheck(objID, objSeq, event);
        });
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_decrease").unbind("mousedown.AXInput").bind("mousedown.AXInput", function (event) {
            bindNumberAdd(objID, -1, objSeq);
            bindNumberCheck(objID, objSeq, event);
        });
        /*
         obj.bindTarget.unbind("blur.AXInput").bind("blur.AXInput", function (event) {
         bindNumberCheck(objID, objSeq, event);
         });
         */
        obj.bindTarget.unbind("keydown.AXInput").bind("keydown.AXInput", function (event) {
            if (event.keyCode == AXUtil.Event.KEY_UP) bindNumberAdd(objID, 1, objSeq);
            else if (event.keyCode == AXUtil.Event.KEY_DOWN) bindNumberAdd(objID, -1, objSeq);
            //else bindNumberCheck(objID, objSeq, event);
        });
        obj.bindTarget.unbind("blur.AXInput").bind("blur.AXInput", function (event) {
            bindNumberCheck(objID, objSeq, event);
        });
    },
    bindNumberAdd: function (objID, adder, objSeq) {
        var obj = this.objects[objSeq];
        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }
        var maxval = obj.config.max;
        var minval = obj.config.min;
        var nval = obj.bindTarget.val().number();
        if (adder > 0) {
            //max 를 초과 하는지 확인
            if ((nval + adder) < minval) nval = minval;
            if (maxval != undefined && maxval != null) {
                if ((nval + adder) > maxval) return;
            }
        }
        else {
            //min 를 초과 하는지 확인
            if (minval != undefined && minval != null) {
                if ((nval + adder) < minval) return;
            }
        }
        obj.bindTarget.val(nval + adder);
        obj.bindTarget.change();
    },
    bindNumberCheck: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }
        if (this.numbercheck_obs) clearTimeout(this.numbercheck_obs);
        this.numbercheck_obs = setTimeout(function () {
            var maxval = obj.config.max;
            var minval = obj.config.min;
            var nval;
            if (obj.bindTarget.val() == "") {
                if (minval != undefined && minval != null) {
                    nval = minval;
                }
                else {
                    nval = obj.bindTarget.val().number();
                }
            }
            else {
                nval = obj.bindTarget.val().number();
            }
            
            if (maxval != undefined && maxval != null) {
                if ((nval) > maxval) {
                    obj.bindTarget.val("");
                    try {
                        this.msgAlert("설정된 최대값을 넘어서는 입력입니다.");
                    } catch (e) {
                    }
                }
                else {
                    if (minval != undefined && minval != null) {
                        if ((nval) < minval) {
                            obj.bindTarget.val("");
                            try {
                                this.msgAlert("설정된 최소값보다 작은 입력입니다.");
                            } catch (e) {
                            }
                        }
                        else {
                            obj.bindTarget.val(nval);
                        }
                    }
                }
            }
            else {
                if (minval != undefined && minval != null) {
                    if ((nval) < minval) {
                        obj.bindTarget.val("");
                        try {
                            this.msgAlert("설정된 최소값보다 작은 입력입니다.");
                        } catch (e) {
                        }
                    }
                }
                else {
                    obj.bindTarget.val(nval);
                }
            }
            obj.bindTarget.trigger("change");
            
            if (event && event.type == "mousedown") {
                obj.bindTarget.setCaret();
            }
            
            if (obj.config.onChange) {
                obj.config.onChange.call({objID: objID, objSeq: objSeq, value: axdom("#" + objID).val()});
            }
            if (obj.config.onchange) {
                obj.config.onchange.call({objID: objID, objSeq: objSeq, value: axdom("#" + objID).val()});
            }
        }, 1);
        
    },
    
    // money
    bindMoney: function (objID, objSeq) {
        var obj = this.objects[objSeq];
        obj.bindTarget.css({"text-align": "right"});
        var bindMoneyCheck = this.bindMoneyCheck.bind(this);
        var val = obj.bindTarget.val().trim();
        if (val != "") val = obj.bindTarget.val().number().money();
        obj.bindTarget.val(val);
        
        obj.bindTarget.unbind("keydown.AXInput").bind("keydown.AXInput", function (event) {
            if ((event.ctrlKey || event.metaKey)) {
                obj.bindTarget.data("ctrlKey", "T");
            }
            else {
                obj.bindTarget.data("ctrlKey", "F");
            }
        });
        obj.bindTarget.unbind("keyup.AXInput").bind("keyup.AXInput", function (event) {
            var elem = obj.bindTarget.get(0);
            
            if (elem.type != "number") {
                event = window.event || event;
                
                // ignore tab & shift key 스킵 & ctrl
                if (
                    (!event.keyCode || event.keyCode == 9 || event.keyCode == 16 || event.keyCode == 17) ||
                    ((obj.bindTarget.data("ctrlKey") == "T") && (event.keyCode == 65 || event.keyCode == 91))
                )
                {
                    jQuery.removeData(obj.bindTarget.get(0), "focusPosition");
                }
                else {
                    var elemFocusPosition;
                    if ('selectionStart' in elem) {
                        // Standard-compliant browsers
                        elemFocusPosition = elem.selectionStart;
                    }
                    else if (document.selection) {
                        // IE
                        //elem.focus();
                        var sel = document.selection.createRange();
                        var selLen = document.selection.createRange().text.length;
                        sel.moveStart('character', -elem.value.length);
                        elemFocusPosition = sel.text.length - selLen;
                    }
                    //trace(elemFocusPosition);
                    // 계산된 포커스 위치 앞에 쉼표 갯수를 구합니다.
                    
                    obj.bindTarget.data("focusPosition", elemFocusPosition);
                    obj.bindTarget.data("prevLen", elem.value.length);
                    
                    if (event.keyCode != AXUtil.Event.KEY_DELETE && event.keyCode != AXUtil.Event.KEY_BACKSPACE && event.keyCode != AXUtil.Event.KEY_LEFT && event.keyCode != AXUtil.Event.KEY_RIGHT) {
                        bindMoneyCheck(objID, objSeq, "keyup");
                    }
                    else if (event.keyCode == AXUtil.Event.KEY_DELETE || event.keyCode == AXUtil.Event.KEY_BACKSPACE) {
                        bindMoneyCheck(objID, objSeq, "keyup");
                    }
                }
            }
        });
        
        /* blur 이벤트 처리 이상 작동으로 제거 - 15-01-16
         obj.bindTarget.unbind("change.AXInput").bind("change.AXInput", function (event) {
         if(obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable"){
         return false;
         }
         if(event.target.type != "number") {
         bindMoneyCheck(objID, objSeq, "change");
         }
         });
         */
    },
    bindMoneyCheck: function (objID, objSeq, eventType) {
        var obj = this.objects[objSeq];
        var maxval = obj.config.max;
        var minval = obj.config.min;
        var nval;
        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }
        if (!obj.config.onChange) obj.config.onChange = obj.config.onchange;
        
        if (obj.bindTarget.val() == "") {
            if (minval != undefined && minval != null) {
                nval = minval;
            }
            else {
                nval = "";
            }
        }
        else {
            if (obj.bindTarget.val() != "-") {
                nval = obj.bindTarget.val().number();
            }
            else {
                nval = "";
            }
        }
        if (maxval != undefined && maxval != null) {
            if ((nval) > maxval) {
                obj.bindTarget.val(maxval.money());
                try {
                    if (eventType == "change") this.msgAlert("설정된 최대값{" + maxval.number().money() + "} 을 넘어서는 입력입니다.");
                } catch (e) {
                }
            }
            else {
                if (minval != undefined && minval != null) {
                    if ((nval) < minval) {
                        obj.bindTarget.val(minval.money());
                        try {
                            if (eventType == "change") this.msgAlert("설정된 최소값{" + minval.number().money() + "}보다 작은 입력입니다.");
                        } catch (e) {
                        }
                    }
                    else {
                        obj.bindTarget.val(nval.money());
                    }
                }
                else {
                    obj.bindTarget.val(nval.money());
                }
            }
        }
        else {
            if (minval != undefined && minval != null) {
                if ((nval) < minval) {
                    obj.bindTarget.val(minval.money());
                    try {
                        if (eventType == "change") this.msgAlert("설정된 최소값{" + minval.number().money() + "}보다 작은 입력입니다.");
                    } catch (e) {
                    }
                }
                else {
                    if (nval != "" && nval != "-") obj.bindTarget.val(nval.money());
                }
            }
            else {
                if (nval != "" && nval != "-") obj.bindTarget.val(nval.money());
            }
        }
        obj.bindTarget.trigger("change");
        
        if (!axf.isEmpty(obj.bindTarget.data("focusPosition"))) {
            obj.bindTarget.setCaret(obj.bindTarget.data("focusPosition").number() + ( obj.bindTarget.val().length - obj.bindTarget.data("prevLen") ));
        }
        
        if (obj.config.onChange) {
            obj.config.onChange.call({objID: objID, objSeq: objSeq, value: obj.bindTarget.val().number()});
        }
        
        if (eventType == "change") {
            if (obj.bindTarget.val() == "-") obj.bindTarget.val('');
        }
    },
    
    // selector
    bindSelector: function (objID, objSeq) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        if (!obj.config.onChange) obj.config.onChange = obj.config.onchange;
        
        if (!obj.bindAnchorTarget) obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        
        obj.bindTarget.data("val", obj.bindTarget.val());
        
        var reserveKeys = jQuery.extend({}, cfg.reserveKeys);
        if (typeof obj.config.reserveKeys == "undefined") obj.config.reserveKeys = {};
        obj.config.reserveKeys = jQuery.extend(reserveKeys, obj.config.reserveKeys, true);
        
        var h = obj.bindAnchorTarget.data("height") - 2;
        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_HandleContainer\" class=\"bindSelectorNodes " + cfg.anchorSelectorHandleContainerClassName + "\" style=\"right:0px;top:0px;width:" + h + "px;height:" + h + "px;\">");
        po.push("	<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_Handle\" class=\"bindSelectorNodes " + cfg.anchorSelectorHandleClassName + "\" style=\"right:0px;top:0px;width:" + h + "px;height:" + h + "px;\">expand</a>");
        po.push("</div>");
        if (obj.config.finder) {
            po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_FinderContainer\" class=\"bindSelectorNodes " + cfg.anchorSelectorFinderContainerClassName + "\" style=\"right:" + h + "px;top:0px;width:" + h + "px;height:" + h + "px;\">");
            po.push("	<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_Finder\" class=\"bindSelectorNodes " + cfg.anchorSelectorFinderClassName + "\" style=\"right:0px;top:0px;width:" + h + "px;height:" + h + "px;\">finder</a>");
            po.push("</div>");
        }
        
        obj.bindAnchorTarget.append(po.join(''));
        obj.bindAnchorTarget.show();
        
        var bindSelectorExpand = this.bindSelectorExpand.bind(this);
        var bindSelectorClose = this.bindSelectorClose.bind(this);
        
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Handle").unbind("click.AXInput").bind("click.AXInput", function (event) {
            if (!AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
                axdom("#" + objID).focus();
            }
            else {
                //bindSelectorExpand(objID, objSeq, true, event);
                bindSelectorClose(objID, objSeq, event);
            }
        });
        obj.bindTarget.unbind("focus.AXInput").bind("focus.AXInput", function (event) {
            if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
                return false;
            }
            try {
                this.select();
            } catch (e) {
            }
            if (!AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
                bindSelectorExpand(objID, objSeq, false, event);
            }
        });

        obj.bindTarget.unbind("keydown.AXInputCheck").bind("keydown.AXInputCheck", function (event) {
            if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
                return false;
            }
            if (!AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
                bindSelectorExpand(objID, objSeq, false, event);
            }
        });

        
        if (obj.config.finder) {
            if (obj.config.finder.onclick) {
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Finder").unbind("click.AXInput").bind("click.AXInput", function (event) {
                    if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
                        return false;
                    }
                    obj.config.finder.onclick.call({
                        targetID: objID,
                        value: axdom("#" + objID).val()
                    }, objID);
                    bindSelectorClose(objID, objSeq, event);
                });
            }
        }
        
        /*
         var bindSelectorInputChange = this.bindSelectorInputChange.bind(this);
         obj.inputChange = function(event){
         bindSelectorInputChange(objID, objSeq, event);
         }
         axdom("#"+objID).bind("change.AXInput", obj.inputChange);
         */
    },
    bindSelectorExpand: function (objID, objSeq, isToggle, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        var reserveKeys = obj.config.reserveKeys;
        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }
        obj.bindTarget.data("val", obj.bindTarget.val().enc());
        
        //alert(obj.bindTarget.data("val").end());
        
        if (this.opendExpandBox) {
            this.bindSelectorClose(this.opendExpandBox.objID, this.opendExpandBox.objSeq, event); // 셀럭터 외의 영역이 므로 닫기
        }
        
        var jqueryTargetObjID = axdom("#" + cfg.targetID + "_AX_" + objID);
        //trace({objID:objID, objSeq:objSeq});
        
        if (axdom("#" + cfg.targetID + "_AX_" + objID).data("blurEvent")) {
            //blur event 발생 상태 메소드 작동 중지
            return;
        }
        
        //Selector Option box Expand
        if (isToggle) { // 활성화 여부가 토글 이면
            if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Handle").removeClass("on");
                //비활성 처리후 메소드 종료
                return;
            }
        }
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 활성화 전에 개체 삭제 처리
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Handle").removeClass("on");
        //Expand Box 생성 구문 작성
        var anchorWidth = jqueryTargetObjID.width() - 2; // anchor width
        var anchorHeight = jqueryTargetObjID.data("height") - 1;
        var styles = [];
        styles.push("top:" + anchorHeight + "px");
        styles.push("width:" + (obj.config.anchorWidth || anchorWidth) + "px");
        styles.push("z-index:5100");
        
        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandBox\" class=\"bindSelectorNodes " + cfg.anchorSelectorExpandBoxClassName + "\" style=\"" + styles.join(";") + "\">");
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandScroll\" class=\"bindSelectorNodes " + cfg.anchorSelectorExpandScrollClassName + "\">");
        po.push("	<div class=\"AXLoadingSmall bindSelectorNodes\"></div>");
        po.push("</div>");
        po.push("</div>");
        axdom(document.body).append(po.join(''));
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Handle").addClass("on");
        
        var expandBox = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox");
        if (obj.config.positionFixed) {
            expandBox.css({"position": "fixed"});
        }
        var expBoxHeight = expandBox.outerHeight();
        var offset = (obj.config.positionFixed) ? jqueryTargetObjID.position() : jqueryTargetObjID.offset();
        if (obj.config.position) {
            offset = jqueryTargetObjID.offset();
            if (obj.config.position.top != undefined) {
                offset.top = obj.config.position.top;
            }
        }
        var css = {};
        css.top = offset.top + anchorHeight;
        if (obj.config.direction == "bottom") {
            css.top -= expandBox.outerHeight();
        }
        
        css.left = offset.left;
        expandBox.css(css);
        
        this.opendExpandBox = {objID: objID, objSeq: objSeq};
        
        //_AX_expandBox set options
        //trace(obj.config.ajaxUrl);
        if (obj.config.onsearch) {
            this.bindSelectorKeyupChargingUp(objID, objSeq, event);
        }
        else if (obj.config.ajaxUrl) {
            // AJAX호출
            this.bindSelectorKeyupChargingUp(objID, objSeq, event);
        }
        else {
            if (!obj.config.options) {
                trace("options 항목이 없어 bind selector 를 완성 할 수 없습니다.");
                return;
            }
            this.bindSelectorSetOptions(objID, objSeq);
            this.bindSelectorKeyupChargingUp(objID, objSeq, event);
        }
        
        var bindSelectorOptionsClick = this.bindSelectorOptionsClick.bind(this);
        obj.documentclickEvent = function (event) {
            bindSelectorOptionsClick(objID, objSeq, event);
        };
        axdom(document).unbind("click.AXInput").bind("click.AXInput", obj.documentclickEvent);
        
    },
    bindSelectorBlur: function (objID) {
        var cfg = this.config;
        var objSeq = null;
        axf.each(this.objects, function (idx, O) {
            //if (this.id == objID && this.isDel == true) objSeq = idx;
            if (this.id == objID) {
                objSeq = idx;
            }
        });
        if (objSeq != null) this.bindSelectorClose(objID, objSeq);
    },
    bindSelectorClose: function (objID, objSeq, event, originChangeCall) {
        
        var cfg = this.config;
        var obj = this.objects[objSeq];
        var reserveKeys = obj.config.reserveKeys;
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        
        if (obj.inProgress) AXReqAbort(); // AJAX 호출 중지 하기
        
        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }
        
        if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
            
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Handle").removeClass("on");
            
            //비활성 처리후 메소드 종료
            
            axdom(document).unbind("click.AXInput");
            obj.bindTarget.unbind("keydown.AXInput");
            obj.bindTarget.unbind("change.AXInput");
            
            if (obj.bindTarget.data("val") == obj.bindTarget.val().enc() && !obj.config.isSelectorClick) {
                //return obj.bindTarget.val();
            }
            
            if (obj.config.isChangedSelect) {
                
                var myVal = "";
                if (obj.config.selectedObject) {
                    myVal = obj.config.selectedObject[reserveKeys.optionText];
                }
                
                if (obj.config.appendable) {
                    //trace(myVal);
                    if (myVal != "") axdom("#" + objID).val(myVal);
                }
                else {
                    axdom("#" + objID).val(myVal);
                }
                
                if (obj.config.onChange) {
                    var sendObj = {
                        targetID: objID,
                        options: obj.config.options,
                        selectedIndex: obj.config.selectedIndex,
                        selectedOption: obj.config.selectedObject
                    }
                    if (obj.config.onChange) obj.config.onChange.call(sendObj);
                    else if (obj.config.onchange) obj.config.onchange.call(sendObj);
                }
                obj.config.isChangedSelect = false;
                if (originChangeCall) obj.bindTarget.change();
            }
            //trace(obj.config.selectedObject);
            if (obj.config.selectedObject) this.bindSelectorInputChange(objID, objSeq);
            else {
                if (!obj.config.appendable) {
                    if (!obj.config.selectedObject && !obj.inProgress) axdom("#" + objID).val("");
                }
            }
            //if(event) event.stopPropagation(); // disableevent
            //return;
        }
    },
    bindSelectorSetOptions: function (objID, objSeq) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var reserveKeys = obj.config.reserveKeys;
        var maxHeight = obj.config.maxHeight || 130;
        var optionPrintLength = obj.config.optionPrintLength || 100;
        if (!obj.config.options) return;
        
        var expandBox = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox");
        var jqueryTargetObjID = axdom("#" + cfg.targetID + "_AX_" + objID);
        var po = [];
        axf.each(obj.config.options, function (index, O) {
            if (!isNaN(optionPrintLength)) {
                if (index > optionPrintLength - 1) return false;
            }
            
            // options의 optionText, optionDesc의 참조값을 디코딩해서 디코딩은 한 번만 사용하도록 변경
            O[reserveKeys.optionText] = (O[reserveKeys.optionText] ? O[reserveKeys.optionText].dec() : "");
            O.desc = (O.desc ? O.desc.dec() : "");
            O.optionDesc = (O.optionDesc ? O.optionDesc.dec() : "");
            
            var descStr = O.desc || O.optionDesc;
            if (descStr != "") descStr = "<span>" + descStr + "</span>";
            po.push("<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_" + index + "_AX_option\" class=\"bindSelectorNodes\">" + O[reserveKeys.optionText] + descStr + "</a>");
        });
        if (po.length == 0) {
            var selectorOptionEmpty = "";
            if (AXConfig.AXInput) selectorOptionEmpty = (AXConfig.AXInput.selectorOptionEmpty || "empty options");
            po.push("<div class=\"empty\">" + selectorOptionEmpty + "</div>");
        }
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandScroll").html(po.join(''));
        obj.config.isSelectorClick = false;
        
        var expandScrollHeight = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandScroll").outerHeight();
        if (expandScrollHeight > maxHeight) expandScrollHeight = maxHeight;
        expandBox.css({height: expandScrollHeight + "px"});
        
        var bindSelectorOptionsClick = this.bindSelectorOptionsClick.bind(this);
        obj.documentclickEvent = function (event) {
            bindSelectorOptionsClick(objID, objSeq, event);
        };
        var bindSelectorKeyup = this.bindSelectorKeyup.bind(this);
        obj.inputKeyup = function (event) {
            bindSelectorKeyup(objID, objSeq, event);
        };
        
        axdom(document).unbind("click.AXInput").bind("click.AXInput", obj.documentclickEvent);
        axdom("#" + objID).unbind("keydown.AXInput").bind("keydown.AXInput", obj.inputKeyup);
        
        if (obj.myUIScroll) obj.myUIScroll.unbind();
        obj.myUIScroll = new AXScroll();
        obj.myUIScroll.setConfig({
            CT_className: "AXScrollSmall",
            targetID: cfg.targetID + "_AX_" + objID + "_AX_expandBox",
            scrollID: cfg.targetID + "_AX_" + objID + "_AX_expandScroll",
            touchDirection: false
        });
        obj.myUIScroll.scrollTop(0);
        
        if (obj.config.selectedIndex != undefined) {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + obj.config.selectedIndex + "_AX_option").addClass("on");
            obj.myUIScroll.focusElement(cfg.targetID + "_AX_" + objID + "_AX_" + obj.config.selectedIndex + "_AX_option"); //focus
            obj.config.focusedIndex = obj.config.selectedIndex;
        }
        
        if (obj.config.direction == "bottom") {
            var offset = (obj.config.positionFixed) ? jqueryTargetObjID.position() : jqueryTargetObjID.offset();
            if (obj.config.position) {
                offset = jqueryTargetObjID.offset();
                if (obj.config.position.top != undefined) {
                    offset.top = obj.config.position.top;
                }
            }
            expandBox.css({top: offset.top - expandBox.outerHeight()});
        }
    },
    bindSelectorOptionsClick: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var reserveKeys = obj.config.reserveKeys;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        
        var myTarget = this.getEventTarget({
            evt: eventTarget,
            until: function (evt, evtIDs) {
                return (evt.parentNode.tagName == "body") ? true : false;
            },
            find: function (evt, evtIDs) {
                if (evt.id == "") return false;
                if (evt.id == objID || axdom(evt).hasClass("bindSelectorNodes")) {
                    return true;
                }
                else {
                    return false;
                }
            }
        });
        var isSelectorClick = (myTarget) ? true : false;
        if (!isSelectorClick) {
            this.bindSelectorClose(objID, objSeq, event); // 셀럭터 외의 영역이 므로 닫기
        }
        else {
            eid = myTarget.id.split(/_AX_/g);
            
            if (eid.last() == "option") {
                var selectedIndex = eid[eid.length - 2];
                obj.config.selectedIndex = selectedIndex;
                obj.config.focusedIndex = selectedIndex;
                obj.config.selectedObject = obj.config.options[selectedIndex];
                obj.config.isChangedSelect = true;
                obj.config.isSelectorClick = true;
                this.bindSelectorClose(objID, objSeq, event, "bindTarget_onchange"); // 값 전달 후 닫기
            }
        }
    },
    bindSelectorKeyup: function (objID, objSeq, event) {
        var obj = this.objects[objSeq], _this = this;
        var cfg = this.config;
        var reserveKeys = obj.config.reserveKeys;
        if (obj.inProgress) {
            obj.inProgressReACT = true;
            return;
        }
        
        if (event.keyCode == AXUtil.Event.KEY_TAB) {
            this.bindSelectorClose(objID, objSeq, event); // 닫기
            this.stopEvent(event);
            return;
        }
        
        if (event.keyCode == AXUtil.Event.KEY_UP) {
            if (!obj.config.options) return;
            if (obj.config.options.length == 0) return;
            var focusIndex = obj.config.options.length - 1;
            if (obj.config.focusedIndex == undefined || obj.config.focusedIndex == 0) {
                //trace(obj.config.selectedIndex+"//"+focusIndex);
            }
            else {
                focusIndex = (obj.config.focusedIndex) - 1;
                //trace(obj.config.selectedIndex+"//"+focusIndex);
            }
            this.bindSelectorSelect(objID, objSeq, focusIndex);
            this.stopEvent(event);
        }
        else if (event.keyCode == AXUtil.Event.KEY_DOWN) {
            if (!obj.config.options) return;
            if (obj.config.options.length == 0) return;
            var focusIndex = 0;
            if (obj.config.focusedIndex == undefined || obj.config.focusedIndex == obj.config.options.length - 1) {
                //trace(obj.config.selectedIndex+"//"+focusIndex);
            }
            else {
                focusIndex = (obj.config.focusedIndex).number() + 1;
                //trace(obj.config.selectedIndex+"//"+focusIndex);
            }
            this.bindSelectorSelect(objID, objSeq, focusIndex);
            this.stopEvent(event);
        }
        else if (event.keyCode == AXUtil.Event.KEY_RETURN) {
            
            if (obj.config.focusedIndex == null) {
                /*axdom("#" + objID).blur();*/
                _this.bindSelectorClose(objID, objSeq, event); // 닫기
            }
            else {
                //trace(obj.config.focusedIndex);
                obj.config.selectedObject = obj.config.options[obj.config.focusedIndex];
                obj.config.selectedIndex = obj.config.focusedIndex;
                obj.config.isChangedSelect = true;
                axdom("#" + objID).val(obj.config.selectedObject[reserveKeys.optionText]);
                /*axdom("#" + objID).blur();*/
                _this.bindSelectorClose(objID, objSeq, event, "bindTarget_onchange"); // 닫기
            }
            this.stopEvent(event);
        }
        else {
            //1. 반복입력 제어 하기
            var bindSelectorKeyupChargingUp = this.bindSelectorKeyupChargingUp.bind(this);
            if (obj.Observer) clearTimeout(obj.Observer); //명령 제거
            obj.Observer = setTimeout(function () {
                bindSelectorKeyupChargingUp(objID, objSeq, event);
            }, 500);
        }
    },
    bindSelectorKeyupChargingUp: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var reserveKeys = obj.config.reserveKeys;
        var objVal = axdom("#" + objID).val();
        var bindSelectorSearch = this.bindSelectorSearch.bind(this);
        https://github.com/axisj/axisj/issues/781
        if (obj.config.onsearch) {
            
            var res = obj.config.onsearch.call(
                {
                    id: objID,
                    value: objVal
                },
                objID,
                objVal,
                (function (res) {
                    obj.config.options = res.options;
                    obj.config.focusedIndex = null;
                    this.bindSelectorSetOptions(objID, objSeq);
                    this.bindSelectorSearch(objID, objSeq, objVal);
                }).bind(this)
            );
            
            /*
             callBack 함수를 이용하는 경우와 return 하는 두 가지 경우가 존재 하겠다. 아래는 obj.config.onsearch 에서 return 한 경우이고 위의 함수는 callBack 함수인 경우이다.
             */
            if (res) {
                res.options = res.options || [];
                obj.config.options = res.options;
                obj.config.focusedIndex = null;
                this.bindSelectorSetOptions(objID, objSeq);
                this.bindSelectorSearch(objID, objSeq, objVal);
            }
            
        }
        else if (obj.config.ajaxUrl) {
            // AJAX호출
            // 2. AJAX request
            // 3. AJAX 결과로 bindSelectorSetOptions 처리하기
            //this.bindSelectorSetOptions(objID, objSeq);
            // 4. 입력어로 bindSelectorSearch 실행하기
            obj.inProgress = true; //진행중 상태 변경
            var bindSelectorSetOptions = this.bindSelectorSetOptions.bind(this);
            var bindSelectorKeyupChargingUp = this.bindSelectorKeyupChargingUp.bind(this);
            
            var url = obj.config.ajaxUrl;
            var pars = obj.config.ajaxPars || {};
            var _method = "post";
            var _headers = {};
            var _contentType = AXConfig.AXReq.contentType;
            var _responseType = AXConfig.AXReq.responseType;
            var _dataType = AXConfig.AXReq.dataType;
            var _async = AXConfig.AXReq.async;
            
            // ajax 옵션 확장
            if (obj.config.method) _method = obj.config.method;
            if (obj.config.headers) _headers = obj.config.headers;
            if (obj.config.contentType) _contentType = obj.config.contentType;
            if (obj.config.responseType) _responseType = obj.config.responseType;
            if (obj.config.dataType) _dataType = obj.config.dataType;
            if (obj.config.ajaxAsync) _async = obj.config.ajaxAsync;
            
            var selectorName = obj.config.selectorName || axdom("#" + objID).attr("name");
            if (pars == "") {
                pars = selectorName + "=" + (objVal || "").enc();
            }
            else if ((typeof pars).toLowerCase() == "string") {
                pars += "&" + selectorName + "=" + objVal.enc();
            }
            else if ((typeof pars).toLowerCase() == "object") {
                pars[selectorName] = objVal.enc();
            }
            
            var msgAlert = this.msgAlert.bind(this);
            new AXReq(url, {
                type: _method,
                headers: _headers,
                contentType: _contentType,
                responseType: _responseType,
                dataType: _dataType,
                async: _async,
                debug: ((typeof obj.config.debug !== "undefined") ? obj.config.debug : false),
                pars: pars,
                onsucc: function (res) {
                    if ((res.result && res.result == AXConfig.AXReq.okCode) || (res.result == undefined && !res.error)) {
                        
                        //obj.config.options = (res.options || []);
                        obj.config.options = (res[reserveKeys.options] || []);
                        obj.config.focusedIndex = null;
                        
                        bindSelectorSetOptions(objID, objSeq);
                        bindSelectorSearch(objID, objSeq, objVal);
                        
                        if (obj.inProgressReACT) {
                            bindSelectorKeyupChargingUp(objID, objSeq, event);
                        }
                    }
                    else {
                        msgAlert(res);
                    }
                    obj.inProgress = false;
                    obj.inProgressReACT = false;
                }
            });
        }
        else {
            // 입력어로 bindSelectorSearch 실행하기

            bindSelectorSearch(objID, objSeq, objVal);
        }
    },
    bindSelectorInputChange: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var reserveKeys = obj.config.reserveKeys;
        if (axdom("#" + objID).val() != obj.config.selectedObject[reserveKeys.optionText]) {
            if (!obj.config.appendable) axdom("#" + objID).val("");
            obj.config.selectedObject = null;
            obj.config.selectedIndex = null;
            obj.config.focusedIndex = null;
            if (obj.config.onChange) {
                obj.config.onChange(null);
            }
        }
    },
    bindSelectorSetValue: function (objID, objSeq, value) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var reserveKeys = obj.config.reserveKeys;
        
        if (!obj.config.options) return;
        
        var selectedIndex = null;
        axf.each(obj.config.options, function (oidx, opt) {
            if (opt[reserveKeys.optionValue] == value) selectedIndex = oidx;
        });
        
        if (selectedIndex != null) {
            obj.config.focusedIndex = selectedIndex;
            obj.config.selectedObject = obj.config.options[selectedIndex];
            obj.config.isChangedSelect = true;
            axdom("#" + objID).val(obj.config.selectedObject[reserveKeys.optionText]);
            
            if (obj.config.onChange || obj.config.onchange) {
                var sendObj = {
                    targetID: objID,
                    options: obj.config.options,
                    selectedIndex: obj.config.selectedIndex,
                    selectedOption: obj.config.selectedObject
                };
                if (obj.config.onChange) obj.config.onChange.call(sendObj);
                else if (obj.config.onchange) obj.config.onchange.call(sendObj);
            }
        }
    },
    bindSelectorSearch: function (objID, objSeq, kword) { // 입력된 값으로 검색 하기
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var reserveKeys = obj.config.reserveKeys;
        if (kword == "") {
            this.bindSelectorSelectClear(objID, objSeq);
            return;
        }
        kword = kword.replace(/\//g, "\\\/");
        var sw = AXUtil.consonantKR((kword || "").dec());
        var reAt = new RegExp("^" + sw + ".*", "i");
        
        var ix = null;
        for (var a = 0; a < obj.config.options.length; a++) {
            if (reAt.test((obj.config.options[a][reserveKeys.optionText] || ""))) {
                ix = a;
                break;
            }
        }
        if (ix != null) {
            this.bindSelectorSelect(objID, objSeq, ix, "dont change value");
        }
        else {
            this.bindSelectorSelectClear(objID, objSeq);
        }
    },
    bindSelectorSelect: function (objID, objSeq, index, changeValue) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var reserveKeys = obj.config.reserveKeys;
        if (obj.config.focusedIndex != undefined) {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + obj.config.focusedIndex + "_AX_option").removeClass("on");
        }
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + index + "_AX_option").addClass("on");
        obj.config.focusedIndex = index;
        //obj.config.selectedObject = obj.config.options[index];
        //obj.config.isChangedSelect = true;
        //if(!changeValue) axdom("#"+objID).val(obj.config.selectedObject.optionText.dec());
        obj.myUIScroll.focusElement(cfg.targetID + "_AX_" + objID + "_AX_" + index + "_AX_option"); //focus
    },
    bindSelectorSelectClear: function (objID, objSeq) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var reserveKeys = obj.config.reserveKeys;
        if (obj.config.selectedIndex != undefined) {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + obj.config.selectedIndex + "_AX_option").removeClass("on");
        }
        obj.config.selectedIndex = null;
        obj.config.focusedIndex = null;
        obj.config.selectedObject = null;
        obj.config.isChangedSelect = true;
    },
    
    // slider
    bindSlider: function (objID, objSeq) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        if (!obj.bindAnchorTarget) obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderBox").remove();
        
        var w = obj.bindAnchorTarget.width();
        var h = obj.bindAnchorTarget.data("height");
        //trace(h);
        var objVal = obj.bindTarget.val().number().money();
        if (objVal.number() < obj.config.min.number()) objVal = obj.config.min;
        else if (objVal.number() > obj.config.max.number()) objVal = obj.config.max;
        
        if (!obj.config.unit) obj.config.unit = "";
        
        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderBox\" class=\"" + cfg.anchorSliderBoxClassName + "\" style=\"left:0px;width:" + w + "px;height:" + h + "px;\">");
        po.push("	<div class=\"AXanchorSliderMinTitle\">" + obj.config.min.number().money() + obj.config.unit + "</div>");
        po.push("	<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderBar\" class=\"AXanchorSliderBar\">");
        po.push("		<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside\" class=\"AXanchorSliderBarInside\"><div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleTitle\" class=\"AXanchorSliderHandleTitle\">" + objVal.number().money() + obj.config.unit + "</div></div>");
        po.push("		<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandle\" class=\"AXanchorSliderHandle\">&nbsp;</a>");
        po.push("	</div>");
        po.push("	<div class=\"AXanchorSliderMaxTitle\">" + obj.config.max.number().money() + obj.config.unit + "</div>");
        po.push("</div>");
        
        //append to anchor
        obj.bindAnchorTarget.append(po.join(''));
        //obj.bindAnchorTarget.css({ height: h + "px", "position": "relative", display: "inline-block", left: "auto", top: "auto" });
        obj.bindAnchorTarget.css({
            height: h + "px",
            "position": "relative",
            display: "inline-block",
            left: "auto",
            top: "auto"
        });
        //, background:"#eee"
        
        var maxTitleWidth = axdom("#" + cfg.targetID + "_AX_" + objID).find(".AXanchorSliderMaxTitle").outerWidth().number() + 10;
        var minTitleWidth = axdom("#" + cfg.targetID + "_AX_" + objID).find(".AXanchorSliderMinTitle").outerWidth().number() + 10;
        if (maxTitleWidth < 30) maxTitleWidth = 30;
        if (minTitleWidth < 30) minTitleWidth = 30;
        axdom("#" + cfg.targetID + "_AX_" + objID).find(".AXanchorSliderMinTitle").css({width: minTitleWidth + "px"});
        axdom("#" + cfg.targetID + "_AX_" + objID).find(".AXanchorSliderMaxTitle").css({width: maxTitleWidth + "px"});
        var sliderBarWidth = w - minTitleWidth - maxTitleWidth;
        obj.bindAnchorTarget.find(".AXanchorSliderBar").css({
            width: sliderBarWidth + "px",
            left: minTitleWidth + "px",
            top: h / 2 + 2
        });
        //------------------------------------
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleTitle").css({width: maxTitleWidth});
        obj.config._maxTitleWidth = maxTitleWidth;
        obj.config._handleWidth = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandle").width();
        obj.config._trackWidth = sliderBarWidth;
        this.bindSliderSetValue(objID, objSeq);
        
        var onmousedown = this.bindSliderMouseDown.bind(this);
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandle").unbind("mousedown.AXInput").bind("mousedown.AXInput", function () {
            onmousedown(objID, objSeq);
        });
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandle").unbind("dragstart.AXInput").bind("dragstart.AXInput", function (event) {
            event.stopPropagation(); // disable  event
            return false;
        });
        
        //add touch event
        if (document.addEventListener) {
            var ontouchstart = this.sliderTouchStart.bind(this);
            obj.bindSliderTouchStart = function (event) { ontouchstart(objID, objSeq); }
            
            AXgetId(cfg.targetID + "_AX_" + objID + "_AX_SliderHandle").addEventListener("touchstart", obj.bindSliderTouchStart, false);
        }
        
        obj.bindAnchorTarget.show();
        obj.bindTarget.hide();
        
    },
    bindSliderMouseDown: function (objID, objSeq) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }
        if (!obj.config.isMoving) {
            var bindSliderMouseMove = this.bindSliderMouseMove.bind(this);
            obj.bindSliderMouseMove = function (event) {
                bindSliderMouseMove(objID, objSeq, event);
            };
            var bindSliderMouseUp = this.bindSliderMouseUp.bind(this);
            obj.bindSliderMouseUp = function (event) {
                bindSliderMouseUp(objID, objSeq, event);
            };
            axdom(document.body).unbind("mousemove.AXInput").bind("mousemove.AXInput", obj.bindSliderMouseMove);
            axdom(document.body).unbind("mouseup.AXInput").bind("mouseup.AXInput", obj.bindSliderMouseUp);
            obj.config.isMoving = true;
        }
        
    },
    bindSliderMouseMove: function (objID, objSeq, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        var eX = event.pageX;
        var cX = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderBar").offset().left;
        
        var rX = eX - cX;
        
        var valueWidth = obj.config.max.number() - obj.config.min.number();
        var pixelWidth = obj.config._trackWidth;
        var objVal = (rX * valueWidth) / pixelWidth;
        var snap = obj.config.snap;
        if (typeof snap == "undefined") snap = 1;
        
        if (snap >= 1) {
            objVal = (objVal.number() + obj.config.min.number()).round();
            objVal = (parseInt(objVal / (snap), 10) * (snap));
        }
        else {
            objVal = (objVal.number() + obj.config.min.number()).round((snap.toString().length - 2));
            objVal = (parseFloat(objVal / (snap)) * (snap)).round((snap.toString().length - 2));
        }
        
        var rX = ((objVal - obj.config.min) * pixelWidth) / valueWidth;
        
        if (objVal < obj.config.min) {
            objVal = obj.config.min;
            rX = 0;
        }
        else if (objVal > obj.config.max) {
            objVal = obj.config.max;
            rX = pixelWidth;
        }
        if (rX > pixelWidth) rX = pixelWidth;
        
        var sX = rX - (obj.config._handleWidth / 2);
        var stX = rX - (obj.config._maxTitleWidth / 2);
        
        //trace({rX:rX, pixelWidth:pixelWidth, objVal:objVal, valueWidth:valueWidth});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandle").css({left: sX});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside").css({width: rX});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleTitle").css({left: stX});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleTitle").text(objVal.number().money() + obj.config.unit);
        axdom("#" + objID).val(objVal);
    },
    bindSliderMouseUp: function (objID, objSeq, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        var objVal = axdom("#" + objID).val();
        if (obj.config.onChange || obj.config.onchange) {
            var onchange = obj.config.onChange || obj.config.onchange;
            onchange.call({id: objID, value: objVal}, objID, objVal);
        }
        
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        obj.bindTarget.change();
        
        axdom(document.body).unbind("mousemove.AXInput");
        axdom(document.body).unbind("mouseup.AXInput");
        obj.config.isMoving = false;
    },
    bindSliderSetValue: function (objID, objSeq, value) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        if (value != undefined) {
            var objVal = value;
        }
        else {
            var objVal = axdom("#" + objID).val();
        }
        
        if (objVal.number() < obj.config.min.number()) objVal = obj.config.min;
        else if (objVal.number() > obj.config.max.number()) objVal = obj.config.max;
        var valueWidth = obj.config.max.number() - obj.config.min.number();
        var pixelWidth = obj.config._trackWidth;
        var pixelLeft = ((objVal - obj.config.min) * pixelWidth) / valueWidth;
        
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandle").css({left: pixelLeft - (obj.config._handleWidth / 2)});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside").css({width: pixelLeft});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleTitle").css({left: pixelLeft - (obj.config._maxTitleWidth / 2)});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleTitle").text(objVal.number().money() + obj.config.unit);
        
        axdom("#" + objID).val(objVal);
    },
    sliderTouchStart: function (objID, objSeq) {
        //alert(objID+"_"+ objSeq);
        var cfg = this.config;
        var obj = this.objects[objSeq];
        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }
        if (!obj.config.isMoving) {
            var bindSliderTouchMove = this.sliderTouchMove.bind(this);
            obj.bindSliderTouchMove = function (event) {
                bindSliderTouchMove(objID, objSeq, event);
            };
            var bindSliderTouchEnd = this.sliderTouchEnd.bind(this);
            obj.bindSliderTouchEnd = function (event) {
                bindSliderTouchEnd(objID, objSeq, event);
            };
            
            if (document.addEventListener) {
                document.addEventListener("touchmove", obj.bindSliderTouchMove, false);
                document.addEventListener("touchend", obj.bindSliderTouchEnd, false);
                
            }
            obj.config.isMoving = true;
            
        }
        
    },
    sliderTouchMove: function (objID, objSeq, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        event.preventDefault();
        var touch = event.touches[0];
        
        var eX = touch.pageX;
        var cX = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderBar").offset().left;
        var rX = eX - cX;
        
        var valueWidth = obj.config.max.number() - obj.config.min.number();
        var pixelWidth = obj.config._trackWidth;
        var objVal = (rX * valueWidth) / pixelWidth;
        var snap = obj.config.snap;
        if (!snap) snap = 1;
        objVal = (objVal.number() + obj.config.min.number()).round();
        objVal = parseInt(objVal / (snap)) * (snap);
        var rX = ((objVal - obj.config.min) * pixelWidth) / valueWidth;
        
        if (objVal < obj.config.min) {
            objVal = obj.config.min;
            rX = 0;
        }
        else if (objVal > obj.config.max) {
            objVal = obj.config.max;
            rX = pixelWidth;
        }
        if (rX > pixelWidth) rX = pixelWidth;
        
        var sX = rX - (obj.config._handleWidth / 2);
        var stX = rX - (obj.config._maxTitleWidth / 2);
        
        //trace({rX:rX, pixelWidth:pixelWidth, objVal:objVal, valueWidth:valueWidth});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandle").css({left: sX});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside").css({width: rX});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleTitle").css({left: stX});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleTitle").text(objVal.number().money() + obj.config.unit);
        axdom("#" + objID).val(objVal);
        if (obj.config.onChange) obj.config.onChange(objID, objVal);
        else if (obj.config.onchange) obj.config.onchange(objID, objVal);
        
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        obj.bindTarget.change();
    },
    sliderTouchEnd: function (objID, objSeq, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        var objVal = axdom("#" + objID).val();
        
        if (obj.config.onChange || obj.config.onchange) {
            var onchange = obj.config.onChange || obj.config.onchange;
            onchange.call({id: objID, value: objVal}, objID, objVal);
        }
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        obj.bindTarget.change();
        
        if (document.addEventListener) {
            document.removeEventListener("touchmove", obj.bindSliderTouchMove, false);
            document.removeEventListener("touchend", obj.bindSliderTouchEnd, false);
        }
        obj.config.isMoving = false;
    },
    
    // twinSlider
    bindTwinSliderGetVals: function (objValString, separator) {
        var objVals = objValString.split(separator);
        var objVal = {min: 0, max: 0};
        if (objVals.length < 2) {
            objVal = {min: objVals[0], max: objVals[0]};
        }
        else {
            objVal = {min: objVals[0], max: objVals[1]};
        }
        return objVal;
    },
    bindTwinSlider: function (objID, objSeq) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        if (!obj.bindAnchorTarget) obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        
        var w = obj.bindAnchorTarget.width();
        var h = obj.bindAnchorTarget.data("height");
        var objValString = obj.bindTarget.val();
        var separator = obj.config.separator || "~";
        var objVal = this.bindTwinSliderGetVals(objValString, separator);
        obj.vals = objVal;
        
        if (objVal.min.number() < obj.config.min.number()) objVal.min = obj.config.min;
        else if (objVal.min.number() > obj.config.max.number()) objVal.min = obj.config.max;
        if (objVal.max.number() < obj.config.min.number()) objVal.max = obj.config.min;
        else if (objVal.max.number() > obj.config.max.number()) objVal.max = obj.config.max;
        
        if (!obj.config.unit) obj.config.unit = "";
        
        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderBox\" class=\"" + cfg.anchorSliderBoxClassName + "\" style=\"left:0px;width:" + w + "px;height:" + h + "px;\">");
        po.push("	<a " + obj.config.href + " class=\"AXanchorSliderMinTitle\">" + obj.config.min.number().money() + obj.config.unit + "</a>");
        po.push("	<a " + obj.config.href + " class=\"AXanchorSliderMaxTitle\">" + obj.config.max.number().money() + obj.config.unit + "</a>");
        po.push("	<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderBar\" class=\"AXanchorSliderBar\">");
        po.push("		<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside\" class=\"AXanchorSliderBarInside\"></div>");
        po.push("		<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMinTitle\" class=\"AXanchorSliderHandleMinTitle\">" + objVal.min.number().money() + obj.config.unit + "</div>");
        po.push("		<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMaxTitle\" class=\"AXanchorSliderHandleMaxTitle\">" + objVal.max.number().money() + obj.config.unit + "</div>");
        po.push("		<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMin\" class=\"AXanchorSliderHandleMin\">&nbsp;</a>");
        po.push("		<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMax\" class=\"AXanchorSliderHandleMax\">&nbsp;</a>");
        po.push("	</div>");
        po.push("</div>");
        
        //append to anchor
        obj.bindAnchorTarget.append(po.join(''));
        obj.bindAnchorTarget.css({
            height: h + "px",
            "position": "relative",
            display: "inline-block",
            left: "auto",
            top: "auto"
        });
        //, background:"#eee"
        obj.bindAnchorTarget.show();
        obj.bindTarget.hide();
        
        var maxTitleWidth = obj.bindAnchorTarget.find(".AXanchorSliderMaxTitle").outerWidth().number() + 10;
        var minTitleWidth = obj.bindAnchorTarget.find(".AXanchorSliderMinTitle").outerWidth().number() + 10;
        obj.bindAnchorTarget.find(".AXanchorSliderMinTitle").css({width: minTitleWidth + "px"});
        obj.bindAnchorTarget.find(".AXanchorSliderMaxTitle").css({width: maxTitleWidth + "px"});
        var sliderBarWidth = w - minTitleWidth - maxTitleWidth;
        obj.bindAnchorTarget.find(".AXanchorSliderBar").css({
            width: sliderBarWidth + "px",
            left: minTitleWidth + "px",
            top: h / 2 + 2
        });
        //------------------------------------
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMinTitle").css({width: maxTitleWidth});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMaxTitle").css({width: maxTitleWidth});
        obj.config._maxTitleWidth = maxTitleWidth;
        obj.config._handleWidth = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMin").width();
        obj.config._trackWidth = sliderBarWidth;
        this.bindTwinSliderSetValue(objID, objSeq);
        
        var onmousedown = this.bindTwinSliderMouseDown.bind(this);
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMin").unbind("mousedown.AXInput").bind("mousedown.AXInput", function () {
            onmousedown(objID, objSeq, "min");
        });
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMax").unbind("mousedown.AXInput").bind("mousedown.AXInput", function () {
            onmousedown(objID, objSeq, "max");
        });
        
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMin").unbind("dragstart.AXInput").bind("dragstart.AXInput", function (event) {
            event.stopPropagation(); // disable  event
            return false;
        });
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMax").unbind("dragstart.AXInput").bind("dragstart.AXInput", function (event) {
            event.stopPropagation(); // disable  event
            return false;
        });
        
        //add touch event
        if (document.addEventListener) {
            var ontouchstart = this.twinSliderTouchStart.bind(this);
            obj.bindTwinSliderTouchStartMin = function (event) { ontouchstart(objID, objSeq, "min"); }
            obj.bindTwinSliderTouchStartMax = function (event) { ontouchstart(objID, objSeq, "max"); }
            
            AXgetId(cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMin").addEventListener("touchstart", obj.bindTwinSliderTouchStartMin, false);
            AXgetId(cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMax").addEventListener("touchstart", obj.bindTwinSliderTouchStartMax, false);
        }
        
    },
    bindTwinSliderMouseDown: function (objID, objSeq, handleName) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }
        if (!obj.config.isMoving) {
            var bindTwinSliderMouseMove = this.bindTwinSliderMouseMove.bind(this);
            obj.bindTwinSliderMouseMove = function (event) {
                bindTwinSliderMouseMove(objID, objSeq, event, handleName);
            };
            var bindTwinSliderMouseUp = this.bindTwinSliderMouseUp.bind(this);
            obj.bindTwinSliderMouseUp = function (event) {
                bindTwinSliderMouseUp(objID, objSeq, event, handleName);
            };
            axdom(document.body).unbind("mousemove.AXInput").bind("mousemove.AXInput", obj.bindTwinSliderMouseMove);
            axdom(document.body).unbind("mouseup.AXInput").bind("mouseup.AXInput", obj.bindTwinSliderMouseUp);
            obj.config.isMoving = true;
        }
        
    },
    bindTwinSliderMouseMove: function (objID, objSeq, event, handleName) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        var eX = event.pageX;
        var cX = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderBar").offset().left;
        
        var rX = eX - cX;
        
        var valueWidth = obj.config.max.number() - obj.config.min.number();
        var pixelWidth = obj.config._trackWidth;
        var objVal = (rX * valueWidth) / pixelWidth;
        var snap = obj.config.snap;
        if (!snap) snap = 1;
        objVal = (objVal.number() + obj.config.min.number()).round();
        objVal = parseInt(objVal / (snap)) * (snap);
        var rX = ((objVal - obj.config.min) * pixelWidth) / valueWidth;
        
        if (objVal < obj.config.min) {
            objVal = obj.config.min;
            rX = 0;
        }
        else if (objVal > obj.config.max) {
            objVal = obj.config.max;
            rX = pixelWidth;
        }
        if (rX > pixelWidth) rX = pixelWidth;
        
        //trace({rX:rX, pixelWidth:pixelWidth, objVal:objVal, valueWidth:valueWidth});
        if (handleName == "min") {
            if (objVal > obj.vals.max) {
                objVal = obj.vals.max;
                rX = obj.handleMaxLeft;
            }
            var sX = rX - (obj.config._handleWidth);
            var stX = rX - (obj.config._maxTitleWidth);
            obj.handleMinLeft = rX;
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMin").css({left: sX});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMinTitle").css({left: stX});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMinTitle").text(objVal.number().money() + obj.config.unit);
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside").css({width: rX});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside").css({
                left: obj.handleMinLeft,
                width: obj.handleMaxLeft - obj.handleMinLeft
            });
            //axdom("#"+objID).val(objVal);
            obj.vals.min = objVal;
        }
        else {
            if (objVal < obj.vals.min) {
                objVal = obj.vals.min;
                rX = obj.handleMinLeft;
            }
            var sX = rX;
            var stX = rX;
            obj.handleMaxLeft = rX;
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMax").css({left: sX});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMaxTitle").css({left: stX});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMaxTitle").text(objVal.number().money() + obj.config.unit);
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside").css({
                left: obj.handleMinLeft,
                width: obj.handleMaxLeft - obj.handleMinLeft
            });
            //axdom("#"+objID).val(objVal);
            obj.vals.max = objVal;
        }
        var separator = obj.config.separator || "~";
        axdom("#" + objID).val(obj.vals.min + separator + obj.vals.max);
        
    },
    bindTwinSliderMouseUp: function (objID, objSeq, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        var objVal = axdom("#" + objID).val();
        if (obj.config.onChange || obj.config.onchange) {
            var onchange = obj.config.onChange || obj.config.onchange;
            onchange.call({id: objID, value: objVal}, objID, objVal);
        }
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        obj.bindTarget.change();
        
        axdom(document.body).unbind("mousemove.AXInput");
        axdom(document.body).unbind("mouseup.AXInput");
        obj.config.isMoving = false;
    },
    bindTwinSliderSetValue: function (objID, objSeq, value) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        if (value != undefined) {
            var objValString = value;
        }
        else {
            var objValString = axdom("#" + objID).val();
        }
        
        var separator = obj.config.separator || "~";
        var objVal = this.bindTwinSliderGetVals(objValString, separator);
        obj.vals = objVal;
        
        if (objVal.min.number() < obj.config.min.number()) objVal.min = obj.config.min;
        else if (objVal.min.number() > obj.config.max.number()) objVal.min = obj.config.max;
        if (objVal.max.number() < obj.config.min.number()) objVal.max = obj.config.min;
        else if (objVal.max.number() > obj.config.max.number()) objVal.max = obj.config.max;
        
        var valueWidth = obj.config.max.number() - obj.config.min.number();
        var pixelWidth = obj.config._trackWidth;
        var pixelMinLeft = ((objVal.min - obj.config.min) * pixelWidth) / valueWidth;
        var pixelMaxLeft = ((objVal.max - obj.config.min) * pixelWidth) / valueWidth;
        
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMin").css({left: pixelMinLeft - (obj.config._handleWidth)});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMinTitle").css({left: pixelMinLeft - (obj.config._maxTitleWidth)});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMinTitle").text(objVal.min.number().money() + obj.config.unit);
        
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMax").css({left: pixelMaxLeft});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMaxTitle").css({left: pixelMaxLeft});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMaxTitle").text(objVal.max.number().money() + obj.config.unit);
        
        obj.handleMinLeft = pixelMinLeft;
        obj.handleMaxLeft = pixelMaxLeft;
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside").css({
            left: pixelMinLeft,
            width: pixelMaxLeft - pixelMinLeft
        });
        
        axdom("#" + objID).val(obj.vals.min + separator + obj.vals.max);
    },
    // -- add touch event
    twinSliderTouchStart: function (objID, objSeq, handleName) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }
        
        if (!obj.config.isMoving) {
            var bindTwinSliderTouchMove = this.twinSliderTouchMove.bind(this);
            obj.bindTwinSliderTouchMove = function (event) {
                bindTwinSliderTouchMove(objID, objSeq, event, handleName);
            };
            var bindTwinSliderTouchEnd = this.twinSliderTouchEnd.bind(this);
            obj.bindTwinSliderTouchEnd = function (event) {
                bindTwinSliderTouchEnd(objID, objSeq, event, handleName);
            };
            
            if (document.addEventListener) {
                document.addEventListener("touchmove", obj.bindTwinSliderTouchMove, false);
                document.addEventListener("touchend", obj.bindTwinSliderTouchEnd, false);
                
            }
            obj.config.isMoving = true;
            
        }
        
    },
    twinSliderTouchMove: function (objID, objSeq, event, handleName) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        event.preventDefault();
        var touch = event.touches[0];
        
        //var eX = event.pageX;
        var eX = touch.pageX;
        var cX = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderBar").offset().left;
        var rX = eX - cX;
        
        var valueWidth = obj.config.max.number() - obj.config.min.number();
        var pixelWidth = obj.config._trackWidth;
        var objVal = (rX * valueWidth) / pixelWidth;
        var snap = obj.config.snap;
        if (!snap) snap = 1;
        objVal = (objVal.number() + obj.config.min.number()).round();
        objVal = parseInt(objVal / (snap)) * (snap);
        var rX = ((objVal - obj.config.min) * pixelWidth) / valueWidth;
        
        if (objVal < obj.config.min) {
            objVal = obj.config.min;
            rX = 0;
        }
        else if (objVal > obj.config.max) {
            objVal = obj.config.max;
            rX = pixelWidth;
        }
        if (rX > pixelWidth) rX = pixelWidth;
        
        //trace({rX:rX, pixelWidth:pixelWidth, objVal:objVal, valueWidth:valueWidth});
        
        if (handleName == "min") {
            if (objVal > obj.vals.max) {
                objVal = obj.vals.max;
                rX = obj.handleMaxLeft;
            }
            var sX = rX - (obj.config._handleWidth);
            var stX = rX - (obj.config._maxTitleWidth);
            obj.handleMinLeft = rX;
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMin").css({left: sX});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMinTitle").css({left: stX});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMinTitle").text(objVal.number().money() + obj.config.unit);
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside").css({width: rX});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside").css({
                left: obj.handleMinLeft,
                width: obj.handleMaxLeft - obj.handleMinLeft
            });
            //axdom("#"+objID).val(objVal);
            obj.vals.min = objVal;
        }
        else {
            if (objVal < obj.vals.min) {
                objVal = obj.vals.min;
                rX = obj.handleMinLeft;
            }
            var sX = rX;
            var stX = rX;
            obj.handleMaxLeft = rX;
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMax").css({left: sX});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMaxTitle").css({left: stX});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMaxTitle").text(objVal.number().money() + obj.config.unit);
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside").css({
                left: obj.handleMinLeft,
                width: obj.handleMaxLeft - obj.handleMinLeft
            });
            //axdom("#"+objID).val(objVal);
            obj.vals.max = objVal;
        }
        var separator = obj.config.separator || "~";
        axdom("#" + objID).val(obj.vals.min + separator + obj.vals.max);
        if (obj.config.onChange) obj.config.onChange(objID, obj.vals.min + separator + obj.vals.max);
        else if (obj.config.onchange) obj.config.onchange(objID, obj.vals.min + separator + obj.vals.max);
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        obj.bindTarget.change();
    },
    twinSliderTouchEnd: function (objID, objSeq, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        var objVal = axdom("#" + objID).val();
        if (obj.config.onChange || obj.config.onchange) {
            var onchange = obj.config.onChange || obj.config.onchange;
            onchange.call({id: objID, value: objVal}, objID, objVal);
        }
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        obj.bindTarget.change();
        document.removeEventListener("touchmove", obj.bindTwinSliderTouchMove, false);
        document.removeEventListener("touchend", obj.bindTwinSliderTouchEnd, false);
        
        obj.config.isMoving = false;
    },
    
    // switch
    bindSwitch: function (objID, objSeq) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        if (!obj.bindAnchorTarget) obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        
        var w = obj.bindAnchorTarget.width();
        var h = obj.bindAnchorTarget.data("height");
        var objVal = obj.bindTarget.val();
        var switchValue = obj.config.on;
        if (objVal == switchValue) {
            obj.switchValue = "on";
        }
        else {
            switchValue = obj.config.off;
            obj.switchValue = "off";
        }
        obj.bindTarget.val(switchValue);
        
        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SwitchBox\" class=\"" + cfg.anchorSwitchBoxClassName + "\" style=\"left:0px;top:0px;width:" + w + "px;height:" + h + "px;\">");
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SwitchDisplay\" class=\"AXanchorSwitchDisplay\" style=\"height:" + h + "px;line-height:" + h + "px;\">" + switchValue + "</div>");
        po.push("<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SwitchHandle\" class=\"AXanchorSwitchHandle\" style=\"height:" + h + "px;\">&nbsp;</a>");
        po.push("</div>");
        
        //append to anchor
        obj.bindAnchorTarget.append(po.join(''));
        obj.bindAnchorTarget.css({
            height: h + "px",
            "position": "relative",
            display: "inline-block",
            left: "auto",
            top: "auto"
        });
        
        obj.bindTarget_switchBox = obj.bindAnchorTarget.find("." + cfg.anchorSwitchBoxClassName);
        obj.bindTarget_switchDisplay = obj.bindAnchorTarget.find(".AXanchorSwitchDisplay");
        obj.bindTarget_switchHandle = obj.bindAnchorTarget.find(".AXanchorSwitchHandle");
        
        if (obj.switchValue == "on") {
            obj.bindAnchorTarget.find("." + cfg.anchorSwitchBoxClassName).addClass("on");
        }
        
        //, background:"#eee"
        obj.bindAnchorTarget.show();
        obj.bindTarget.hide();
        
        var bindSwitchClick = this.bindSwitchClick.bind(this);
        obj.bindSwitchClick = function (event) {
            bindSwitchClick(objID, objSeq, event);
        };
        obj.bindAnchorTarget.find("." + cfg.anchorSwitchBoxClassName).unbind("click.AXInput").bind("click.AXInput", obj.bindSwitchClick);
        
    },
    bindSwitchClick: function (objID, objSeq, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }
        
        if (obj.switchValue == "on") {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SwitchBox").removeClass("on");
            obj.switchValue = "off";
            axdom("#" + objID).val(obj.config.off);
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SwitchDisplay").html(obj.config.off);
        }
        else {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SwitchBox").addClass("on");
            obj.switchValue = "on";
            axdom("#" + objID).val(obj.config.on);
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SwitchDisplay").html(obj.config.on);
        }
        if (obj.config.onChange || obj.config.onchange) {
            var sendObj = {
                targetID: objID,
                on: obj.config.on,
                off: obj.config.off,
                value: axdom("#" + objID).val()
            }
            if (obj.config.onChange) obj.config.onChange.call(sendObj);
            if (obj.config.onchange) obj.config.onchange.call(sendObj);
        }
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        obj.bindTarget.change();
    },
    bindSwitchSetValue: function (objID, objSeq, value) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        var objVal = value;
        var switchValue = obj.config.on;
        if (objVal == switchValue) {
            obj.switchValue = "on";
        }
        else {
            switchValue = obj.config.off;
            obj.switchValue = "off";
        }
        axdom("#" + objID).val(switchValue);
        
        if (obj.switchValue == "off") {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SwitchBox").removeClass("on");
            obj.switchValue = "off";
            axdom("#" + objID).val(obj.config.off);
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SwitchDisplay").html(obj.config.off);
        }
        else {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SwitchBox").addClass("on");
            obj.switchValue = "on";
            axdom("#" + objID).val(obj.config.on);
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SwitchDisplay").html(obj.config.on);
        }
        if (obj.config.onChange || obj.config.onchange) {
            var sendObj = {
                targetID: objID,
                on: obj.config.on,
                off: obj.config.off,
                value: axdom("#" + objID).val()
            }
            if (obj.config.onChange) obj.config.onChange.call(sendObj);
            else if (obj.config.onchange) obj.config.onchange.call(sendObj);
        }
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        obj.bindTarget.change();
    },
    bindSwitch_touchstart: function () {
        
    },
    bindSwitch_touchMove: function () {
        
    },
    bindSwitch_touchEnd: function () {
        
    },
    
    // segment
    bindSegment: function (objID, objSeq) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        if (!obj.bindAnchorTarget) obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        
        var w = obj.bindAnchorTarget.width();
        var h = obj.bindAnchorTarget.data("height");
        var objVal = obj.bindTarget.val();
        var segmentOptions = obj.config.options;
        obj.selectedSegmentIndex = null;
        axf.each(segmentOptions, function (idx, seg) {
            //trace({optionValue:this.optionValue, objVal:objVal});
            if (this.optionValue == objVal) {
                obj.selectedSegmentIndex = idx;
                obj.selectedSegment = seg;
            }
        });
        if (obj.selectedSegmentIndex == null) {
            obj.selectedSegmentIndex = 0;
            obj.selectedSegment = segmentOptions[0];
        }
        obj.bindTarget.val(obj.selectedSegment.optionValue);
        
        var handleWidth = (w / segmentOptions.length).round() - 2;
        var po = [];
        var theme = obj.config.theme || cfg.anchorSegmentBoxClassName;
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SegmentBox\" class=\"" + theme + "\" style=\"left:0px;top:0px;width:" + w + "px;\">");
        axf.each(segmentOptions, function (idx, seg) {
            var addClass = "";
            if (idx == 0) addClass = " segmentLeft";
            else if (idx == segmentOptions.length - 1) addClass = " segmentRight";
            if (obj.selectedSegmentIndex == idx) addClass += " on";
            if (seg.addClass) addClass += " " + seg.addClass;
            po.push("<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SegmentHandle_AX_" + idx + "\" class=\"AXanchorSegmentHandle" + addClass + "\" style=\"width:" + handleWidth + "px;\">" + seg.optionText + "</a>");
        });
        po.push("</div>");
        
        //append to anchor
        obj.bindAnchorTarget.append(po.join(''));
        obj.bindAnchorTarget.css({
            height: h + "px",
            "position": "relative",
            display: "inline-block",
            left: "auto",
            top: "auto"
        });
        var borderTop = obj.bindAnchorTarget.find(".AXanchorSegmentHandle").css("border-top-width").number();
        var borderBot = obj.bindAnchorTarget.find(".AXanchorSegmentHandle").css("border-bottom-width").number();
        obj.bindAnchorTarget.find(".AXanchorSegmentHandle").css({
            height: (obj.bindAnchorTarget.innerHeight() - borderTop - borderBot) + "px",
            "line-height": (obj.bindAnchorTarget.innerHeight() - borderTop - borderBot) + "px"
        });
        
        //, background:"#eee"
        obj.bindAnchorTarget.show();
        obj.bindTarget.hide();
        
        var bindSegmentClick = this.bindSegmentClick.bind(this);
        obj.bindSegmentClick = function (event) {
            bindSegmentClick(objID, objSeq, event);
        };
        
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SegmentBox").find(".AXanchorSegmentHandle").unbind("click.AXInput").bind("click.AXInput", obj.bindSegmentClick);
    },
    bindSegmentClick: function (objID, objSeq, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }
        
        var segmentOptions = obj.config.options;
        
        var myTarget = axf.get_event_target(event.target, {tagname: "a", clazz: "AXanchorSegmentHandle"});
        if (myTarget) {
            
            var seq = myTarget.id.split(/_AX_/g).last();
            if (obj.selectedSegmentIndex != seq) {
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SegmentHandle_AX_" + obj.selectedSegmentIndex).removeClass("on");
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SegmentHandle_AX_" + seq).addClass("on");
                obj.selectedSegmentIndex = seq;
                obj.selectedSegment = segmentOptions[seq];
            }
            //strace(obj.selectedSegment.optionValue);
            axdom("#" + objID).val(obj.selectedSegment.optionValue);
            //trace(axdom("#"+objID).val());
            if (obj.config.onChange || obj.config.onchange) {
                var sendObj = {
                    targetID: objID,
                    options: segmentOptions,
                    selectedIndex: obj.selectedSegmentIndex,
                    selectedOption: obj.selectedSegment
                };
                if (obj.config.onChange) obj.config.onChange.call(sendObj);
                else if (obj.config.onchange) obj.config.onchange.call(sendObj);
            }
            if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
            obj.bindTarget.change();
        }
    },
    bindSegmentSetValue: function (objID, objSeq, value) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        var selectedSegmentIndex = obj.selectedSegmentIndex;
        
        var objVal = value;
        var segmentOptions = obj.config.options;
        obj.selectedSegmentIndex = null;
        axf.each(segmentOptions, function (idx, seg) {
            if (this.optionValue == objVal) {
                obj.selectedSegmentIndex = idx;
                obj.selectedSegment = seg;
            }
        });
        if (obj.selectedSegmentIndex == null) {
            obj.selectedSegmentIndex = 0;
            obj.selectedSegment = segmentOptions[0];
        }
        axdom("#" + objID).val(obj.selectedSegment.optionValue);
        
        if (selectedSegmentIndex != obj.selectedSegmentIndex) {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SegmentHandle_AX_" + selectedSegmentIndex).removeClass("on");
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SegmentHandle_AX_" + obj.selectedSegmentIndex).addClass("on");
        }
        
        if (obj.config.onChange || obj.config.onchange) {
            var sendObj = {
                targetID: objID,
                options: segmentOptions,
                selectedIndex: obj.selectedSegmentIndex,
                selectedOption: obj.selectedSegment
            };
            if (obj.config.onChange) obj.config.onChange.call(sendObj);
            else if (obj.config.onchange) obj.config.onchange.call(sendObj);
        }
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        obj.bindTarget.change();
    },
    
    // date
    bindDate: function (objID, objSeq) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        if (!obj.bindAnchorTarget) obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        
        var h = obj.bindAnchorTarget.data("height");
        var po = [];
        po.push("<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle\" class=\"" + cfg.anchorDateHandleClassName + "\" style=\"right:0px;top:0px;width:" + h + "px;height:" + h + "px;\">&nbsp;</a>");
        obj.bindAnchorTarget.append(po.join(''));
        obj.bindAnchorTarget.show();
        
        var bindDateExpand = this.bindDateExpand.bind(this);
        var bindDateExpandClose = this.bindDateExpandClose.bind(this);
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle").unbind("click.AXInput").bind("click.AXInput", function (event) {
            if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
                bindDateExpandClose(objID, objSeq, event);
            }
            else {
                bindDateExpand(objID, objSeq, true, event);
            }
        });
        obj.bindTarget.unbind("focus.AXInput").bind("focus.AXInput", function (event) {
            setTimeout(function () {
                obj.bindTarget.select();
            }, 1);
        });
        
        var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
        
        //trace(obj.config);
        
        obj.bindTarget.unbind("keydown.AXInput").bind("keydown.AXInput", function (event) {
            var _this = this;
            setTimeout(function () {
                if (event.keyCode == axf.Event.KEY_RETURN) {
                    //bindDateInputBlur(objID, objSeq, event);
                    _this.blur();
                }
                else if (event.keyCode != AXUtil.Event.KEY_BACKSPACE && event.keyCode != AXUtil.Event.KEY_DELETE && event.keyCode != AXUtil.Event.KEY_LEFT && event.keyCode != AXUtil.Event.KEY_RIGHT) {
                    var va = _this.value.replace(/\D/gi, ""); //숫자 이외의 문자를 제거 합니다.
                    if (obj.config.selectType == "y") {
                        if (va.length > 4) _this.value = va.left(4);
                    }
                    else if (obj.config.selectType == "m") {
                        if (va.length == 4) {
                            va = va + separator;
                            _this.value = va;
                        }
                        else if (va.length > 4) {
                            va = va.substr(0, 4) + separator + va.substr(4, 2);
                            _this.value = va;
                        }
                    }
                    else {
                        if (va.length < 4) {
                            _this.value = va;
                        }
                        else if (va.length == 4) {
                            va = va + separator;
                            _this.value = va;
                        }
                        else if (va.length <= 6) {
                            va = va.substr(0, 4) + separator + va.substr(4, 2) + separator;
                            _this.value = va;
                        }
                        else if (va.length <= 8) {
                            va = va.substr(0, 4) + separator + va.substr(4, 2) + separator + va.substr(6, 2);
                            if (obj.config.expandTime) va += " ";
                            _this.value = va;
                        }
                        else {
                            if (obj.config.expandTime) {
                                if (va.length <= 10) {
                                    va = va.substr(0, 4) + separator + va.substr(4, 2) + separator + va.substr(6, 2) + " " + va.substr(8, 2) + ":";
                                    _this.value = va;
                                }
                                else if (va.length > 12) {
                                    va = va.substr(0, 4) + separator + va.substr(4, 2) + separator + va.substr(6, 2) + " " + va.substr(8, 2) + ":" + va.substr(10, 2);
                                    _this.value = va;
                                }
                            }
                            else {
                                va = va.substr(0, 4) + separator + va.substr(4, 2) + separator + va.substr(6, 2);
                                _this.value = va;
                            }
                        }
                    }
                }
            });
        });
        
        var bindDateInputBlur = this.bindDateInputBlur.bind(this);
        obj.bindTarget.unbind("blur.AXInput").bind("blur.AXInput", function (event) {
            bindDateInputBlur(objID, objSeq, event);
        });
        
        // config.expand : true, 속성 bindDateExpand
        if (obj.config.expand === true) {
            bindDateExpand(objID, objSeq, true, event);
            setTimeout(function () {
                obj.bindTarget.focus();
            }, 100);
        }
    },
    bindDateExpand: function (objID, objSeq, isToggle, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }
        
        for (var OO, oidx = 0, __arr = this.objects; (oidx < __arr.length && (OO = __arr[oidx])); oidx++) {
            if (OO.expandBox_axdom) {
                OO.expandBox_axdom.remove();
                OO.expandBox_axdom = null;
            }
        }
        
        if (AXUtil.clientWidth() < cfg.responsiveMobile) {
            this.bindDateExpandMobile(objID, objSeq, isToggle, event);
            return;
            /* 클라이언트 너비가 모바일 너비이면 프로세스 중지 */
        }
        var obj = this.objects[objSeq];
        var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
        
        //Selector Option box Expand
        if (isToggle) { // 활성화 여부가 토글 이면
            if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Handle").removeClass("on");
                //비활성 처리후 메소드 종료
                return;
            }
        }
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 활성화 전에 개체 삭제 처리
        
        //Expand Box 생성 구문 작성
        var objVal = axdom("#" + objID).val(), objHours = "";
        if (obj.config.expandTime) obj.config.selectType == "d"; //시간 확장 시 selectType : d 로 고정
        
        var today = new Date();
        if (obj.config.selectType == "y") {
            if (objVal != "") {
                objVal = objVal.left(4) + separator + "01" + separator + "01";
            }
        }
        else if (obj.config.selectType == "m") {
            if (objVal != "") {
                objVal = objVal + separator + "02";
            }
        }
        
        var dfDate = (obj.config.defaultDate || "").date();
        var myDate = objVal.date(separator, dfDate);
        
        var myYear = myDate.getUTCFullYear();
        var myMonth = (myDate.getUTCMonth() + 1).setDigit(2);
        
        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandBox\" class=\"" + cfg.bindDateExpandBoxClassName + "\" style=\"z-index:5100;\">");
        po.push("	<div>");
        po.push("		<div class=\"dateControlBox\">");
        po.push("			<a " + obj.config.href + " class=\"yearbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_controlYear\">" + myYear + "년</a>");
        po.push("			<a " + obj.config.href + " class=\"monthbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_controlMonth\">" + myMonth + "월</a>");
        po.push("			<a " + obj.config.href + " class=\"prevbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandPrev\">P</a>");
        po.push("			<a " + obj.config.href + " class=\"nextbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandNext\">N</a>");
        po.push("		</div>");
        po.push("		<div class=\"dateDisplayBox\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_displayBox\"></div>");
        if (obj.config.expandTime) { //시간 선택 기능 확장시
            po.push("		<div class=\"timeDisplayBox\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_displayTimeBox\"></div>");
        }
        po.push("	</div>");
        po.push("</div>");
        
        axdom(document.body).append(po.join('')); // bindDateExpandBox append
        //axdom("#"+cfg.targetID + "_AX_" + objID+"_AX_Handle").addClass("on");
        
        // AXCalendar display
        obj.nDate = myDate;
        obj.mycalendar = new AXCalendar();
        obj.mycalendar.setConfig({
            targetID: cfg.targetID + "_AX_" + objID + "_AX_displayBox",
            basicDate: myDate,
            href: obj.config.href,
            minDate: obj.config.minDate,
            maxDate: obj.config.maxDate,
            onBeforeShowDay: obj.config.onBeforeShowDay
        });
        if (obj.config.expandTime) { //시간 선택 기능 확장시
            obj.nDate = myDate;
            var mycalendartimeChange = this.bindDateTimeChange.bind(this);
            obj.mycalendartimeChange = function (myTime) {
                mycalendartimeChange(objID, objSeq, myTime);
            };
            obj.mycalendartime = new AXCalendar();
            obj.mycalendartime.setConfig({
                targetID: cfg.targetID + "_AX_" + objID + "_AX_displayTimeBox",
                onChange: obj.mycalendartimeChange
            });
            var apm = "AM";
            var myTimes = myDate.print("hh:mi").split(":");
            var myHH = myTimes[0].number();
            var myMI = myTimes[1];
            
            if (myHH == 12 && myMI > 0) {
                apm = "PM";
            }
            else if (myHH > 12) {
                apm = "PM";
                myHH -= 12;
            }
            obj.mycalendartime.printTimePage(myHH.setDigit(2) + ":" + myMI.setDigit(2) + " " + apm);
        }
        
        var printDate = "";
        if (obj.config.selectType == "y") {
            obj.mycalendarPageType = "y";
            obj.mycalendar.printYearPage(myDate.print("yyyy"));
            printDate = myDate.print("yyyy");
            axdom("#" + objID).val(printDate);
        }
        else if (obj.config.selectType == "m") {
            obj.mycalendarPageType = "m";
            obj.mycalendar.printMonthPage(myDate);
            printDate = myDate.print("yyyy" + separator + "mm");
            axdom("#" + objID).val(printDate);
        }
        else {
            if (obj.config.defaultSelectType) {
                if (obj.config.defaultSelectType == "y") {
                    obj.mycalendarPageType = "y";
                    obj.mycalendar.printYearPage(myDate.print("yyyy"));
                }
                else if (obj.config.defaultSelectType == "m") {
                    obj.mycalendarPageType = "m";
                    obj.mycalendar.printMonthPage(myDate);
                }
                else {
                    obj.mycalendarPageType = "d";
                    obj.mycalendar.printDayPage(myDate);
                }
                printDate = myDate.print("yyyy" + separator + "mm" + separator + "dd");
                if (obj.config.expandTime) {
                    printDate += " " + myDate.print("hh:mi");
                }
                axdom("#" + objID).val(printDate);
                
            }
            else {
                obj.mycalendarPageType = "d";
                obj.mycalendar.printDayPage(myDate);
                printDate = myDate.print("yyyy" + separator + "mm" + separator + "dd");
                if (obj.config.expandTime) {
                    printDate += " " + myDate.print("hh:mi");
                }
                axdom("#" + objID).val(printDate);
            }
        }
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ AXCalendar display
        
        // expandBox set Position ~~~~~~~~~~~~~~~~~~~~~~~~~
        var expandBox = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox");
        var expBoxWidth = expandBox.outerWidth();
        var expBoxHeight = expandBox.outerHeight();
        var offset = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle").offset();
        var handleWidth = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle").width();
        var handleHeight = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle").height();
        
        var css = {};
        if (obj.config.align == "left") {
            css.left = offset.left.number() - expBoxWidth;
        }
        else if (obj.config.align == "center") {
            css.left = offset.left.number() - expBoxWidth / 2 + handleWidth;
        }
        else if (obj.config.align == "right") {
            css.left = offset.left.number() + handleWidth;
        }
        else {
            css.left = offset.left.number() + handleWidth;
        }
        if (obj.config.valign == "top") {
            css.top = offset.top;
        }
        else if (obj.config.valign == "middle") {
            css.top = offset.top.number() - expBoxHeight / 2 + handleWidth / 2;
        }
        else if (obj.config.valign == "bottom") {
            css.top = offset.top.number() - expBoxHeight + handleWidth;
        }
        else {
            css.top = offset.top;
        }
        
        if (obj.config.customPos != undefined) {
            css.top = css.top + obj.config.customPos.top;
            css.left = css.left + obj.config.customPos.left;
        }
        
        var pElement = expandBox.offsetParent();
        var pBox = {width: pElement.width(), height: pElement.height()};
        
        var clientHeight = (AXUtil.docTD == "Q") ? document.body.scrollHeight : document.documentElement.scrollHeight;
        var clienWidth = (AXUtil.docTD == "Q") ? document.body.scrollWidth : document.documentElement.scrollWidth;
        if (clienWidth > pBox.width) pBox.width = clienWidth;
        if (clientHeight > pBox.height) pBox.height = clientHeight;
        var _box = {width: expandBox.outerWidth() + 10, height: expandBox.outerHeight() + 10};
        
        if ((_box.height.number() + css.top.number()) > pBox.height) {
            css.top = css.top - ((_box.height.number() + css.top.number()) - pBox.height);
        }
        if (css.top < 0) {
            css.top = 0;
        }
        
        if ((_box.width.number() + css.left.number()) > pBox.width) {
            css.left = css.left - ((_box.width.number() + css.left.number()) - pBox.width);
        }
        if (css.left < 0) {
            css.left = 0;
        }
        
        expandBox.css(css);
        obj.expandBox_axdom = expandBox;
        
        // ~~~~~~~~~~~~~~~~~~~~~~~~~ expandBox set Position ~~~~~~~~~~~~~~~~~~~~~~~~~
        
        var bindDateExpandBoxClick = this.bindDateExpandBoxClick.bind(this);
        obj.documentclickEvent = function (event) {
            //trace(objID);
            bindDateExpandBoxClick(objID, objSeq, event);
        }
        var bindDateKeyup = this.bindDateKeyup.bind(this);
        obj.inputKeyup = function (event) {
            bindDateKeyup(objID, objSeq, event);
        }
        if (obj.config.selectType == "y") {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear").css({left: "70px"});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlMonth").hide();
        }
        
        //trace("event bind");
        axdom(document).unbind("click.AXInput").bind("click.AXInput", obj.documentclickEvent);
        axdom("#" + objID).bind("keydown.AXInput", obj.inputKeyup);
    },
    // -- bindDate for mobile
    bindDateExpandMobile: function (objID, objSeq, isToggle, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }
        
        axdom("#" + objID).unbind("keydown.AXInput").bind("keydown.AXInput", obj.inputKeyup);
        
        //Selector Option box Expand
        if (isToggle) { // 활성화 여부가 토글 이면
            if (obj.modal && obj.modal.opened) {
                obj.modal.close();
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Handle").removeClass("on");
                //비활성 처리후 메소드 종료
                return;
            }
        }
        
        /* mobile modal ready */
        obj.modal = new AXMobileModal();
        obj.modal.setConfig({
            addClass: "",
            height: (obj.config.expandTime) ? 532 : 388,
            width: 300,
            head: {},
            onclose: function () { }
        });
        
        var initBindDateMobileModal = this.initBindDateMobileModal.bind(this);
        var onLoad = function (modalObj) {
            initBindDateMobileModal(objID, objSeq, modalObj);
        };
        obj.modal.open(null, onLoad);
    },
    initBindDateMobileModal: function (objID, objSeq, modalObj) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
        
        //Expand Box 생성 구문 작성
        var objVal = axdom("#" + objID).val();
        if (obj.config.expandTime) obj.config.selectType == "d"; //시간 확장 시 selectType : d 로 고정			
        
        var today = new Date();
        if (obj.config.selectType == "y") {
            if (objVal != "") {
                objVal = objVal.left(4) + separator + "01" + separator + "01";
            }
        }
        else if (obj.config.selectType == "m") {
            if (objVal != "") {
                objVal = objVal + separator + "01";
            }
        }
        
        var dfDate = (obj.config.defaultDate || "").date();
        var myDate = objVal.date(separator, dfDate);
        
        var myYear = myDate.getFullYear();
        var myMonth = (myDate.getMonth() + 1).setDigit(2);
        
        /* head 만들기 */
        var headPo = [];
        /* 현재 선택된 메뉴 선택 하는 기능구현 필요 */
        headPo.push("<div class=\"AXDateControlBox\">");
        headPo.push("	<a " + obj.config.href + " class=\"AXDateControl yearbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_controlYear\">" + (AXConfig.AXInput.yearText || "{year}년").replace("{year}", myYear) + "</a>");
        headPo.push("	<a " + obj.config.href + " class=\"AXDateControl monthbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_controlMonth\">" + (AXConfig.AXInput.monthText || "{month}월").replace("{month}", myMonth) + "</a>");
        headPo.push("	<a " + obj.config.href + " class=\"AXDateControl prevbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandPrev\">P</a>");
        headPo.push("	<a " + obj.config.href + " class=\"AXDateControl nextbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandNext\">N</a>");
        headPo.push("</div>");
        
        var bodyPo = [];
        bodyPo.push('<div class="AXDateContainer">');
        bodyPo.push('<div class="AXDateDisplayBox" id="' + cfg.targetID + '_AX_' + objID + '_AX_displayBox"></div>');
        if (obj.config.expandTime) { //시간 선택 기능 확장시
            bodyPo.push('		<div class="AXTimeDisplayBox" id="' + cfg.targetID + '_AX_' + objID + '_AX_displayTimeBox"></div>');
        }
        bodyPo.push('</div>');
        
        var footPo = [];
        footPo.push('<div class="AXDateButtonBox" id="' + cfg.targetID + '_AX_' + objID + '_AX_buttonBox">');
        footPo.push('	<button class="AXButtonSmall W80 AXBindDateConfirm" type="button" id="' + cfg.targetID + '_AX_' + objID + '_AX_button_AX_confirm">' + (AXConfig.AXInput.confirmText || "확인") + '</button>');
        footPo.push('</div>');
        
        /* modal에 캘린더 장착 */
        modalObj.modalHead.empty();
        modalObj.modalHead.append(headPo.join(''));
        modalObj.modalBody.empty();
        modalObj.modalBody.append(bodyPo.join(''));
        modalObj.modalFoot.empty();
        modalObj.modalFoot.append(footPo.join(''));
        
        /* 캘린더 클래스 로드 */
        // AXCalendar display
        obj.nDate = myDate;
        obj.mycalendar = new AXCalendar();
        obj.mycalendar.setConfig({
            targetID: cfg.targetID + "_AX_" + objID + "_AX_displayBox",
            basicDate: myDate,
            href: obj.config.href
        });
        if (obj.config.expandTime) { //시간 선택 기능 확장시
            obj.nDate = myDate;
            var mycalendartimeChange = this.bindDateTimeChange.bind(this);
            obj.mycalendartimeChange = function (myTime) {
                mycalendartimeChange(objID, objSeq, myTime);
            };
            obj.mycalendartime = new AXCalendar();
            obj.mycalendartime.setConfig({
                targetID: cfg.targetID + "_AX_" + objID + "_AX_displayTimeBox",
                onChange: obj.mycalendartimeChange
            });
            var apm = "AM";
            var myTimes = myDate.print("hh:mi").split(":");
            var myHH = myTimes[0].number();
            var myMI = myTimes[1];
            
            if (myHH == 12 && myMI > 0) {
                apm = "PM";
            }
            else if (myHH > 12) {
                apm = "PM";
                myHH -= 12;
            }
            obj.mycalendartime.printTimePage(myHH.setDigit(2) + ":" + myMI.setDigit(2) + " " + apm);
        }
        
        var printDate = "";
        if (obj.config.selectType == "y") {
            obj.mycalendarPageType = "y";
            obj.mycalendar.printYearPage(myDate.print("yyyy"));
            printDate = myDate.print("yyyy");
            axdom("#" + objID).val(printDate);
        }
        else if (obj.config.selectType == "m") {
            obj.mycalendarPageType = "m";
            obj.mycalendar.printMonthPage(myDate);
            printDate = myDate.print("yyyy" + separator + "mm");
            axdom("#" + objID).val(printDate);
        }
        else {
            if (obj.config.defaultSelectType) {
                if (obj.config.defaultSelectType == "y") {
                    obj.mycalendarPageType = "y";
                    obj.mycalendar.printYearPage(myDate.print("yyyy"));
                }
                else if (obj.config.defaultSelectType == "m") {
                    obj.mycalendarPageType = "m";
                    obj.mycalendar.printMonthPage(myDate);
                }
                else {
                    obj.mycalendarPageType = "d";
                    obj.mycalendar.printDayPage(myDate);
                }
                printDate = myDate.print("yyyy" + separator + "mm" + separator + "dd");
                if (obj.config.expandTime) {
                    printDate += " " + myDate.print("hh:mi");
                }
                axdom("#" + objID).val(printDate);
                
            }
            else {
                obj.mycalendarPageType = "d";
                obj.mycalendar.printDayPage(myDate);
                printDate = myDate.print("yyyy" + separator + "mm" + separator + "dd");
                if (obj.config.expandTime) {
                    printDate += " " + myDate.print("hh:mi");
                }
                axdom("#" + objID).val(printDate);
            }
        }
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ AXCalendar display
        
        // control event bind
        var _this = this;
        /*var bindDateMobileModalHeadClick = this.bindDateMobileModalHeadClick.bind(this);*/
        modalObj.modalHead.unbind("click.AXInput").bind("click.AXInput", function (event) {
            _this.bindDateMobileModalHeadClick(objID, objSeq, event);
        });
        /*var bindDateMobileModalBodyClick = this.bindDateMobileModalBodyClick.bind(this);*/
        modalObj.modalBody.unbind("click.AXInput").bind("click.AXInput", function (event) {
            _this.bindDateMobileModalBodyClick(objID, objSeq, event);
        });
        /*var bindDateMobileModalFootClick = this.bindDateMobileModalFootClick.bind(this);*/
        modalObj.modalFoot.unbind("click.AXInput").bind("click.AXInput", function (event) {
            _this.bindDateMobileModalFootClick(objID, objSeq, event);
        });
        // control event bind
    },
    bindDateMobileModalHeadClick: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            until: function (evt, evtIDs) { return (axdom(evt.parentNode).hasClass("AXDateControlBox")) ? true : false; },
            find: function (evt, evtIDs) { return (axdom(evt).hasClass("AXDateControl")) ? true : false; }
        });
        if (myTarget) {
            var act = myTarget.id.split(/_AX_/g).last();
            var nDate = obj.nDate;
            
            if (act == "controlYear") {
                this.bindDateChangePage(objID, objSeq, nDate, "y");
            }
            else if (act == "controlMonth") {
                if (obj.config.selectType != "y") {
                    this.bindDateChangePage(objID, objSeq, nDate, "m");
                }
            }
            else if (act == "expandPrev") {
                if (obj.mycalendarPageType == "d") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(-1, "m"), "d");
                }
                else if (obj.mycalendarPageType == "m") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(-1, "y"), "m");
                }
                else if (obj.mycalendarPageType == "y") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(-12, "y"), "y");
                }
            }
            else if (act == "expandNext") {
                if (obj.mycalendarPageType == "d") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(1, "m"), "d");
                }
                else if (obj.mycalendarPageType == "m") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(1, "y"), "m");
                }
                else if (obj.mycalendarPageType == "y") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(12, "y"), "y");
                }
            }
        }
    },
    bindDateMobileModalBodyClick: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            until: function (evt, evtIDs) { return (axdom(evt.parentNode).hasClass("AXDateContainer")) ? true : false; },
            find: function (evt, evtIDs) { return (axdom(evt).hasClass("calendarDate") || axdom(evt).hasClass("calendarMonth")) ? true : false; }
        });
        if (myTarget) {
            var ids = myTarget.id.split(/_AX_/g);
            var act = ids.last();
            var nDate = obj.nDate;
            var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
            if (act == "date") {
                //trace(ids[ids.length-2]);
                obj.nDate = ids[ids.length - 2].date();
                var printDate = obj.nDate.print("yyyy" + separator + "mm" + separator + "dd");
                if (obj.config.expandTime) {
                    printDate += " " + obj.mycalendartime.getTime();
                }
                axdom("#" + objID).val(printDate);
                //obj.modal.close();
                this.bindDateExpandClose(objID, objSeq, event);
            }
            else if (act == "month") {
                var myMonth = ids[ids.length - 2].number() - 1;
                if (obj.config.selectType == "m") {
                    var yy = nDate.getFullYear();
                    var dd = 1;
                    obj.nDate = new Date(Date.UTC(yy, myMonth, dd));
                    //obj.modal.close();
                    this.bindDateExpandClose(objID, objSeq, event);
                }
                else {
                    var yy = nDate.getFullYear();
                    var dd = 1;
                    obj.nDate = new Date(Date.UTC(yy, myMonth, dd));
                    this.bindDateChangePage(objID, objSeq, obj.nDate, "d");
                }
            }
            else if (act == "year") {
                var myYear = ids[ids.length - 2];
                if (obj.config.selectType == "y") {
                    var mm = 0;
                    var dd = 1;
                    obj.nDate = new Date(Date.UTC(myYear, mm, dd));
                    //obj.modal.close();
                    this.bindDateExpandClose(objID, objSeq, event);
                }
                else {
                    var mm = 0;
                    var dd = 1;
                    obj.nDate = new Date(Date.UTC(myYear, mm, dd));
                    this.bindDateChangePage(objID, objSeq, obj.nDate, "m");
                }
            }
            
        }
    },
    bindDateMobileModalFootClick: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            until: function (evt, evtIDs) { return (axdom(evt.parentNode).hasClass("AXDateButtonBox")) ? true : false; },
            find: function (evt, evtIDs) { return (axdom(evt).hasClass("AXBindDateConfirm")) ? true : false; }
        });
        if (myTarget) {
            var act = myTarget.id.split(/_AX_/g).last();
            if (act == "confirm") {
                obj.modal.close();
            }
        }
    },
    // -- bindDate for mobile
    bindDateExpandClose: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        
        if (!obj) {
            //비활성 처리후 메소드 종료
            axdom(document).unbind("click.AXInput");
            //axdom("#" + objID).unbind("keydown.AXInput");
            return;
        }
        
        if (obj.modal && obj.modal.opened) { /* mobile modal close */
            var objVal = axdom("#" + objID).val();
            if (objVal == "") {
                
            }
            else {
                var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
                if (obj.config.selectType == "y") {
                    axdom("#" + objID).val(obj.nDate.print("yyyy"));
                }
                else if (obj.config.selectType == "m") {
                    axdom("#" + objID).val(obj.nDate.print("yyyy" + separator + "mm"));
                }
                else {
                    //axdom("#"+objID).val(obj.nDate.print("yyyy"+separator+"mm"+separator+"dd"));
                    printDate = obj.nDate.print("yyyy" + separator + "mm" + separator + "dd");
                    if (obj.config.expandTime) {
                        printDate += " " + obj.mycalendartime.getTime();
                    }
                    axdom("#" + objID).val(printDate);
                }
            }
            
            if (!obj.config.onChange) obj.config.onChange = obj.config.onchange;
            
            if (obj.config.onChange) {
                if (axdom.isFunction(obj.config.onChange)) {
                    obj.config.onChange.call({
                        objID: objID,
                        value: axdom("#" + objID).val()
                    });
                }
                else {
                    var st_date, ed_date;
                    if (obj.config.onChange.earlierThan) {
                        st_date = axdom("#" + objID).val();
                        ed_date = axdom("#" + obj.config.onChange.earlierThan).val();
                    }
                    else if (obj.config.onChange.laterThan) {
                        ed_date = axdom("#" + objID).val();
                        st_date = axdom("#" + obj.config.onChange.laterThan).val();
                    }
                    if (st_date != "" && ed_date != "") {
                        if (st_date.date().diff(ed_date) < 0) {
                            this.msgAlert(obj.config.onChange.err);
                            axdom("#" + objID).val("");
                            return;
                        }
                    }
                    
                    obj.config.onChange.onChange.call({
                        objID: objID,
                        value: axdom("#" + objID).val(),
                        eventType: "expandClose"
                    });
                }
            }
            
            if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
            obj.bindTarget.trigger("change");
            
            obj.modal.close();
            //axdom("#" + objID).unbind("keydown.AXInput");
            
            //비활성 처리후 메소드 종료
            axdom(document).unbind("click.AXInput");
            //axdom("#" + objID).unbind("keydown.AXInput");
            return;
        }
        if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
            //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
            var objVal = axdom("#" + objID).val();
            
            if (objVal == "") {
                
            }
            else {
                var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
                if (obj.config.selectType == "y") {
                    axdom("#" + objID).val(obj.nDate.print("yyyy"));
                }
                else if (obj.config.selectType == "m") {
                    axdom("#" + objID).val(obj.nDate.print("yyyy" + separator + "mm"));
                }
                else {
                    //axdom("#"+objID).val(obj.nDate.print("yyyy"+separator+"mm"+separator+"dd"));
                    printDate = obj.nDate.print("yyyy" + separator + "mm" + separator + "dd");
                    if (obj.config.expandTime) {
                        printDate += " " + obj.mycalendartime.getTime();
                    }
                    axdom("#" + objID).val(printDate);
                }
            }
            
            if (!obj.config.onChange) obj.config.onChange = obj.config.onchange;
            
            if (obj.config.onChange) {
                if (axdom.isFunction(obj.config.onChange)) {
                    obj.config.onChange.call({
                        objID: objID,
                        value: axdom("#" + objID).val()
                    });
                }
                else {
                    var st_date, ed_date;
                    if (obj.config.onChange.earlierThan) {
                        st_date = axdom("#" + objID).val();
                        ed_date = axdom("#" + obj.config.onChange.earlierThan).val();
                    }
                    else if (obj.config.onChange.laterThan) {
                        ed_date = axdom("#" + objID).val();
                        st_date = axdom("#" + obj.config.onChange.laterThan).val();
                    }
                    if (st_date != "" && ed_date != "") {
                        if (st_date.date().diff(ed_date) < 0) {
                            this.msgAlert(obj.config.onChange.err);
                            axdom("#" + objID).val("");
                            return;
                        }
                    }
                    if (obj.config.onChange.onChange) {
                        obj.config.onChange.onChange.call({
                            objID: objID,
                            value: axdom("#" + objID).val()
                        });
                    }
                    else if (obj.config.onChange.onchange) {
                        obj.config.onChange.onchange.call({
                            objID: objID,
                            value: axdom("#" + objID).val()
                        });
                    }
                }
            }
            if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
            obj.bindTarget.trigger("change");
            
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리
            obj.expandBox_axdom = null;
            obj.mycalendartime = null;
            
            //비활성 처리후 메소드 종료
            axdom(document).unbind("click.AXInput");
            //axdom("#" + objID).unbind("keydown.AXInput");
            
            event.stopPropagation(); // disableevent
            return;
        }
    },
    bindDateInputBlur: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var objVal = axdom("#" + objID).val();
        /*
         if(obj.config.expand === true) {
         //return false;
         }
         */
        
        if (objVal == "") {
            
        }
        else {
            var clearDate = false;
            var nDate = (obj.nDate || new Date());
            var va = axdom("#" + objID).val().replace(/\D/gi, ""); //숫자 이외의 문자를 제거 합니다.
            if (va.search(/\d+/g) == -1) {
                clearDate = true;
            }
            
            if (clearDate) {
                axdom("#" + objID).val("");
            }
            else {
                var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
                if (obj.config.selectType == "y") {
                    
                    var yy = va.left(4).number();
                    if (yy == 0) yy = nDate.getFullYear();
                    if (yy < 1000) yy += 2000;
                    var mm = nDate.getMonth();
                    var dd = nDate.getDate();
                    obj.nDate = new Date(Date.UTC(yy, mm, dd, 12));
                    
                    axdom("#" + objID).val(obj.nDate.print("yyyy"));
                    
                }
                else if (obj.config.selectType == "m") {
                    
                    if (va.length > 4) {
                        var yy = va.left(4).number();
                        var mm = va.substr(4, 2).number() - 1;
                        var dd = 1;
                    }
                    else {
                        var yy = va.left(4).number();
                        var mm = 0;
                        var dd = 1;
                    }
                    if (yy == 0) yy = nDate.getFullYear();
                    if (yy < 1000) yy += 2000;
                    obj.nDate = new Date(Date.UTC(yy, mm, dd, 12));
                    
                    axdom("#" + objID).val(obj.nDate.print("yyyy" + separator + "mm"));
                    
                }
                else {
                    var needAlert = false;
                    if (va.length > 5) {
                        var yy = va.left(4).number();
                        var mm = va.substr(4, 2).number() - 1;
                        var dd = va.substr(6, 2).number();
                    }
                    else if (va.length > 3) {
                        var yy = "20" + va.substr(0, 2);
                        var mm = va.substr(2, 2).number() - 1;
                        var dd = va.substr(4, 2).number();
                    }
                    else if (va.length > 2) {
                        var yy = nDate.getFullYear();
                        var mm = va.substr(0, 2).number() - 1;
                        var dd = va.substr(2, 2).number();
                    }
                    else {
                        var yy = nDate.getFullYear(); //va.left(4).number();
                        var mm = nDate.getMonth();
                        var dd = va.substr(0, 2).number();
                    }
                    if (yy == 0) needAlert = true;
                    if (yy == 0) yy = nDate.getFullYear();
                    if (yy < 1000) yy += 2000;
                    
                    obj.nDate = new Date(Date.UTC(yy, mm, dd, 12));
                    
                    //trace(obj.nDate.getFullYear() != yy.number());
                    //trace(obj.nDate.getMonth() != mm.number());
                    //trace(obj.nDate.getDate(), dd.number());
                    
                    if (obj.nDate.getFullYear() != yy.number()
                        || obj.nDate.getMonth() != mm.number()
                        || obj.nDate.getDate() != dd.number())
                    {
                        needAlert = true;
                        obj.nDate = new Date();
                    }
                    
                    printDate = obj.nDate.print("yyyy" + separator + "mm" + separator + "dd");
                    
                    if (obj.config.expandTime) {
                        var hh, mi;
                        try {
                            printDate += " " + obj.mycalendartime.getTime();
                            trace(printDate);
                            
                        } catch (e) {
                            if (va.length > 11) { // hh,mm
                                hh = va.substr(8, 2).number();
                                mi = va.substr(10, 2).number();
                            }
                            else if (va.length > 9) {
                                hh = va.substr(8, 2).number();
                                mi = "00";
                            }
                            else {
                                hh = "12";
                                mi = "00";
                            }
                            printDate += " " + hh.setDigit(2) + ":" + mi.setDigit(2);
                        }
                    }
                    
                    if (needAlert) {
                        this.msgAlert("날짜 형식이 올바르지 않습니다.");
                    }
                    axdom("#" + objID).val(printDate);
                }
            }
        }
        
        if (!obj.config.onChange) obj.config.onChange = obj.config.onchange;
        if (obj.config.onChange) {
            
            if (axdom("#" + objID).data("val") && axdom("#" + objID).data("val") != axdom("#" + objID).val()) {
                
                if (axdom.isFunction(obj.config.onChange)) {
                    obj.config.onChange.call({
                        objID: objID,
                        value: axdom("#" + objID).val()
                    });
                }
                else {
                    var st_date, ed_date;
                    if (obj.config.onChange.earlierThan) {
                        st_date = axdom("#" + objID).val();
                        ed_date = axdom("#" + obj.config.onChange.earlierThan).val();
                    }
                    else if (obj.config.onChange.laterThan) {
                        ed_date = axdom("#" + objID).val();
                        st_date = axdom("#" + obj.config.onChange.laterThan).val();
                    }
                    if (st_date != "" && ed_date != "") {
                        if (st_date.date().diff(ed_date) < 0) {
                            this.msgAlert(obj.config.onChange.err);
                            axdom("#" + objID).val("");
                        }
                    }
                    
                    obj.config.onChange.onChange.call({
                        objID: objID,
                        value: axdom("#" + objID).val(),
                        eventType: "blur"
                    });
                }
                axdom("#" + objID).data("val", axdom("#" + objID).val());
                
            }
        }

        /*
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        obj.bindTarget.trigger("change");
        */

        /* ie10 버그
         axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리
         
         //비활성 처리후 메소드 종료
         axdom(document).unbind("click.AXInput");
         axdom("#" + objID).unbind("keydown.AXInput");
         */
        
        event.stopPropagation(); // disableevent
        return;
    },
    unbindDate: function (obj) {
        var cfg = this.config;
        var objID = obj.id;
        var objSeq = null;
        
        axf.each(this.objects, function (oidx, O) {
            if (this.id == objID) {
                objSeq = oidx;
                return false;
            }
        });
        
        if (objSeq != null) {
            var obj = this.objects[objSeq];
            
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리
            
            //비활성 처리후 메소드 종료
            axdom(document).unbind("click.AXInput");
            axdom("#" + objID).unbind("keydown.AXInput");
        }
        
        var collect = [];
        var removeAnchorId;
        axf.each(this.objects, function () {
            if (this.id != obj.id) collect.push(this);
            else {
                removeAnchorId = this.anchorID;
            }
        });
        this.objects = collect;
        
        axdom("#" + removeAnchorId).remove();
        
    },
    bindDateTimeChange: function (objID, objSeq, myTime) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
        var printDate = obj.nDate.print("yyyy" + separator + "mm" + separator + "dd");
        if (obj.config.expandTime) {
            printDate += " " + obj.mycalendartime.getTime();
        }
        axdom("#" + objID).val(printDate);
    },
    bindDateExpandBoxClick: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var isDateClick = false;
        
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget,
            until: function (evt, evtIDs) {
                return (evt.parentNode.tagName == "BODY") ? true : false;
            },
            find: function (evt, evtIDs) {
                if (!evt.id) return false;
                var checkID = cfg.targetID + "_AX_" + objID;
                if (evt.id == objID || evt.id.substr(0, checkID.length) == checkID) {
                    return true;
                }
                else {
                    return false;
                }
            }
        });
        
        isDateClick = (myTarget) ? true : false;
        if (!isDateClick) {
            this.bindDateExpandClose(objID, objSeq, event);
        }
        else {
            if (axdom(myTarget).hasClass("disabled")) {
                return;
            } // disabled 대상은 선택 불가
            
            var ids = myTarget.id.split(/_AX_/g);
            var ename = ids.last();
            
            var nDate = obj.nDate;
            var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
            if (ename == "expandPrev") {
                if (obj.mycalendarPageType == "d") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(-1, "m"), "d");
                }
                else if (obj.mycalendarPageType == "m") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(-1, "y"), "m");
                }
                else if (obj.mycalendarPageType == "y") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(-12, "y"), "y");
                }
            }
            else if (ename == "expandNext") {
                if (obj.mycalendarPageType == "d") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(1, "m"), "d");
                }
                else if (obj.mycalendarPageType == "m") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(1, "y"), "m");
                }
                else if (obj.mycalendarPageType == "y") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(12, "y"), "y");
                }
            }
            else if (ename == "controlYear") {
                this.bindDateChangePage(objID, objSeq, nDate, "y");
            }
            else if (ename == "controlMonth") {
                if (obj.config.selectType != "y") {
                    this.bindDateChangePage(objID, objSeq, nDate, "m");
                }
            }
            else if (ename == "date") {
                //trace(ids[ids.length-2]);
                obj.nDate = ids[ids.length - 2].date();
                var printDate = obj.nDate.print("yyyy" + separator + "mm" + separator + "dd");
                if (obj.config.expandTime) {
                    printDate += " " + obj.mycalendartime.getTime();
                }
                axdom("#" + objID).val(printDate);
                this.bindDateExpandClose(objID, objSeq, event);
            }
            else if (ename == "month") {
                var myMonth = ids[ids.length - 2].number() - 1;
                if (obj.config.selectType == "m") {
                    var yy = nDate.getFullYear();
                    var dd = 1;
                    obj.nDate = new Date(Date.UTC(yy, myMonth, dd, 12));
                    this.bindDateExpandClose(objID, objSeq, event);
                }
                else {
                    var yy = nDate.getFullYear();
                    var dd = 1;
                    obj.nDate = new Date(Date.UTC(yy, myMonth, dd, 12));
                    this.bindDateChangePage(objID, objSeq, obj.nDate, "d");
                }
            }
            else if (ename == "year") {
                var myYear = ids[ids.length - 2];
                if (obj.config.selectType == "y") {
                    var mm = 0;
                    var dd = 1;
                    obj.nDate = new Date(Date.UTC(myYear, mm, dd, 12));
                    this.bindDateExpandClose(objID, objSeq, event);
                }
                else {
                    var mm = 0;
                    var dd = 1;
                    obj.nDate = new Date(Date.UTC(myYear, mm, dd, 12));
                    this.bindDateChangePage(objID, objSeq, obj.nDate, "m");
                }
            }
        }
    },
    bindDateKeyup: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        if (obj.config.selectType == "y") {
            
        }
        else if (obj.config.selectType == "m") {
            
        }
        else {
            
        }
    },
    bindDateChangePage: function (objID, objSeq, setDate, pageType) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
        
        if (pageType == "m") {
            //alert(setDate);
            obj.mycalendarPageType = "m";
            obj.nDate = setDate;
            obj.mycalendar.printMonthPage(setDate);
            var myYear = setDate.getFullYear();
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear").html(myYear + "년");
        }
        else if (pageType == "y") {
            obj.mycalendarPageType = "y";
            obj.nDate = setDate;
            obj.mycalendar.printYearPage(setDate.getFullYear());
            var myYear = setDate.getFullYear();
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear").html(myYear + "년");
        }
        else {
            obj.mycalendarPageType = "d";
            obj.nDate = setDate;
            obj.mycalendar.printDayPage(setDate);
            var myYear = setDate.getFullYear();
            var myMonth = (setDate.getMonth() + 1).setDigit(2);
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear").html(myYear + "년");
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlMonth").html(myMonth + "월");
        }
        
        if (obj.config.selectType == "y") {
            axdom("#" + objID).val(obj.nDate.print("yyyy"));
        }
        else if (obj.config.selectType == "m") {
            axdom("#" + objID).val(obj.nDate.print("yyyy" + separator + "mm"));
        }
        else {
            //axdom("#"+objID).val(obj.nDate.print("yyyy"+separator+"mm"+separator+"dd"));
            var printDate = obj.nDate.print("yyyy" + separator + "mm" + separator + "dd");
            if (obj.config.expandTime) {
                printDate += " " + obj.mycalendartime.getTime();
            }
            axdom("#" + objID).val(printDate);
        }
    },
    
    // twinDate
    bindTwinDate: function (objID, objSeq, option) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        if (!obj.bindAnchorTarget) obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        obj.bindTargetStart = axdom("#" + obj.config.startTargetID);
        
        var h = obj.bindAnchorTarget.data("height");
        var po = [];
        var handleLeft = 0;
        if (obj.config) handleLeft = (obj.config.handleLeft || 0).number();
        
        po.push("<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle\" class=\"" + cfg.anchorDateHandleClassName + "\" style=\"right:" + (0 - handleLeft) + "px;top:0px;width:" + h + "px;height:" + h + "px;\">&nbsp;</a>");
        obj.bindAnchorTarget.append(po.join(''));
        obj.bindAnchorTarget.show();
        
        var bindDateExpand = this.bindTwinDateExpand.bind(this);
        var bindTwinDateExpandClose = this.bindTwinDateExpandClose.bind(this);
        
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle").unbind("click.AXInput").bind("click.AXInput", function (event) {
            if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
                bindTwinDateExpandClose(objID, objSeq, event);
            }
            else {
                bindDateExpand(objID, objSeq, true, event);
            }
        });
        obj.bindTarget.unbind("focus.AXInput").bind("focus.AXInput", function (event) {
            setTimeout(function () {
                obj.bindTarget.select();
            }, 1);
            /*
             if(!AXgetId(cfg.targetID + "_AX_"+objID+"_AX_expandBox")){
             bindDateExpand(objID, objSeq, false, event);
             }
             */
        });
        obj.bindTargetStart.unbind("focus.AXInput").bind("focus.AXInput", function (event) {
            setTimeout(function () {
                obj.bindTargetStart.select();
            }, 1);
            /*
             if(!AXgetId(cfg.targetID + "_AX_"+objID+"_AX_expandBox")){
             bindDateExpand(objID, objSeq, false, event);
             }
             */
        });
        
        var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
        axdom("#" + objID + ", #" + obj.config.startTargetID).unbind("keyup.AXInput").bind("keyup.AXInput", function (event) {
            //alert(this.value);
            if (event.keyCode == axf.Event.KEY_RETURN) {
                //bindDateInputBlur(objID, objSeq, event);
                this.blur();
            }
            else if (event.keyCode != AXUtil.Event.KEY_BACKSPACE && event.keyCode != AXUtil.Event.KEY_DELETE && event.keyCode != AXUtil.Event.KEY_LEFT && event.keyCode != AXUtil.Event.KEY_RIGHT) {
                
                var va = this.value.replace(/\D/gi, ""); //숫자 이외의 문자를 제거 합니다.
                var _this = this;
                
                if (obj.config.selectType == "y") {
                    if (va.length > 4) _this.value = va.left(4);
                }
                else if (obj.config.selectType == "m") {
                    if (va.length == 4) {
                        va = va + separator;
                        _this.value = va;
                    }
                    else if (va.length > 4) {
                        va = va.substr(0, 4) + separator + va.substr(4, 2);
                        _this.value = va;
                    }
                }
                else {
                    if (va.length < 4) {
                        _this.value = va;
                    }
                    else if (va.length <= 6) {
                        va = va.substr(0, 4) + separator + va.substr(4, 2);
                        _this.value = va;
                    }
                    else if (va.length <= 8) {
                        va = va.substr(0, 4) + separator + va.substr(4, 2) + separator + va.substr(6, 2);
                        _this.value = va;
                    }
                    else if (va.length <= 10) {
                        if (obj.config.expandTime) {
                            va = va.substr(0, 4) + separator + va.substr(4, 2) + separator + va.substr(6, 2) + " " + va.substr(8, 2);
                            _this.value = va;
                        }
                        else {
                            va = va.substr(0, 4) + separator + va.substr(4, 2) + separator + va.substr(6, 2);
                            _this.value = va;
                        }
                    }
                    else if (va.length > 10) {
                        if (obj.config.expandTime) {
                            va = va.substr(0, 4) + separator + va.substr(4, 2) + separator + va.substr(6, 2) + " " + va.substr(8, 2) + ":" + va.substr(10, 2);
                            _this.value = va;
                        }
                        else {
                            va = va.substr(0, 4) + separator + va.substr(4, 2) + separator + va.substr(6, 2);
                            _this.value = va;
                        }
                    }
                }
            }
        });
        
        var bindTwinDateInputBlur = this.bindTwinDateInputBlur.bind(this);
        obj.bindTarget.unbind("blur.AXInput").bind("blur.AXInput", function (event) {
            bindTwinDateInputBlur(objID, objSeq, event, 2);
        });
        axdom("#" + obj.config.startTargetID).unbind("blur.AXInput").bind("blur.AXInput", function (event) {
            bindTwinDateInputBlur(objID, objSeq, event, 1);
        });
        
        var objVal1 = obj.bindTargetStart.val();
        var objVal2 = obj.bindTarget.val();
        var myDate1 = objVal1.date(separator);
        var myDate2 = objVal2.date(separator);
        obj.nDate1 = myDate1;
        obj.nDate2 = myDate2;
    },
    bindTwinDateExpand: function (objID, objSeq, isToggle, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        
        for (var OO, oidx = 0, __arr = this.objects; (oidx < __arr.length && (OO = __arr[oidx])); oidx++) {
            if (OO.expandBox_axdom) {
                OO.expandBox_axdom.remove();
                OO.expandBox_axdom = null;
            }
        }
        
        var obj = this.objects[objSeq];
        
        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }
        
        var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
        
        //Selector Option box Expand
        if (isToggle) { // 활성화 여부가 토글 이면
            if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Handle").removeClass("on");
                //비활성 처리후 메소드 종료
                return;
            }
        }
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 활성화 전에 개체 삭제 처리
        //axdom("#"+cfg.targetID + "_AX_" + objID+"_AX_Handle").removeClass("on");
        
        //Expand Box 생성 구문 작성
        var objVal1 = axdom("#" + obj.config.startTargetID).val();
        var objVal2 = axdom("#" + objID).val();
        
        if (obj.config.expandTime) obj.config.selectType == "d"; //시간 확장 시 selectType : d 로 고정
        
        var today = new Date();
        var objVal1Empty = false;
        if (obj.config.selectType == "y") {
            if (objVal1 != "") {
                objVal1 = objVal1.left(4) + separator + "01" + separator + "02";
            }
            else {
                objVal1Empty = true;
            }
            if (objVal2 != "") {
                objVal2 = objVal2.left(4) + separator + "01" + separator + "02";
            }
        }
        else if (obj.config.selectType == "m") {
            if (objVal1 != "") {
                objVal1 = objVal1 + separator + "02";
            }
            else {
                objVal1Empty = true;
            }
            if (objVal2 != "") {
                objVal2 = objVal2 + separator + "02";
            }
        }
        if (AXUtil.isEmpty(objVal1)) {
            objVal1 = "";
            objVal1Empty = true;
        }
        
        /*var myDate1 = (objVal1Empty) ? objVal1.date(separator).add(-1, "m") : objVal1.date(separator);*/
        var myDate1 = objVal1.date(separator);
        var myDate2 = objVal2.date(separator);
        var myYear1 = myDate1.getFullYear();
        var myYear2 = myDate2.getFullYear();
        var myMonth1 = (myDate1.getMonth() + 1).setDigit(2);
        var myMonth2 = (myDate2.getMonth() + 1).setDigit(2);
        var buttonText = obj.config.buttonText || "OK";
        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandBox\" class=\"" + cfg.bindTwinDateExpandBoxClassName + "\" style=\"z-index:5100;\">");
        po.push("	<div>");
        po.push("		<table cellpadding=\"0\" cellspacing=\"0\">");
        po.push("			<tbody>");
        po.push("				<tr>");
        po.push("					<td style=\"padding-right:3px;\">");
        po.push("					<div class=\"dateTypeName\">START</div>");
        po.push("					<div class=\"dateControlBox\">");
        po.push("						<a " + obj.config.href + " class=\"yearbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_controlYear1\">" + myYear1 + "년</a>");
        po.push("						<a " + obj.config.href + " class=\"monthbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_controlMonth1\">" + myMonth1 + "월</a>");
        po.push("						<a " + obj.config.href + " class=\"prevbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandPrev1\">P</a>");
        po.push("						<a " + obj.config.href + " class=\"nextbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandNext1\">N</a>");
        po.push("					</div>");
        po.push("					<div class=\"dateDisplayBox\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_displayBox1\"></div>");
        if (obj.config.expandTime) { //시간 선택 기능 확장시
            po.push("					<div class=\"timeDisplayBox\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_displayTimeBox1\"></div>");
        }
        po.push("					</td>");
        po.push("					<td style=\"padding-left:3px;\">");
        po.push("					<div class=\"dateTypeName\">END</div>");
        po.push("					<div class=\"dateControlBox\">");
        po.push("						<a " + obj.config.href + " class=\"yearbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_controlYear2\">" + myYear2 + "년</a>");
        po.push("						<a " + obj.config.href + " class=\"monthbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_controlMonth2\">" + myMonth2 + "월</a>");
        po.push("						<a " + obj.config.href + " class=\"prevbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandPrev2\">P</a>");
        po.push("						<a " + obj.config.href + " class=\"nextbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandNext2\">N</a>");
        po.push("					</div>");
        po.push("					<div class=\"dateDisplayBox\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_displayBox2\"></div>");
        if (obj.config.expandTime) { //시간 선택 기능 확장시
            po.push("					<div class=\"timeDisplayBox\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_displayTimeBox2\"></div>");
        }
        po.push("					</td>");
        po.push("				</tr>");
        po.push("			</tbody>");
        po.push("		</table>");
        po.push("	</div>");
        po.push("	<div style=\"padding-top:5px;\" align=\"center\">");
        po.push("		<input type=\"button\" value=\"" + buttonText + "\" class=\"AXButton Classic W70\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_closeButton\">");
        po.push("	</div>");
        po.push("</div>");
        axdom(document.body).append(po.join('')); // bindDateExpandBox append
        //axdom("#"+cfg.targetID + "_AX_" + objID+"_AX_Handle").addClass("on");
        
        // AXCalendar display
        obj.nDate1 = myDate1;
        obj.mycalendar1 = new AXCalendar();
        obj.mycalendar1.setConfig({
            targetID: cfg.targetID + "_AX_" + objID + "_AX_displayBox1",
            basicDate: myDate1,
            minDate: obj.config.minDate,
            maxDate: obj.config.maxDate,
            onBeforeShowDay: obj.config.onBeforeShowDay
        });
        
        obj.nDate2 = myDate2;
        obj.mycalendar2 = new AXCalendar();
        obj.mycalendar2.setConfig({
            targetID: cfg.targetID + "_AX_" + objID + "_AX_displayBox2",
            basicDate: myDate2,
            minDate: obj.config.minDate,
            maxDate: obj.config.maxDate,
            onBeforeShowDay: obj.config.onBeforeShowDay
        });
        
        if (obj.config.expandTime) { //시간 선택 기능 확장시
            obj.nDate1 = myDate1;
            var mycalendartimeChange1 = this.bindTwinDateTimeChange.bind(this);
            obj.mycalendartimeChange1 = function (myTime) {
                mycalendartimeChange1(objID, objSeq, myTime, 1);
            };
            obj.mycalendartime1 = new AXCalendar();
            obj.mycalendartime1.setConfig({
                targetID: cfg.targetID + "_AX_" + objID + "_AX_displayTimeBox1",
                onChange: obj.mycalendartimeChange1
            });
            var apm = "AM";
            var myTimes = myDate1.print("hh:mi").split(":");
            var myHH = myTimes[0].number();
            var myMI = myTimes[1];
            if (myHH > 12) {
                apm = "PM";
                myHH -= 12;
            }
            obj.mycalendartime1.printTimePage(myHH.setDigit(2) + ":" + myMI.setDigit(2) + " " + apm);
            
            obj.nDate2 = myDate2;
            var mycalendartimeChange2 = this.bindTwinDateTimeChange.bind(this);
            obj.mycalendartimeChange2 = function (myTime) {
                mycalendartimeChange2(objID, objSeq, myTime, 2);
            };
            obj.mycalendartime2 = new AXCalendar();
            obj.mycalendartime2.setConfig({
                targetID: cfg.targetID + "_AX_" + objID + "_AX_displayTimeBox2",
                onChange: obj.mycalendartimeChange2
            });
            var apm = "AM";
            var myTimes = myDate2.print("hh:mi").split(":");
            var myHH = myTimes[0].number();
            var myMI = myTimes[1];
            if (myHH > 12) {
                apm = "PM";
                myHH -= 12;
            }
            obj.mycalendartime2.printTimePage(myHH.setDigit(2) + ":" + myMI.setDigit(2) + " " + apm);
        }
        
        var printDate1 = "";
        var printDate2 = "";
        if (obj.config.selectType == "y") {
            obj.mycalendarPageType = "y";
            obj.mycalendar1.printYearPage(myDate1.print("yyyy"));
            obj.mycalendar2.printYearPage(myDate2.print("yyyy"));
            printDate1 = myDate1.print("yyyy");
            printDate2 = myDate2.print("yyyy");
            axdom("#" + obj.config.startTargetID).val(printDate1);
            axdom("#" + objID).val(printDate2);
        }
        else if (obj.config.selectType == "m") {
            obj.mycalendarPageType = "m";
            obj.mycalendar1.printMonthPage(myDate1);
            obj.mycalendar2.printMonthPage(myDate2);
            printDate1 = myDate1.print("yyyy" + separator + "mm");
            printDate2 = myDate2.print("yyyy" + separator + "mm");
            axdom("#" + obj.config.startTargetID).val(printDate1);
            axdom("#" + objID).val(printDate2);
        }
        else {
            obj.mycalendarPageType = "d";
            obj.mycalendar1.printDayPage(myDate1);
            obj.mycalendar2.printDayPage(myDate2);
            printDate1 = myDate1.print("yyyy" + separator + "mm" + separator + "dd");
            printDate2 = myDate2.print("yyyy" + separator + "mm" + separator + "dd");
            if (obj.config.expandTime) {
                printDate1 += " " + myDate1.print("hh:mi");
                printDate2 += " " + myDate2.print("hh:mi");
            }
            axdom("#" + obj.config.startTargetID).val(printDate1);
            axdom("#" + objID).val(printDate2);
        }
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ AXCalendar display
        
        // expandBox set Position ~~~~~~~~~~~~~~~~~~~~~~~~~
        var expandBox = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox");
        var expBoxWidth = expandBox.outerWidth();
        var expBoxHeight = expandBox.outerHeight();
        var offset = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle").offset();
        var handleWidth = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle").width();
        var handleHeight = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle").height();
        
        var css = {};
        if (obj.config.align == "left") {
            css.left = offset.left.number() - expBoxWidth;
        }
        else if (obj.config.align == "center") {
            css.left = offset.left.number() - expBoxWidth / 2 + handleWidth;
        }
        else if (obj.config.align == "right") {
            css.left = offset.left.number() + handleWidth;
        }
        else {
            css.left = offset.left.number() + handleWidth;
        }
        if (obj.config.valign == "top") {
            css.top = offset.top;
        }
        else if (obj.config.valign == "middle") {
            css.top = offset.top.number() - expBoxHeight / 2 + handleWidth / 2;
        }
        else if (obj.config.valign == "bottom") {
            css.top = offset.top.number() - expBoxHeight + handleWidth;
        }
        else {
            css.top = offset.top;
        }
        
        if (obj.config.customPos != undefined) {
            css.top = css.top + obj.config.customPos.top;
            css.left = css.left + obj.config.customPos.left;
        }
        
        var pElement = expandBox.offsetParent();
        var pBox = {width: pElement.width(), height: pElement.height()};
        
        var clientHeight = (AXUtil.docTD == "Q") ? document.body.scrollHeight : document.documentElement.scrollHeight;
        var clienWidth = (AXUtil.docTD == "Q") ? document.body.scrollWidth : document.documentElement.scrollWidth;
        if (clienWidth > pBox.width) pBox.width = clienWidth;
        if (clientHeight > pBox.height) pBox.height = clientHeight;
        var _box = {width: expandBox.outerWidth() + 10, height: expandBox.outerHeight() + 10};
        
        if ((_box.height.number() + css.top.number()) > pBox.height) {
            css.top = css.top - ((_box.height.number() + css.top.number()) - pBox.height);
        }
        if (css.top < 0) {
            css.top = 0;
        }
        
        if ((_box.width.number() + css.left.number()) > pBox.width) {
            css.left = css.left - ((_box.width.number() + css.left.number()) - pBox.width);
        }
        if (css.left < 0) {
            css.left = 0;
        }
        
        expandBox.css(css);
        obj.expandBox_axdom = expandBox;
        
        // ~~~~~~~~~~~~~~~~~~~~~~~~~ expandBox set Position ~~~~~~~~~~~~~~~~~~~~~~~~~
        
        var bindTwinDateExpandBoxClick = this.bindTwinDateExpandBoxClick.bind(this);
        obj.documentclickEvent = function (event) {
            bindTwinDateExpandBoxClick(objID, objSeq, event);
        }
        var bindTwinDateKeyup = this.bindTwinDateKeyup.bind(this);
        obj.inputKeyup = function (event) {
            bindTwinDateKeyup(objID, objSeq, event);
        }
        
        if (obj.config.selectType == "y") {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear1").css({left: "70px"});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlMonth1").hide();
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear2").css({left: "70px"});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlMonth2").hide();
        }
        
        axdom(document).unbind("click.AXInput").bind("click.AXInput", obj.documentclickEvent);
        axdom("#" + objID).unbind("keydown.AXInput").bind("keydown.AXInput", obj.inputKeyup);
        var bindTwinDateExpandClose = this.bindTwinDateExpandClose.bind(this);
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_closeButton").unbind("click.AXInput").bind("click.AXInput", function (event) {
            bindTwinDateExpandClose(objID, objSeq, event);
        });
    },
    bindTwinDateTimeChange: function (objID, objSeq, myTime, seq) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        if (seq == 1) {
            var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
            var printDate = obj.nDate1.print("yyyy" + separator + "mm" + separator + "dd");
            if (obj.config.expandTime) {
                printDate += " " + obj.mycalendartime1.getTime();
            }
            axdom("#" + obj.config.startTargetID).val(printDate);
        }
        else {
            var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
            var printDate = obj.nDate2.print("yyyy" + separator + "mm" + separator + "dd");
            if (obj.config.expandTime) {
                printDate += " " + obj.mycalendartime2.getTime();
            }
            axdom("#" + objID).val(printDate);
        }
    },
    bindTwinDateExpandClose: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        //trace("bindTwinDateExpandClose");
        if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
            
            //axdom("#"+cfg.targetID+"_AX_"+objID+"_AX_Handle").removeClass("on");
            //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
            var objVal1 = axdom("#" + obj.config.startTargetID).val();
            var objVal2 = axdom("#" + objID).val();
            var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
            
            if (obj.config.selectType == "y") {
                if (objVal1.length < 4) axdom("#" + obj.config.startTargetID).val(obj.nDate1.print("yyyy"));
                else {
                    objVal1 = objVal1.left(4);
                    axdom("#" + obj.config.startTargetID).val(objVal1);
                    axdom("#" + obj.config.startTargetID).trigger("change");
                }
                if (objVal2.length < 4) axdom("#" + objID).val(obj.nDate2.print("yyyy"));
                else {
                    objVal2 = objVal2.left(4);
                    axdom("#" + objID).val(objVal2);
                    axdom("#" + objID).trigger("change");
                }
            }
            else if (obj.config.selectType == "m") {
                axdom("#" + obj.config.startTargetID).val(obj.nDate1.print("yyyy" + separator + "mm"));
                axdom("#" + obj.config.startTargetID).trigger("change");
                axdom("#" + objID).val(obj.nDate2.print("yyyy" + separator + "mm"));
                axdom("#" + objID).trigger("change");
            }
            else {
                printDate1 = obj.nDate1.print("yyyy" + separator + "mm" + separator + "dd");
                printDate2 = obj.nDate2.print("yyyy" + separator + "mm" + separator + "dd");
                if (obj.config.expandTime) {
                    printDate1 += " " + obj.mycalendartime1.getTime();
                    printDate2 += " " + obj.mycalendartime2.getTime();
                }
                axdom("#" + obj.config.startTargetID).val(printDate1);
                axdom("#" + objID).val(printDate2);
                axdom("#" + obj.config.startTargetID).trigger("change");
                axdom("#" + objID).trigger("change");
            }
            
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리
            
            if (!obj.config.onChange) obj.config.onChange = obj.config.onchange;
            if (obj.config.onChange) {
                obj.config.onChange.call({
                    ST_objID: obj.config.startTargetID,
                    ED_objID: objID,
                    ST_value: axdom("#" + obj.config.startTargetID).val(),
                    ED_value: axdom("#" + objID).val()
                });
            }
            if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
            obj.bindTarget.trigger("change");
            
            obj.expandBox_axdom = null;
            //비활성 처리후 메소드 종료
            axdom(document).unbind("click.AXInput");
            axdom("#" + objID).unbind("keydown.AXInput");
            
            event.stopPropagation(); // disableevent
            return;
        }
    },
    bindTwinDateExpandBoxClick: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var isDateClick = false;
        
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget,
            until: function (evt, evtIDs) {
                return (evt.parentNode.tagName == "body") ? true : false;
            },
            find: function (evt, evtIDs) {
                if (evt.id == "" || evt.id == null || evt.id == undefined) return false;
                if (evt.id == objID || evt.id == obj.config.startTargetID || (evt.id.substr(0, cfg.targetID.length) == cfg.targetID && (evt.id.search(objID) != -1 || evt.id.search(obj.config.startTargetID) != -1))) {
                    return true;
                }
                else {
                    return false;
                }
            }
        });
        
        isDateClick = (myTarget) ? true : false;
        if (!isDateClick) {
            this.bindTwinDateExpandClose(objID, objSeq, event);
        }
        else {
            if (axdom(myTarget).hasClass("disabled")) {
                return;
            } // disabled 대상은 선택 불가
            
            var ids = myTarget.id.split(/_AX_/g);
            var ename = ids.last();
            var boxType = ids[ids.length - 3];
            var nDate1 = obj.nDate1;
            var nDate2 = obj.nDate2;
            var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
            if (ename == "expandPrev1") {
                if (obj.mycalendarPageType == "d") {
                    this.bindTwinDateChangePage(objID, objSeq, 1, nDate1.add(-1, "m"), "d");
                }
                else if (obj.mycalendarPageType == "m") {
                    this.bindTwinDateChangePage(objID, objSeq, 1, nDate1.add(-1, "y"), "m");
                }
                else if (obj.mycalendarPageType == "y") {
                    this.bindTwinDateChangePage(objID, objSeq, 1, nDate1.add(-12, "y"), "y");
                }
            }
            else if (ename == "expandPrev2") {
                if (obj.mycalendarPageType == "d") {
                    this.bindTwinDateChangePage(objID, objSeq, 2, nDate2.add(-1, "m"), "d");
                }
                else if (obj.mycalendarPageType == "m") {
                    this.bindTwinDateChangePage(objID, objSeq, 2, nDate2.add(-1, "y"), "m");
                }
                else if (obj.mycalendarPageType == "y") {
                    this.bindTwinDateChangePage(objID, objSeq, 2, nDate2.add(-12, "y"), "y");
                }
            }
            else if (ename == "expandNext1") {
                if (obj.mycalendarPageType == "d") {
                    this.bindTwinDateChangePage(objID, objSeq, 1, nDate1.add(1, "m"), "d");
                }
                else if (obj.mycalendarPageType == "m") {
                    this.bindTwinDateChangePage(objID, objSeq, 1, nDate1.add(1, "y"), "m");
                }
                else if (obj.mycalendarPageType == "y") {
                    this.bindTwinDateChangePage(objID, objSeq, 1, nDate1.add(12, "y"), "y");
                }
            }
            else if (ename == "expandNext2") {
                if (obj.mycalendarPageType == "d") {
                    this.bindTwinDateChangePage(objID, objSeq, 2, nDate2.add(1, "m"), "d");
                }
                else if (obj.mycalendarPageType == "m") {
                    this.bindTwinDateChangePage(objID, objSeq, 2, nDate2.add(1, "y"), "m");
                }
                else if (obj.mycalendarPageType == "y") {
                    this.bindTwinDateChangePage(objID, objSeq, 2, nDate2.add(12, "y"), "y");
                }
            }
            else if (ename == "controlYear1") {
                this.bindTwinDateChangePage(objID, objSeq, 1, nDate1, "y");
            }
            else if (ename == "controlYear2") {
                this.bindTwinDateChangePage(objID, objSeq, 2, nDate2, "y");
            }
            else if (ename == "controlMonth1") {
                if (obj.config.selectType != "y") {
                    this.bindTwinDateChangePage(objID, objSeq, 1, nDate1, "m");
                }
            }
            else if (ename == "controlMonth2") {
                if (obj.config.selectType != "y") {
                    this.bindTwinDateChangePage(objID, objSeq, 2, nDate2, "m");
                }
            }
            else if (ename == "date") {
                if (boxType == "displayBox1") {
                    obj.nDate1 = ids[ids.length - 2].date();
                    var printDate = obj.nDate1.print("yyyy" + separator + "mm" + separator + "dd");
                    if (obj.config.expandTime) {
                        printDate += " " + obj.mycalendartime1.getTime();
                    }
                    axdom("#" + obj.config.startTargetID).val(printDate);
                    obj.mycalendar1.dayPageSetDay(obj.nDate1);
                }
                else {
                    obj.nDate2 = ids[ids.length - 2].date();
                    var printDate = obj.nDate2.print("yyyy" + separator + "mm" + separator + "dd");
                    if (obj.config.expandTime) {
                        printDate += " " + obj.mycalendartime2.getTime();
                    }
                    axdom("#" + objID).val(printDate);
                    obj.mycalendar2.dayPageSetDay(obj.nDate2);
                }
                
                if (obj.nDate1.diff(obj.nDate2) < 0) {
                    if (boxType == "displayBox1") {
                        obj.nDate2 = obj.nDate1;
                        var printDate = obj.nDate2.print("yyyy" + separator + "mm" + separator + "dd");
                        if (obj.config.expandTime) {
                            printDate += " " + obj.mycalendartime2.getTime();
                        }
                        axdom("#" + objID).val(printDate);
                        obj.mycalendar2.dayPageSetDay(obj.nDate2);
                    }
                    else {
                        obj.nDate1 = obj.nDate2;
                        var printDate = obj.nDate1.print("yyyy" + separator + "mm" + separator + "dd");
                        if (obj.config.expandTime) {
                            printDate += " " + obj.mycalendartime1.getTime();
                        }
                        axdom("#" + obj.config.startTargetID).val(printDate);
                        obj.mycalendar1.dayPageSetDay(obj.nDate1);
                    }
                }
                
            }
            else if (ename == "month") {
                var myMonth = ids[ids.length - 2].number() - 1;
                if (boxType == "displayBox1") {
                    if (obj.config.selectType == "m") {
                        var yy = nDate1.getFullYear();
                        var dd = nDate1.getDate();
                        obj.nDate1 = new Date(Date.UTC(yy, myMonth, dd));
                        var printDate = obj.nDate1.print("yyyy" + separator + "mm");
                        axdom("#" + obj.config.startTargetID).val(printDate);
                        //this.bindTwinDateExpandClose(objID, objSeq, event);
                        obj.mycalendar1.monthPageSetMonth(obj.nDate1);
                    }
                    else {
                        var yy = nDate1.getFullYear();
                        var dd = nDate1.getDate();
                        obj.nDate1 = new Date(Date.UTC(yy, myMonth, dd));
                        //trace("start ----");
                        this.bindTwinDateChangePage(objID, objSeq, 1, obj.nDate1, "d");
                    }
                }
                else {
                    if (obj.config.selectType == "m") {
                        var yy = nDate2.getFullYear();
                        var dd = nDate2.getDate();
                        obj.nDate2 = new Date(Date.UTC(yy, myMonth, dd));
                        var printDate = obj.nDate2.print("yyyy" + separator + "mm");
                        axdom("#" + objID).val(printDate);
                        obj.mycalendar2.monthPageSetMonth(obj.nDate2);
                    }
                    else {
                        var yy = nDate2.getFullYear();
                        var dd = nDate2.getDate();
                        obj.nDate2 = new Date(Date.UTC(yy, myMonth, dd));
                        this.bindTwinDateChangePage(objID, objSeq, 2, obj.nDate2, "d");
                    }
                }
                
                if (obj.config.selectType == "m") {
                    if (obj.nDate1.diff(obj.nDate2) < 0) {
                        obj.nDate2 = obj.nDate1;
                        var printDate = obj.nDate2.print("yyyy" + separator + "mm");
                        axdom("#" + objID).val(printDate);
                        axdom("#" + obj.config.startTargetID).val(printDate);
                        obj.mycalendar2.monthPageSetMonth(obj.nDate2);
                    }
                }
                
            }
            else if (ename == "year") {
                var myYear = ids[ids.length - 2];
                if (boxType == "displayBox1") {
                    if (obj.config.selectType == "y") {
                        var mm = nDate1.getMonth();
                        var dd = nDate1.getDate();
                        obj.nDate1 = new Date(Date.UTC(myYear, mm, dd));
                        var printDate = obj.nDate1.print("yyyy");
                        axdom("#" + obj.config.startTargetID).val(printDate);
                        //this.bindTwinDateExpandClose(objID, objSeq, event);
                        obj.mycalendar1.yearPageSetYear(obj.nDate1);
                    }
                    else {
                        var mm = nDate1.getMonth();
                        var dd = nDate1.getDate();
                        obj.nDate1 = new Date(Date.UTC(myYear, mm, dd));
                        this.bindTwinDateChangePage(objID, objSeq, 1, obj.nDate1, "m");
                    }
                }
                else {
                    if (obj.config.selectType == "y") {
                        var mm = nDate2.getMonth();
                        var dd = nDate2.getDate();
                        obj.nDate2 = new Date(Date.UTC(myYear, mm, dd));
                        var printDate = obj.nDate2.print("yyyy");
                        axdom("#" + objID).val(printDate);
                        //this.bindTwinDateExpandClose(objID, objSeq, event);
                        obj.mycalendar2.yearPageSetYear(obj.nDate2);
                    }
                    else {
                        var mm = nDate2.getMonth();
                        var dd = nDate2.getDate();
                        obj.nDate2 = new Date(Date.UTC(myYear, mm, dd));
                        this.bindTwinDateChangePage(objID, objSeq, 2, obj.nDate2, "m");
                    }
                }
                
                if (obj.config.selectType == "y") {
                    if (obj.nDate1.print("yyyy").number() > obj.nDate2.print("yyyy").number()) {
                        obj.nDate2 = obj.nDate1;
                        var printDate = obj.nDate2.print("yyyy");
                        axdom("#" + obj.config.startTargetID).val(printDate);
                        axdom("#" + objID).val(printDate);
                        obj.mycalendar2.yearPageSetYear(obj.nDate2);
                    }
                }
            }
        }
    },
    bindTwinDateKeyup: function (objID, objSeq, event) {
        //trace(event.keyCode);
        if (obj.config.selectType == "y") {
            
        }
        else if (obj.config.selectType == "m") {
            
        }
        else {
            
        }
    },
    bindTwinDateChangePage: function (objID, objSeq, objType, setDate, pageType) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
        
        if (pageType == "m") {
            if (objType == 1) {
                //obj.mycalendarPageType = "m";
                obj.nDate1 = setDate;
                obj.mycalendar1.printMonthPage(setDate);
                var myYear = setDate.getFullYear();
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear1").html(myYear + "년");
            }
            else {
                //obj.mycalendarPageType = "m";
                obj.nDate2 = setDate;
                obj.mycalendar2.printMonthPage(setDate);
                var myYear = setDate.getFullYear();
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear2").html(myYear + "년");
            }
        }
        else if (pageType == "y") {
            if (objType == 1) {
                //obj.mycalendarPageType = "y";
                obj.nDate1 = setDate;
                obj.mycalendar1.printYearPage(setDate.getFullYear());
                var myYear = setDate.getFullYear();
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear1").html(myYear + "년");
            }
            else {
                //obj.mycalendarPageType = "y";
                obj.nDate2 = setDate;
                obj.mycalendar2.printYearPage(setDate.getFullYear());
                var myYear = setDate.getFullYear();
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear2").html(myYear + "년");
            }
        }
        else {
            //obj.mycalendarPageType = "d";
            
            //trace({objID:objID, objSeq:objSeq, objType:objType, setDate:setDate, pageType:pageType});
            
            if (objType == 1) {
                obj.nDate1 = setDate;
                obj.mycalendar1.printDayPage(setDate);
                var myYear = setDate.getFullYear();
                var myMonth = (setDate.getMonth() + 1).setDigit(2);
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear1").html(myYear + "년");
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlMonth1").html(myMonth + "월");
            }
            else {
                obj.nDate2 = setDate;
                obj.mycalendar2.printDayPage(setDate);
                var myYear = setDate.getFullYear();
                var myMonth = (setDate.getMonth() + 1).setDigit(2);
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear2").html(myYear + "년");
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlMonth2").html(myMonth + "월");
            }
        }
        
        if (objType == 1) {
            if (obj.config.selectType == "y") {
                axdom("#" + obj.config.startTargetID).val(obj.nDate1.print("yyyy"));
            }
            else if (obj.config.selectType == "m") {
                axdom("#" + obj.config.startTargetID).val(obj.nDate1.print("yyyy" + separator + "mm"));
            }
            else {
                var printDate = obj.nDate1.print("yyyy" + separator + "mm" + separator + "dd");
                if (obj.config.expandTime) {
                    printDate += " " + obj.mycalendartime1.getTime();
                }
                axdom("#" + obj.config.startTargetID).val(printDate);
            }
        }
        else {
            if (obj.config.selectType == "y") {
                axdom("#" + objID).val(obj.nDate2.print("yyyy"));
            }
            else if (obj.config.selectType == "m") {
                axdom("#" + objID).val(obj.nDate2.print("yyyy" + separator + "mm"));
            }
            else {
                var printDate = obj.nDate2.print("yyyy" + separator + "mm" + separator + "dd");
                if (obj.config.expandTime) {
                    printDate += " " + obj.mycalendartime2.getTime();
                }
                axdom("#" + objID).val(printDate);
            }
        }
    },
    bindTwinDateInputBlur: function (objID, objSeq, event, seq) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var objVal, targetObjID;
        if (seq == 1) {
            targetObjID = obj.config.startTargetID;
            objVal = axdom("#" + obj.config.startTargetID).val();
        }
        else {
            targetObjID = objID;
            objVal = axdom("#" + objID).val();
        }
        
        if (objVal == "") {
            
        }
        else {
            var clearDate = false;
            var nDate = (obj["nDate" + seq] || new Date());
            var va = axdom("#" + targetObjID).val().replace(/\D/gi, ""); //숫자 이외의 문자를 제거 합니다.
            if (va.search(/\d+/g) == -1) {
                clearDate = true;
            }
            
            if (clearDate) {
                axdom("#" + targetObjID).val("");
            }
            else {
                var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
                if (obj.config.selectType == "y") {
                    
                    var yy = va.left(4).number();
                    if (yy == 0) yy = nDate.getFullYear();
                    if (yy < 1000) yy += 2000;
                    var mm = nDate.getMonth();
                    var dd = nDate.getDate();
                    obj["nDate" + seq] = new Date(Date.UTC(yy, mm, dd, 12));
                    
                    axdom("#" + targetObjID).val(obj["nDate" + seq].print("yyyy"));
                    
                }
                else if (obj.config.selectType == "m")
                {
                    
                    if (va.length > 5) {
                        var yy = va.left(4).number();
                        var mm = va.substr(4, 2).number() - 1;
                        var dd = 1;
                    }
                    else {
                        var yy = va.left(4).number();
                        var mm = 0;
                        var dd = 1;
                    }
                    if (yy == 0) yy = nDate.getFullYear();
                    if (yy < 1000) yy += 2000;
                    obj["nDate" + seq] = new Date(Date.UTC(yy, mm, dd, 12));
                    
                    axdom("#" + targetObjID).val(obj["nDate" + seq].print("yyyy" + separator + "mm"));
                    
                }
                else {
                    var needAlert = false;
                    var yy, mm, dd, hh, mi;
                    if (va.length > 7) {
                        yy = va.left(4).number();
                        mm = va.substr(4, 2).number() - 1;
                        dd = va.substr(6, 2).number();
                    }
                    else if (va.length > 4) {
                        yy = "20" + va.substr(0, 2);
                        mm = va.substr(2, 2).number() - 1;
                        dd = va.substr(4, 2).number();
                    }
                    else if (va.length > 2) {
                        yy = nDate.getFullYear();
                        mm = va.substr(0, 2).number() - 1;
                        dd = va.substr(2, 2).number();
                    }
                    else {
                        yy = nDate.getFullYear(); //va.left(4).number();
                        mm = nDate.getMonth();
                        dd = va.substr(0, 2).number();
                    }
                    
                    if (va.length >= 9) {
                        hh = va.substr(8, 2).number();
                        mi = va.substr(10, 2).number();
                    }
                    else {
                        hh = "00";
                        mi = "00";
                    }
                    
                    if (yy == 0) needAlert = true;
                    if (yy == 0) yy = nDate.getFullYear();
                    if (yy < 1000) yy += 2000;
                    obj["nDate" + seq] = new Date(Date.UTC(yy, mm, dd, 12));
                    
                    if (obj["nDate" + seq].getFullYear() != yy.number()
                        || obj["nDate" + seq].getMonth() != mm.number()
                        || obj["nDate" + seq].getDate() != dd.number())
                    {
                        needAlert = true;
                        obj["nDate" + seq] = new Date();
                    }
                    
                    printDate = obj["nDate" + seq].print("yyyy" + separator + "mm" + separator + "dd");
                    if (obj.config.expandTime) {
                        printDate += " " + hh.setDigit(2) + ":" + mi.setDigit(2);
                    }
                    
                    if (needAlert) {
                        this.msgAlert("날짜 형식이 올바르지 않습니다.");
                    }
                    axdom("#" + targetObjID).val(printDate);
                    
                    if (obj.nDate1 == undefined) {
                        var va = axdom("#" + obj.config.startTargetID).val().replace(/\D/gi, ""); //숫자 이외의 문자를 제거 합니다.
                        if (va.search(/\d+/g) != -1) {
                            if (va.length > 7) {
                                var yy = va.left(4).number();
                                var mm = va.substr(4, 2).number() - 1;
                                var dd = va.substr(6, 2).number();
                            }
                            else if (va.length > 5) {
                                var yy = va.left(4).number();
                                var mm = va.substr(4, 2).number() - 1;
                                var dd = 1;
                            }
                            else {
                                var yy = va.left(4).number();
                                var mm = nDate.getMonth();
                                var dd = nDate.getDate();
                            }
                            if (yy == 0) needAlert = true;
                            if (yy == 0) yy = nDate.getFullYear();
                            if (yy < 1000) yy += 2000;
                            obj.nDate1 = new Date(Date.UTC(yy, mm, dd, 12));
                        }
                    }
                    if (obj.nDate2 == undefined) {
                        obj.nDate2 = obj.nDate1;
                        printDate = obj["nDate" + 2].print("yyyy" + separator + "mm" + separator + "dd");
                        if (obj.config.expandTime) {
                            if (obj["mycalendartime" + 2]) printDate += " " + obj["mycalendartime" + 2].getTime();
                        }
                        axdom("#" + objID).val(printDate);
                    }
                    
                    if (obj.nDate1.diff(obj.nDate2) < 0) {
                        if (seq == 1) {
                            obj.nDate2 = obj.nDate1;
                            printDate = obj["nDate" + 2].print("yyyy" + separator + "mm" + separator + "dd");
                            if (obj.config.expandTime) {
                                if (obj["mycalendartime" + 2]) printDate += " " + obj["mycalendartime" + 2].getTime();
                            }
                            axdom("#" + objID).val(printDate);
                        }
                        else {
                            obj.nDate1 = obj.nDate2;
                            printDate = obj["nDate" + 1].print("yyyy" + separator + "mm" + separator + "dd");
                            if (obj.config.expandTime) {
                                if (obj["mycalendartime" + 1]) printDate += " " + obj["mycalendartime" + 1].getTime();
                            }
                            axdom("#" + obj.config.startTargetID).val(printDate);
                        }
                    }
                }
            }
        }
        
        if (!obj.config.onChange) obj.config.onChange = obj.config.onchange;
        if (obj.config.onChange) {
            obj.config.onChange.call({
                event: event,
                ST_objID: obj.config.startTargetID,
                ED_objID: objID,
                ST_value: axdom("#" + obj.config.startTargetID).val(),
                ED_value: axdom("#" + objID).val()
            });
        }
        /*
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        obj.bindTarget.trigger("change");
        */

        /* ie10 버그 픽스
         axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리
         
         //비활성 처리후 메소드 종료
         axdom(document).unbind("click.AXInput");
         axdom("#" + objID).unbind("keydown.AXInput");
         */
        event.stopPropagation(); // disableevent
        return;
    },
    
    // checked
    bindChecked: function (objID, objSeq) {
        var cfg = this.config, _this = this;
        var obj = this.objects[objSeq];
        
        if (!obj.bindAnchorTarget) obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        //var tagName = obj.bindTarget.get(0).tagName.ucase();
        obj.bindTarget.css({opacity: 0});
        
        var h = obj.bindAnchorTarget.data("height"),
            marginWidth = obj.bindTarget.css("margin-left").number() + obj.bindTarget.css("margin-right").number(),
            marginHeight = obj.bindTarget.css("margin-top").number() + obj.bindTarget.css("margin-bottom").number(),
            chk_size = Math.max((h + marginWidth), (h + marginHeight)) - 1,
            left = (obj.bindTarget.css("margin-left").number() - obj.bindTarget.css("margin-right").number()).abs(),
            anchorHandle, linked_items = [];
        
        var onchange = function (e) {
            if (obj.bindTarget.get(0).checked) {
                anchorHandle.addClass("checked");
            }
            else {
                anchorHandle.removeClass("checked");
            }
            if (linked_items.length > 0) {
                for (var li = 0; li < linked_items.length; li++) {
                    var aHandle = jQuery(linked_items[li]).next().find("." + cfg.anchorCheckedContainerClassName + "_radio");
                    if (linked_items[li].checked) {
                        aHandle.addClass("checked");
                    }
                    else {
                        aHandle.removeClass("checked");
                    }
                }
            }
        };
        
        var po = [];
        po.push('<div id="' + cfg.targetID + '_AX_' + objID + '_AX_HandleContainer"');
        if (obj.bindTarget.attr("type") == "radio") {
            po.push(' class="' + cfg.anchorCheckedContainerClassName + '_radio" ');
        }
        else {
            po.push(' class="' + cfg.anchorCheckedContainerClassName + '" ');
        }
        
        po.push(' style="left:' + left + 'px;top:0px;width:' + chk_size + 'px;height:' + chk_size + 'px;"');
        po.push(' onselectstart="return false;">');
        po.push('<a class="checked-icon"></a>')
        po.push('</div>');
        obj.bindAnchorTarget.append(po.join(''));
        obj.bindAnchorTarget.show();
        if (obj.bindTarget.attr("type") == "radio") {
            anchorHandle = obj.bindAnchorTarget.find("." + cfg.anchorCheckedContainerClassName + "_radio");
        }
        else {
            anchorHandle = obj.bindAnchorTarget.find("." + cfg.anchorCheckedContainerClassName);
        }
        
        obj.bindTarget.unbind("change.AXInput").bind("change.AXInput", onchange);
        anchorHandle.bind("click", function (e) {
            obj.bindTarget.get(0).checked = !obj.bindTarget.get(0).checked;
            obj.bindTarget.trigger("change");
            _this.stopEvent(e);
        });
        if (obj.bindTarget.attr("type") == "radio") {
            // 이름이 같은 라디오 아이템을 수집하여 링크 합니다.
            var nm = obj.bindTarget.attr("name");
            //trace(nm, objID);
            jQuery("input[name=" + nm + "]").each(function () {
                if (objID != this.id) {
                    linked_items.push(this);
                }
            });
        }
        onchange();
    }
});

var AXInput = new AXInputConverter();
AXInput.setConfig({targetID: "inputBasic"});

/**
 * @method jQueryExtends.unbindInput
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 바인딩된 컨트롤을 제거합니다.
 * @example
 ```js
 axdom("#AXInputNumber").unbindInput();
 ```
 **/
axdom.fn.unbindInput = function (config) {
    axf.each(this, function () {
        if (config == undefined) config = {};
        config.id = this.id;
        AXInput.unbind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindSearch
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에  검색 컨트롤을 바인딩 합니다. IE9 이하에서도 placeholder를 지원합니다.
 * @example
 ```js
 axdom(".AXInputSearch").bindSearch();
 ```
 **/
axdom.fn.bindSearch = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        if (config == undefined) config = {};
        config.id = this.id;
        config.bindType = "search";
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindNumber
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 숫자 컨트롤을 바인딩 합니다.
 * @example
 ```js
 var config = {
    min: 1,   // {Number} [min=Number.MIN_VALUE] - 최소값 (optional)
    max: 100, // {Number} [max=Number.MAX_VALUE] - 최대값 (optional)
    onchange: function(){ // {Function} - 값이 변경되었을 때 이벤트 콜백함수 (optional)
        trace(this);
    }
};
 axdom("#AXInputNumber").bindNumber(config);
 ```
 **/
axdom.fn.bindNumber = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "number";
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindMoney
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 통화단위가 입력 되도록 합니다.
 * @example
 ```js
 var config = {
    min: 1,  // {Number} [min=Number.MIN_VALUE] - 최소값 (optional)
    max: 100 // {Number} [max=Number.MAX_VALUE] - 최대값 (optional)
};
 axdom("#AXInputMoney").bindMoney(config);
 ```
 **/
axdom.fn.bindMoney = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "money";
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindSelector
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 selector 컨트롤을 바인딩 합니다.
 * @example
 ```js
 var config = {
    appendable   : ( true || false ),                      // {Boolean}  - options 에 정해진 값 외의 입력 가능 여부 true 이면 입력이 가능합니다. (optional)
    options      : [{optionValue:"1", optionText:"AXISJ"}] // {Array}    - [{optionValue:"값", optionText:"라벨"}]
    ajaxUrl      : "./data.json",                          // {String}   - AJAX 데이터 호출 URL (optional)
    ajaxPars     : "param1=val1&param2=val2",              // {String}   - AJAX 데이터 호출 URL 파라미터 (optional)
    positionFixed: ( true || false ),                      // {Boolean}  - expandBox position CSS 를 fixed 할지 여부. selector 가 fixed 된 엘리먼트 위에 위치하는 경우 사용하세요 (optional)
    direction    : "bottom",                               // {String}   - expandBox의 위/아래 열리는 방향을 지정합니다. 기본값은 ""이며 "bottom"을 사용하는 경우 expandBox의 방향이 밑에서 위로 열리게 됩니다. (optional)
    onchange     : function() {                            // {Function} - 값 변경 이벤트 콜백함수 (optional)
        trace(this);
    },
    onsearch     : function(objID, objVal, callBack) {               // {Function} - 값 변경시 options 변경 구현 함수(optional) ※ 주의: ajaxUrl과 중복 사용할 수 없습니다. 만약 두 옵션이 같이 선언되면 onsearch가 적용되고 ajaxUrl은 무시됩니다.
        // this = { id: objID, value: objVal }
        // 아래와 같은 형식으로 options 값을 반환해야 합니다.
        return {
            options:[
                {optionValue:1, optionText:"Seoul", desc:"부가설명글"},
                ...
            ]
        }
        // 또는 callBack 함수를 호출합니다.
    }
    finder: {
        onclick: function() { // {Function} - 파인더 버튼 클릭 이벤트 콜백함수 (optional)
            trace(this);
        }
    },
    maxHeight   : {Number} [150] - selector panel height
};
 
 // 서버에서 리턴하는 JSON 구문 예시
 // 아래 형식을 만족 시켜야 합니다.
 // desc 또는 optionDesc 값을 지정하면 option 라벨 뒤에 부가설명글로 표시됩니다.
 {
	result:"ok",
	options:[
		{optionValue:1, optionText:"Seoul", desc:"부가설명글"},
		{optionValue:2, optionText:"대구"},
		{optionValue:3, optionText:"대전", optionDesc:"부가설명글"},
		{optionValue:8, optionText:"전주"},
		{optionValue:9, optionText:"Gwangju"}
	]
}
 
 axdom("#AXInputSelector").bindSelector(config);
 ```
 **/
axdom.fn.bindSelector = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "selector";
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindSelectorBlur
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description 옵션 목록이 열려있으면 닫습니다.
 * @example
 ```js
 axdom("#AXInputSelector").bindSelectorBlur();
 ```
 **/
axdom.fn.bindSelectorBlur = function (config) {
    axf.each(this, function () {
        AXInput.bindSelectorBlur(this.id);
    });
    return this;
};

/**
 * @method jQueryExtends.bindSlider
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 slider 컨트롤을 바인딩 합니다.
 * @example
 ```js
 var config = {
    min: 0,    // {Number} [min=Number.MIN_VALUE] - 최소값 (optional)
    max: 100,  // {Number} [min=Number.MAX_VALUE] - 최대값 (optional)
    snap: 100, // {Number} [snap=1] -
    unit: "%", // {String} [unit=""] - 값 뒤에 붙여 표현하는 단위 (optional)
    onchange: function() { // {Function} - 값 변경 이벤트 콜백함수 (optional)
        trace(this);
    }
};
 axdom("#AXInputSlider").bindSlider(config);
 ```
 **/
axdom.fn.bindSlider = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "slider";
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindTwinSlider
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 번위 선택이 가능한 slider 컨트롤을 바인딩 합니다.
 * @example
 ```js
 var config = {
    min: 0,         // {Number} [min=Number.MIN_VALUE] - 최소값 (optional)
    max: 100,       // {Number} [max=Number.MAX_VALUE] - 최대값 (optional)
    separator: "~", // {String} [separator="~"] -두개의 값 사이를 구분 지을 문자열
    snap: 100,      // {Number} [snap=1] -
    unit: "%",      // {String} [unit=""] 값 뒤에 붙여 표현하는 단위 (optional)
    onchange: function() { // {Function} - 값 변경 이벤트 콜백함수 (optional)
        trace(this);
    }
};
 axdom("#AXInputTwinSlider").bindTwinSlider(config);
 ```
 **/
axdom.fn.bindTwinSlider = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "twinSlider";
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindSwitch
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 스위치 컨트롤을 적용합니다.
 * @example
 ```js
 var config = {
    off: "AM", // {String} switch off value
    on : "PM", // {String} switch on vlaue
    onchange:function(){
        trace(this);
    }
};
 axdom("#AXInputSwitch").bindSwitch(config);
 ```
 **/
axdom.fn.bindSwitch = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "switch";
        AXInput.bind(config);
        return this;
    });
};

/**
 * @method jQueryExtends.bindSegment
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 segment 컨트롤을 바인딩 합니다.
 * @example
 ```js
 var config = {
    theme:"AXSegmentTest", // {String} CSS 클래스
    options : [            // {String} {optionValue:"옵션의값", optionText:"옵션라벨", addClass:"옵션아이템에 추가될 CSS 클래스"}
        {optionValue:0, optionText:"왼쪽", addClass:"type1"},
        {optionValue:1, optionText:"가운데", addClass:"type2"},
        {optionValue:2, optionText:"오른쪽", addClass:"type3"}
    ],
    onchange:function(){  // {Function} 값이 변경되었을 때 발생하는 이벤트 콜백함수
        //this.targetID, this.options, this.selectedIndex, this.selectedOption
        trace(this);
    }
};
 axdom("#AXInputSegment").bindSegment(config);
 ```
 **/
axdom.fn.bindSegment = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "segment";
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindDate
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 날짜 컨트롤을 바인딩 합니다.
 * @example
 ```js
 var config = {
    align            :"right", // {String} ("left"|"center"|"right") 달력에서 input text 의 위치
    valign           :"top",   // {String} ("top"|"middle"|"bottom") 달력에서 input text 의 위치
    separator        : "-",    // {String} 날짜형식 표시 구분 문자열
    selectType       : "d",    // {String} ("y"|"m"|"d") 날짜선택범위 y 를 지정하면 년도만 선택됩니다.
    defaultSelectType: "d",    // {String} ("y"|"m"|"d") 달력컨트롤의 년월일 선택도구 중에 먼저 보이는 도구타입
    defaultDate      : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 빈값의 달력 기준일을 설정합니다. 지정하지 않으면 시스템달력의 오늘을 기준으로 합니다.
    minDate          : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 선택할 수 있는 최소일을 설정합니다.
    maxDate          : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 선택할 수 있는 최대일을 설정합니다.
    onBeforeShowDay  : {}      // {Function} 날짜를 보여주기 전에 호출하는 함수. date를 파라미터로 받으며 다음과 같은 형식의 Object를 반환해야 한다. { isEnable: true|false, title:'성탄절', className: 'holyday', style: 'color:red' }
    onchange: function(){      // {Function} 값이 변경되었을 때 발생하는 이벤트 콜백함수
        trace(this);
    }
};
 axdom("#AXInputDate").bindDate(config);
 ```
 **/
axdom.fn.bindDate = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "date";
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.unbindDate
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 바인딩된 날짜 컨트롤을 제거합니다.
 * @example
 ```js
 axdom("#AXInputDate").unbindDate();
 ```
 **/
axdom.fn.unbindDate = function (config) {
    axf.each(this, function () {
        config = config || {};
        config.id = this.id;
        AXInput.unbindDate(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindDateTime
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 날짜와 시간 컨트롤을 바인딩 합니다.
 * @example
 ```js
 var config = {
    align            : "right",// {String} ("left"|"center"|"right") 달력에서 input text 의 위치
    valign           : "top",  // {String} ("top"|"middle"|"bottom") 달력에서 input text 의 위치
    separator        : "-",    // {String} 날짜형식 표시 구분 문자열
    selectType       : "d",    // {String} ("y"|"m"|"d") 날짜선택범위 y 를 지정하면 년도만 선택됩니다.
    defaultSelectType: "d",    // {String} ("y"|"m"|"d") 달력컨트롤의 년월일 선택도구 중에 먼저 보이는 도구타입
    defaultDate      : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 빈값의 달력 기준일을 설정합니다. 지정하지 않으면 시스템달력의 오늘을 기준으로 합니다.
    minDate          : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 선택할 수 있는 최소일을 설정합니다.
    maxDate          : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 선택할 수 있는 최대일을 설정합니다.
    onBeforeShowDay  : {}      // {Function} 날짜를 보여주기 전에 호출하는 함수. date를 파라미터로 받으며 다음과 같은 형식의 Object를 반환해야 한다. { enable: true|false, title:'성탄절', class: 'holyday', style: 'color:red' }
    onchange: function(){      // {Function} 값이 변경되었을 때 발생하는 이벤트 콜백함수
        trace(this);
    }
};
 axdom("#AXInputDate").bindDateTime(config);
 ```
 **/
axdom.fn.bindDateTime = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "date";
        config.expandTime = true;
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindTwinDate
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 날짜(start ~ end) 컨트롤을 바인딩 합니다.
 * @example
 ```js
 var config = {
    startTargetID    : "AXInputDateST", // {String}시작일 input text 아이디
    align            : "right",// {String} ("left"|"center"|"right") 달력에서 input text 의 위치
    valign           : "top",  // {String} ("top"|"middle"|"bottom") 달력에서 input text 의 위치
    separator        : "-",    // {String} 날짜형식 표시 구분 문자열
    selectType       : "d",    // {String} ("y"|"m"|"d") 날짜선택범위 y 를 지정하면 년도만 선택됩니다.
    defaultSelectType: "d",    // {String} ("y"|"m"|"d") 달력컨트롤의 년월일 선택도구 중에 먼저 보이는 도구타입
    defaultDate      : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 빈값의 달력 기준일을 설정합니다. 지정하지 않으면 시스템달력의 오늘을 기준으로 합니다.
    minDate          : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 선택할 수 있는 최소일을 설정합니다.
    maxDate          : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 선택할 수 있는 최대일을 설정합니다.
    buttonText       : "OK"    // {String} ["OK"] - 선택 버튼 텍스트 설정
    onBeforeShowDay  : {}      // {Function} 날짜를 보여주기 전에 호출하는 함수. date를 파라미터로 받으며 다음과 같은 형식의 Object를 반환해야 한다. { enable: true|false, title:'성탄절', class: 'holyday', style: 'color:red' }
    onchange: function(){      // {Function} 값이 변경되었을 때 발생하는 이벤트 콜백함수
        trace(this);
    }
};
 axdom("#AXInputDateED").bindTwinDate(config);
 ```
 **/
axdom.fn.bindTwinDate = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "twinDate";
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindTwinDateTime
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 날짜와 시간(start ~ end) 컨트롤을 바인딩 합니다.
 * @example
 ```js
 var config = {
    startTargetID    : "AXInputDateST", // {String}시작일 input text 아이디
    align            : "right",// {String} ("left"|"center"|"right") 달력에서 input text 의 위치
    valign           : "top",  // {String} ("top"|"middle"|"bottom") 달력에서 input text 의 위치
    separator        : "-",    // {String} 날짜형식 표시 구분 문자열
    selectType       : "d",    // {String} ("y"|"m"|"d") 날짜선택범위 y 를 지정하면 년도만 선택됩니다.
    defaultSelectType: "d",    // {String} ("y"|"m"|"d") 달력컨트롤의 년월일 선택도구 중에 먼저 보이는 도구타입
    defaultDate      : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 빈값의 달력 기준일을 설정합니다. 지정하지 않으면 시스템달력의 오늘을 기준으로 합니다.
    minDate          : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 선택할 수 있는 최소일을 설정합니다.
    maxDate          : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 선택할 수 있는 최대일을 설정합니다.
    buttonText       : "OK"    // {String} ["OK"] - 선택 버튼 텍스트 설정
    onBeforeShowDay  : {}      // {Function} 날짜를 보여주기 전에 호출하는 함수. date를 파라미터로 받으며 다음과 같은 형식의 Object를 반환해야 한다. { enable: true|false, title:'성탄절', class: 'holyday', style: 'color:red' }
    onchange: function(){      // {Function} 값이 변경되었을 때 발생하는 이벤트 콜백함수
        trace(this);
    }
};
 axdom("#AXInputDateED").bindTwinDateTime(config);
 ```
 **/
axdom.fn.bindTwinDateTime = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "twinDateTime";
        config.expandTime = true;
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindPlaceHolder
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description IE9 이하에서도 input text 엘리먼트에 placeholder를 지원합니다. placeholder를 지원하는 브라우저에서는 브라우저의 native code가 사용됩니다.
 * @example
 ```js
 axdom(".AXInputPlaceholder").bindPlaceHolder();
 ```
 **/
axdom.fn.bindPlaceHolder = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "placeHolder";
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindChecked
 * @param {Object} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 체크 컨트롤을 바인딩 합니다.(구현중)
 * @example
 ```js
 axdom(".AXInputChecked").bindChecked();
 ```
 **/
axdom.fn.bindChecked = function (config) {
    axf.each(this, function () {
        config = config || {};
        config.id = (this.id || (this.id = "axchecked-" + axf.getUniqueId()));
        config.bindType = "checked";
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.setConfigInput
 * @param {Object} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 config를 할당합니다.
 * @example
 ```js
 axdom(".AXInput").setConfigInput( 100 );
 ```
 **/
axdom.fn.setConfigInput = function (config) {
    axf.each(this, function () {
        AXInput.bindSetConfig(this.id, config);
    });
    return this;
};

/**
 * @method jQueryExtends.setValueInput
 * @param {Object} value - 할당할 값
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 바인딩된 컨트롤에 값을 할당합니다.(아직 search, number, money, date, twinDate 컨트롤은 구현되지 않았습니다.)
 * @example
 ```js
 axdom(".AXInput").setValueInput( 100 );
 ```
 **/
axdom.fn.setValueInput = function (value) {
    axf.each(this, function () {
        AXInput.bindSetValue(this.id, value);
    });
    return this;
};

/**
 * @method jQueryExtends.bindInputDisabled
 * @param {Boolean} [Disabled=true] - 컨트롤을 disabled | enabled 합니다.
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 바인딩된 컨트롤을 비활성화 하거나 활성화 합니다.
 * @example
 ```js
 axdom(".AXInput").bindInputDisabled( true | false );
 ```
 **/
jQuery.fn.bindInputDisabled = function (Disabled) {
    axf.each(this, function () {
        AXInput.bindInputDisabled(this.id, Disabled);
    });
    return this;
};
/* ---------------------------- */
var AXInputConverterPro = Class.create(AXJ, {
	initialize: function(AXJ_super) {
		AXJ_super();
		this.objects = [];
		this.inputTypes = [
			{type: "pattern", type: "tagSelector"}
		];
		this.config.anchorClassName = "AXanchor";
		this.config.anchorSelectorExpandBoxClassName = "AXanchorSelectorExpandBox";
		this.config.anchorSelectorExpandScrollClassName = "AXanchorSelectorExpandScroll"

		/* 모바일 반응 너비 */
		this.config.responsiveMobile = AXConfig.mobile.responsiveWidth;
	},
	init: function() {
		axdom(window).resize(this.alignAllAnchor.bind(this));

		// 예약어 초기화
		this.config.reserveKeys = {
			options: (AXConfig.AXInput && AXConfig.AXInput.keyOptions) || "options",
			optionValue: (AXConfig.AXInput && AXConfig.AXInput.keyOptionValue) || "optionValue",
			optionText: (AXConfig.AXInput && AXConfig.AXInput.keyOptionText) || "optionText"
		};
	},
	windowResize: function() {
		// 사용안함
		var windowResizeApply = this.windowResizeApply.bind(this);
		if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
		this.windowResizeObserver = setTimeout(function() {
			windowResizeApply();
		}, 10);
	},
	windowResizeApply: function() {
		// 사용안함
		if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
		this.alignAllAnchor();
	},
	alignAllAnchor: function() {
		for (var i = 0; i < this.objects.length; i++) {
			this.alignAnchor(this.objects[i].id, i);
		}
	},
	bindSetConfig: function(objID, configs) {
		var findIndex = null;
		axf.each(this.objects, function(index, O) {
			if (O.id == objID) {
				findIndex = index;
				return false;
			}
		});
		if (findIndex == null) {
			//trace("바인드 된 오브젝트를 찾을 수 없습니다.");
			return;
		}
		else {
			var _self = this.objects[findIndex];
			axf.each(configs, function(k, v) {
				_self.config[k] = v;
			});
		}
	},
	bind: function(obj) {
		var cfg = this.config;
		if (!AXgetId(obj.id)) {
			trace("bind 대상이 없어 bind 처리할 수 없습니다.");
			return;
		}

		var objID = obj.id;
		var objSeq = null;
		for (var index = 0; index < this.objects.length; index++) {
			if (this.objects[index].id == objID) {
				objSeq = index;
				break;
			}
		}

		if (obj.href == undefined) obj.href = cfg.href;

		if (objSeq == null) {
			objSeq = this.objects.length;
			this.objects.push({
				id: objID,
				anchorID: cfg.targetID + "_AX_" + objID,
				config: obj,
				bindType: obj.bindType
			});
		}
		else {
			this.objects[objSeq].isDel = undefined;
			this.objects[objSeq].config = obj;
		}

		if (obj.bindType != "checked") {
			this.appendAnchor(objID, objSeq, obj.bindType);
		}
		// bind checked 는 anchor연결 안함.

		if (obj.bindType == "null") {

		}
		else if (obj.bindType == "pattern") {
			this.bindPattern(objID, objSeq);
		}
		else if (obj.bindType == "tagSelector") {
			if (!this.objects[objSeq].config.reserveKeys) {
				this.objects[objSeq].config.reserveKeys = axdom.extend({}, this.config.reserveKeys);
			}
			this.bindTagSelector(objID, objSeq);
		}
	},
	unbind: function(obj) {
		var cfg = this.config;
		var removeAnchorId;
		var removeIdx;
		axf.each(this.objects, function(idx, O) {
			if (O.id != obj.id) {
				// collect.push(this);
			}
			else {
				if (O.isDel != true) {
					removeAnchorId = this.anchorID;
					removeIdx = idx;
				}
			}
		});

		if (removeAnchorId) {
			this.objects[removeIdx].isDel = true;
			axdom("#" + obj.id).removeAttr("data-axbind");
			axdom("#" + removeAnchorId).remove();
			var objID = obj.id;
			var obj = this.objects[removeIdx];
			if (obj.documentclickEvent) axdom(document).unbind("click.AXInput", obj.documentclickEvent);
			axdom("#" + objID).unbind("keydown.AXInput");
			axdom("#" + objID).unbind("keydown.AXInputCheck");

			axdom("#" + objID).unbind("change.AXInput");

			if (obj.bindSliderMouseMove) axdom(document.body).unbind("mousemove.AXInput", obj.bindSliderMouseMove);
			if (obj.bindSliderMouseUp) axdom(document.body).unbind("mouseup.AXInput", obj.bindSliderMouseUp);
			if (obj.bindSliderTouchMove) document.removeEventListener("touchmove.AXInput", obj.bindSliderTouchMove, false);
			if (obj.bindSliderTouchEnd) document.removeEventListener("touchend.AXInput", obj.bindSliderTouchEnd, false);
			if (obj.bindTwinSliderMouseMove) axdom(document.body).unbind("mousemove.AXInput", obj.bindTwinSliderMouseMove);
			if (obj.bindTwinSliderMouseUp) axdom(document.body).unbind("mouseup.AXInput", obj.bindTwinSliderMouseUp);

			if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
				axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리
				axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Handle").removeClass("on");
			}
		}
	},
	appendAnchor: function(objID, objSeq, bindType) {
		var cfg = this.config;
		var obj = this.objects[objSeq];
		//trace("appendAnchor");
		axdom("#" + cfg.targetID + "_AX_" + objID).remove();
		var anchorNode = axdom("<div id=\"" + cfg.targetID + "_AX_" + objID + "\" class=\"" + cfg.anchorClassName + "\" style=\"display:none;\"></div>");
		var iobj = axdom("#" + objID);
		iobj.attr("data-axbind", bindType);
		iobj.after(anchorNode);

		obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
		obj.bindTarget = iobj;

		//var offSetParent = iobj.offsetParent();
		var iobjPosition = iobj.position();
		var l = iobjPosition.left, t = iobjPosition.top, w = 0, h = 0;

		var borderW = iobj.css("border-left-width").number();
		var borderH = iobj.css("border-top-width").number();
		var marginW = iobj.css("margin-left").number();
		var marginH = iobj.css("margin-top").number();
		l = l + marginW;
		/*t = t;*/
		w = iobj.outerWidth();
		h = iobj.outerHeight();

		var css = {left: l, top: t, width: w, height: 0};
		//trace(css);
		obj.bindAnchorTarget.css(css);
		obj.bindAnchorTarget.data("height", h);

		var _this = this;
		setTimeout(function() {
			_this.alignAnchor(objID, objSeq);
		}, 10);
	},
	alignAnchor: function(objID, objSeq) {
		var cfg = this.config;
		var obj = this.objects[objSeq];

		if (!AXgetId(objID)) return;
		/* 엘리먼트 존재 여부 확인 */

		if (obj.bindType == "tagSelector") {
			if (obj.tagList.length > 0) obj.bindTarget.css({"padding-top": obj.tagContainer.height()});
		}
		else {
			var iobjPosition = obj.bindTarget.position();
			var l = iobjPosition.left, t = iobjPosition.top;
			var w = obj.bindTarget.outerWidth();
			var h = obj.bindTarget.outerHeight();
			if (obj.bindTarget.css("display") == "none") {
				h = obj.bindAnchorTarget.data("height");
				var css = {width: w};
			}
			else {
				var css = {left: l, top: t, width: w, height: 0};
			}
			//trace(css);
			obj.bindAnchorTarget.css(css);
			obj.bindAnchorTarget.data("height", h);

			if (obj.bindType == "null") {

			}
			else if (obj.bindType == "pattern") {

			}
		}
	},

	// TODO : pattern명 정의
	/*
	 money, moneyint, date, datetime, bizno, phone, "USER String", [Function]
	 */
	// pattern
	bindPattern: function(objID, objSeq) {
		var obj = this.objects[objSeq], cfg = this.config, _this = this;
		if (!obj.bindAnchorTarget) obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
		if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);

		// TODO : 키 입력 제어 구문 시작점 (방법1)
		if (obj.config.pattern == "_custom") { // 커버 개체를 삽입하는 방식.. 실패..

			var h = obj.bindAnchorTarget.data("height");
			obj.bindAnchorTarget.css({"height": h});
			var po = [];
			var inputCoverClass = obj.bindTarget.attr("class");
			//trace();
			var inputCoverFont = obj.bindTarget.css("font-family");
			po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_inputCover\" " +
				"class=\"" + inputCoverClass + "\" " +
				"style=\"background:transparent;cursor:text;font-family:" + inputCoverFont + ";white-space:nowrap;\"" +
				"></div>");

			obj.bindAnchorTarget.append(po.join(''));
			obj.bindAnchorTarget.show();
			obj.bindTarget.css({color: obj.bindTarget.css("background-color")});

			obj.bindTargetCover = obj.bindAnchorTarget.find("#" + cfg.targetID + "_AX_" + objID + "_AX_inputCover");

			obj.bindTargetCover.bind("click", function() {
				obj.bindTarget.focus();
			});

			var val = obj.bindTarget.val().trim();
			if (val != "") {
				val = this.bindPatternGetValue(objID, objSeq, obj.bindTarget.val());
			}
			obj.bindTarget.val(val);

			obj.bindTarget.attr("onselectstart", "return false");
			obj.bindTarget.unbind("keypress.AXInput").bind("keypress.AXInput", function(event) {
				//obj.bindTargetCover.text(event.target.value);
			});
			obj.bindTarget.unbind("keyup.AXInput").bind("keyup.AXInput", function(event) {
				obj.bindTargetCover.html(_this.bindPatternGetValue(objID, objSeq, event.target.value) + "<div class='edit-input-cursor'>|</div>");
				//obj.bindTargetCover.val( _this.bindPatternGetValue(objID, objSeq, event.target.value) );
			});
			obj.bindTarget.unbind("focus.AXInput").bind("focus.AXInput", function(event) {
				obj.bindTargetCover.html(_this.bindPatternGetValue(objID, objSeq, event.target.value) + "<div class='edit-input-cursor'>|</div>");
				//obj.bindTargetCover.val( _this.bindPatternGetValue(objID, objSeq, event.target.value) );
			});
			obj.bindTarget.unbind("blur.AXInput").bind("blur.AXInput", function(event) {
				obj.bindTargetCover.find(".edit-input-cursor").remove();
			});

			return;
		}

		// TODO : 키 입력 제어 구문 시작점 (방법2)
		if (obj.config.pattern == "_custom") {

			// KEY_BACKSPACE: 8, KEY_TAB: 9, KEY_RETURN: 13, KEY_ESC: 27, KEY_LEFT: 37, KEY_UP: 38, KEY_RIGHT: 39, KEY_DOWN: 40, KEY_DELETE: 46, KEY_HOME: 36, KEY_END: 35, KEY_PAGEUP: 33, KEY_PAGEDOWN: 34,
			// KEY_INSERT: 45, KEY_SPACE: 32

			obj.bindTarget.unbind("keypress.AXInput").bind("keypress.AXInput", function(event) {
				var elem = event.target;
				var elemFocusPosition, elemFocusEndPosition;
				if ('selectionStart' in elem) {
					// Standard-compliant browsers
					elemFocusPosition = elem.selectionStart;
					elemFocusEndPosition = elem.selectionEnd;
				}
				else if (document.selection) {
					// IE
					//elem.focus();
					var sel = document.selection.createRange();
					var selLen = document.selection.createRange().text.length;
					sel.moveStart('character', -elem.value.length);
					elemFocusPosition = sel.text.length - selLen;
					elemFocusEndPosition = elemFocusPosition + selLen;
				}
				obj.DSP = elemFocusPosition;
				obj.DEP = elemFocusEndPosition;

				//키 입력전 입력문자열;
				if (elem.value == "") {
					obj.originalValue = ""; // 오리지널 밸류 초기화
				}
				obj.prevValue = event.target.value;

				//trace("D" + obj.DEP);
			});

			obj.bindTarget.unbind("keyup.AXInput").bind("keyup.AXInput", function(event) {
				var elem = event.target;
				var elemFocusPosition;
				if ('selectionStart' in elem) {
					// Standard-compliant browsers
					elemFocusPosition = elem.selectionStart;
					elemFocusEndPosition = elem.selectionEnd;
				}
				else if (document.selection) {
					// IE
					//elem.focus();
					var sel = document.selection.createRange();
					var selLen = document.selection.createRange().text.length;
					sel.moveStart('character', -elem.value.length);
					elemFocusPosition = sel.text.length - selLen;
					elemFocusEndPosition = elemFocusPosition + selLen;
				}
				obj.USP = elemFocusPosition;
				obj.UEP = elemFocusEndPosition;

				var v1 = elem.value, v2 = obj.prevValue;
				var editText = v2.substring(obj.DSP, obj.DEP), editedText = v1.substring(obj.DEP, obj.UEP);
				//trace("U" + obj.UEP);

				// case 1 : 한글자씩 타이핑 하는 경우

				if (v1 != v2 && v1.length > v2.length) {
					// 추가입력
					if (obj.DSP == obj.DEP && obj.USP == obj.UEP && obj.DSP + 1 == obj.USP) {
						if (obj.USP == v1.length) {
							//trace("끝에서 한글자 타이핑");
							obj.originalValue += editedText;
						}
						else if (obj.USP < v1.length) {
							//trace("중간에서 한글자 타이핑");
							//var _v1 = obj.originalValue.split("");
							//var _v2 = editedText.split("");
							var _v2 = "";
							obj.originalValue = obj.originalValue.substring(0, obj.DEP) + editedText + obj.originalValue.substr(obj.DEP);
						}
						// 입력된 문자열의 위치에 패턴을 처리 합니다.

					}
					else {
						if (obj.USP == v1.length) {
							//trace("끝에서 다중문자 타이핑");
							obj.originalValue += editedText;
						}
						else if (obj.USP < v1.length) {
							trace("중간에서 다중문자 타이핑");
						}
					}
					/*
					 trace({
					 nvalue: v1,
					 prevValue: v2,
					 nowText: editText,
					 editedText: editedText,
					 originalValue: obj.originalValue,
					 eD:[obj.DSP, obj.DEP],
					 eU:[obj.USP, obj.UEP]
					 });
					 */
				}
				else if (v1 != v2 && v1.length < v2.length) {
					// 삭제 obj.originalValue의 삭제된 문자열 위치를 찾아 제거 합니다.

					if (obj.DSP == obj.DEP && obj.USP == obj.UEP && obj.DSP - 1 == obj.USP) {
						if (obj.USP == v1.length) {
							trace("끝에서 한글자 삭제");
						}
						else if (obj.USP < v1.length) {
							trace("중간에서 한글자 삭제");
						}
					}
					else {
						if (obj.USP == v1.length) {
							trace("끝에서 다중문자 삭제");
						}
						else if (obj.USP < v1.length) {
							trace("중간에서 다중문자 삭제");
						}
					}
				}
				else {
					// 커서이동
					if (obj.DSP == obj.DEP && obj.USP == obj.UEP && obj.DSP + 1 == obj.USP) {
						trace("커서 우로 이동");
					}
					else if (obj.DSP == obj.DEP && obj.USP == obj.UEP && obj.DSP == obj.USP + 1) {
						trace("커서 좌로 이동");
					}
					else if (obj.DSP == obj.DEP && obj.USP == obj.UEP && obj.DSP == obj.USP) {
						trace("제자리");
					}
				}
			});
			return;
		}
		// TODO : 키 입력 제어 구문 끝점 (방법2)

		var eventStop = function(event) {
			// 이벤트 중지 구문
			if (event.preventDefault) event.preventDefault();
			if (event.stopPropagation) event.stopPropagation();
			event.cancelBubble = true;
			return false;
			// 이벤트 중지 구문 끝
		};
		// 약속된 패턴 형식 구문
		var bindPatternCheck = this.bindPatternCheck.bind(this);
		var val = obj.bindTarget.val().trim();

		// 패턴 적용 값 구하기 함수를 통해 얻어진 val을 input value로 재 설정 합니다.
		if (val != "") {
			val = this.bindPatternGetValue(objID, objSeq, obj.bindTarget.val(), "blur");
		}
		// 패턴 구문에 따라 달라져야 하는 부분 ------------------------------

		obj.bindTarget.val(val);

		obj.bindTarget.unbind("focus.AXInput").bind("focus.AXInput", function(event) {
			if (obj.config.pattern == "custom") {
				if (typeof obj.originalValue === "undefined") obj.originalValue = event.target.value;
				event.target.value = _this.bindPatternGetValue(objID, objSeq, (obj.originalValue), "keyup");
			}
		});
		obj.bindTarget.unbind("keydown.AXInput").bind("keydown.AXInput", function(event) {
			if (
				event.which &&
				(
					event.which > 47 && event.which < 58 ||
					event.which > 36 && event.which < 41 ||
					event.which > 95 && event.which < 106 ||
					event.which == axf.Event.KEY_BACKSPACE ||
					event.which == axf.Event.KEY_TAB ||
					event.which == axf.Event.KEY_RETURN ||
					event.which == axf.Event.KEY_DELETE ||
					event.which == axf.Event.NUMPAD_SUBTRACT ||
					event.which == axf.Event.NUMPAD_DECIMAL ||
					event.which == axf.Event.KEY_MINUS ||
					event.which == axf.Event.KEY_EQUAL ||
					event.which == axf.Event.KEY_PERIOD ||
					event.which == axf.Event.KEY_HOME ||
					event.which == axf.Event.KEY_END
				)
			)
			{

				// 패턴에 따라 제어 소수점 허용안되는 경우 블락
				var isStop = false;

				if (event.which == 190 && (obj.config.pattern == "moneyint" || obj.config.pattern == "numberint")) {
					// 소수점 입력 막기
					isStop = true;
				}
				else if (event.which == axf.Event.KEY_MINUS || event.which == axf.Event.KEY_EQUAL || event.which == axf.Event.KEY_PERIOD) {
					if (
						(
							obj.config.pattern == "money" ||
							obj.config.pattern == "moneyint" ||
							obj.config.pattern == "number" ||
							obj.config.pattern == "numberint"
						) &&
						obj.config.allow_minus
					)
					{

					}
					else {
						isStop = true;
					}
				}
				else if (
					event.which == axf.Event.KEY_BACKSPACE ||
					event.which == axf.Event.KEY_TAB ||
					event.which == axf.Event.KEY_RETURN ||
					event.which == axf.Event.KEY_LEFT ||
					event.which == axf.Event.KEY_RIGHT ||
					event.which == axf.Event.KEY_DELETE ||
					event.which == axf.Event.KEY_HOME ||
					event.which == axf.Event.KEY_END)
				{ // 백스페이스, 탭, 리턴, 좌, 우, delete

					if (event.which == 13) {
						obj.bindTarget.trigger("blur");
					}
				}
				else {

					if (obj.config.pattern.left(8) == "datetime") {
						if (event.target.value.replace(/\D/g, "").length == 14) { // 초까지 입력되게 확장
							isStop = true;
						}
					}
					else if (obj.config.pattern.left(4) == "date") {
						if (event.target.value.replace(/\D/g, "").length == 8) {
							isStop = true;
						}
					}
					else if (obj.config.pattern == "bizno") {
						if (event.target.value.replace(/\D/g, "").length == 10) {
							isStop = true;
						}
					}
					else if (
						obj.config.pattern == "money" ||
						obj.config.pattern == "moneyint" ||
						obj.config.pattern == "number" ||
						obj.config.pattern == "numberint"
					)
					{
						// TODO : 숫자형 패턴에서 문자열의 길이 및, 소수점 자리수 제한 구현
						if (Object.isNumber(obj.config.max_length)) {

							if (event.target.value.replace(/\D/g, "").length >= obj.config.max_length) {
								isStop = true;
							}
						}
						if (!isStop && Object.isNumber(obj.config.max_round)) {
							var dotIndex = 0;
							if ((dotIndex = event.target.value.indexOf(".")) > -1) {
								if (event.target.value.substr(dotIndex + 1).length >= obj.config.max_round) {
									isStop = true;
								}
							}
						}
					}
					else if (Object.isNumber(obj.config.max_length)) {
						if (event.target.value.replace(/[^A-Za-z0-9]/g, "").length == obj.config.max_length.number()) {
							isStop = true;
						}
					}
				}

				if (isStop) eventStop(event);

			}
			else {
				if ((event.ctrlKey || event.metaKey)) {
					obj.bindTarget.data("ctrlKey", "T");
				}
				else {
					obj.bindTarget.data("ctrlKey", "F");

					//trace('block', event.which);
					eventStop(event);
				}
			}
		});
		obj.bindTarget.unbind("keyup.AXInput").bind("keyup.AXInput", function(event) {
			var elem = obj.bindTarget.get(0);
			var elemFocusPosition;
			if ('selectionStart' in elem) {
				// Standard-compliant browsers
				elemFocusPosition = elem.selectionStart;
			}
			else if (document.selection) {
				// IE
				//elem.focus();
				var sel = document.selection.createRange();
				var selLen = document.selection.createRange().text.length;
				sel.moveStart('character', -elem.value.length);
				elemFocusPosition = sel.text.length - selLen;
			}
			//trace(obj.bindTarget.val());

			// 계산된 포커스 위치
			obj.bindTarget.data("focusPosition", elemFocusPosition);
			obj.bindTarget.data("prevLen", elem.value.length);

			var event = window.event || event;
			// ignore tab & shift key 스킵 & ctrl
			if (!event.keyCode || event.keyCode == axf.Event.KEY_TAB || event.keyCode == 16 || event.keyCode == 17 ||
				event.which == axf.Event.KEY_HOME ||
				event.which == axf.Event.KEY_END) return;

			if ((obj.bindTarget.data("ctrlKey") == "T") && (event.keyCode == 65 || event.keyCode == 91)) return;
			if (event.keyCode != AXUtil.Event.KEY_DELETE && event.keyCode != AXUtil.Event.KEY_BACKSPACE && event.keyCode != AXUtil.Event.KEY_LEFT && event.keyCode != AXUtil.Event.KEY_RIGHT) {
				bindPatternCheck(objID, objSeq, "keyup");
			}
			else if (event.keyCode == AXUtil.Event.KEY_DELETE || event.keyCode == AXUtil.Event.KEY_BACKSPACE) {
				bindPatternCheck(objID, objSeq, "keyup");
			}
		});
		obj.bindTarget.unbind("change.AXInput").bind("change.AXInput", function(event) {
			//bindPatternCheck(objID, objSeq, "change");
		});
		obj.bindTarget.unbind("blur.AXInput").bind("blur.AXInput", function(event) {
			bindPatternCheck(objID, objSeq, "blur");
		});
	},
	bindPatternCheck: function(objID, objSeq, eventType) {
		var obj = this.objects[objSeq];
		var val, nval;
		// callback 함수 대소문자 지원
		if (!obj.config.onBlur) obj.config.onBlur = obj.config.onBlur;
		if (!obj.config.onChange) obj.config.onChange = obj.config.onchange;

		if (eventType == "blur") {

			val = obj.bindTarget.val();
			//trace(val);
			nval = this.bindPatternGetValue(objID, objSeq, val, eventType);
			// 패턴 적용
			obj.bindTarget.val(nval);
			if (val != nval) obj.bindTarget.trigger("change");

			if (Object.isFunction(obj.config.onBlur)) {
				obj.config.onBlur.call({objID: objID, objSeq: objSeq, value: nval});
			}

		}
		else {

			val = obj.bindTarget.val();
			nval = this.bindPatternGetValue(objID, objSeq, val, eventType);
			// 패턴 적용
			obj.bindTarget.val(nval);
			if (val != nval) obj.bindTarget.trigger("change");

			if (!axf.isEmpty(obj.bindTarget.data("focusPosition"))) {
				obj.bindTarget.setCaret(
					obj.bindTarget.data("focusPosition").number() + ( obj.bindTarget.val().length - obj.bindTarget.data("prevLen") )
				);
			}
			if (Object.isFunction(obj.config.onChange)) {
				obj.config.onChange.call({objID: objID, objSeq: objSeq, value: nval});
			}

		}
	},
	bindPatternGetValue: function(objID, objSeq, val, eventType) {
		var obj = this.objects[objSeq];
		var regExpPattern, returnValue = "";

		var getFormatterDate = function(_val, _pattern, ynm, mnd, dnt, tnt) {
			var returnValue = "";
			if (_val == "") {

			}
			else if (eventType == "blur") { // 타이핑 완료
				var nDate = new Date(), needAlert = false;
				if (_val.length > 7) {
					var yy = _val.left(4).number();
					var mm = _val.substr(4, 2).number() - 1;
					var dd = _val.substr(6, 2).number();
				}
				else if (_val.length > 4) {
					var yy = "20" + _val.substr(0, 2);
					var mm = _val.substr(2, 2).number() - 1;
					var dd = _val.substr(4, 2).number();
				}
				else if (_val.length > 2) {
					var yy = nDate.getFullYear();
					var mm = _val.substr(0, 2).number() - 1;
					var dd = _val.substr(2, 2).number();
				}
				else {
					var yy = nDate.getFullYear(); //va.left(4).number();
					var mm = nDate.getMonth();
					var dd = _val.substr(0, 2).number();
				}
				if (yy == 0) needAlert = true;
				if (yy == 0) yy = nDate.getFullYear();
				if (yy < 1000) yy += 2000;
				nDate = new Date(yy, mm, dd, 12);

				if (nDate.getFullYear() != yy.number()
					|| nDate.getMonth() != mm.number()
					|| nDate.getDate() != dd.number())
				{
					needAlert = true;
					nDate = new Date();
				}

				printDate = nDate.print("yyyy" + ynm + "mm" + mnd + "dd");

				if (dnt != " ") {
					printDate += dnt;
				}

				if (_pattern.left(8) == "datetime") {
					if (dnt == " ") printDate += dnt;
					var hh, mm, ss = null;
					if (_val.length > 11) { // hh,mm
						hh = _val.substr(8, 2).number().setDigit(2);
						mm = _val.substr(10, 2).number().setDigit(2);
						ss = _val.substr(12, 2).number().setDigit(2);
					}
					else if (_val.length > 8) {
						hh = _val.substr(8, 2).number().setDigit(2);
						mm = "00";
					}
					else {
						hh = "12";
						mm = "00";
					}
					printDate += hh + tnt + mm + (function() {
							if (ss != null) {
								return tnt + ss;
							}
						})();
				}

				if (needAlert) {
					//alert("날짜 형식이 올바르지 않습니다.");
				}
				returnValue = printDate;

			}
			else { // 타이핑 중
				if (_val.length < 5) {
					returnValue = _val;
				}
				else if (_val.length < 7) {
					returnValue = _val.substr(0, 4) + ynm + _val.substr(4);
				}
				else if (_val.length < 9) {
					returnValue = _val.substr(0, 4) + ynm + _val.substr(4, 2) + mnd + _val.substr(6, 2);
					if (dnt != " ") {
						returnValue += dnt;
					}
				}
				else if (_val.length < 11 && _pattern.left(8) == "datetime") {
					returnValue = _val.substr(0, 4) + ynm + _val.substr(4, 2) + mnd + _val.substr(6, 2) + dnt + _val.substr(8, 2);
				}
				else {
					if (_pattern.left(8) == "datetime") {
						returnValue = _val.substr(0, 4) + ynm + _val.substr(4, 2) + mnd + _val.substr(6, 2) + dnt + _val.substr(8, 2) + tnt + _val.substr(10, 2) + (function() {
								if (_val.substr(12, 2) != "") {
									return tnt + _val.substr(12, 2);
								}
								else {
									return "";
								}
							})();
					}
					else {
						returnValue = _val.substr(0, 4) + ynm + _val.substr(4, 2) + mnd + _val.substr(6, 2);
					}
				}
			}
			return returnValue;
		};
		var getNumberApplyConfig = function(_val, valType) {
			if (valType == "float") {
				if (Object.isNumber(obj.config.max_round)) {
					var dotIndex = 0;
					if ((dotIndex = _val.indexOf(".")) > -1) {
						_val = _val.substring(0, dotIndex + 1) +
							_val.substr(dotIndex + 1).replace(/\D/g, "").left(obj.config.max_round);
					}
				}
			}
			var __val = _val.replace(/\D/g, "");
			if (Object.isNumber(obj.config.max_length)) {
				if (__val.length > obj.config.max_length) {
					if (obj.config.allow_minus && val.left(1) == "-") {
						_val = "-" + __val.left(obj.config.max_length);
					}
					else {
						_val = __val.left(obj.config.max_length);
					}
				}
			}
			__val = null;
			return _val;
		};
		var getFormatterTime = function(_val, _pattern, tnt) {
			var returnValue = "";
			if (_val == "") {

			}
			else if (eventType == "blur") { // 타이핑 완료
				var nDate = new Date(), needAlert = false;
				if (_val.length > 2) {
					var hh = _val.substr(0, 2).number();
					var mi = _val.substr(2, 2).number();
				}
				else if (_val.length > 0) {
					var hh = _val.substr(0, 2).number();
					var mi = 0;
				}
				else {
					var hh = 0;
					var mi = 0;
				}

				if (hh > 23) hh = 23;
				if (mi > 59) mi = 59;

				returnValue = hh.setDigit(2) + tnt + mi.setDigit(2);
			}
			else { // 타이핑 중
				if (_val.length < 3) {
					returnValue = _val;
				}
				else {
					returnValue = _val.substr(0, 2) + tnt + _val.substr(2, 2);
				}
			}
			return returnValue;
		};

		if (
			obj.config.pattern == "money" ||
			obj.config.pattern == "moneyint" ||
			obj.config.pattern == "number" ||
			obj.config.pattern == "numberint"
		)
		{

			if (obj.config.pattern == "moneyint") { // 소수점 포함안함
				//val = val.replace(/[\D,]/g, "");
				val = val.replace(/[^0-9^\-]/g, "");

				if (eventType == "blur") {
					val = getNumberApplyConfig(val, "int");
				}

				if (val == "") {
					returnValue = "";
				}
				else {
					returnValue = Math.ceil(val).money();
				}
			}
			else if (obj.config.pattern == "money") { // 소수점 포함
				//val = val.replace(/[^0-9^\.]/g, "");
				val = val.replace(/[^0-9^\.^\-]/g, "");

				if (eventType == "blur") {
					val = getNumberApplyConfig(val, "float");
				}

				regExpPattern = new RegExp('([0-9])([0-9][0-9][0-9][,.])');

				var arrNumber = val.split('.');
				arrNumber[0] += '.';

				do {
					arrNumber[0] = arrNumber[0].replace(regExpPattern, '$1,$2');
				} while (regExpPattern.test(arrNumber[0]));
				if (arrNumber.length > 1) {
					if (Object.isNumber(obj.config.max_round)) {
						returnValue = arrNumber[0] + arrNumber[1].left(obj.config.max_round);
					}
					else {
						returnValue = arrNumber.join('');
					}
				}
				else {
					returnValue = arrNumber[0].split('.')[0];
				}
				if (eventType == "blur") {
					if (returnValue.right(1) == ".") returnValue = returnValue.replace(/\./g, "");
				}
			}
			else if (obj.config.pattern == "numberint") { // 통화표시 없이 숫자 형태로 입력
				//val = val.replace(/[\D]/g, "");
				val = val.replace(/[^0-9^\-]/g, "");

				if (eventType == "blur") {
					val = getNumberApplyConfig(val, "int");
				}

				if (val == "") {
					returnValue = "";
				}
				else {
					returnValue = Math.ceil(val);
				}
			}
			else if (obj.config.pattern == "number") { // 통화표시 없이 숫자 형태로 입력
				//val = val.replace(/[^0-9^\.]/g, "");
				val = val.replace(/[^0-9^\.^\-]/g, "");

				if (eventType == "blur") {
					val = getNumberApplyConfig(val, "float");
				}

				var arrNumber = val.split('.');
				arrNumber[0] += '.';
				if (arrNumber.length > 1) {
					if (Object.isNumber(obj.config.max_round)) {
						returnValue = arrNumber[0] + arrNumber[1].left(obj.config.max_round);
					}
					else {
						returnValue = arrNumber.join('');
					}
				}
				else {
					returnValue = arrNumber[0].split('.')[0];
				}
				if (eventType == "blur") {
					if (returnValue.right(1) == ".") returnValue = returnValue.replace(/\./g, "");
				}
			}
			if (obj.config.allow_minus) {
				// 첫번째 문자열을 제외하고
				returnValue = returnValue.toString().substring(0, 1) + returnValue.toString().substr(1).replace(/\-/g, "");
			}
			else {
				returnValue = returnValue.toString().replace(/\-/g, "");
			}
		}
		else if (obj.config.pattern == "bizno") {
			val = val.replace(/\D/g, "");
			regExpPattern = /^([0-9]{3})\-?([0-9]{1,2})?\-?([0-9]{1,5})?.*$/;
			returnValue = val.replace(regExpPattern, function(a, b) {
				var nval = [arguments[1]];
				if (arguments[2]) nval.push(arguments[2]);
				if (arguments[3]) nval.push(arguments[3]);
				return nval.join("-");
			});
		}
		else if (obj.config.pattern == "phone") {

			val = val.replace(/\D/g, "");
			regExpPattern = /^(010|011|016|017|018|019)(\d+)*$/;
			var regExpPattern2 = /^(070|080|060|050|02|031|032|033|041|042|043|051|052|053|054|055|061|062|063|064)(\d+)*$/;

			if (regExpPattern.test(val)) { // 휴대전화일 경우
				returnValue = val.replace(regExpPattern, function(a, b) {
					var nval = [arguments[1]];
					if (arguments[2]) {
						if (arguments[2].length < 4) {
							nval.push(arguments[2]);
						}
						else if (arguments[2].length < 8) {
							nval.push(arguments[2].substring(0, 3) + "-" + arguments[2].substr(3));
						}
						else if (arguments[2].length > 8) {
							nval.push(arguments[2].substring(0, 4) + "-" + arguments[2].substr(4, 4) + ", " + arguments[2].substr(8));
						}
						else {
							nval.push(arguments[2].substring(0, 4) + "-" + arguments[2].substr(4, 4));
						}
					}
					return nval.join("-");
				});
			}
			else if (regExpPattern2.test(val)) { // 일반전화일 경우
				returnValue = val.replace(regExpPattern2, function(a, b) {
					var nval = [arguments[1]];
					if (arguments[2]) {
						if (arguments[2].length < 4) {
							nval.push(arguments[2]);
						}
						else if (arguments[2].length < 8) {
							nval.push(arguments[2].substring(0, 3) + "-" + arguments[2].substr(3));
						}
						else if (arguments[2].length > 8) {
							nval.push(arguments[2].substring(0, 4) + "-" + arguments[2].substr(4, 4) + ", " + arguments[2].substr(8));
						}
						else {
							nval.push(arguments[2].substring(0, 4) + "-" + arguments[2].substr(4, 4));
						}
					}
					return nval.join("-");
				});
			}
			else { // 확인안됨.
				var regExpPattern3 = /^([0-9]{3})\-?([0-9]{1,4})?\-?([0-9]{1,4})?\-?([0-9]{1,4})?\-?([0-9]{1,4})?/;
				returnValue = val.replace(regExpPattern3, function(a, b) {
					var nval = [arguments[1]];
					if (arguments[2]) nval.push(arguments[2]);
					if (arguments[3]) nval.push(arguments[3]);
					if (arguments[4]) nval.push(arguments[4]);
					if (arguments[5]) nval.push(arguments[5]);
					return nval.join("-");
				});
			}

		}
		else if (obj.config.pattern == "date") {
			val = val.replace(/\D/g, "");
			returnValue = getFormatterDate(val, obj.config.pattern, "-", "-", " ", ":");
		}
		else if (obj.config.pattern == "date(/)") {
			val = val.replace(/\D/g, "");
			returnValue = getFormatterDate(val, obj.config.pattern, "/", "/", " ", ":");
		}
		else if (obj.config.pattern == "date(년월일)") {
			val = val.replace(/\D/g, "");
			returnValue = getFormatterDate(val, obj.config.pattern, "년", "월", "일", ":");
		}
		else if (obj.config.pattern == "datetime") {
			val = val.replace(/\D/g, "");
			returnValue = getFormatterDate(val, obj.config.pattern, "-", "-", " ", ":");
		}
		else if (obj.config.pattern == "datetime(/)") {
			val = val.replace(/\D/g, "");
			returnValue = getFormatterDate(val, obj.config.pattern, "/", "/", " ", ":");
		}
		else if (obj.config.pattern == "datetime(년월일)") {
			val = val.replace(/\D/g, "");
			returnValue = getFormatterDate(val, obj.config.pattern, "년", "월", "일", "시");
		}
		else if (obj.config.pattern == "time") {
			val = val.replace(/\D/g, "");
			returnValue = getFormatterTime(val, obj.config.pattern, ":");
		}
		else if (obj.config.pattern == "custom") {
			// Z, 9, X
			val = val.replace(/[^0-9^a-z^A-Z]/g, "");
			var ess = val.split("");
			//trace(ess);
			var pss = obj.config.patternString.split("");

			if (eventType == "blur") {
				obj.originalValue = val; // 암호화 되기 전 문자열 저장
				//trace(val);
			}

			var newText = "";
			// TODO : 패턴 문자열의 인덱스와 원본 문자열 인덱스 분리
			// TODO : 포커스 되면 암호화된 문자열 원래 문자열로 변환, 블러되면 문자열 암호화 하고 originalValue 에 저장 -> 나중에 getText 에 이용
			var eidx = 0, pidx = 0;
			while (ess[eidx]) {
				if (pss[pidx] == "9") {
					newText += ess[eidx].number();
					pidx++;
					eidx++;
				}
				else if (pss[pidx] == "Z") {
					if (ess[eidx] > 0) {
						newText += ess[eidx];
					}
					else {
						newText += "1";
					}
					pidx++;
					eidx++;
				}
				else if (pss[pidx] == "X") {
					if (eventType == "blur") {
						newText += "*";
					}
					else {
						newText += ess[eidx];
					}
					pidx++;
					eidx++;
				}
				else if (typeof pss[pidx] != "undefined") {
					newText += pss[pidx];
					pidx++;
				}
				else {
					newText += ess[eidx];
					eidx++;
				}
			}
			/*
			 for(var eidx = 0;eidx<ess.length;eidx++){

			 }
			 */
			return newText;

		}
		else if (Object.isFunction(obj.config.pattern)) {
			returnValue = obj.config.pattern.call({val: val, objID: objID, config: obj.config}, val);
		}
		else {
			returnValue = val;
		}

		return returnValue;
	},
	bindPatternGetText: function(objID, objSeq) {

		if (!Object.isNumber(objSeq)) {
			/*
			 axf.each(this.objects, function (index, O) {
			 if (O.id == objID) {
			 objSeq = index;
			 return false;
			 }
			 });
			 */
			for (var index = 0; index < this.objects.length; index++) {
				if (this.objects[index].id == objID) {
					objSeq = index;
					break;
				}
			}
		}
		if (!Object.isNumber(objSeq)) return;
		var obj = this.objects[objSeq], val = obj.bindTarget.val();

		var regExpPattern, returnValue = "";
		if (obj.config.pattern == "moneyint") { // 소수점 포함안함
			returnValue = val.replace(/[\D]/g, "");
		}
		else if (obj.config.pattern == "money") { // 소수점 포함
			returnValue = (val == "") ? "" : val.number();
		}
		else if (obj.config.pattern == "bizno") {
			returnValue = val.replace(/\D/g, "");
		}
		else if (obj.config.pattern == "phone") {
			returnValue = val.replace(/\D/g, "");
		}
		else if (obj.config.pattern == "date" || obj.config.pattern == "date(/)" || obj.config.pattern == "date(년월일)") {
			returnValue = val.replace(/\D/g, "");
		}
		else if (obj.config.pattern == "datetime" || obj.config.pattern == "datetime(/)" || obj.config.pattern == "datetime(년월일)") {
			returnValue = val.replace(/\D/g, "");
		}
		else if (obj.config.pattern == "time") {
			returnValue = val.replace(/\D/g, "");
		}
		else if (obj.config.pattern == "custom") {
			returnValue = obj.originalValue;
		}
		else if (Object.isFunction(obj.config.depattern)) {
			returnValue = obj.config.depattern.call({val: val, objID: objID, config: obj.config}, val);
		}
		else {
			returnValue = val;
		}

		return returnValue;
	},
	bindPatternGetDisplayText: function(objID, objSeq) {

		if (!Object.isNumber(objSeq)) {
			/*
			 axf.each(this.objects, function (index, O) {
			 if (O.id == objID) {
			 objSeq = index;
			 return false;
			 }
			 });
			 */
			for (var index = 0; index < this.objects.length; index++) {
				if (this.objects[index].id == objID) {
					objSeq = index;
					break;
				}
			}
		}
		if (!Object.isNumber(objSeq)) return;
		var obj = this.objects[objSeq], val = obj.bindTarget.val();

		var regExpPattern, returnValue = "";
		if (Object.isFunction(obj.config.depattern)) {
			returnValue = obj.config.depattern.call({val: val, objID: objID, config: obj.config}, val);
		}
		else {
			returnValue = val;
		}

		return returnValue;
	},
	bindPatternSetText: function(objID, objSeq, val) {
		if (!Object.isNumber(objSeq)) {
			/*
			 axf.each(this.objects, function (index, O) {
			 if (O.id == objID) {
			 objSeq = index;
			 return false;
			 }
			 });
			 */
			for (var index = 0; index < this.objects.length; index++) {
				if (this.objects[index].id == objID) {
					objSeq = index;
					break;
				}
			}
		}
		if (!Object.isNumber(objSeq)) return;
		var obj = this.objects[objSeq];
		obj.bindTarget.val(this.bindPatternGetValue(objID, objSeq, val, "blur"));
		obj.bindTarget.trigger("change");
	},

	/**
	 * bindTagSelector
	 */
	bindTagSelector: function(objID, objSeq) {
		var _this = this, cfg = this.config,
			obj = this.objects[objSeq], po, h;

		if (!obj.config.onchange) obj.config.onchange = obj.config.onChange;
		if (!obj.bindAnchorTarget) obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
		if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
		if (!obj.bindTarget_paddingTop) obj.bindTarget_paddingTop = obj.bindTarget.css("padding-top");

		obj.bindTarget.css({"box-sizing": "content-box", "padding": obj.bindTarget_paddingTop});

		// 저장된 태그 리스트
		obj.tagList = [];
		obj.deletedTagList = [];

		obj.bindAnchorTarget.show();
		h = obj.bindAnchorTarget.data("height") - 2;

		po = [];
		po.push('<div id="' + cfg.targetID + '_AX_' + objID + '_AX_tagContainer" class="AXTag-selector-tagcontainer">');
		po.push('</div>');
		obj.bindAnchorTarget.html(po.join(''));
		obj.tagContainer = obj.bindAnchorTarget.find('#' + cfg.targetID + '_AX_' + objID + '_AX_tagContainer');

		// 태그 컨테이너 클릭 이벤트 연결

		obj.tagContainer.bind("click", (function(e) {
			var event_type = "";
			e = e || window.event;
			var target = axf.get_event_target(e.target, function(el) {
				if (axdom(el).hasClass("AXTag-selector-tagitem-remove")) {
					event_type = "remove";
					return true;
				}
				else if (axdom(el).hasClass("AXTag-selector-tagitem")) {
					event_type = "item";
					return true;
				}
			});

			if (target && event_type == "remove") {
				this.bindTagSelector_removeItem(objID, objSeq, axdom(target).attr("data-tag-index"));
			}
			else if (!target) obj.bindTarget.focus();

		}).bind(this));

		// 옵션 박스 패널
		obj.tagExpandBoxId = cfg.targetID + "_AX_" + objID + "_AX_expandBox";

		obj.bindTarget.unbind("focus.AXTagSelector").bind("focus.AXTagSelector", function(event) {
			if (obj.keydownTimer) clearTimeout(obj.keydownTimer);
			obj.keydownTimer = setTimeout((function(event) {
				if (event.target.value != "") _this.bindTagSelector_onkeydown(event, objID, objSeq);
			}).bind(_this, event), 100);
		});
		obj.bindTarget.unbind("keydown.AXTagSelector").bind("keydown.AXTagSelector", function(event) {
			if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") return false;

			if (obj.keydownTimer) clearTimeout(obj.keydownTimer);
			obj.keydownTimer = setTimeout((function(event) {
				_this.bindTagSelector_onkeydown(event, objID, objSeq);
			}).bind(_this, event), 100);
		});
	},
	bindTagSelector_onkeydown: function(e, objID, objSeq) {
		var _this = this, cfg = this.config,
			obj = this.objects[objSeq], po,
			anchorWidth, anchorHeight, styles, focusedIndex;

		if (e.type == "keydown") {
			if (e.target.value == "" && e.keyCode == axf.Event.KEY_BACKSPACE) {
				if (obj.tagList.length > 0) {
					if (obj.ready_backspace) {
						this.bindTagSelector_removeItem(objID, objSeq, obj.tagList.length - 1);
						this.bindTagSelector_close(objID, objSeq);
						obj.config.focusedIndex = undefined;
						delete obj.ready_backspace;
					}
					else {
						obj.ready_backspace = true;
					}
				}
				return this;
			}
			else {
				delete obj.ready_backspace;
			}

			if (
				e.keyCode == axf.Event.KEY_RETURN ||
				e.keyCode == axf.Event.KEY_DOWN ||
				e.keyCode == axf.Event.KEY_UP
			)
			{
				if (!AXgetId(obj.tagExpandBoxId)) return this;
				if (e.keyCode == axf.Event.KEY_RETURN) {
					if (typeof obj.config.focusedIndex !== "undefined") {
						this.bindTagSelector_addItem(objID, objSeq, obj.config.focusedIndex);
						this.bindTagSelector_close(objID, objSeq);
						obj.config.focusedIndex = undefined;
					}
				}
				else if (e.keyCode == axf.Event.KEY_DOWN) {
					focusedIndex = 0;
					if (typeof obj.config.focusedIndex !== "undefined") {
						axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + obj.config.focusedIndex + "_AX_option").removeClass("on");
						focusedIndex = Number(obj.config.focusedIndex) + 1;
						if (obj.config.options.length <= focusedIndex) focusedIndex = obj.config.options.length - 1;
					}
					axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + focusedIndex + "_AX_option").addClass("on");
					obj.config.focusedIndex = focusedIndex;
					obj.myUIScroll.focusElement(cfg.targetID + "_AX_" + objID + "_AX_" + focusedIndex + "_AX_option"); //focus
				}
				else if (e.keyCode == axf.Event.KEY_UP) {
					focusedIndex = 0;
					if (typeof obj.config.focusedIndex !== "undefined") {
						axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + obj.config.focusedIndex + "_AX_option").removeClass("on");
						focusedIndex = Number(obj.config.focusedIndex) - 1;
						if (0 > focusedIndex) focusedIndex = 0;
					}
					axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + focusedIndex + "_AX_option").addClass("on");
					obj.config.focusedIndex = focusedIndex;
					obj.myUIScroll.focusElement(cfg.targetID + "_AX_" + objID + "_AX_" + focusedIndex + "_AX_option"); //focus
				}
				return this;
			}
		}

		//console.log(e);
		if (!AXgetId(obj.tagExpandBoxId)) {
			//Expand Box 생성 구문 작성
			anchorWidth = obj.bindAnchorTarget.width() - 2; // anchor width
			anchorHeight = obj.bindAnchorTarget.data("height") - 1;
			styles = [];

			styles.push("top:" + anchorHeight + "px");
			styles.push("width:" + (obj.config.selectorWidth || anchorWidth) + "px");
			styles.push("z-index:10000");

			po = [];
			po.push("<div id=\"" + obj.tagExpandBoxId + "\" class=\"bindSelectorNodes " + cfg.anchorSelectorExpandBoxClassName + "\" style=\"" + styles.join(";") + "\">");
			po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandScroll\" class=\"bindSelectorNodes " + cfg.anchorSelectorExpandScrollClassName + "\">");
			po.push("	<div class=\"AXLoadingSmall bindSelectorNodes\"></div>");
			po.push("</div>");
			po.push("</div>");
			axdom(document.body).append(po.join(''));

			obj.tagExpandBox = axdom("#" + obj.tagExpandBoxId);
			obj.tagExpandBoxScroll = obj.tagExpandBox.find("#" + cfg.targetID + "_AX_" + objID + "_AX_expandScroll");
			if (obj.config.positionFixed) {
				obj.tagExpandBox.css({"position": "fixed"});
			}
			var expBoxHeight = obj.tagExpandBox.outerHeight();
			var offset = (obj.config.positionFixed) ? obj.bindAnchorTarget.position() : obj.bindAnchorTarget.offset();
			if (obj.config.position) {
				offset = obj.bindAnchorTarget.offset();
				if (obj.config.position.top != undefined) {
					offset.top = obj.config.position.top;
				}
			}
			var css = {};
			css.top = offset.top + anchorHeight;
			if (obj.config.direction == "bottom") {
				css.top -= obj.tagExpandBox.outerHeight();
			}

			css.left = offset.left;
			obj.tagExpandBox.css(css);

			// 다른 영역을 클릭했는가?
			axdom(document.body).unbind("click.AXTagSelector").bind("click.AXTagSelector", (function(e) {
				if (obj.blurTimer) clearTimeout(obj.blurTimer);
				obj.blurTimer = setTimeout(function() {
					_this.bindTagSelector_onclick(e || window.event, objID, objSeq);
				}, 100);
			}).bind(this));
			obj.bindTarget.unbind("blur.AXTagSelector").bind("blur.AXTagSelector", (function(e) {
				if (obj.blurTimer) clearTimeout(obj.blurTimer);
				obj.blurTimer = setTimeout(function() {
					_this.bindTagSelector_onclick(e || window.event, objID, objSeq);
				}, 700);
			}).bind(this));
		}
		this.bindTagSelector_setOptions(objID, objSeq, obj.bindTarget.val());
	},
	bindTagSelector_setOptions: function(objID, objSeq, kword) {
		var _this = this, cfg = this.config,
			obj = this.objects[objSeq], po,
			maxHeight = obj.config.maxHeight || 130,
			next_fn;

		obj.deletedTagList = [];
		next_fn = function() {
			if (po.length == 0) {
				var selectorOptionEmpty = "";
				if (AXConfig.AXInput) selectorOptionEmpty = (AXConfig.AXInput.selectorOptionEmpty || "empty options");
				po.push("<div class=\"empty\">" + selectorOptionEmpty + "</div>");
			}
			obj.tagExpandBoxScroll.html(po.join(''));

			var expandScrollHeight = obj.tagExpandBoxScroll.outerHeight();
			if (expandScrollHeight > maxHeight) expandScrollHeight = maxHeight;
			obj.tagExpandBox.css({height: expandScrollHeight + "px"});

			if (obj.myUIScroll) obj.myUIScroll.unbind();
			obj.myUIScroll = new AXScroll();
			obj.myUIScroll.setConfig({
				CT_className: "AXScrollSmall",
				targetID: cfg.targetID + "_AX_" + objID + "_AX_expandBox",
				scrollID: cfg.targetID + "_AX_" + objID + "_AX_expandScroll",
				touchDirection: false
			});
			obj.myUIScroll.scrollTop(0);

			if (obj.config.selectedIndex != undefined) {
				axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + obj.config.selectedIndex + "_AX_option").addClass("on");
				obj.myUIScroll.focusElement(cfg.targetID + "_AX_" + objID + "_AX_" + obj.config.selectedIndex + "_AX_option"); //focus
				obj.config.focusedIndex = obj.config.selectedIndex;
			}

			if (obj.config.direction == "bottom") {
				var offset = (obj.config.positionFixed) ? obj.bindAnchorTarget.position() : obj.bindAnchorTarget.offset();
				if (obj.config.position) {
					offset = obj.bindAnchorTarget.offset();
					if (obj.config.position.top != undefined) {
						offset.top = obj.config.position.top;
					}
				}
				obj.tagExpandBox.css({top: offset.top - obj.tagExpandBox.outerHeight()});
			}

			// focus item
			if (typeof kword !== "undefined" && kword != "") {
				kword = kword.replace(/\//g, "\\\/");
				var sw = axf.consonantKR((kword || "").dec());
				var reAt = new RegExp("^" + sw + ".*", "i");

				var ix = null;
				for (var i = 0, l = obj.config.options.length; i < l; i++) {
					if (reAt.test((obj.config.options[i][obj.config.reserveKeys.optionText] || ""))) {
						ix = i;
						break;
					}
				}
				if (ix != null) {
					if (typeof obj.config.focusedIndex !== "undefined") {
						axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + obj.config.focusedIndex + "_AX_option").removeClass("on");
					}
					axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + ix + "_AX_option").addClass("on");
					obj.config.focusedIndex = ix;
					obj.myUIScroll.focusElement(cfg.targetID + "_AX_" + objID + "_AX_" + ix + "_AX_option"); //focus
				}
			}
			else {
				if (obj.config.focusedIndex != undefined) {
					axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + obj.config.focusedIndex + "_AX_option").removeClass("on");
				}
			}
		};

		var get_options = function(options) {
			var npo = [];
			for (var i = 0, l = options.length; i < l; i++) {
				var O = options[i];
				// options의 optionText, optionDesc의 참조값을 디코딩해서 디코딩은 한 번만 사용하도록 변경
				O[obj.config.reserveKeys.optionText] = (O[obj.config.reserveKeys.optionText] ? O[obj.config.reserveKeys.optionText].dec() : "");
				O.desc = (O.desc ? O.desc.dec() : "");
				O.optionDesc = (O.optionDesc ? O.optionDesc.dec() : "");

				var descStr = O.desc || O.optionDesc, styles;
				if (descStr != "") descStr = "<span>" + descStr + "</span>";

				styles = "";
				for (var ti = 0, tl = obj.tagList.length, tag; ti < tl; ti++) {
					tag = obj.tagList[ti];
					//trace(tag[obj.config.reserveKeys.optionValue] == O[obj.config.reserveKeys.optionValue]);
					if (tag[obj.config.reserveKeys.optionValue] == O[obj.config.reserveKeys.optionValue]) {
						styles = ' style="text-decoration: line-through;"';
					}
				}
				npo.push("<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_" + i + "_AX_option\" class=\"bindSelectorNodes\" " + styles + ">"
					+ O[obj.config.reserveKeys.optionText] + descStr + "</a>");
			}
			return npo;
		};

		if (obj.config.ajaxUrl && kword != "") {

			obj.inProgress = true; //진행중 상태 변경
			var url = obj.config.ajaxUrl;
			var pars = obj.config.ajaxPars || {};
			var _method = "post";
			var _headers = {};
			var _contentType = AXConfig.AXReq.contentType;
			var _responseType = AXConfig.AXReq.responseType;
			var _dataType = AXConfig.AXReq.dataType;
			var _async = AXConfig.AXReq.async;

			// ajax 옵션 확장
			if (obj.config.method) _method = obj.config.method;
			if (obj.config.headers) _headers = obj.config.headers;
			if (obj.config.contentType) _contentType = obj.config.contentType;
			if (obj.config.responseType) _responseType = obj.config.responseType;
			if (obj.config.dataType) _dataType = obj.config.dataType;
			if (obj.config.ajaxAsync) _async = obj.config.ajaxAsync;

			var selectorName = obj.config.selectorName || obj.bindTarget.attr("name");
			if (pars == "") {
				pars = selectorName + "=" + (kword || "").enc();
			}
			else if ((typeof pars).toLowerCase() == "string") {
				pars += "&" + selectorName + "=" + kword.enc();
			}
			else if ((typeof pars).toLowerCase() == "object") {
				pars[selectorName] = kword.enc();
			}

			new AXReq(url, {
				type: _method,
				headers: _headers,
				contentType: _contentType,
				responseType: _responseType,
				dataType: _dataType,
				async: _async,
				debug: ((typeof obj.config.debug !== "undefined") ? obj.config.debug : false),
				pars: pars,
				onsucc: function(res) {

					if (!res.error) {

						obj.config.options = (res[obj.config.reserveKeys.options] || []);
						obj.config.focusedIndex = undefined;
						po = get_options(obj.config.options);
						next_fn.call(_this);

					}
					else {
						axf.alert(res.error);
					}
					obj.inProgress = false;
				}
			});

		}
		else if (obj.config.onsearch) {
			var res = obj.config.onsearch.call(
				{
					id: objID,
					value: kword
				},
				objID,
				kword,
				(function(res) {
					obj.config.options = res;
					obj.config.focusedIndex = undefined;
					po = get_options(obj.config.options);
					next_fn.call(_this);
				}).bind(this)
			);
		}
		else {
			//var optionPrintLength = obj.config.optionPrintLength || 100;
			if (!obj.config.options) {
				console.log("config.options is not defined");
				return this;
			}

			po = get_options(obj.config.options);

			//  옵션리스트 구성완료 후 처리
			next_fn.call(this);
		}
	},
	bindTagSelector_onclick: function(e, objID, objSeq) {
		var _this = this, cfg = this.config,
			obj = this.objects[objSeq];

		if (e.type == "blur") {
			this.bindTagSelector_close(objID, objSeq);
		}
		else if (e.type == "click") {
			var click_type = "";
			var target = axf.get_event_target(e.target, function(el) {
				if (axdom(el).hasClass("bindSelectorNodes")) {
					click_type = "option";
					return true;
				}
				else if (el.id == objID) {
					click_type = "input";
					return true;
				}
			});

			if (target) {
				//console.log(target, click_type);
				if (click_type == "option") {
					// get option index
					var ids = target.id.split(/_AX_/g);
					var optionIndex = ids[ids.length - 2];
					this.bindTagSelector_addItem(objID, objSeq, optionIndex);
					this.bindTagSelector_close(objID, objSeq);
				}
				else if (click_type == "input") {
					// 입풋을 누르다니..
				}
			}
			else {
				this.bindTagSelector_close(objID, objSeq);
			}
		}
		//trace(e.type);
		//trace(objID, objSeq);
	},
	bindTagSelector_close: function(objID, objSeq) {
		var _this = this, cfg = this.config,
			obj = this.objects[objSeq];

		if (obj.tagExpandBox) obj.tagExpandBox.remove();
		axdom(document.body).unbind("click.AXTagSelector");
		obj.bindTarget.unbind("blur.AXTagSelector");
	},
	bindTagSelector_addItem: function(objID, objSeq, optionIndex) {
		var _this = this, cfg = this.config,
			obj = this.objects[objSeq], objName, po, addOption, pass_add;

		if (isNaN(Number(optionIndex))) {
			console.log("optionIndex is NaN");
			return this;
		}

		//obj.tagList 태그저장리스트
		addOption = obj.config.options[optionIndex];
		pass_add = true; // 등록 허용
		for (var i = 0, l = obj.tagList.length, tag; i < l; i++) {
			tag = obj.tagList[i];
			if (tag[obj.config.reserveKeys.optionValue] == addOption[obj.config.reserveKeys.optionValue]) {
				pass_add = false; // 이미 등록된 값이 존재함.
				break;
			}
		}
		if (pass_add) {
			objName = obj.bindTarget.attr("name");
			po = [];
			if (!obj.config.optionValue_inputName) obj.config.optionValue_inputName = objName;
			po.push('<span class="AXTag-selector-tagitem" data-option-value="' + addOption[obj.config.reserveKeys.optionValue] + '">');
			if (obj.config.optionValue_inputName) po.push('<input type="hidden" name="' + obj.config.optionValue_inputName + '" value="' + addOption[obj.config.reserveKeys.optionValue] + '" />');
			if (obj.config.optionText_inputName) po.push('<input type="hidden" name="' + obj.config.optionText_inputName + '" value="' + addOption[obj.config.reserveKeys.optionText] + '" />');

			po.push(addOption[obj.config.reserveKeys.optionText]);
			po.push('<span class="AXTag-selector-tagitem-remove" data-tag-index="' + obj.tagList.length + '"></span>');
			po.push('</span>');
			obj.tagContainer.append(po.join(''));
			obj.tagList.push(addOption);
			//
			obj.bindTarget.css({"padding-top": obj.tagContainer.height()}).val('');
			obj.bindAnchorTarget.data("height", obj.bindTarget.outerHeight());
			axdom(window).resize();
		}
	},
	bindTagSelector_removeItem: function(objID, objSeq, tagIndex) {
		var _this = this, cfg = this.config,
			obj = this.objects[objSeq], po, objName = obj.bindTarget.attr("name");
		;

		if (typeof tagIndex !== "undefined") {
			obj.tagContainer.find('[data-tag-index="' + tagIndex + '"]').remove();
			obj.deletedTagList.push(obj.tagList[tagIndex]);
			obj.tagList.splice(tagIndex, 1);
		}

		po = [];
		for (var i = 0, l = obj.tagList.length, tag; i < l; i++) {
			tag = obj.tagList[i];
			po.push('<span class="AXTag-selector-tagitem" data-option-value="' + tag[obj.config.reserveKeys.optionValue] + '">');
			po.push('<input type="hidden" name="' + objName + '" value="' + tag[obj.config.reserveKeys.optionValue] + '" />');
			po.push(tag[obj.config.reserveKeys.optionText]);
			po.push('<span class="AXTag-selector-tagitem-remove" data-tag-index="' + i + '"></span>');
			po.push('</span>');
		}
		obj.tagContainer.html(po.join(''));

		if (obj.tagList.length == 0) {
			obj.bindTarget.css({"padding-top": obj.bindTarget_paddingTop}).val('');
		}
		else {
			obj.bindTarget.css({"padding-top": obj.tagContainer.height()}).val('');
		}

		obj.bindAnchorTarget.data("height", obj.bindTarget.outerHeight());
		axdom(window).resize();
	},
	bindTagSelector_setItem: function(objID, tags) {
		var cfg = this.config,
			objSeq = null, obj;
		for (var i = 0, l = this.objects.length; i < l; i++) {
			if (this.objects[i].id === objID) {
				objSeq = i;
				break;
			}
		}
		obj = this.objects[objSeq];
		obj.deletedTagList = [];

		if (Object.isArray(tags)) {
			obj.tagList = [];
			for (var i = 0, l = tags.length, tag; i < l; i++) {
				var tag = tags[i];
				if (typeof tag[obj.config.reserveKeys.optionValue] === "undefined") tag[obj.config.reserveKeys.optionValue] = tag.toString();
				if (typeof tag[obj.config.reserveKeys.optionText] === "undefined") tag[obj.config.reserveKeys.optionText] = tag.toString();
				obj.tagList.push(tag);
			}
			this.bindTagSelector_removeItem(objID, objSeq);
		}
		return this;
	},
	bindTagSelector_getItem: function(objID) {
		var cfg = this.config,
			objSeq = null, obj;
		for (var i = 0, l = this.objects.length; i < l; i++) {
			if (this.objects[i].id === objID) {
				objSeq = i;
				break;
			}
		}
		obj = this.objects[objSeq];
		return {list: obj.tagList, deletedList: obj.deletedTagList};
	}
});

var AXInputPro = new AXInputConverterPro();
AXInputPro.setConfig({targetID: "inputBasic"});

/**
 * @method jQueryFns.bindPattern
 * @param config {JSObject} bindConfig
 * @returns jQueryObject
 * @description
 * @example
 ```
 $("#id").bindPattern({
	pattern:"money|bizno|{function}"
});

 //sample
 $("#ax-bind-pattern-custom-target").bindPattern({
    pattern: function(val){
        //trace(this); //전달된 this를 확인 할 수 있습니다.
        return val.ucase();
    }
});
 ```
 */
axdom.fn.bindPattern = function(config) {
	axf.each(this, function() {
		if (!this.id) this.id = "AXInputPro-" + axf.getUniqueId();
		config = config || {};
		config.id = this.id;
		config.bindType = "pattern";
		AXInputPro.bind(config);
	});
	return this;
};

/**
 * @method jQueryFns.bindPatternSetConfig
 * @param config {JSObject} bindPattern config
 * @returns jQueryObject
 * @description
 * @example
 ```
 $("#id").bindPatternSetConfig({
    allow_minus: true,
	max_length: 5
 });
 ```
 */
axdom.fn.bindPatternSetConfig = function(config) {
	axf.each(this, function() {
		AXInputPro.bindSetConfig(this.id, config);
	});
	return this;
};

/**
 * @method jQueryFns.bindPatternGetText
 * @param
 * @returns returnVals {String|Array}
 * @description
 * @example
 ```
 var text = $("#id").bindPatternGetText();
 ```
 */
axdom.fn.bindPatternGetText = function() {
	var returnVals = "";
	axf.each(this, function() {
		var getVal = AXInputPro.bindPatternGetText(this.id);
		if (returnVals == "") {
			returnVals = getVal;
		}
		else {
			if (Object.isString(returnVals)) {
				returnVals = [returnVals]; // 형변환
				returnVals.push(getVal);
			}
			else if (Object.isArray(returnVals)) {
				returnVals.push(getVal);
			}
		}
	});
	return returnVals;
};

/**
 * @method jQueryFns.bindPatternSetText
 * @param val {String}
 * @returns jQueryObject
 * @description
 * @example
 ```
 $("#id").bindPatternSetText("12345.123");
 ```
 */
axdom.fn.bindPatternSetText = function(val) {
	axf.each(this, function() {
		AXInputPro.bindPatternSetText(this.id, null, val);
	});
	return this;
};

/**
 * @method jQueryFns.bindPatternGetDisplayText
 * @param null
 * @returns String
 * @description 표시된 값 가져오는 함수
 * @example
 ```
 $("#id").bindPatternGetDisplayText();
 ```
 */

axdom.fn.bindPatternGetDisplayText = function() {
	var returnVals = "";
	axf.each(this, function() {
		var getVal = AXInputPro.bindPatternGetDisplayText(this.id);
		if (returnVals == "") {
			returnVals = getVal;
		}
		else {
			if (Object.isString(returnVals)) {
				returnVals = [returnVals]; // 형변환
				returnVals.push(getVal);
			}
			else if (Object.isArray(returnVals)) {
				returnVals.push(getVal);
			}
		}

	});
	return returnVals;
};

/**
 * @method jQueryFns.bindTagSelector
 * @param config {JSObject} bindConfig
 * @returns jQueryObject
 * @description
 * @example
 * ```js
 * //sample
 * $("#ax-bind-pattern-custom-target").bindTagSelector({
 *
 * });
 * ```
 */
axdom.fn.bindTagSelector = function(config) {
	axf.each(this, function() {
		if (!this.id) this.id = "AXInputPro-" + axf.getUniqueId();
		config = config || {};
		config.id = this.id;
		config.bindType = "tagSelector";
		AXInputPro.bind(config);
	});
	return this;
};

/**
 * @method jQueryFns.bindTagSelector_setItem
 * @param config {JSObject} bindConfig
 * @returns jQueryObject
 * @description
 * @example
 * ```js
 * //sample
 * $("#ax-bind-pattern-custom-target").bindTagSelector_setItem([
 *  {optionValue:1, optionText:"Seoul"},
 *  {optionValue:2, optionText:"대구"}
 * ]);
 * ```
 */
axdom.fn.bindTagSelector_setItem = function(list) {
	axf.each(this, function() {
		AXInputPro.bindTagSelector_setItem(this.id, list);
	});
	return this;
};

/**
 * @method jQueryFns.bindTagSelector_getItem
 * @returns Object
 * @description
 * @example
 * ```js
 * //sample
 * $("#ax-bind-pattern-custom-target").bindTagSelector_getItem();
 * ```
 */
axdom.fn.bindTagSelector_getItem = function() {
	if (this[0])
		return AXInputPro.bindTagSelector_getItem(this[0].id);
}


/* ---------------------------- */
var AXMobileMenu = Class.create(AXJ, {
    initialize: function(AXJ_super) {
		AXJ_super();
		
		this.moveSens = 0;
		this.config.moveSens = 1;
		this.touchMode;
		this.selectedPoi = null;
		this.config.width = 300;
		this.config.height = 388;
		this.config.reserveKeys = {
			labelKey:"label",
			urlKey:"url",
			targetKey:"target",
			addClassKey:"addClass",
			subMenuKey:"cn"
		};
    },
/**
 * 선언된 클래스를 사용하기 위해 속성을 정의합니다.
 * @method AXMobileMenu.setConfig
 * @param {Object} Config of Object
 * @example
```js
var myMobileMenu = new AXMobileMenu();
myMobileMenu.setConfig({
	// 사용자 키 정의
	reserveKeys:{
		primaryKey:"menuID",
		labelKey:"label",
		urlKey:"url",
		targetKey:"target",
		addClassKey:"ac",
		subMenuKey:"cn"
	},

	// ac : 메뉴 아이템에 추가하고 싶은 클래스 네임 addClass의 약자
	menu:[
		{menuID:"1", label:"menu 1", ac:"Dashboard", url:"http://www.axisj.com"},
		{menuID:"4", label:"menu 4", ac:"Cashiering", url:"http://www.axisj.com"},
		{menuID:"5", label:"menu 5", ac:"Housekeeping", url:"http://www.axisj.com"},
		{menuID:"6", label:"menu 6", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"2", label:"menu 2", ac:"Reservation", cn:[
			{menuID:"2-1", label:"menu 2-1", url:"http://www.axisj.com"},
			{menuID:"2-2", label:"menu 2-2", cn:[
				{menuID:"2-2-1", label:"menu 2-2-1", url:"http://www.axisj.com"},
				{menuID:"2-2-2", label:"menu 2-2-2", url:"http://www.axisj.com"},
				{menuID:"2-2-3", label:"menu 2-2-3", url:"http://www.axisj.com"}
			]},
			{menuID:"2-3", label:"menu 2-3", url:"http://www.axisj.com"},
			{menuID:"2-4", label:"menu 2-4", url:"http://www.axisj.com"},
			{menuID:"2-5", label:"menu 2-5", url:"http://www.axisj.com"},
			{menuID:"2-6", label:"menu 2-6", url:"http://www.axisj.com"},
			{menuID:"2-7", label:"menu 2-7", url:"http://www.axisj.com"},
			{menuID:"2-8", label:"menu 2-8", url:"http://www.axisj.com"},
			{menuID:"2-9", label:"menu 2-9", url:"http://www.axisj.com"},
			{menuID:"2-10", label:"menu 2-10", url:"http://www.axisj.com"},
			{menuID:"2-11", label:"menu 2-11", url:"http://www.axisj.com"},
			{menuID:"2-12", label:"menu 2-12", url:"http://www.axisj.com"},
			{menuID:"2-13", label:"menu 2-13", url:"http://www.axisj.com"}
		]},
		{menuID:"7", label:"menu 7", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"8", label:"menu 8", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"9", label:"menu 9", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"10", label:"menu 10", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"11", label:"menu 11", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"12", label:"menu 12", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"13", label:"menu 13", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"14", label:"menu 14", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"15", label:"menu 15", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"16", label:"menu 16", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"17", label:"menu 17", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"18", label:"menu 18", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"19", label:"menu 19", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"20", label:"menu 20", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"21", label:"menu 21", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"22", label:"menu 22", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"23", label:"menu 23", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"3", label:"menu 3", ac:"Guest", cn:[
			{menuID:"3-1", label:"menu 3-1", url:"http://www.axisj.com"},
			{menuID:"3-2", label:"menu 3-2", cn:[
				{menuID:"3-2-1", label:"menu 3-2-1", url:"http://www.axisj.com"},
				{menuID:"3-2-2", label:"menu 3-2-2", url:"http://www.axisj.com"},
				{menuID:"3-2-3", label:"menu 3-2-3", url:"http://www.axisj.com"}
			]},
			{menuID:"3-3", label:"menu 3-3", url:"http://www.axisj.com"},
			{menuID:"3-4", label:"menu 3-4", url:"http://www.axisj.com"},
			{menuID:"3-5", label:"menu 3-5", url:"http://www.axisj.com"}
		]},
		{menuID:"24", label:"menu 24", ac:"Configuration", url:"http://www.axisj.com"}
	],
	onclick: function(){ // 메뉴 클릭 이벤트
		myMobileMenu.close();
		//location.href = this.url;
	}
});
```
 */
    init: function() {
		var cfg = this.config;
		
		/* 이벤트 대소문자 확장 */
		if(!cfg.onclick) cfg.onclick = cfg.onClick;


	    if(cfg.menuBoxID){
		    // 메뉴데이터 태그로 부터 가져오기
		    cfg.menu = this.collectMenuItem(cfg.menuBoxID);
	    }

		//var close = this.close.bind(this);
		this.modal = new AXMobileModal();
		this.modal.setConfig({
			addClass:"AXMobileMenu",
			height: cfg.height,
			width: cfg.width,
			head:{
				close:{
					onclick:function(){
						
					}
				}
			},
			onclose: function(){
				//close();
			}
		});
		
    },
/**
 * 모바일 메뉴를 오픈합니다.
 * @method AXMobileMenu.open
 * @returns {AXMobileMenu}
 * @example
```js
 <button class="AXButton" onclick="myMobileMenu.open();">Open the mobile menu</button>
```
 */
    open: function(){
    	var cfg = this.config;
    	/*
    	var obj = this.modal.open();
    	this.initMenu(obj);
    	*/
    	var onLoad = this.initMenu.bind(this);
    	this.modal.open(null, onLoad);
		return this;
    },
    initMenu: function(obj){
    	var cfg = this.config;
    	this.modalObj = obj;
    	this.modalID = obj.jQueryModal.get(0).id;
    	
    	if(this.selectedPoi){
    		var lpoi = this.selectedPoi.last();
    		var apoi = this.selectedPoi.concat();
    		apoi.pop();
    		var menu = cfg.menu;
			axf.each(apoi, function(idx, P){
				if(idx == 0){
					menu = menu[P];
				}else{
					menu = menu[cfg.reserveKeys.subMenuKey][P];
				}
			});
			
			if(menu[cfg.reserveKeys.subMenuKey] && menu[cfg.reserveKeys.subMenuKey][lpoi][cfg.reserveKeys.subMenuKey] && menu[cfg.reserveKeys.subMenuKey][lpoi][cfg.reserveKeys.subMenuKey].length > 0){
				apoi.push(lpoi);
				var tpl = this.getMenu(this.modalID, menu[cfg.reserveKeys.subMenuKey][lpoi], apoi);
			}else{
				var tpl = this.getMenu(this.modalID, menu, apoi);
			}			
    	}else{
    		var tpl = this.getMenu(this.modalID, cfg.menu);
    	}
    	
		if(AXUtil.browser.mobile){
			//obj.modalBody.unbind("touchstart.AXMobileMenu").bind("touchstart.AXMobileMenu", this.touchstart.bind(this));
			var modalBodyID = obj.modalBody.get(0).id;
			var touchstart = this.touchstart.bind(this);
			this.touchstartBind = function () {
				touchstart();
			};
			if (document.addEventListener) {
				AXgetId(modalBodyID).addEventListener("touchstart", this.touchstartBind, false);
			}
		}else{
			obj.modalBody.unbind("mousedown.AXMobileMenu").bind("mousedown.AXMobileMenu", this.touchstart.bind(this));
		}

		obj.modalBody.attr("onselectstart", "return false");
		//obj.modalBody.addClass("AXUserSelectNone");
		obj.modalBody.bind("click.AXMobileMenu", this.onclickModalBody.bind(this));
		
    	/* drag cancle */
    	//obj.modalBody.unbind("dragstart.AXMobileMenu").bind("dragstart.AXMobileMenu", this.cancelEvent.bind(this));
    	this.printMenu(tpl);
    },
    printMenu: function(tpl){
    	var obj = this.modalObj;
    	
    	obj.modalHead.empty();
    	obj.modalHead.append(tpl.headPo);
    	obj.modalBody.empty();
    	obj.modalBody.append(tpl.bodyPo);
    	obj.modalFoot.empty();
    	obj.modalFoot.append(tpl.pagePo);
    	
    	/*
    	obj.modalBody.hide();
    	obj.modalBody.fadeIn("300");
    	*/
    	obj.modalHead.find(".mobileMenuHome").bind("click", this.onclickHome.bind(this));
    	obj.modalHead.find(".mobileMenuPrev").bind("click", this.onclickPrev.bind(this));
    	
		this.menuPageWidth = obj.modalBody.find(".mobileMenuBodyPage").width() + 9;
    	this.mobileMenuBodyScroll = obj.modalBody.find(".mobileMenuBodyScroll");
    	obj.modalBody.find(".mobileMenuBodyScroll").css({width:tpl.pageNum * this.menuPageWidth});
    },
    getMenu: function(modalID, _menu, poi){
    	var cfg = this.config;
    	var countPerBlock = 9;
    	var menu = _menu;
    	var menuTitle = "";
    	if(poi == undefined || poi.length == 0) poi = [];
    	else{
    		menuTitle = menu[cfg.reserveKeys.labelKey];
    		menu = menu[cfg.reserveKeys.subMenuKey];
    	}

    	var headPo = [];
    	/* 현재 선택된 메뉴 선택 하는 기능구현 필요 */
    	headPo.push('<a ' + cfg.href + ' class="mobileMenuHome">home</a>');
    	if(menuTitle != ""){
    		headPo.push('<a ' + cfg.href + ' class="mobileMenuPrev" id="', modalID ,'_AX_menuTitle_AX_', poi.join("_"),'">', menuTitle,'</a>');
    	}
		
    	var bodyPo = [];
    	bodyPo.push('<div class="mobileMenuBody">');
    	bodyPo.push('	<div class="mobileMenuBodyScroll" id="', modalID ,'_AX_bodyScroll">');
    	bodyPo.push('		<div class="mobileMenuBodyPage">');
    	
    	var ppoi = poi.join("_");
    	if(ppoi != "") ppoi += "_";
    	
    	var selectedPoi = "";
    	if(this.selectedPoi){
    		selectedPoi = this.selectedPoi.join("_");
    	}
    	
    	axf.each(menu, function(midx, M){
    		if(midx % countPerBlock == 0 && midx > 0){
    			bodyPo.push('	</div>');
    			bodyPo.push('	<div class="mobileMenuBodyPage">');
    		}
    		var addClass = [];
    		if(this[cfg.reserveKeys.addClassKey]){
    			addClass.push(this[cfg.reserveKeys.addClassKey]);
    		}
    		if(selectedPoi == (ppoi + midx)){
    			addClass.push("selected");
    		}
    		bodyPo.push('<a ' + cfg.href + ' class="mobileMenuItem ' + addClass.join(" ") + '" id="', modalID,'_AX_', ppoi, midx,'">');
    		bodyPo.push(this[cfg.reserveKeys.labelKey]);
    		if(this[cfg.reserveKeys.subMenuKey] && this[cfg.reserveKeys.subMenuKey].length > 0){
    			bodyPo.push('<span class="hasSubMenu"></span>');
    		}
    		bodyPo.push('</a>');
    	});
    	bodyPo.push('		</div>');
    	bodyPo.push('	</div>');
    	bodyPo.push('</div>');

		var pageNum = (menu.length / (countPerBlock)).ceil();
		this.pageNo = 0;
		this.pageNum = pageNum;

    	var pagePo = [];
    	pagePo.push('<div class="mobileMenuFoot">');
    	axf.each(pageNum.rangeFrom(1), function(pidx, p){
    		if(pidx == 0) pagePo.push('<div class="pageNav on" ');
    		else pagePo.push('<div class="pageNav" ');
    		pagePo.push(' id="', modalID ,'_AX_pageNav_AX_', pidx ,'"></div>');
    	});
    	pagePo.push('</div>');

    	return {
    		headPo : headPo.join(''),
    		bodyPo : bodyPo.join(''),
    		pagePo : pagePo.join(''),
    		pageNum : ( pageNum )
    	};
    },
/**
 * 모바일 메뉴를 닫습니다.
 * @method AXMobileMenu.close
 * @returns {AXMobileMenu}
 * @example
 ```js
 myMobileMenu.close();
 ```
 */
    close: function(){
    	var cfg = this.config;
    	this.modal.close();
		return this;
    },
/**
 * 모바일 메뉴 트리 인덱스에 해당하는 메뉴를 선택된 상태로 표시합니다. '-' 는 하위 뎁스표현
 * @method AXMobileMenu.setHighLight
 * @param {String} menuID
 * @returns {AXMobileMenu}
 * @example
```js
 myMobileMenu.setHighLight("2-2");
```
 */
    setHighLight: function(menuID){
    	var cfg = this.config;
		
		var menu = cfg.menu;
		var pois = "";
		
		var treeFn = function(subTree, parentPoi){
			axf.each(subTree, function(idx, M){
				if(M[cfg.reserveKeys.primaryKey] == menuID){
					pois = parentPoi + "_" + idx;
					return false;
				}else{
					if(M[cfg.reserveKeys.subMenuKey] && M[cfg.reserveKeys.subMenuKey].length > 0) treeFn(M[cfg.reserveKeys.subMenuKey], parentPoi + "_" + idx);
				}
			});
		};
		
		axf.each(menu, function(idx, M){
			if(M[cfg.reserveKeys.primaryKey] == menuID){
				pois = idx + "";
				return false;
			}else{
				if(M[cfg.reserveKeys.subMenuKey] && M[cfg.reserveKeys.subMenuKey].length > 0) treeFn(M[cfg.reserveKeys.subMenuKey], idx);
			}
		});

		var poi;
		if(pois != "") poi = pois.split(/_/g);
		this.selectedPoi = poi;
		return this;
    },
/**
 * 모바일 메뉴 트리 인덱스에 해당하는 메뉴를 선택된 상태로 표시합니다. '-' 는 하위 뎁스표현
 * @method AXMobileMenu.setHighLightMenu
 * @param {String} menuID
 * @returns {AXMobileMenu}
 * @example
 ```js
 myMobileMenu.setHighLightMenu("2-2");
 ```
 */
    setHighLightMenu: function(menuID){
    	return this.setHighLight(menuID);
    },
/**
 * 모바일 메뉴 데이터에 사용자가 정의한 id에 해당하는 메뉴를 선택된 상태로 표시합니다.
 * @method AXMobileMenu.setHighLightOriginID
 * @param {String} menuID
 * @returns {AXMobileMenu}
 * @example
 ```js
 mxMenu.setHighLightOriginID("ID1245");
 ```
 */
	setHighLightOriginID: function(menuID){
		var cfg = this.config;

		var menu = cfg.menu;
		var pois = "";

		var treeFn = function(subTree, parentPoi){
			axf.each(subTree, function(idx, M){
				if(M._id == menuID){
					pois = parentPoi + "_" + idx;
					return false;
				}else{
					if(M[cfg.reserveKeys.subMenuKey] && M[cfg.reserveKeys.subMenuKey].length > 0) treeFn(M[cfg.reserveKeys.subMenuKey], parentPoi + "_" + idx);
				}
			});
		};

		axf.each(menu, function(idx, M){
			if(M._id == menuID){
				pois = idx + "";
				return false;
			}else{
				if(M[cfg.reserveKeys.subMenuKey] && M[cfg.reserveKeys.subMenuKey].length > 0) treeFn(M[cfg.reserveKeys.subMenuKey], idx);
			}
		});

		var poi;

		//trace(pois);

		if(pois != "") poi = pois.split(/_/g);
		this.selectedPoi = poi;
	},
    onclickModalBody: function(event){
    	var cfg = this.config;
		var eid = event.target.id.split(/_AX_/g);
		var eventTarget = event.target;
		var myTarget = this.getEventTarget({
			evt : eventTarget, evtIDs : eid,
			until:function(evt, evtIDs){ return (axdom(evt.parentNode).hasClass("mobileMenuBodyScroll")) ? true:false; },
			find:function(evt, evtIDs){ return (axdom(evt).hasClass("mobileMenuItem")) ? true : false; }
		});
		
		if(myTarget){
			//something
			//trace(myTarget.id);
			var poi = myTarget.id.split(/_AX_/g).last();
			var menu = cfg.menu;
			var apoi = poi.split(/_/g);
			axf.each(apoi, function(idx, P){
				if(idx == 0){
					menu = menu[P];
				}else{
					menu = menu[cfg.reserveKeys.subMenuKey][P];
				}
			});
			
			if(menu[cfg.reserveKeys.subMenuKey] && menu[cfg.reserveKeys.subMenuKey].length > 0){
				/* animated menu */
				var menuItem = this.modalObj.modalBody.find("#"+myTarget.id);
				menuItem.css({opacity:0});
				var menuItemPos = menuItem.position();

				var mobileMenuBody = this.modalObj.modalBody.find(".mobileMenuBodyScroll");
				var bodyPos = mobileMenuBody.position();
				var cloneMenuItem = axdom("<div class='mobileMenuItemGhost' id='"+this.modalID+"_AX_cloneMenuItem'>" + menuItem.html() + "</div>");
				mobileMenuBody.append(cloneMenuItem);
				cloneMenuItem.css({
					position:"absolute",
					left:menuItemPos.left,
					top:menuItemPos.top
				});

				var getMenuBind = this.getMenu.bind(this);
				var printMenuBind = this.printMenu.bind(this);
				var modalID = this.modalID;
				cloneMenuItem.animate({left:9 - bodyPos.left, top:0, width:270, height:270}, 300, "backInOut").animate({opacity:0}, 100, "expoOut", function () {
					var tpl = getMenuBind(modalID, menu, apoi);
					printMenuBind(tpl);
				});
				
				return;
			}else{
				if(cfg.onclick){
					cfg.onclick.call(menu, menu);
				}
			}
		}
    },
    onclickHome: function(event){
    	var cfg = this.config;
    	var tpl = this.getMenu(this.modalID, cfg.menu);
    	this.printMenu(tpl);
    },
    onclickPrev: function(event){
    	var cfg = this.config;
    	var poi = event.target.id.split(/_AX_/g).last();
		var menu = cfg.menu;
		var apoi = poi.split(/_/g);
		apoi.pop();
		
		axf.each(apoi, function(idx, P){
			if(idx == 0){
				menu = menu[P];
			}else{
				menu = menu[cfg.reserveKeys.subMenuKey][P];
			}
		});
    	
    	var tpl = this.getMenu(this.modalID, menu, apoi);
    	this.printMenu(tpl);
    },
/**
 * 모바일 메뉴 데이터를 설정합니다.
 * @method AXMobileMenu.setTree
 * @param {Object} tree
 * @returns {AXMobileMenu}
 * @example
```js
 var menuStr = '[{"label":"test", "link":"/index.php?mid=page_XhGM56", "target":"_self", "url":"page_XhGM56", "selected":1, "expand":"N", "isShow":true, "parent_srl":"0", "k":"66", "cn":null}, {"label":"We are...", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"0", "k":"104", "cn":[{"label":"Jowrney & Stacey", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"104", "k":"105", "cn":[{"label":"aaa", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"105", "k":"140", "cn":[{"label":"ddd", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"140", "k":"143", "cn":[{"label":"fff", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"143", "k":"145", "cn":null}], "addClass":"hasSubMenu"}, {"label":"eee", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"140", "k":"144", "cn":null}], "addClass":"hasSubMenu"}, {"label":"bbb", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"105", "k":"141", "cn":null}, {"label":"ccc", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"105", "k":"142", "cn":null}], "addClass":"hasSubMenu"}, {"label":"Bike", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"104", "k":"106", "cn":null}, {"label":"Gear & Stuff", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"104", "k":"107", "cn":null}, {"label":"Media outlet", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"104", "k":"108", "cn":null}, {"label":"Sponsor", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"104", "k":"109", "cn":null}, {"label":"World adventure proposal", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"104", "k":"110", "cn":null}, {"label":"iBooks", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"104", "k":"111", "cn":null}, {"label":"Rewards", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"104", "k":"112", "cn":null}, {"label":"Rancho", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"104", "k":"113", "cn":null}], "addClass":"hasSubMenu"}, {"label":"Route", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"0", "k":"114", "cn":[{"label":"Where we go", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"114", "k":"115", "cn":null}, {"label":"Trace of flybasket", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"114", "k":"116", "cn":null}, {"label":"Cost", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"114", "k":"117", "cn":null}], "addClass":"hasSubMenu"}, {"label":"Travels", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"0", "k":"118", "cn":[{"label":"World Adventure", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"118", "k":"119", "cn":null}, {"label":"2013 Dokdo, Aroound the Ulleun island", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"118", "k":"120", "cn":null}, {"label":"2012 Cross country, along the river", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"118", "k":"121", "cn":null}, {"label":"2011 Around the Jeju island", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"118", "k":"122", "cn":null}, {"label":"2010 Jumujin, Go to the East sea", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"118", "k":"123", "cn":null}, {"label":"2009 We rode the japan honeymoon", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"118", "k":"124", "cn":null}, {"label":"2008 Haenam, the end of the Korea", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"118", "k":"125", "cn":null}], "addClass":"hasSubMenu"}, {"label":"Blog", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"0", "k":"126", "cn":null}, {"label":"Project", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"0", "k":"127", "cn":[{"label":"Experience farm in the world", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"127", "k":"128", "cn":null}, {"label":"Click the shutter for the world", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"127", "k":"129", "cn":null}, {"label":"10 thousands hours playing the violins", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"127", "k":"130", "cn":null}, {"label":"Go to 30,000 km by bike", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"127", "k":"131", "cn":null}, {"label":"On around the earth", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"127", "k":"132", "cn":null}, {"label":"Create UI set by countries", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"127", "k":"133", "cn":null}], "addClass":"hasSubMenu"}, {"label":"Friends", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"0", "k":"134", "cn":null}, {"label":"Guestbook", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"0", "k":"135", "cn":null}, {"label":"Donation", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"0", "k":"136", "cn":null}] ';
 myMobileMenu.setTree( menuStr.object() );
```
 */
    setTree: function(tree){
    	this.config.menu = tree;
		return this;
    },
	collectMenuItem: function(targetID){
		var cfg = this.config;
		var menuBox = axdom("#"+targetID)
		var tree = [];

		//{menuID:"1", label:"menu 1", ac:"Dashboard", url:"http://www.axisj.com"}
		var initChilds = function(EL, cid, _tree){
			var childDiv = jQuery(EL).children("."+cfg.childsMenu.className).get(0);
			if(childDiv) {
				var childDivID = cid.replace("PMA", "PMC");
				if(!childDiv.id) childDiv.id = childDivID;
				else childDivID = childDiv.id;

				jQuery("#"+childDivID+">ul>li").each(function(ci, EL) {
					var citem = {}, c_domEL = axdom(EL);
					if(c_domEL.children("A").attr("data-axmenuid")){
						citem._id = c_domEL.children("A").attr("data-axmenuid");
					}else if(c_domEL.children("A").get(0).id) {
						citem._id = c_domEL.children("A").get(0).id;
					}else {
						c_domEL.children("A").get(0).id = (citem._id = cid + "_" + ci);
					}

					citem[cfg.reserveKeys.primaryKey] = cid + "_" + ci;
					citem[cfg.reserveKeys.labelKey] = c_domEL.children("A").text();
					citem[cfg.reserveKeys.urlKey] = c_domEL.children("A").attr("href");
					citem[cfg.reserveKeys.targetKey] = c_domEL.children("A").attr("target") || "_self";
					citem[cfg.reserveKeys.addClassKey] = c_domEL.children("A").attr("class") || "";
					citem[cfg.reserveKeys.subMenuKey] = [];
					_tree[cfg.reserveKeys.subMenuKey].push(citem);

					//trace(pi,  ci);
					initChilds(EL, citem[cfg.reserveKeys.primaryKey], _tree[cfg.reserveKeys.subMenuKey][ci]);
				});
			}
		};

		menuBox.find("." + cfg.parentMenu.className).each(function(pi, EL){
			if(!EL.id) EL.id = cfg.menuBoxID + "_PM_" + pi;
			var item = {}, domEL = axdom(EL), nid = "";
			if(domEL.children("A").attr("data-axmenuid")){
				item._id = domEL.children("A").attr("data-axmenuid");
			}else if(domEL.children("A").get(0).id) {
				item._id = domEL.children("A").get(0).id;
			}else {
				domEL.children("A").get(0).id = (item._id = cfg.menuBoxID + "_PMA_" + pi);
			}

			if(domEL.children("A").get(0).id) {
				nid = domEL.children("A").get(0).id;
			}else {
				nid = cfg.menuBoxID + "_PMA_" + pi;
			}

			item._child_id = nid.replace("PMA", "PMC");
			item[cfg.reserveKeys.primaryKey] = targetID + "_PM_" + pi;
			item[cfg.reserveKeys.labelKey] = domEL.children("A").text();
			item[cfg.reserveKeys.urlKey] = domEL.children("A").attr("href");
			item[cfg.reserveKeys.targetKey] = domEL.children("A").attr("target") || "_self";
			item[cfg.reserveKeys.addClassKey] = domEL.children("A").attr("class") || "";
			item[cfg.reserveKeys.subMenuKey] = [];
			tree.push(item);

			var child = domEL.children("."+cfg.childMenu.className).get(0);
			if(child){
				if(!child.id) child.id = item._child_id;
				jQuery("#"+item._child_id+">ul>li").each(function(ci, EL) {
					var citem = {}, c_domEL = axdom(EL);

					if(c_domEL.children("A").attr("data-axmenuid")){
						citem._id = c_domEL.children("A").attr("data-axmenuid");
					}else if(c_domEL.children("A").get(0).id) {
						citem._id = c_domEL.children("A").get(0).id;
					}else {
						c_domEL.children("A").get(0).id = (citem._id = item._child_id.replace("PMC", "PMA") + "_" + ci);
					}

					citem[cfg.reserveKeys.primaryKey] = item._child_id.replace("PMC", "PMA") + "_" + ci;
					citem[cfg.reserveKeys.labelKey] = c_domEL.children("A").text();
					citem[cfg.reserveKeys.urlKey] = c_domEL.children("A").attr("href");
					citem[cfg.reserveKeys.targetKey] = c_domEL.children("A").attr("target") || "_self";
					citem[cfg.reserveKeys.addClassKey] = c_domEL.children("A").attr("class") || "";
					citem[cfg.reserveKeys.subMenuKey] = [];
					tree[pi][cfg.reserveKeys.subMenuKey].push(citem);

					//trace(pi,  ci);
					initChilds(EL, citem[cfg.reserveKeys.primaryKey], tree[pi][cfg.reserveKeys.subMenuKey][ci]);
				});
			}else{

			}
		});

		return tree;
	},
    /* 메뉴 터치 이동관련 함수 - s */
	touchstart: function (e) {
		var cfg = this.config;

		var touch;
		var event = window.event;
		if (AXUtil.browser.mobile){
			touch = event.touches[0];
			if (!touch.pageX) return;
		}else{
			var event = e;
			touch = {
				pageX : e.pageX, 
				pageY : e.pageY
			};
		}
		
		this.touchStartXY = {
			sTime: ((new Date()).getTime() / 1000),
			sLeft:  this.mobileMenuBodyScroll.position().left,
			x: touch.pageX,
			y: touch.pageY
		};

		if(AXUtil.browser.mobile){
			var event = window.event;
			var touchEnd = this.touchEnd.bind(this);
			this.touchEndBind = function () {
				touchEnd(event);
			};	
			var touchMove = this.touchMove.bind(this);
			this.touchMoveBind = function () {
				touchMove(event);
			};
			if (document.addEventListener) {
				document.addEventListener("touchend", this.touchEndBind, false);
				document.addEventListener("touchmove", this.touchMoveBind, false);
			}
		}else{
			axdom(document.body).bind("mouseup.AXMobileMenu", this.touchEnd.bind(this));
			axdom(document.body).bind("mousemove.AXMobileMenu", this.touchMove.bind(this));
		}
		
		this.mobileMenuBodyScroll.stop();
	},
	touchMove: function (e) {
		if (this.touhEndObserver) clearTimeout(this.touhEndObserver); //닫기 명령 제거
		var cfg = this.config;
		
		var touch;
		var event = window.event;
		if (AXUtil.browser.mobile){
			touch = event.touches[0];
			if (!touch.pageX) return;
		}else{
			var event = e;
			touch = {
				pageX : e.pageX, 
				pageY : e.pageY
			};
		}
		
		if ((this.touchStartXY.x - touch.pageX).abs() < (this.touchStartXY.y - touch.pageY).abs()) {
			//this.touchMode = ((this.touchStartXY.y - touch.pageY) <= 0) ? "up" : "dn"; /* 위아래 이동 */
		} else if ((this.touchStartXY.x - touch.pageX).abs() > (this.touchStartXY.y - touch.pageY).abs()) {
			//this.touchMode = ((this.touchStartXY.x - touch.pageX) <= 0) ? "lt" : "rt"; /* 좌우 이동 */
			
			this.moveBlock(touch.pageX - this.touchStartXY.x);
			if (event.preventDefault) event.preventDefault();
			else return false;
			
		}
		if (((this.touchStartXY.x - touch.pageX).abs() - (this.touchStartXY.y - touch.pageY).abs()).abs() < 5) {
			//this.touchSelecting = true;
		}
	},
	touchEnd: function (e) {
		var cfg = this.config;
		var event = window.event || e;
		//this.moveSens = 0;
		//this.touchMode = false;
		
		if(AXUtil.browser.mobile){
			if (document.removeEventListener) {
				document.removeEventListener("touchend", this.touchEndBind, false);
				document.removeEventListener("touchmove", this.touchMoveBind, false);
			}
		}else{
			axdom(document.body).unbind("mouseup.AXMobileMenu");
			axdom(document.body).unbind("mousemove.AXMobileMenu");
		}
		
		var moveEndBlock = this.moveEndBlock.bind(this);
		this.touhEndObserver = setTimeout(function () {
			moveEndBlock();
		}, 10);
	},
	moveBlock: function(moveX){
		//trace(this.mobileMenuBodyScroll.width());
		var cfg = this.config;
		var newLeft = (this.touchStartXY.sLeft + (moveX * 1));
		if(newLeft > this.menuPageWidth*0.5){
			newLeft = this.menuPageWidth*0.5;
		}else if(newLeft < ( - this.mobileMenuBodyScroll.width()) * 1.5){
			newLeft = ( - this.mobileMenuBodyScroll.width()) * 1.5;
		}
		this.mobileMenuBodyScroll.css({left: newLeft});
	},
	moveEndBlock: function(){
		/* 관성발동여부 체크 */
		if(!this.touchStartXY) return;
		var sTime = this.touchStartXY.sTime;
		var eTime = ((new Date()).getTime() / 1000);
		var dTime = eTime - sTime;
		var eLeft = this.mobileMenuBodyScroll.position().left;
		var dLeft = eLeft - this.touchStartXY.sLeft;
		var velocity = Math.ceil((dLeft/dTime)/10); // 속력= 거리/시간
		var endLeft = Math.ceil(eLeft + velocity); //스크롤할때 목적지
		/*trace({eLeft: eLeft, velocity:velocity, endLeft:endLeft});*/
		if(endLeft > 0){
			endLeft = 0;
		}		
		var calLeft = (endLeft.abs() % this.menuPageWidth);
		var absPage = (endLeft.abs() / this.menuPageWidth).floor();
		var newLeft = 0;
		if(calLeft < this.menuPageWidth/2){
		}else{
			absPage += 1;
		}
		if(absPage > this.pageNum-1) absPage = this.pageNum - 1;
		newLeft = this.menuPageWidth * absPage;
		
		//trace(absPage);
		this.touchStartXY.sLeft = -newLeft;

		this.mobileMenuBodyScroll.animate({left: -newLeft}, (this.mobileMenuBodyScroll.position().left + newLeft).abs(), "cubicOut", function () {});
		this.modalObj.modalFoot.find('#' + this.modalID + '_AX_pageNav_AX_' + this.pageNo).removeClass("on");
		this.modalObj.modalFoot.find('#' + this.modalID + '_AX_pageNav_AX_' + absPage).addClass("on");
		
		this.pageNo = absPage;
		
		this.touchStartXY = null;
	},
	/* 메뉴 터치 이동관련 함수 - e */
	
	cancelEvent: function (event) {
		event.stopPropagation(); // disable  event
		return false;
	}
});
/* ---------------------------- */
/* http://www.axisj.com, license : http://www.axisj.com/license */


/**
 * @class AXModal
 * @classdesc 모달창을 생성하고 제어 합니다. 모달창은 window, iframe, div 세 가지로 생성할 수 있습니다.
 * @extends AXJ
 * @version v1.40
 * @author tom@axisj.com
 * @logs
 "2013-02-13 오전 10:39:17 - axmods 에서 컨버트 : tom ",
 "2013-04-08 오전 12:15:17 - resize 메소스 추가 및 버그 픽스 : tom ",
 "2013-06-20 오후 5:21:24 - open 메소드 속성에 width 조건 추가 : tom ",
 "2013-07-09 오후 4:41:48 - animateDuration 속성 추가  : tom ",
 "2013-08-21 오후 4:46:51 - openNew 버그 픽스 : tom ",
 "2013-08-22 오전 10:56:20 - resize 버그 픽스 : tom ",
 "2013-08-24 - openNew 메소드 기능 확장 : tom ",
 "2013-10-14 오전 6:54:40 - resize 기능 보강 : tom ",
 "2013-11-15 오후 4:01:29 - tom : openDiv scroll 버그 패치",
 "2013-11-18 오후 5:16:02 - tom resize 버그 패치",
 "2014-05-21 - tom : AXModal mediaQuery 속성 추가"
 "2014-06-09 tom : mediaQuery bugfix"
 "2014-08-04 tom : fix resize error"
 "2014-09-17 tom : 'add Config' scrollLock"
 "2014-11-16 tom : openDiv 메소드에 verticalAlign 속성 확장"
 "2015-03-25 root : 각 open 메소드에 closeButton 속성 확장"
 "2015-04-22 root : axdom 독립 우회 코드 변경"
 "2015-05-08 tom : loaded 메소드 추가"

 */
var AXModal = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();
        this.config.maskCss = "AXMask";
        this.config.windowBoxCss = "AXModalBox";
        this.config.padding = "0";
        this.config.defaultTop = 10;
        this.config.animateDuration = 300;
        this.config.autoHide = false;
        this.config.windowID = "AXModal" + AXUtil.timekey();
        this.config.contentDivClass = (AXConfig.AXModal) ? AXConfig.AXModal.contentDivClass : "bodyHeightDiv";
        this.config.displayLoading = true;
        this.config.viewMode = "dx";
        this.config.opendModalID = "";
        this.config.scrollLock = false;
        this.config.closeButton = true;
    },
    /**
     * 모달의 기본 환경설정값을 셋팅합니다.
     * @method AXModal.setConfig
     * @param {Object} modalConfig
     * @example
     * ```js
     * var myModal = new AXModal();
     * var modalConfig = {
     *     animateDuration: {Number} [300],
     *     contentDivClass: {String} ["bodyHeightDiv"] - iframe 모달의 창이 오픈된 경우 iframe 의 높이를 정확히 제어하기 위해 컨텐츠 전체를 감싸는 대상에 지정한 className 값,
     *     defaultTop: {Number} [10] - 모달창 포지션 top,
     *     displayLoading: {Boolean} [true] - 모달이 오픈될 때 로딩 표시 여부,
     *     maskCss: "AXMask" - 배경 mask div의 css,
     *     opendModalID: {String} - 모달 ID,
     *     padding: {(String|Number)} ["0"] - 모달 padding 값,
     *     viewMode: {String} ["dx"],
     *     width: {(String|Number)} - 모달의 기본 너비,
     *     windowBoxCss: {String} ["AXModalBox"] - 모달을 감싸는 제일 바깥쪽 div의 css,
     *     windowID: {String} ["AXModal" + timekey] - 모달 식별 아이디,
     *     onclose: {Function} - 모달창이 닫힐 때 이벤트,
     *     closeButton: {Boolean} [true] - 모달창 닫기버튼의 노출 여부
     * };
     * myModal.setConfig(modalConfig);
     * ```
     */
    init: function () {
        var cfg = this.config;
        this.mask = axdom("<div class=\"" + cfg.maskCss + "\"></div>");
        if (cfg.mediaQuery) {
            var _viewMode = "", clientWidth = axf.clientWidth();
            axf.each(cfg.mediaQuery, function (k, v) {
                if (Object.isObject(v)) {

                    if(v.min != undefined && v.max != undefined){
                        if (v.min <= clientWidth && clientWidth <= v.max) {
                            _viewMode = (k == "dx") ? "dx" : "mx";
                            return false;
                        }
                    }else{
                        if (v.min <= clientWidth) {
                            _viewMode = (k == "dx") ? "dx" : "mx";
                            return false;
                        }
                    }
                }
            });
            if (_viewMode != "") {
                cfg.viewMode = _viewMode;
            }
        }

    },
    /**
     * @method AXModal.setWidth
     * @param {(String|Number)} - 모달의 기본 너비 pixel({Number}) or percent({String})
     * @description 모달의 기본 너비 속성을 변경하고 창이 열려있는 상태이면 동적으로 창의 크기도 변경합니다. (단, openDIV 로 모달이 오픈된 경우는 해당사항 없음)
     * @example
     * ```js
     * myModal.setWidth(800);
     * myModal.setWidth("80%");
     * ```
     */
    setWidth: function (width) {
        var cfg = this.config;
        if (width) {
            cfg.width = width;
            this.config.fixedWidth = true;
        } else {
            cfg.width = undefined;
            this.config.fixedWidth = false;
        }

        axdom("#" + cfg.windowID).css({ width: width });
        var maskWidth = axdom("#" + cfg.windowID).outerWidth();
        var maskLeft = (axdom(document.body).width() / 2) - (maskWidth / 2);
        if (maskLeft < 0) maskLeft = 0;
        axdom("#" + cfg.windowID).css({ left: maskLeft });
    },
    /**
     * @method AXModal.open
     * @param {Object} - configs
     * @description iframe 을 내장하는 모달 창을 오픈합니다.
     * @example
     * ```js
     * var configs = {
     *     url: {String} - 모달창의 URL,
     *     pars: {(Object|Array)} - 모달창 URL 에 전달 될 파라미터,
     *     method: {String} ["post"] -파라미터 전달방식,
     *     top: {Number} [scrollTop + 100] - 모달창 포지션 top,
     *     width: {(String|Number)} - 모달창 너비,
     *     closeByEscKey: {Boolean} [false] - 모달창 닫기를 esc 키로 닫을 지 여부,
     *     closeButton: {Boolean} [true] - 모달창 닫기버튼의 노출 여부
     * }
     * myModal.open(configs);
     * ```
     */
    open: function (http) {
        var cfg = this.config;

        if (this._windowOpend) return;

        mask.open();
        this.winID = "mdw" + AXUtil.timekey();
        this.frmID = "frm" + AXUtil.timekey();

        var maskWidth, maskLeft;
        if (this.config.width) {
            maskWidth = this.config.width;
            maskLeft = (axdom(document.body).width() / 2) - (this.config.width / 2);
            this.config.fixedWidth = true;
        } else {
            maskWidth = axdom(document.body).width() - 50;
            maskLeft = 10;
            this.config.fixedWidth = false;
        }

        if (http.width) {
            maskWidth = http.width;
            maskLeft = (axdom(document.body).width() / 2) - (http.width / 2);
            this.config.fixedWidth = true;
        }

        var maskTop = this.config.defaultTop;
        if (http.top != undefined) {
            maskTop = http.top;
        } else {
            maskTop = axdom(window).scrollTop() + 100;
        }
        if (maskLeft < 0) maskLeft = 0;

        var po = [];
        po.push("<div id='" + this.config.windowID + "' class='" + this.config.windowBoxCss + "' style='top:" + maskTop + "px;left:" + maskLeft + "px;width:" + maskWidth + "px;'>");
        po.push("	<div class='windowbox' id='" + this.winID + "_box' style='padding:" + this.config.padding + "px'>");
        if (cfg.displayLoading) {
            po.push("		<div id='" + this.config.windowID + "_loading' style='position:absolute;left:0px;top:0px;width:100%;padding:50px 0px 0px 0px;' align='center'>");
            po.push("		<div class=\"AXLoading\"></div>");
            po.push("		<br/><br><span class='blue'>페이지를 로딩 중입니다. 잠시만 기다려 주세요.</span></div>");
        }


        var closeButton = (http.closeButton == undefined) ? cfg.closeButton : http.closeButton;
        if (closeButton){
            po.push("		<a id='" + this.config.windowID + "_close' class='closeBtn'>닫기</a>");
        }

        po.push("		<form name='" + this.frmID + "' method='" + (http.method || "post") + "' target='" + this.winID + "' action='" + http.url + "'>");
        po.push("		<input type='hidden' name='winID' value='" + this.winID + "' />");

        if (isNaN(http.pars.length)) {
            axdom.each(http.pars, function (key, val) {
                po.push("		<input type='hidden' name='" + key + "' value='" + val + "' />");
            });
        } else {
            axdom.each(http.pars, function () {
                axdom.each(this, function (key, val) {
                    po.push("		<input type='hidden' name='" + key + "' value='" + val + "' />");
                });
            });
        }

        if(AXConfig.AXModal.pars){
            var appendPars = {};
            if(Object.isString(AXConfig.AXModal.pars)){
                appendPars = AXConfig.AXModal.pars.queryToObject();
            }
            axdom.each(appendPars, function (key, val) {
                po.push("<input type='hidden' name='" + key + "' value='" + val + "' />");
            });
        }

        po.push("		</form>");
        po.push("		<iframe src='' name='" + this.winID + "' id='" + this.winID + "' frameborder='0' class='windowboxFrame' style='width:100%;overflow:-y:hidden;' scrolling='no'></iframe>");
        po.push("	</div>");
        po.push("</div>");

        if (this.config.appendTargetID) {
            axdom("#" + this.config.appendTargetID).append(po.join(''));
        } else {
            axdom(document.body).append(po.join(''));
        }

        axdom("#" + cfg.windowID).data("width", maskWidth);
        axdom("#" + cfg.windowID).data("top", maskTop);

        if(cfg.viewMode == "mx"){
            axdom("#" + cfg.windowID).css({ left: 0, top:axdom(window).scrollTop(), width:"100%" });
        }

        var loadingID = this.config.windowID + "_loading";
        var _winID = this.winID;
        var _frmID = this.frmID;

        document[_frmID].submit();
        var keydown = this.keydown.bind(this);

        axdom("#" + this.winID).bind("load", function () {
            var myIframe = window[_winID];

            var bodyHeight = axdom(myIframe.document).innerHeight();
            if (axdom(myIframe.document.body).find("." + cfg.contentDivClass).get(0)) {
                bodyHeight = axdom(myIframe.document.body).find("." + cfg.contentDivClass).outerHeight();
            }
            axdom(this).css({ height: (bodyHeight) }, cfg.animateDuration, "cubicInOut");
            axdom("#" + _winID + "_box").css({ height: (bodyHeight) }, cfg.animateDuration, "cubicInOut");
            if (cfg.displayLoading) axdom("#" + loadingID).fadeOut("slow");
            axdom("#" + _winID).addClass("loaded");

            if (http.closeByEscKey) {
                axdom(myIframe.document.body).bind("keydown.AXModal", keydown);
            }
        });

        axdom("#" + this.config.windowID + "_close").bind("click", this.close.bind(this));

        if (http.closeByEscKey) {
            axdom(document.body).bind("keydown.AXModal", keydown);
        }

        this._windowOpend = true;

        axdom(window).unbind("resize.AXModal");
        axdom(window).bind("resize.AXModal", this.onDocResize.bind(this));

        if (cfg.scrollLock == true) {
            axdom(document.body).css({'overflow':'hidden'});
        }
    },
    /**
     * @deprecated AXModal.openI
     * @see AXModal.open
     */
    openI: function (http) {
        var cfg = this.config;

        if (this._windowOpend) return;

        mask.open();
        this.winID = "mdw" + AXUtil.timekey();
        this.frmID = "frm" + AXUtil.timekey();

        var maskWidth, maskLeft;
        if (this.config.width) {
            maskWidth = this.config.width;
            maskLeft = (axdom(document.body).width() / 2) - (this.config.width / 2);
            this.config.fixedWidth = true;
        } else {
            maskWidth = axdom(document.body).width() - 50;
            maskLeft = 10;
            this.config.fixedWidth = false;
        }

        if (http.width) {
            maskWidth = http.width;
            maskLeft = (axdom(document.body).width() / 2) - (http.width / 2);
            this.config.fixedWidth = true;
        }

        var maskTop = this.config.defaultTop;
        if (http.top != undefined) {
            maskTop = http.top;
        } else {
            maskTop = axdom(window).scrollTop() + 100;
        }

        if (maskLeft < 0) maskLeft = 0;

        var po = [];
        po.push("<div id='" + this.config.windowID + "' class='" + this.config.windowBoxCss + "' style='top:" + maskTop + "px;left:" + maskLeft + "px;width:" + maskWidth + "px;'>");
        po.push("	<div class='windowbox' id='" + this.winID + "_box' style='padding:" + this.config.padding + "px'>");
        po.push("		<div id='" + this.config.windowID + "_loading' style='position:absolute;left:0px;top:0px;width:" + maskWidth + "px;padding:50px 0px 0px 0px;' align='center'>");
        po.push("		<div class=\"AXLoading\"></div>");
        po.push("		<br/><br><span class='blue'>페이지를 로딩 중입니다. 잠시만 기다려 주세요.</span></div>");

        var closeButton = (http.closeButton == undefined) ? cfg.closeButton : http.closeButton;
        if (closeButton){
            po.push("		<a href='#modsExecption' id='" + this.config.windowID + "_close' class='closeBtn'>닫기</a>");
        }

        po.push("		<form name='" + this.frmID + "' method='post' target='" + this.winID + "' action='" + http.url + "'>");
        po.push("		<input type='hidden' name='winID' value='" + this.winID + "' />");

        if (isNaN(http.pars.length)) {
            axdom.each(http.pars, function (key, val) {
                po.push("		<input type='hidden' name='" + key + "' value='" + val + "' />");
            });
        } else {
            axdom.each(http.pars, function () {
                axdom.each(this, function (key, val) {
                    po.push("		<input type='hidden' name='" + key + "' value='" + val + "' />");
                });
            });
        }

        if(AXConfig.AXModal.pars){
            var appendPars = {};
            if(Object.isString(AXConfig.AXModal.pars)){
                appendPars = AXConfig.AXModal.pars.queryToObject();
            }
            axdom.each(appendPars, function (key, val) {
                po.push("<input type='hidden' name='" + key + "' value='" + val + "' />");
            });
        }

        po.push("		</form>");

        if (http.maxHeight) {
            po.push("		<iframe src='' name='" + this.winID + "' id='" + this.winID + "' frameborder='0' class='windowboxFrame' style='width:100%;overflow:-y:hidden;' scrolling='auto'></iframe>");
        } else {
            po.push("		<iframe src='' name='" + this.winID + "' id='" + this.winID + "' frameborder='0' class='windowboxFrame' style='width:100%;overflow:-y:hidden;' scrolling='no'></iframe>");
        }

        po.push("	</div>");
        po.push("</div>");


        if (this.config.appendTargetID) {
            axdom("#" + this.config.appendTargetID).append(po.join(''));
        } else {
            axdom(document.body).append(po.join(''));
        }

        var loadingID = this.config.windowID + "_loading";
        var _winID = this.winID;
        var _frmID = this.frmID;

        document[_frmID].submit();

        axdom("#" + this.winID).bind("load", function () {
            var myIframe = window[_winID];

            var bodyHeight = axdom(myIframe.document).innerHeight();
            if (axdom(myIframe.document.body).find("." + cfg.contentDivClass).get(0)) {
                bodyHeight = axdom(myIframe.document.body).find("." + cfg.contentDivClass).outerHeight();
            }
            if (http.maxHeight) {
                if (http.maxHeight < (bodyHeight.number() + maskTop.number() + 10)) {
                    bodyHeight = http.maxHeight - maskTop.number() - 10;
                }
            }

            axdom(this).css({ height: (bodyHeight) }, cfg.animateDuration, "cubicInOut");
            axdom("#" + _winID + "_box").css({ height: (bodyHeight) }, cfg.animateDuration, "cubicInOut");
            axdom("#" + loadingID).fadeOut("slow");
            axdom("#" + _winID).addClass("loaded");
        });
        axdom("#" + this.config.windowID + "_close").bind("click", this.close.bind(this));

        /*
         if (this.mask) {
         if (this.config.autoHide) this.mask.bind("click", this.close.bind(this));
         }
         */
        //window.scroll(0, 0);
        this._windowOpend = true;

        axdom(window).unbind("resize.AXModal");
        axdom(window).bind("resize.AXModal", this.onDocResize.bind(this));

        if (cfg.scrollLock == true) {
            axdom(document.body).css({'overflow':'hidden'});
        }
    },
    windowResizeApply: function(){
        this.onDocResize();
    },
    /**
     * @method AXModal.openDiv
     * @param {Object} - configs
     * @description div 모달 창을 오픈합니다.
     * @example
     * ```js
     * var configs = {
     *     modalID: {String} - 모달창의 식별자,
     *     targetID: {String} - 모달창 타켓 엘리먼트 아이디,
     *     top: {Number} [scrollTop + 100] - 모달창 포지션 top,
     *     width: {(String|Number)} - 모달창 너비,
     *     closeByEscKey: {Boolean} [false] - 모달창 닫기를 esc 키로 닫을 지 여부,
     *     verticalAlign: {Boolean} [false] - 모달창 가운데 표시 여부,
     *     closeButton: {Boolean} [true] - 모달창 닫기버튼의 노출 여부
     * }
     * myModal.openDiv(configs);
     * ```
     */
    openDiv: function (args) {
        var cfg = this.config;
        mask.open();

        var modalID = cfg.opendModalID = args.modalID;

        if (AXgetId(modalID)) {
            var modalTarget = $("#" + modalID);
            modalTarget.show();

            var maskTop = this.config.defaultTop;
            if (args.top != undefined) {
                maskTop = axdom(window).scrollTop() + args.top;
            } else {
                maskTop = axdom(window).scrollTop() + 50;
            }

            if(cfg.viewMode == "mx"){
                maskTop = axdom(window).scrollTop();
            }

            if( args.verticalAlign ){
                modalTarget.css({top: axf.clientHeight() / 2 - modalTarget.height()/2 + axdom(window).scrollTop() })
            }else{
                modalTarget.css({ "top": maskTop });
            }

            if (args.closeByEscKey) {
                var keydown = this.keydown.bind(this);
                var keydownBind = function () {
                    keydown(event, modalID);
                };
                axdom(document.body).bind("keydown.AXModal", keydownBind);
            }
            return;
        }

        var maskWidth, maskLeft;
        if (this.config.width) {
            maskWidth = this.config.width;
            maskLeft = (axdom(document.body).width() / 2) - (this.config.width / 2);
            this.config.fixedWidth = true;
        } else {
            maskWidth = axdom(document.body).width() - 50;
            maskLeft = 10;
            this.config.fixedWidth = false;
        }

        if (args.width) {
            maskWidth = args.width;
            maskLeft = (axdom(document.body).width() / 2) - (args.width / 2);
            this.config.fixedWidth = true;
        }

        var maskTop = this.config.defaultTop;
        if (args.top != undefined) {
            maskTop = axdom(window).scrollTop() + args.top;
        } else {
            maskTop = axdom(window).scrollTop() + 50;
        }

        if (maskLeft < 0) maskLeft = 0;

        var po = [];
        po.push("<div id='" + modalID + "' class='" + this.config.windowBoxCss + "' style='top:" + maskTop + "px;left:" + maskLeft + "px;width:" + maskWidth + "px;'>");
        po.push("	<div class='windowbox' style='padding:" + this.config.padding + "px'>");

        var closeButton = (args.closeButton == undefined) ? cfg.closeButton : args.closeButton;
        if (closeButton){
            po.push("		<a href='#modsExecption' id='" + modalID + "_close' class='closeBtn'>닫기</a>");
        }

        po.push("		<div id='" + modalID + "_content'></div>");
        po.push("	</div>");
        po.push("</div>");

        axdom(document.body).append(po.join(''));

        axdom("#" + modalID + "_content").append(axdom("#" + args.targetID));

        axdom("#" + cfg.opendModalID).data("width", maskWidth);
        axdom("#" + cfg.opendModalID).data("top", maskTop);

        if(cfg.viewMode == "mx"){
            axdom("#" + cfg.opendModalID).css({ left: 0, top:axdom(window).scrollTop(), width:"100%" });
        }

        var loadingID = modalID + "_loading";

        var closeBind = this.close.bind(this);
        var closeModal = function (event) {
            closeBind(event, modalID);
        };
        axdom("#" + modalID + "_close").bind("click", closeModal);

        if (args.closeByEscKey) {
            var keydown = this.keydown.bind(this);
            var keydownBind = function () {
                keydown(event, modalID);
            };
            axdom(document.body).bind("keydown.AXModal", keydownBind);
        }

        /*
         if (this.mask) {
         if (this.config.autoHide) this.mask.bind("click", close);
         }
         */

        axdom(window).unbind("resize.AXModal");
        axdom(window).bind("resize.AXModal", this.onDocResize.bind(this));

        if (cfg.scrollLock == true) {
            axdom(document.body).css({'overflow':'hidden'});
        }

        if( args.verticalAlign ){
            var modalTarget = $("#" + modalID);
            $("#" + modalID).css({top: axf.clientHeight() / 2 - modalTarget.height()/2 + axdom(window).scrollTop() })
        }
    },
    /**
     * @method AXModal.openNew
     * @param {Object} - configs
     * @description 새로운 창으로 모달 창을 오픈 합니다.
     * @example
     * ```js
     * var configs = {
     *     url: {String} - 새창 오픈 URL,
     *     pars: {(Object|Array)} - 새창 오픈 URL 전달 파라미터,
     *     name: {String} ["mdw" + timekey]- 새창이름,
     *     options: {String} - 새창 오픈 옵션 window.open 속성과 동일합니다.
     * }
     * myModal.openNew(configs);
     * ```
     */
    openNew: function (http) {
        this.winID = "mdw" + AXUtil.timekey();
        this.frmID = "frm" + AXUtil.timekey();

        if (this.openWindow) {
            //top.mask.close();
            this.openWindow.close();
        }

        this.openWindow = window.open("", (http.name || this.winID), http.options);
        this.openWindow.focus();

        if (http.title != undefined){
            this.openWindow.document.title = http.title;
        }

        if (AXgetId(this.config.windowID)) axdom("#" + this.config.windowID).remove();

        var po = [];
        po.push("<div id='" + this.config.windowID + "'>");
        po.push("		<form name='" + this.frmID + "' method='" + (http.method || "post") + "' target='" + (http.name || this.winID) + "' action='" + http.url + "'>");
        po.push("		<input type='hidden' name='winID' value='" + this.winID + "' />");

        if (isNaN(http.pars.length)) {
            axdom.each(http.pars, function (key, val) {
                po.push("		<input type='hidden' name='" + key + "' value='" + val + "' />");
            });
        } else {
            axdom.each(http.pars, function () {
                axdom.each(this, function (key, val) {
                    po.push("		<input type='hidden' name='" + key + "' value='" + val + "' />");
                });
            });
        }
        po.push("		</form>");
        po.push("</div>");
        axdom(document.body).append(po.join(''));
        document[this.frmID].submit();
        axdom("#" + this.config.windowID).remove();
    },
    keydown: function (event, modalID) {
        if (event.keyCode == AXUtil.Event.KEY_ESC) {
            this.close(event, modalID);
        }
    },
    /**
     * @method AXModal.close
     * @param {String} - modalID
     * @description 오픈된 모달 창을 닫습니다.
     * @example
     * ```js
     * myModal.close("modalDiv01");
     * parent.myModal.close(); // iframe 모달창을 오픈한 경우 열려진 iframe 안에서 호출 합니다.
     * ```
     */
    close: function (event, modalID) {
        var cfg = this.config;
        if (this.openWindow) {
            this.openWindow.close();
        }

        if (event) {
            if (event.type == undefined) {
                modalID = event;
            }
        }

        if (modalID) {
            axdom("#" + modalID).hide();
            this.config.opendModalID = "";
            mask.close();
        } else {
            if (window[this.winID]) {
                window[this.winID].location.href = "about:blank";
                var windowID = this.config.windowID;

                setTimeout(function () {
                    axdom("#" + windowID).remove();
                }, 1);

                mask.close();
                this._windowOpend = false;
            }
        }

        axdom(document.body).unbind("keydown.AXModal");

        if(this.config.onclose){
            this.config.onclose.call(
                {
                    winID: this.winID,
                    windowID: this.config.windowID,
                    modalID: modalID
                }
            );
        }

        if (cfg.scrollLock == true) {
            axdom(document.body).css({'overflow':'auto'});
        }
    },
    /**
     * @method AXModal.remove
     * @description 오픈된 모달 창을 제거합니다.
     * @example
     * ```js
     * myModal.remove();
     * parent.myModal.remove(); //iframe 모달창을 오픈한 경우 열려진 iframe 안에서 호출 합니다.
     * ```
     */
    remove: function (event) {
        var windowID = this.config.windowID;
        setTimeout(function () {
            axdom("#" + windowID).remove();
        }, 1);
        mask.close();
        axdom(document.body).css({'overflow':'auto'});
        this._windowOpend = false;
        /*
         try {
         this.mask.remove();
         } catch (e) { }
         */
    },
    /**
     * @method AXModal.resize
     * @description 열려진 iframe modal 의 높이를 iframe 창의 높이 만큼 리사이즈 합니다. contentDivClass 가 정의된 경우 contentDivClass 높이값으로 resize 합니다.
     * @example
     * ```js
     * myModal.resize();
     * parent.myModal.resize(); //iframe 모달창을 오픈한 경우 열려진 iframe 안에서 호출 합니다.
     * ```
     */
    resize: function (event) {
        var cfg = this.config;
        var _winID = this.winID;
        setTimeout(function () {

            try {
                var myIframe = window[_winID];
                var bodyHeight = axdom(myIframe.document).innerHeight();
                if (axdom(myIframe.document.body).find("." + cfg.contentDivClass).get(0)) {
                    bodyHeight = axdom(myIframe.document.body).find("." + cfg.contentDivClass).outerHeight();
                }
                axdom("#" + _winID).css({ height: (bodyHeight) }, cfg.animateDuration, "cubicInOut");
                axdom("#" + _winID + "_box").css({ height: (bodyHeight) }, cfg.animateDuration, "cubicInOut");
            }catch(e){

            }

            try {
                parent.fcObj.contentResetHeight();
            } catch (e) {
                //trace(e);
            }

            try {
                parent.fnObj.contentResetHeight(null, bodyHeight + 100);
            } catch (e) {
                //trace(e);
            }
        }, 50);
    },
    onDocResize: function () {
        var cfg = this.config;

        if (cfg.mediaQuery) {
            var _viewMode = "", clientWidth = axf.clientWidth();

            axf.each(cfg.mediaQuery, function (k, v) {
                if (Object.isObject(v)) {

                    if(v.min != undefined && v.max != undefined){
                        if (v.min <= clientWidth && clientWidth <= v.max) {
                            _viewMode = (k == "dx") ? "dx" : "mx";
                            return false;
                        }
                    }else{
                        if (v.min <= clientWidth) {
                            _viewMode = (k == "dx") ? "dx" : "mx";
                            return false;
                        }
                    }
                }
            });
            if (_viewMode != "") {
                cfg.viewMode = _viewMode;
            }
        }

        if(cfg.viewMode == "dx"){
            try {
                if (cfg.fixedWidth) {
                    var maskWidth, maskLeft;
                    if(cfg.opendModalID != ""){
                        maskWidth = axdom("#" + cfg.opendModalID).outerWidth();
                        if(maskWidth != axdom("#" + cfg.opendModalID).data("width")) {
                            axdom("#" + cfg.opendModalID).css({
                                top: axdom("#" + cfg.opendModalID).data("top"),
                                width: axdom("#" + cfg.opendModalID).data("width")
                            });
                        }
                        maskLeft = (axdom(document.body).width() / 2) - (maskWidth / 2);
                        if (maskLeft < 0) maskLeft = 0;
                        axdom("#" + cfg.opendModalID).css({ left: maskLeft });
                    }else{
                        maskWidth = axdom("#" + cfg.windowID).outerWidth();
                        if(maskWidth != axdom("#" + cfg.windowID).data("width")) {
                            axdom("#" + cfg.windowID).css({
                                top: axdom("#" + cfg.windowID).data("top"),
                                width: axdom("#" + cfg.windowID).data("width")
                            });
                        }
                        maskLeft = (axdom(document.body).width() / 2) - (maskWidth / 2);
                        if (maskLeft < 0) maskLeft = 0;
                        axdom("#" + cfg.windowID).css({ left: maskLeft });
                    }
                } else {
                    if(cfg.opendModalID != "") {
                        maskWidth = axdom(".container").width() - 50;
                        axdom("#" + cfg.opendModalID).css({ width: maskWidth });
                    }else{
                        maskWidth = axdom(".container").width() - 50;
                        axdom("#" + cfg.windowID).css({ width: maskWidth });
                    }
                }
            } catch (e) {

            }
        }else if(cfg.viewMode == "mx"){
            if(cfg.opendModalID != "") {
                axdom("#" + cfg.opendModalID).css({ left: 0, top: axdom(window).scrollTop(), width: "100%" });
            }else {
                axdom("#" + cfg.windowID).css({ left: 0, top: axdom(window).scrollTop(), width: "100%" });
            }
        }

    },
    /**
     * @method AXModal.loaded
     * @description 모달의 로딩중 상태를 강제로 로드 완료 처리 합니다.
     * @example
     * ```js
     * myModal.loaded();
     * parent.myModal.loaded(); //iframe 모달창을 오픈한 경우 열려진 iframe 안에서 호출 합니다.
     * ```
     */
    loaded: function () {
        var cfg = this.config, _winID = this.winID;
        var loadingID = this.config.windowID + "_loading";
        var myIframe = window[this.winID];

        var bodyHeight = axdom(myIframe.document).innerHeight();
        if (axdom(myIframe.document.body).find("." + cfg.contentDivClass).get(0)) {
            bodyHeight = axdom(myIframe.document.body).find("." + cfg.contentDivClass).outerHeight();
        }
        axdom(this).css({ height: (bodyHeight) }, cfg.animateDuration, "cubicInOut");
        axdom("#" + _winID + "_box").css({ height: (bodyHeight) }, cfg.animateDuration, "cubicInOut");
        if (cfg.displayLoading) axdom("#" + loadingID).fadeOut("slow");
        axdom("#" + _winID).addClass("loaded");
    }
});
/* ---------------------------- */
/* http://www.axisj.com, license : http://www.axisj.com/license */
 

var AXModelControl = Class.create(AXJ, {
    version: "AXModelControl V0.1",
    author: "tom@axisj.com",
	logs: [
		"2013-12-03 오후 5:27:18"
	],
    initialize: function(AXJ_super) {
        AXJ_super();
        this.config.theme = "";
        this.config.collectSelector = "";
        this.config.subModelDetectClassName = "AXModelDetect";
        this.config.excludeClassName = "";
        this.config.cursorFocus = false;
        this.returnJSData = {};
    },
    init: function() {
		var cfg = this.config;
		if(Object.isUndefined(cfg.targetID)){
			trace("need targetID - setConfig({targetID:''})");
			return;
		}
		this.target = jQuery("#"+cfg.targetID);
		//trace(this.collectItem);
		
    },
    collectModelItem: function(){
    	var cfg = this.config;
    	var finderCSS = "";
		if(cfg.collectSelector != ""){
			finderCSS = cfg.collectSelector;
		}else{
			finderCSS = "input[type=text], input[type=hidden], input[type=radio], input[type=checkbox], select, textarea";
		}
		var _this = this;
		var getParentSubModel = function(ele){
			var result = false;
			var checkEle = ele;
			var rooping = true;
			while (rooping) {
				if(!checkEle.get(0)){
					rooping = false;
					break;
				}
				if(checkEle.get(0).id == cfg.targetID){
					rooping = false;
					break;
				}else if(checkEle.parent().hasClass(cfg.subModelDetectClassName)){
					result = true;
					rooping = false;
					break;
				}else{
					checkEle = checkEle.parent();
				}
			}
			return {
				result:result,
				parents:ele.parentsUntil("#"+cfg.targetID)
			};
		};

		var collectItem = [];
		var oncursorKeyup = this.oncursorKeyup.bind(this);
		
		/*trace(finderCSS);*/		
		this.target.find(finderCSS).each(function(){
			var jQueryObj = axdom(this);
			var getSubModel = getParentSubModel(axdom(this));
			if(!getSubModel.result){
				var collectOk = false;
				if(cfg.excludeClassName != ""){
					collectOk = !jQueryObj.hasClass(cfg.excludeClassName);
				}else{
					collectOk = true;
				}
				
				if(collectOk){
					jQueryObj.attr("data-axisjModelId", collectItem.length);
					collectItem.push({
						keys:[this.name],
						jQueryObj:jQueryObj,
						axisjModelId:collectItem.length,
						name:this.name,
						type:this.type
					});
				}
			}else{
				
				jQueryObj.attr("data-axisjModelId", collectItem.length);
				
				var relationKey = [];
				axdom.each(getSubModel.parents, function(){
					if(this.id != ""){
						if(this.id.left(cfg.subModelDetectClassName.length) == cfg.subModelDetectClassName){
							var myKey = this.id.substr(this.id.lastIndexOf("_").number()+1);
							relationKey.push(myKey);
						}
					}
				});
				relationKey.push(this.name);

				collectItem.push({
					keys:relationKey,
					jQueryObj:jQueryObj,
					axisjModelId:collectItem.length,
					name:this.name,
					type:this.type
				});
			}
			jQueryObj = null;
		});		
		
		this.collectItem = collectItem;
		
		
		
		var returnJSData = {};
		axdom.each(this.collectItem, function(itemIndex, item){
			var keys = item.keys;
			var targetJS = returnJSData;
			
			var key;
			for(var kidx=0;kidx<keys.length-1;kidx++){
				key = keys[kidx];
				if(targetJS[key] == undefined){
					targetJS[key] = {};
				}
				targetJS = targetJS[key];
			}
			key = keys.last();
			
			var nVal = "";
			if(targetJS[key] == undefined){
				if(this.type == "checkbox"){
					var keyLength = 0;
					axdom.each(collectItem, function(){
						if(this.keys.join(".") == keys.join(".")) keyLength++;
					});
					if(keyLength == 1){
						targetJS[key] = "";
					}else{
						targetJS[key] = [];
					}
				}else{
					targetJS[key] = "";
				}
				this.keySeq = 0;
			}else{
				if(Object.isArray(targetJS[key])){
					if(this.type != "checkbox"){
						targetJS[key].push(nVal);
						this.keySeq = targetJS[key].length-1;
						//this.keys[this.keys.length-1] += "["+ this.keySeq +"]";
					}
				}else{
					var oVal = targetJS[key];
					if(this.type == "radio"){
						
					}else if(this.type == "checkbox"){
						var keyLength = 0;
						axdom.each(collectItem, function(){
							if(this.keys.join(".") == keys.join(".")) keyLength++;
						});
						if(keyLength == 1){
							targetJS[key] = oVal;
						}else{
							targetJS[key] = [oVal];
							targetJS[key].push(nVal);
							this.keySeq = targetJS[key].length-1;
						}
					}else{
						targetJS[key] = [oVal];
						targetJS[key].push(nVal);
						this.keySeq = targetJS[key].length-1;
						//this.keys[this.keys.length-1] += "["+ this.keySeq +"]";
					}
				}
			}
			
			
			
			if(cfg.cursorFocus){
	
				var jQueryObj = item.jQueryObj;

				//trace(jQueryObj.attr("data-axbind"));

				if(jQueryObj.attr("data-axbind") == "select"){
					jQueryObj.bindSelectGetAnchorObject().unbind("keydown.AXModelControl").bind("keydown.AXModelControl", function(event){
						setTimeout(function(){
							oncursorKeyup(jQueryObj, event, itemIndex);
						}, 10);
					});
				}else{
					jQueryObj.unbind("keydown.AXModelControl").bind("keydown.AXModelControl", function(event){
						setTimeout(function(){
							oncursorKeyup(jQueryObj, event, itemIndex);
						}, 10);
						//if (event.preventDefault) event.preventDefault();
						//if (event.stopPropagation) event.stopPropagation();
						//event.cancelBubble = true;
						//return false;						
					});
				}

			}
		});
		this.returnJSData = returnJSData;
    },
    sync: function(){
		var cfg = this.config;
		if(!this.collectItem) this.collectModelItem();
    },
    clearCollect: function(){
    	this.collectItem = undefined;
    },
    getData: function(){
		var cfg = this.config;
		this.sync();
		var getElementValue = function(jQueryObj, type){
			if(type == "radio" || type == "checkbox"){
				if(jQueryObj.get(0).checked){
					return jQueryObj.val();
				}
			}else{
				return jQueryObj.val();
			}
		};
		
		var returnJSData = this.returnJSData;
		
		var collectItem = this.collectItem;
		axdom.each(this.collectItem, function(){
			var keys = this.keys;
			var targetJS = returnJSData;
			var key;
			for(var kidx=0;kidx<keys.length-1;kidx++){
				key = keys[kidx];
				if(targetJS[key] == undefined){
					targetJS[key] = {};
				}
				targetJS = targetJS[key];
			}
			key = keys.last();
			if(this.type == "checkbox"){
				var keyLength = 0;
				axdom.each(collectItem, function(){
					if(this.keys.join(".") == keys.join(".")) keyLength++;
				});
				if(keyLength > 1) targetJS[key] = [];
				else targetJS[key] = "";
			}
		});
		
		axdom.each(this.collectItem, function(){
			var keys = this.keys;
			var targetJS = returnJSData;
			
			var key;
			for(var kidx=0;kidx<keys.length-1;kidx++){
				key = keys[kidx];
				if(targetJS[key] == undefined){
					targetJS[key] = {};
				}
				targetJS = targetJS[key];
			}
			key = keys.last();
			
			var nVal = getElementValue(this.jQueryObj, this.type);
			if(this.type == "checkbox"){
				if(!AXUtil.isEmpty(nVal)){
					var keyLength = 0;
					axdom.each(collectItem, function(){
						if(this.keys.join(".") == keys.join(".")) keyLength++;
					});
					if(keyLength > 1) targetJS[key].push(nVal);
					else targetJS[key] = nVal;
				}
			}else if(this.type == "radio"){
				if(!AXUtil.isEmpty(nVal)){
					targetJS[key] = nVal;
				}
			}else{
				if(Object.isArray(targetJS[key])){
					targetJS[key][this.keySeq] = nVal;
				}else{
					targetJS[key] = nVal;
				}
			}
		});
		this.returnJSData = returnJSData;
		return Object.clone(this.returnJSData);
    },
    setData: function(jsPathObj, val){
		if(Object.isString(val) || Object.isArray(val) || Object.isNumber(val) ){
			this.applyValue(jsPathObj, val);
		}else{
			var applyValue = this.applyValue.bind(this);
			var fnApplyValue = function(prefixKey, _val, depth){
				if(depth > 5) return; /* 만약의 경우를 대비하여 10 뎁스 이상 연산 처리 하지 않습니다. 무한 루프를 방지 */
				if(prefixKey != "") prefixKey += ".";
				axf.each(_val, function(k, v){
					if(Object.isString(v) || Object.isArray(v) || AXUtil.isEmpty(v) || Object.isNumber(v) ){
						applyValue({key:prefixKey + k}, v);
					}else{
						fnApplyValue(prefixKey+k, v, (depth+1));
					}
				});
			};
			fnApplyValue("", val, 0);
		}
		return true;
    },
    applyValue: function(jsPathObj, val){
		var cfg = this.config;
		this.getData();
		var returnJSData = this.returnJSData;
		if(jsPathObj.key){
			try{
				eval("returnJSData = returnJSData." + jsPathObj.key);
			}catch(e){
				trace(e);
			}
		}
		
		if(returnJSData != undefined){
			if(Object.isString(val) || Object.isNumber(val)){
				
				var findedItem = false;
				axdom.each(this.collectItem, function(){
					if(this.keys.join(".") == jsPathObj.key){
						if(jsPathObj.keySeq != undefined){
							if(jsPathObj.keySeq == this.keySeq){
								this.jQueryObj.val(val);
								findedItem = true;
								return false;
							}
						}else{
							if(this.type == "radio" || this.type == "checkbox"){
								if(this.jQueryObj.get(0).value == val){
									this.jQueryObj.get(0).checked = true;
									findedItem = true;
								}else{
									this.jQueryObj.get(0).checked = false;
									findedItem = true;
								}
							}else{
								this.jQueryObj.val(val);
								findedItem = true;
								return false;	
							}
						}
					}
				});

				if(!findedItem){
					return {error:"not found keySeq"};
				}

			}else if(Object.isArray(val)){
				
				var findedItem = false;
				axdom.each(this.collectItem, function(){
					if(this.keys.join(".") == jsPathObj.key){
						if(jsPathObj.keySeq != undefined){
							if(jsPathObj.keySeq == this.keySeq){
								this.jQueryObj.val(val.join(","));
								findedItem = true;
								return false;
							}else{
								
							}
						}else{
							if(this.type == "checkbox" || this.type == "radio"){
								var jQueryObj = this.jQueryObj;
								if(val.length == 0){
									jQueryObj.get(0).checked = false;
								}else{
									jQueryObj.get(0).checked = false;
									axf.each(val, function(){
										if(jQueryObj.get(0).value == this){
											jQueryObj.get(0).checked = true;
										}
									});
								}
								findedItem = true;
							}else{

								if(val[this.keySeq] != undefined){
									this.jQueryObj.val(val[this.keySeq]);
									findedItem = true;
								}
								//return false;
							}
						}
					}
				});

				if(!findedItem){
					return {error:"not found keySeq"};
				}
				
			}
		}
		
		return true;
    },
    
    /* cursorFocus */
    oncursorKeyup: function(jQueryObj, event, itemIndex){
    	var cfg = this.config;
    	if(event.ctrlKey) return;
    	if(cfg.oncursor){
    		// AXBind 된 경우에는 위아래 사용을 제한 해야함. 2014-01-04 오후 5:57:24
    		var axbind = jQueryObj.attr("data-axbind");
    		var htmlTag = jQueryObj.get(0).type;
    		var direction = "";
    		if(event.keyCode == AXUtil.Event.KEY_UP) direction = "U";
    		else if(event.keyCode == AXUtil.Event.KEY_DOWN) direction = "D";
    		else if(event.keyCode == AXUtil.Event.KEY_LEFT) direction = "L";
    		else if(event.keyCode == AXUtil.Event.KEY_RIGHT) direction = "R";
    		else if(event.keyCode == AXUtil.Event.KEY_RETURN && axbind != "select" && htmlTag != "textarea") direction = "E";	
    		if(cfg.oncursor.call(
    			{
    				event:event,
    				direction:direction,
    				itemIndex:itemIndex,
    				jQueryObj:jQueryObj
    			}
    		) === false) return false;
			if(direction == "") return;
			
			//trace(jQueryObj.get(0).tagName);
			//if(axbind) return;
			if(direction == "U" || direction == "D" || direction == "L" || direction == "R") return;
			else if(direction == "E" && (event.shiftKey || event.metaKey)){
				if(itemIndex == 0){
					if(cfg.oncursorEmpty){
						cfg.oncursorEmpty({type:"indexOver", index:-1});
					}
					return;
				}
				this.blurItem(jQueryObj);
				//this.focusItem(this.collectItem[(itemIndex-1)].jQueryObj);
				
				var nextItemIndex = itemIndex-1;
				for(var ii=nextItemIndex;ii>-1;ii--){
					if(!this.collectItem[ii].jQueryObj.get(0).disabled){
						nextItemIndex = ii;
						break;
					}
				}
				this.focusItem(this.collectItem[nextItemIndex].jQueryObj);
			}else if(direction == "E"){
				if(itemIndex >= this.collectItem.length-1){
					if(cfg.oncursorEmpty){
						cfg.oncursorEmpty({type:"indexOver", index:1});
					}
					return;
				}
				this.blurItem(jQueryObj);
				
				var nextItemIndex = itemIndex+1;
				for(var ii=nextItemIndex;ii<this.collectItem.length;ii++){
					if(!this.collectItem[ii].jQueryObj.get(0).disabled){
						nextItemIndex = ii;
						break;
					}
				}
				this.focusItem(this.collectItem[nextItemIndex].jQueryObj);
			}
			
    	}
    },
    blurItem: function(jQueryObj){
    	var cfg = this.config;
    	
    	var axbind = jQueryObj.attr("data-axbind");
    	if(axbind){
    		if(axbind == "select"){
    			jQueryObj.bindSelectBlur();
    		}else if(axbind == "selector"){
    			jQueryObj.bindSelectorBlur();
    		}
    	}else{
    		//trace(jQueryObj.get(0).type);
    	}
    },
    focusItem: function(jQueryObj){
    	var cfg = this.config;
    	var axbind = jQueryObj.attr("data-axbind");
    	if(axbind){
    		if(axbind == "select") jQueryObj.bindSelectFocus();
    		else if(axbind == "selector") jQueryObj.focus();
    		else jQueryObj.focus();
    	}else{
    		//trace(jQueryObj.get(0).id);
    		jQueryObj.focus();
    	}
    },
    focus: function(focusIndex){
    	var cfg = this.config;
    	
    	if(focusIndex == undefined) focusIndex = 0;
    	//trace(Object.isString(focusIndex));
    	if(Object.isString(focusIndex)){
    		if(focusIndex == "first") focusIndex = 0;
    		else if(focusIndex == "last") focusIndex = this.collectItem.length-1;
    	}else{
    		if(focusIndex < 0) focusIndex = 0;
    		if(focusIndex >= this.collectItem.length) focusIndex = this.collectItem.length-1;
    	}
    	this.focusItem(this.collectItem[focusIndex].jQueryObj);
    }
});
/* ---------------------------- */
var AXModelControlGrid = Class.create(AXJ, {
	initialize: function(AXJ_super) {
		AXJ_super();
		this.config.theme = "AXModelControlGrid";
		this.removedList = [];
	},
	init: function() {
		var cfg = this.config;
		if(Object.isUndefined(cfg.targetID)){
			trace("need targetID - setConfig({targetID:''})");
			return;
		}
		this.target = jQuery("#"+cfg.targetID);

		var theme = cfg.theme;
		/* grid 뼈대 그리기 ----------------------------------------------------------------------------------------------------- */
		var ol = [];
		ol.push("<div class=\"" + theme + "\" id=\"" + cfg.targetID + "_AX_grid\" style=\"\">");
		ol.push("	<div class=\"AXgridScrollBody\" id=\"" + cfg.targetID + "_AX_gridScrollBody\" style=\"z-index:2;\">");
		ol.push("		<div class=\"AXGridColHead AXUserSelectNone\" id=\"" + cfg.targetID + "_AX_gridColHead\" onselectstart=\"return false;\"></div>");
		ol.push("		<div class=\"AXGridBody\" id=\"" + cfg.targetID + "_AX_gridBody\"></div>");
		//ol.push("		<div style=\"height:13px;\"></div>");
		ol.push("	</div>");
		this.target.empty();
		this.target.append(ol.join(''));
		/* grid 뼈대 그리기 ----------------------------------------------------------------------------------------------------- */

		this.gridBody = jQuery("#" + cfg.targetID + "_AX_grid");
		this.scrollBody = jQuery("#" + cfg.targetID + "_AX_gridScrollBody");
		this.colHead = jQuery("#" + cfg.targetID + "_AX_gridColHead");
		this.body = jQuery("#" + cfg.targetID + "_AX_gridBody");

		/*colHead setting */
		this.setColHead();
		//this.scrollBody.css({height:this.scrollBody.outerHeight()+13});

		this.myUIScroll = new AXScroll(); // 스크롤 인스턴스 선언
		this.myUIScroll.setConfig({
			targetID : cfg.targetID + "_AX_grid",
			scrollID : cfg.targetID + "_AX_gridScrollBody",
			touchDirection : false,
			yscroll:false,
			xscroll:true
		});

		jQuery(window).bind("resize", this.windowResize.bind(this));
	},
	windowResizeApply: function () {
		var cfg = this.config;
		var bodyWidth = this.gridBody.width() - 2;
		var colWidth = 0;
		var astricCount = 0;

		axdom.each(cfg.colGroup, function (cidx, CG) {
			if(CG.widthAstric){
				CG.width = 0;
				CG._owidth = CG.width;
				astricCount++;
			}
			colWidth += (CG._owidth||0).number();
		});
		this.colWidth = colWidth;

		var newColWidth = 0;
		/* width * 예외처리 구문 ------------ s */
		if ((bodyWidth) > (colWidth + 100 * astricCount)) {
			var remainsWidth = (bodyWidth) - colWidth;
			axdom.each(cfg.colGroup, function (cidx, CG) {
				if (CG.widthAstric) {
					CG._owidth = remainsWidth / astricCount;
					CG.width = CG._owidth;
					colWidth += (CG._owidth||0).number();
				}
				newColWidth += CG.width.number();
			});
		}else{
			axdom.each(cfg.colGroup, function (cidx, CG) {
				if (CG.widthAstric) {
					CG._owidth = 200;
					CG.width = 200;
					colWidth += (CG._owidth||0).number();
				}
				newColWidth += CG.width.number();
			});
		}
		this.colWidth = newColWidth;

		axdom.each(cfg.colGroup, function (cidx, CG) {
			axdom("#" + cfg.targetID + "_AX_col_AX_" + cidx + "_AX_head").attr("width", this.width);
			axdom("#" + cfg.targetID + "_AX_col_AX_" + cidx + "_AX_body").attr("width", this.width);
		});

		this.scrollBody.css({width:this.colWidth});

		this.colHead.find("table").css({width:this.colWidth});
		this.body.find("table").css({width:this.colWidth});
		this.myUIScroll.resizeScroll();
		this.myUIScroll.moveTo(0);
	},
	getColGroup: function (subfix) {
		var cfg = this.config;
		var po = [];
		po.push("<colgroup>");
		axdom.each(cfg.colGroup, function (cidx, CG) {
			po.push("<col width=\"" + CG.width + "\" style=\"\" id=\"" + cfg.targetID + "_AX_col_AX_" + cidx + "_AX_" + subfix + "\" />");
		});
		po.push("</colgroup>");
		return po.join('');
	},
	getHeadItem: function (arg) {

		var cfg = this.config;
		var po = [];
		po.push("<td class=\"colHeadTd\">");
		po.push("	<div class=\"tdRelBlock\" style=\"text-align:" + (arg.align||"left") + ";\">");

		if(arg.html){
			var html = arg.html.call({
				rowIndex: arg.rowIndex,
				colIndex: arg.colIndex,
				data: arg.data
			});
			po.push(html);
		}else{
			po.push(arg.label);
		}

		po.push("	</div>");
		po.push("</td>");

		return po.join('');
	},
	setColHead: function(rewrite){
		var cfg = this.config;
		var bodyWidth = this.gridBody.width()-2;
		var colWidth = 0;
		var astricCount = 0;

		axdom.each(cfg.colGroup, function (cidx, CG) {
			if (!rewrite){
				if(CG.width == "*"){
					CG.width = 0;
					CG.widthAstric = true;
					astricCount++;
				}
				CG._owidth = CG.width; /* 최초의 너비값 기억 하기 */
			}else{
				if(CG.widthAstric){
					CG.width = 0;
					CG._owidth = CG.width;
					astricCount++;
				}
			}
			colWidth += (CG._owidth||0).number();
		});
		this.colWidth = colWidth;

		var newColWidth = 0;
		/* width * 예외처리 구문 ------------ s */
		if ((bodyWidth) > (colWidth + 100 * astricCount)) {
			var remainsWidth = (bodyWidth) - colWidth;
			axdom.each(cfg.colGroup, function (cidx, CG) {
				if (CG.widthAstric) {
					CG._owidth = remainsWidth / astricCount;
					CG.width = CG._owidth;
					colWidth += (CG._owidth||0).number();
				}
				newColWidth += CG.width.number();
			});
		}else{
			axdom.each(cfg.colGroup, function (cidx, CG) {
				if (CG.widthAstric) {
					CG._owidth = 200;
					CG.width = 200;
					colWidth += (CG._owidth||0).number();
				}
				newColWidth += CG.width.number();
			});
		}

		this.colWidth = newColWidth;
		this.scrollBody.css({width:this.colWidth});

		var getHeadItem = this.getHeadItem.bind(this);

		var po = [];
		po.push("<table class=\"colHeadTable\" style=\"width:" + this.colWidth + "px;\">");
		po.push(this.getColGroup("head")); /*colGroup 삽입 */
		po.push("<tbody>");
		po.push("<tr>");
		var colCount = 0;
		axdom.each(cfg.colGroup, function (CHidx, CH) {
			po.push(getHeadItem({
				rowIndex:0, colIndex:CHidx,
				align: CH.align,
				label:CH.label, html:CH.html, data:CH.data
			}));
			colCount += CH.colspan;
		});
		po.push("</tr>");
		po.push("</tbody>");
		po.push("</table>");

		this.colHead.empty();
		this.colHead.append(po.join(''));
	},
	setList: function(list, setType){
		var cfg = this.config;
		if (typeof setType == "undefined") {
			this.list = list;
			this.removedList = []; // 그리드가 초기화 되어 삭제된 리스트도 초기화 됩니다.
		} else {
			this.list = list;
			//this.removedList = []; // 그리드가 초기화 되어 삭제된 리스트도 초기화 됩니다.
		}

		this.printList();
		//this.scrollBody.css({height:this.scrollBody.outerHeight()+13});

		this.myUIScroll.resizeScroll();
	},
	appendList: function(item){
		var cfg = this.config;

		item._CUD = "C";

		this.list.push(item);

		//trace(this.list);

		var lidx = this.list.length-1;
		this.printItem(lidx, this.list[lidx]);
		this.printFootItem();

		this.myUIScroll.resizeScroll();
	},
	getItem: function(arg, update){
		var cfg = this.config;
		var po = [];


		if(update == undefined) po.push("<td class=\"bodyTd\">");
		po.push("	<div class=\"tdRelBlock\" style=\"text-align:" + (arg.align||"left") + ";\">");

		if(arg.html){
			var html = arg.html.call({
				rowIndex: arg.rowIndex,
				colIndex: arg.colIndex,
				data: arg.data,
				item:this.list[arg.rowIndex], list:this.list
			});
			po.push(html);
		}else{
			po.push("&nbsp;");
		}

		po.push("	</div>");;
		if(update == undefined) po.push("</td>");

		return po.join('');
	},
	printList: function(){
		var cfg = this.config;
		var printItem = this.printItem.bind(this);

		var po = [];
		po.push("<table class=\"gridBodyTable\" style=\"width:" + this.colWidth + "px;\">");
		po.push(this.getColGroup("body")); /*colGroup 삽입 */
		po.push("<tbody>");
		po.push("</tbody>");
		po.push("<tfoot>");
		po.push("</tfoot>");
		po.push("</table>");

		this.body.empty();
		this.body.append(po.join(''));

		axdom.each(this.list, function (lidx, L) {
			printItem(lidx, L);
		});

		this.printFootItem();
	},
	printItem: function(lidx, L, update, event){
		var cfg = this.config;
		var getItem = this.getItem.bind(this);
		var AXbindOnchange = this.AXbindOnchange.bind(this);
		var _body = this.body.find("tbody");

		if (!L) return;

		var tr = [];
		if(update == undefined) tr.push("<tr class='modelControlTR' id='" + cfg.targetID + "_tbodyTR_" + lidx + "'>");

		axdom.each(cfg.body.form, function (fidx, form) {
			if (form) {
				tr.push(getItem({
					rowIndex: lidx, colIndex: fidx,
					align: (form.align || "left"),
					html: form.html, data: form.data
				}));
			}
		});
		if(update == undefined) tr.push("</tr>");
		if(update == undefined){
			_body.append(tr.join(''));
		}else{
			_body.find("#" + cfg.targetID + "_tbodyTR_" + lidx).html(tr.join(''));
		}

		var oncursorKeyup = this.oncursorKeyup.bind(this);

		axdom.each(cfg.body.form, function (fidx, form) {
			if (form) {
				if (form.AXBind) {
					var bindID = form.AXBind.id.replace(/@rowIndex/g, lidx);
					var myConfig = AXUtil.copyObject(form.AXBind.config);
					axdom.each(myConfig, function (k, v) {
						if (Object.isString(v)) myConfig[k] = v.replace(/@rowIndex/g, lidx);
					});

					myConfig.onchange = function () {
						AXbindOnchange(lidx, fidx, this);
					};

					if (form.AXBind.type == "TwinDate") {
						jQuery("#" + bindID).bindTwinDate(myConfig);
					} else if (form.AXBind.type == "Date") {
						jQuery("#" + bindID).bindDate(myConfig);
					} else if (form.AXBind.type == "Select") {
						jQuery("#" + bindID).unbindSelect();
						jQuery("#" + bindID).bindSelect(myConfig);
						if (cfg.cursorFocus) {
							jQuery("#" + bindID).bindSelectGetAnchorObject().bind("keydown.AXModelControlGrid", function (event) {
								setTimeout(function () {
									oncursorKeyup(jQuery("#" + bindID), event, lidx);
								}, 10);
							});
						}
					} else if (form.AXBind.type == "Selector") {
						jQuery("#" + bindID).bindSelector(myConfig);
					} else if (form.AXBind.type == "Money") {
						jQuery("#" + bindID).bindMoney(myConfig);
					} else if (form.AXBind.type == "Number") {
						jQuery("#" + bindID).bindNumber(myConfig);
					}
				}
			}
		});

		if(cfg.cursorFocus){
			_body.find("#" + cfg.targetID + "_tbodyTR_" + lidx).find("input[type=text],input[type=checkbox],input[type=radio],select,textarea").unbind("keydown.AXModelControlGrid").bind("keydown.AXModelControlGrid", function(event){
				setTimeout(function(){
					oncursorKeyup(jQuery(event.target), event, lidx);
				}, 10);
			});
		}

		var printFootItem = this.printFootItem.bind(this);
		var _this = this;
		_body.find("#" + cfg.targetID + "_tbodyTR_" + lidx).find("input[type=text],input[type=checkbox],input[type=radio],select,textarea").unbind("change.AXModelControlGrid").bind("change.AXModelControlGrid", function(){
			_this.list[lidx][this.name] = axdom(this).val();
			printFootItem();
		});
		//_body.find("#" + cfg.targetID + "_tbodyTR_" + lidx).find("input[type=checkbox],input[type=radio]")

		if(update == "update"){
			//printFootItem();
		}
	},
	oncursorKeyup: function(jQueryObj, event, lidx){
		var cfg = this.config;

		if(!event.target) return;
		if(event.shiftKey || event.metaKey || event.ctrlKey) return;
		var eventName = jQueryObj.get(0).name;
		if(cfg.oncursor){
			var axbind = jQueryObj.attr("data-axbind");
			var direction = "";
			if(event.keyCode == AXUtil.Event.KEY_UP) direction = "U";
			else if(event.keyCode == AXUtil.Event.KEY_DOWN) direction = "D";
			else if(event.keyCode == AXUtil.Event.KEY_LEFT) direction = "L";
			else if(event.keyCode == AXUtil.Event.KEY_RIGHT) direction = "R";
			else if(event.keyCode == AXUtil.Event.KEY_RETURN && axbind != "select") direction = "R";
			if(cfg.oncursor.call(
				{
					event:event,
					direction:direction,
					listIndex:lidx,
					jQueryObj:jQueryObj
				}
			) === false) return false;
			if(direction == "") return;

			if(axbind && (direction == "U" || direction == "D")) return;
			if((direction == "U" || direction == "D") && jQueryObj.get(0).tagName == "SELECT") return;
			if(direction == "U"){

				if(lidx == 0) return;
				this.blurItem(jQueryObj);
				var nextItemList = this.body.find("#" + cfg.targetID + "_tbodyTR_" + (lidx-1)).find("input[type=text],input[type=checkbox],input[type=radio],select,textarea");
				var findItem;
				nextItemList.each(function(){
					if(this.name == eventName) findItem = this;
				});
				this.focusItem(jQuery(findItem));
			}else if(direction == "D"){

				if(lidx >= this.list.length-1) return;
				this.blurItem(jQueryObj);
				var nextItemList = this.body.find("#" + cfg.targetID + "_tbodyTR_" + (lidx+1)).find("input[type=text],input[type=checkbox],input[type=radio],select,textarea");
				var findItem;
				nextItemList.each(function(){
					if(this.name == eventName) findItem = this;
				});
				this.focusItem(jQuery(findItem));

			}else if(direction == "L"){

				var colIndex;
				var itemList = this.body.find("#" + cfg.targetID + "_tbodyTR_" + lidx).find("input[type=text],input[type=checkbox],input[type=radio],select,textarea");
				itemList.each(function(cidx, item){
					if(this.name == eventName) colIndex = cidx;
				});

				if(colIndex == 0){
					if(lidx == 0) return;
					this.blurItem(jQueryObj);
					var nextItemList = this.body.find("#" + cfg.targetID + "_tbodyTR_" + (lidx-1)).find("input[type=text],input[type=checkbox],input[type=radio],select,textarea");
					this.focusItem(jQuery(nextItemList.last()));
				}else{
					this.blurItem(jQueryObj);
					this.focusItem(jQuery(itemList[colIndex-1]));
				}

			}else if(direction == "R"){

				var colIndex;
				var itemList = this.body.find("#" + cfg.targetID + "_tbodyTR_" + lidx).find("input[type=text],input[type=checkbox],input[type=radio],select,textarea");
				itemList.each(function(cidx, item){
					if(this.name == eventName) colIndex = cidx;
				});

				if(colIndex >= itemList.length-1){
					if(lidx >= this.list.length-1) return;
					this.blurItem(jQueryObj);
					var nextItemList = this.body.find("#" + cfg.targetID + "_tbodyTR_" + (lidx+1)).find("input[type=text],input[type=checkbox],input[type=radio],select,textarea");
					this.focusItem(jQuery(nextItemList.first()));
				}else{
					this.blurItem(jQueryObj);
					this.focusItem(jQuery(itemList[colIndex+1]));
				}
			}


		}
		//trace(event.target.name, lidx);
	},
	blurItem: function(jQueryObj){
		var cfg = this.config;
		var axbind = jQueryObj.attr("data-axbind");
		if(axbind){
			if(axbind == "select"){
				jQueryObj.bindSelectBlur();
			}else if(axbind == "selector"){
				jQueryObj.bindSelectorBlur();
			}else{

			}
		}
	},
	focusItem: function(jQueryObj){
		var cfg = this.config;

		var axbind = jQueryObj.attr("data-axbind");
		if(axbind){
			if(axbind == "select") jQueryObj.bindSelectFocus();
			else if(axbind == "selector") jQueryObj.focus();
			else jQueryObj.focus();
		}else{
			jQueryObj.focus();
		}
	},
	focusIndex: function(rowIndex, colIndex){
		var cfg = this.config;
		//trace(rowIndex, colIndex);
		var myTd = this.body.find("tbody tr#" + cfg.targetID + "_tbodyTR_" + rowIndex + " td:nth-child(" + (colIndex+1) + ")");
		//trace(myTd.html());
		var item = myTd.find("input[type=text],input[type=checkbox],input[type=radio],select,textarea").get(0);
		item.focus();
	},

	AXbindOnchange: function(lidx, fidx, AXBindThis){
		var cfg = this.config;
		if(!cfg.body.form[fidx].AXBind.onchange) cfg.body.form[fidx].AXBind.onchange = cfg.body.form[fidx].AXBind.onChange;
		if(cfg.body.form[fidx].AXBind.onchange){

			var sendObj = {
				rowIndex: lidx,
				colIndex: fidx,
				data: cfg.body.form[fidx].data,
				item:this.list[lidx], list:this.list
			};

			axf.each(AXBindThis, function(k, v){
				sendObj[k] = v;
			});

			cfg.body.form[fidx].AXBind.onchange.call(sendObj);
		}
	},

	/* foot */
	printFootItem: function(){
		var cfg = this.config;

		if(!cfg.foot) return;
		if(!cfg.foot.form) return;

		var _body = this.body.find("tfoot");
		var _list = this.list;
		var foot = [];
		foot.push("<tr class='modelControlTR' id='" + cfg.targetID + "_tbodyTR_foot'>");

		axdom.each(cfg.foot.form, function(fidx, arg){
			foot.push("<td class=\"bodyTd\" colspan=\"" + (arg.colspan || 1) + "\">");
			foot.push("	<div class=\"tdRelBlock\" style=\"text-align:" + (arg.align||"left") + ";\">");

			if(arg.html){
				var html = arg.html.call({
					rowIndex: 0,
					colIndex: fidx,
					data: arg.data,
					list:_list
				});
				foot.push(html);
			}else{
				foot.push("&nbsp;");
			}

			foot.push("	</div>");
			foot.push("</td>");
		});

		foot.push("</tr>");

		_body.empty();
		_body.append(foot.join(''));

	},
	updateItem: function(lidx, item, onlyDataChane, event){
		var cfg = this.config;
		var getItem = this.getItem.bind(this);

		item._CUD = "U";

		this.list[lidx] = AXUtil.overwriteObject(this.list[lidx], item, true);
		if(!onlyDataChane) this.printItem(lidx, this.list[lidx], "update", event);
		else{


			var _body = this.body;
			axdom.each(cfg.body.form, function (fidx, form) {
				if(form.updateReload){
					var td = getItem({
						rowIndex:lidx, colIndex:fidx,
						align:form.align,
						html:form.html, data:form.data
					}, "update");
					var myTD = jQuery(_body.find("tbody tr#" + cfg.targetID + "_tbodyTR_" + lidx + " td").get(fidx));
					myTD.html(td);
				}
			});

			var oncursorKeyup = this.oncursorKeyup.bind(this);
			if(cfg.cursorFocus){
				_body.find("#" + cfg.targetID + "_tbodyTR_" + lidx).find("input[type=text],input[type=checkbox],input[type=radio],select,textarea").unbind("keyup.AXModelControlGrid").bind("keyup.AXModelControlGrid", function(event){
					oncursorKeyup(jQuery(event.target), event, lidx);
				});
			}

		}


		this.printFootItem();
	},
	removeItem: function(collectIdx){
		var cfg = this.config, _this = this;

		this.list = this.getList();
		var newList = [];

		axf.each(this.list, function(lidx, L){
			if(Object.isArray(collectIdx)){
				var isOk = true;
				axf.each(collectIdx, function(){
					if(this == lidx) isOk = false;
				});
				if (isOk) {
					newList.push(L);
				}
				else {
					if (L._CUD != "C" && L._CUD != "D")
						_this.removedList.push(L);
				}
			}else{
				if (collectIdx != lidx) {
					newList.push(L);
				}
				else {
					if (L._CUD != "C" && L._CUD != "D")
						_this.removedList.push(L);
				}
			}
		});

		this.setList(newList, "update");
	},
	getValue: function(name){
		var cfg = this.config;
		var returnValues = [];
		this.body.find("input[type=checkbox][name="+name+"]").each(function(){
			returnValues.push(this.value);
		});
		return returnValues;
	},
	getCheckedValue: function(name){
		var cfg = this.config;
		var returnValues = [];
		this.body.find("input[type=checkbox][name="+name+"]:checked").each(function(){
			returnValues.push(this.value);
		});
		return returnValues;
	},
	getList: function(){
		var cfg = this.config;

		var _body = this.body.find("tbody");
		axf.each(this.list, function(lidx, L){

			var item = {};
			_body.find("#" + cfg.targetID + "_tbodyTR_" + lidx).find("input[type=text],select,textarea").each(function(){
				item[this.name] = axdom(this).val();
			});

			var checkNames = {};
			_body.find("#" + cfg.targetID + "_tbodyTR_" + lidx).find("input[type=checkbox],input[type=radio]").each(function(){
				if(this.type == "checkbox"){
					if(checkNames[this.name]){
						checkNames[this.name].count += 1;
					}else{
						checkNames[this.name] = {name:this.name, count:1};
						item[this.name] = "";
					}
				}
				if(this.checked){
					if(this.type == "checkbox"){
						if(item[this.name]){
							item[this.name].push(this.value);
						}else{
							item[this.name] = [this.value];
						}
					}else{
						item[this.name] = this.value;
					}
				}
			});

			axdom.each(checkNames, function(k, v){
				if(v.count == 1){
					if(Object.isArray(item[v.name])){
						item[v.name] = item[v.name].join(",");
					}
				}
			});

			L = AXUtil.overwriteObject(L, item, true);
		});

		return this.list;

		/*
		 this.body.find("tr.modelControlTR").each(function(trIndex, TR){
		 trace(trIndex);
		 });
		 */
	},
	getRemovedList: function () {
		return this.removedList;
	}
});


/* ---------------------------- */
/* http://www.axisj.com, license : http://www.axisj.com/license */
 

var AXMultiSelector = Class.create(AXJ, {
    version: "AXMultiSelector v1.21",
    author: "tom@axisj.com",
    logs: [
		"2013-08-01 오후 3:08:07",
		"2014-03-21 오후 2:19:52 : tom multiselect 기본값 설정 함수 추가"
	],
    initialize: function (AXJ_super) {
        AXJ_super();

    },
    init: function () {
    	var cfg = this.config;
    	axdom("#"+cfg.targetID).bind("click", this.expandOptionBox.bind(this));
    },
    expandOptionBox: function(){
    	var cfg = this.config;
    	
    	axdom.each(cfg.optionGroup, function (gidx, G) {
    		if (G.getOptionValue) {
    			axdom.each(cfg.optionGroup[gidx].options, function (oidx, O) {
    				cfg.optionGroup[gidx].options[oidx].selected = false;
    			});
    		}
    	});

		var po = [];
		po.push("<div id=\""+cfg.targetID + "_AX_expandBox\" class=\"AXMultiSelector_expandBox\">");
		var boxWidth = 0;
		axdom.each(cfg.optionGroup, function(gidx, G){
			po.push("<div id=\""+cfg.targetID + "_AX_expandScrollBox_AX_"+gidx+"\" class=\"AXMultiSelector_scrollBox\" style=\"width:"+this.width+"px;\">");
			po.push("	<div id=\""+cfg.targetID + "_AX_expandScroll_AX_"+gidx+"\" class=\"AXMultiSelector_scroll\">");
			axdom.each(this.options, function(index, O){
				var selectedClass = (O.selected) ? " on" : "";
				po.push("<a href=\"#AXexec\" id=\""+cfg.targetID + "_AX_"+gidx+"_AX_option_AX_"+index+"\" class=\"bindSelectorNodes "+selectedClass+"\">"+ O.optionText +"</a>");
			});
			po.push("	</div>");
			po.push("</div>");
			boxWidth += (this.width + 2);
		});
		po.push("<div style=\"clear:both\"></div>");
		po.push("<div align=\"center\" style=\"padding-top:5px;\">");
		po.push("	<input type=\"button\" value=\"확인\" class=\"AXButton\" id=\""+cfg.targetID + "_AX_expandScrollBox_AX_confirm\" />");
		po.push("	<input type=\"button\" value=\"취소\" class=\"AXButton\" id=\""+cfg.targetID + "_AX_expandScrollBox_AX_cancel\" />");
		po.push("</div>");
		po.push("</div>");
		axdom(document.body).append(po.join(''));
		
		boxWidth = boxWidth + (cfg.optionGroup.length * 5) + 5;
		axdom("#"+cfg.targetID + "_AX_expandBox").css({width:boxWidth});
		
    	var css = {};
    	var offset = axdom("#"+cfg.targetID).offset();
    	css.top = offset.top;
    	//css.left = offset.left - boxWidth + axdom("#"+cfg.targetID).outerWidth();
    	css.left = offset.left;
    	axdom("#"+cfg.targetID + "_AX_expandBox").css(css);


		axdom.each(cfg.optionGroup, function(gidx, G){
			G.myUIScroll = new AXScroll();
			G.myUIScroll.setConfig({
				CT_className:"AXScrollSmall",
				targetID:cfg.targetID + "_AX_expandScrollBox_AX_"+gidx,
				scrollID:cfg.targetID + "_AX_expandScroll_AX_"+gidx,
				touchDirection:false
			});
			
			var selectedValue = "";
			if (G.getOptionValue) selectedValue = G.getOptionValue.call(G);

			axdom.each(cfg.optionGroup[gidx].options, function (oidx, O) {
				if (G.getOptionValue) {
					if (O.optionValue == selectedValue) {
						O.selected = true;
						axdom("#" + cfg.targetID + "_AX_" + gidx + "_AX_option_AX_" + oidx).addClass("on");
						G.myUIScroll.focusElement(cfg.targetID + "_AX_" + gidx + "_AX_option_AX_" + oidx); //focus
					}
				}else if(O.selected){
					O.selected = true;
					axdom("#" + cfg.targetID + "_AX_" + gidx + "_AX_option_AX_" + oidx).addClass("on");
					G.myUIScroll.focusElement(cfg.targetID + "_AX_" + gidx + "_AX_option_AX_" + oidx); //focus
				} else {
					cfg.optionGroup[gidx].options[oidx].selected = false;
				}
			});
			
		});
		
		axdom("#"+cfg.targetID + "_AX_expandScrollBox_AX_confirm").bind("click", function(){
			if(cfg.onChange){
				var selectObj = {};
				axdom.each(cfg.optionGroup, function(gidx, G){
					selectObj[G.name] = {};
					axdom.each(cfg.optionGroup[gidx].options, function(oidx, O){
						if(O.selected){
							selectObj[G.name] = O;
						}
					});
				});
				cfg.onChange.call(selectObj);
			}
			axdom("#"+cfg.targetID + "_AX_expandBox").remove(); // 개체 삭제 처리
		});
		axdom("#"+cfg.targetID + "_AX_expandScrollBox_AX_cancel").bind("click", function(){
			axdom("#"+cfg.targetID + "_AX_expandBox").remove(); // 개체 삭제 처리
		});
		
		axdom("#"+cfg.targetID + "_AX_expandBox").find(".bindSelectorNodes").bind("click", function(event){
			var idx = event.target.id.split(/_AX_/g);
			var gidx = idx[idx.length-3];
			var index = idx[idx.length-1];
			
			axdom("#"+cfg.targetID + "_AX_"+gidx+"_AX_option_AX_"+index).addClass("on");
			
			axdom.each(cfg.optionGroup[gidx].options, function(oidx, O){
				if(O.selected){
					axdom("#"+cfg.targetID + "_AX_"+gidx+"_AX_option_AX_"+oidx).removeClass("on");
					delete O.selected;
				}
			});
			cfg.optionGroup[gidx].options[index].selected = true;
			
		});
    },
    setValue: function(obj){
    	var cfg = this.config;
    	axdom.each(cfg.optionGroup, function(gidx, G){
    		axdom.each(obj, function(k, v){
    			if(G.name == k){
    				axdom.each(G.options, function(){
    					if(this.optionValue+"" == v+""){
    						this.selected = true;
    					}else{
    						delete this.selected;
    					}
    				});
    				
    			}
    		});
    	});
    	
    }
});
/* ---------------------------- */
/* http://www.axisj.com, license : http://www.axisj.com/license */
/**
 * AXProgress
 * @class AXProgress
 * @extends AXJ
 * @version v1.1
 * @author tom@axisj.com
 * @logs
 "2012-12-19 오후 5:47:58",
 "2014-02-03 오후 9:29:34 : tom count 표시문제 해결"
 "2014-10-15 groovedk : 주석추가"
 */

var AXProgress = Class.create(AXJ, {
/**
 * @method AXProgress.initialize
 * @param {fn} -
 * @param {jsObject} [options] - config.options 에 할당 / 추가
 * @description
 * 프로그래스바를 시작합니다. options 를 지정하지 않으면 setConfig에 지정한 속성을 이용하여 프로그래스바를 시작합니다.
 * @example
 ```
var myProgress = new AXProgress();

myProgress.setConfig({
	theme:"AXlineProgress", //[String = "AXlineProgress"] - 프로그래스 CSS Class 이름 AXlineProgress, AXCircleProgress 클래스가 기본 제공됩니다.
	totalCount:100,         //{number} - 프로그래스 전체 카운트 수
	width:400,              //{number} - 프로그래스바 너비
	top:100,                //{number} - 프로그래스바 표시 위치
	title:"AXProgress BAR", //{String} - 프로그래스바 제목
	duration:50             //{number = 50} - 프로그래스바의 애니메이션 속도 값 입니다.
});

 ```
 */
	initialize: function(AXJ_super) {
		AXJ_super();
		this.Observer = null;
		//this.config.easing = {duration:10, easing:""};
		this.config.duration = 50;
		this.config.theme = "AXlineProgress";
	},
	init: function(){
		
	},

/**
 * @method AXProgress.start
 * @param {fn} - callBack function
 * @param {jsObject} [options] - config.options 에 할당 / 추가
 * @description
 * 프로그래스바를 시작합니다. options 를 지정하지 않으면 setConfig에 지정한 속성을 이용하여 프로그래스바를 시작합니다.
 * @example
 ```
var myProgress = new AXProgress();

myProgress.start(function(){
	trace(this);
	if(this.isEnd){
		myProgress.close();
		mask.close();
		toast.push("progress end");
	}else{
		// 무언가 처리를 해줍니다.	대부분 비동기 AJAX 통신 처리 구문을 수행합니다.
		myProgress.update(); // 프로그레스의 다음 카운트를 시작합니다.
	}
});

// options 지정방식
mask.open();
myProgress.start(function(){
    if(this.isEnd){
		myProgress.close();
		mask.close();
		toast.push("progress end");
	}else{
		// 무언가 처리를 해줍니다.	대부분 비동기 AJAX 통신 처리 구문을 수행합니다.
		myProgress.update(); // 프로그레스의 다음 카운트를 시작합니다.
	}},
    {
        totalCount:10,
        width:500,
        top:200,
        title:"Set Options Type Progress"
    }
);

 ```
 */
	start: function(callBack, options){
		var config = this.config;
		config.callBack = callBack;
		
		config.options = options;
		
		var totalCount = config.totalCount || 100;
		this.loadedCount = 0;
		var loadedCount = this.loadedCount;
		var loadedRate = (loadedCount / totalCount * 100).round(1);
		var progressWidth = config.width || 200;
		var progressTitle = config.title || "";
		var progressTop = config.top || 0;
		this.progressID = "progress_AX_"+AXUtil.timekey();
		var progressID = this.progressID;
		this.progressStop = false;
		var theme = config.theme;
		
		var hasCancel = false;
		
		if(config.options){
			if(config.options.totalCount) totalCount = config.options.totalCount;
			if(config.options.width) progressWidth = config.options.width;
			if(config.options.top) progressTop = config.options.top;
			if(config.options.title) progressTitle = config.options.title;
			if(config.options.cancel) hasCancel = config.options.cancel;
			if(config.options.theme) theme = config.options.theme;
		}

		var po = [];
		po.push("<div class=\"AXprogressTray "+theme+"\" id=\""+progressID+"_AX_tray\" align=\"center\" style=\"top:"+progressTop+"px;\">");
		if(progressTitle != ""){
			po.push("	<div class=\"AXprogressTitle\" id=\""+progressID+"_AX_title\" style=\"width:"+progressWidth+"px;\" align=\"left\">"+progressTitle+"</div>");
		}
		po.push("<div class=\"AXprogress\" id=\""+progressID+"\" style=\"width:"+progressWidth+"px;\">");
		po.push("	<div class=\"AXprogressContainer\" id=\""+progressID+"_AX_container\" align=\"left\" style=\"overflow:hidden;\">");
		if(theme == "AXlineProgress") po.push("		<div class=\"AXprogressBar\" id=\""+progressID+"_AX_bar\" style=\"width:"+loadedRate+"%;\"></div>");
		else  po.push("		<div class=\"AXprogressBar\" id=\""+progressID+"_AX_bar\"></div>");

		po.push("	</div>");

        po.push("    <div class=\"AXprogressLoadedText\" id=\""+progressID+"_AX_loadedText\">"+loadedRate+"%</div>");

		if(hasCancel){
			po.push(" <a href=\"#axexec\" id=\""+progressID+"_AX_cancel\" class=\"AXprogressCancel\">Cancel</a>");
		}

		po.push("</div>");
				
		po.push("</div>");
		this.progress = axdom(po.join(''));
		axdom(document.body).append(this.progress);
		
		axdom("#"+progressID+"_AX_cancel").bind("click", this.cancel.bind(this));
        this.loadedCount = 1;
		this.update();
	},

/**
 * @method AXProgress.update
 * @description - 프로그레스바 진행 상태를 업데이트 합니다.
 * @example
 ```
myProgress.update();
 ```
 */
	update: function(){
		var config = this.config;
		var theme = config.theme;
		
		if(this.progressStop) return;

		var totalCount = config.totalCount || 100;

		if(config.options){
			if(config.options.totalCount) totalCount = config.options.totalCount;
			if(config.options.theme) theme = config.options.theme;
		}
		
		var loadedCount = this.loadedCount;
		
		var progressID = this.progressID;
		var loadedRate = ((loadedCount-1) / (totalCount.number()) * 100).round(1);
		if(loadedRate > 100) loadedRate = 100;
		axdom("#"+progressID+"_AX_loadedText").html(loadedRate+"%<span>"+(loadedCount-1).money()+"/"+totalCount.money()+"</span>");
		
		if(theme == "AXlineProgress"){
			axdom("#"+progressID+"_AX_bar").animate(
				{width:loadedRate+"%"},
				config.duration, "", 
				function(){
					if(config.callBack){
						config.callBack.call({
							totalCount:totalCount,
							loadedCount:loadedCount,
							loadedRate:(loadedCount / (totalCount.number()+1) * 100).round(1),
							isEnd:((loadedCount-1) == totalCount)
						});
					}
				}
			);
		}else{
			//circle
			setTimeout(function(){
				axdom("#"+progressID+"_AX_bar").addClass("percent"+((loadedCount / (totalCount.number()) * 100).round(0) / 5).round() * 5);
				if(config.callBack){
					config.callBack.call({
						totalCount:totalCount,
						loadedCount:loadedCount-1,
						loadedRate:(loadedCount / (totalCount.number()+1) * 100).round(1),
						isEnd:((loadedCount-1) == totalCount)
					});
				}				
			}, config.duration);
		}
		this.loadedCount++;
	},

/**
 * @method AXProgress.cancel
 * @description - 프로그래스바 진행을 중지합니다.
 * @example
 ```
myProgress.cancel();
 ```
 */
	cancel: function(){
		var config = this.config;
		var progressID = this.progressID;
		var cancelMSg = AXConfig.AXProgress.cancelMsg;
		if(config.options){
			var cancel = config.options.cancel;
			if(cancel.confirmMsg) cancelMSg = cancel.confirmMsg;
			if(confirm(cancelMSg)){
				this.progressStop = true;
				var totalCount = config.totalCount || 100;
				var loadedCount = this.loadedCount;
				cancel.oncancel.call({
					totalCount:totalCount,
					loadedCount:loadedCount,
					loadedRate:(loadedCount / totalCount * 100).round(1),
					isEnd:(loadedCount == totalCount)
				});
			}else{
				
			}
		}
	},

/**
 * @method AXProgress.restart
 * @description - 중지된 프로그레스바 진행상태를 재시작 합니다.
 * @example
 ```
myProgress.restart();
 ```
 */
	restart: function(){
		this.progressStop = false;
		this.update();
    },

/**
 * @method AXProgress.close
 * @description - 프로그레스바 창을 닫습니다.
 * @example
 ```
myProgress.close();
 ```
 */
	close: function(){
		var config = this.config;
		var progressID = this.progressID;
		axdom("#"+progressID+"_AX_tray").remove();
	}
});
/* ---------------------------- */
/**
 * @method AXSearch.setConfig
 * @param {Object} config - searchConfig
 * @description
 * 선언된 클래스를 사용하기 위해 속성을 정의합니다.
 * @example
 * ```js
 * var mySearch = new AXSearch();
 * mySearch.setConfig({
 *     targetID:"AXSearchTarget",  //{string} - AXSearch 클래스 코딩이 처리될 HTML 엘리먼트 타겟아이디
 *     theme : "AXSearch",         //[string = "AXSearch"] - AXSearch 에 적용될 CSS Class 이름
 *     onsubmit: function(){       //[fn] - Function AXSearch 가 onsubmit 이벤트 발생되었을 때 연결되는 콜백함수
 *         fnObj.search1(); // 버튼이 선언되지 않았거나 submit 개체가 있는 경우 발동 합니다.
 *     },
 *     rows:[  //AXSearch 의 각 row는 배열로 정의합니다.
 *         {
 *             display:true,       //[boolean=true] - 해당 줄의 노출 여부. 숨겨진 row의 경우 사용자의 선택으로 활성화 처리할 수 있습니다.
 *             addClass:"gray",    //[string] - row에 추가될 CSS 클래스
 *             style:"",           //[string] - row에 추가될 CSS style
 *             list:[
 *                 {
 *                     label:"공개설정",   //[string] - 아이템 라벨
 *                     labelWidth:"100",   //[number] - 라벨너비
 *                     type:"link",        //[string] - 아이템 타입 ( link | checkBox | radioBox | selectBox | inputText | button | submit )
 *                     width:"",           //[number] - 아이템 너비
 *                     key:"openType",     //[string] - 아이템 유니크 키
 *                     addClass:"",        //[string] - 아이템 엘리먼트에 추가될 CSS 클래스
 *                     valueBoxStyle:"",   //[string] - 아이템 엘리먼트에 추가될 CSS style
 *                     value:"open",       //[string] - 아이템 value ( options 가 정의되는 아이템 link | checkBox | radioBox | selectBox 에는 정의할 수 없습니다 )
 *                     options:[       //select options
 *                         {optionValue:"all", optionText:"전체보기"},
 *                         {optionValue:"open", optionText:"공개"},
 *                         {optionValue:"close", optionText:"비공개"},
 *                         {optionValue:"close2", optionText:"비공개2", display:false},
 *                         {optionValue:"close3", optionText:"비공개3", display:false},
 *                         {optionValue:"close4", optionText:"비공개4", display:false}
 *                     ],
 *                     onChange: function(selectedObject, value){  //[fn] - onchange 이벤트 바인드
 *                     },
 *                     onClcik: function(selectedObject, value){  //[fn] - onclick 이벤트 바인드
 *                     }
 *                 }
 *             ]
 *         }
 *     ]
 * });
 * ```
 */

var AXSearch = Class.create(AXJ, {
    initialize: function(AXJ_super) {
        AXJ_super();
        this.formbindMethod = "script";
        this.config.theme = "AXSearch";
        this.config.viewMode = "dx";
    },
    init: function() {
        var cfg = this.config;
        if(Object.isUndefined(cfg.targetID)){
            trace("need targetID - setConfig({targetID:''})");
            return;
        }

        if (cfg.mediaQuery) {
            var _viewMode = "", clientWidth = axf.clientWidth();
            axf.each(cfg.mediaQuery, function (k, v) {
                if (Object.isObject(v)) {

                    if(v.min != undefined && v.max != undefined){
                        if (v.min <= clientWidth && clientWidth <= v.max) {
                            _viewMode = (k == "dx") ? "dx" : "mx";
                            return false;
                        }
                    }else{
                        if (v.min <= clientWidth) {
                            _viewMode = (k == "dx") ? "dx" : "mx";
                            return false;
                        }
                    }
                }
            });
            if (_viewMode != "") {
                cfg.viewMode = _viewMode;
            }
        }

        this.target = axdom("#"+cfg.targetID);

        // 스크립트 바인드 방식
        if(cfg.rows)
        {
            this.formbindMethod = "script";
            this.setBody();
            axdom(window).bind("resize", this.windowResize.bind(this));
        }

        // tagBind 방식
        else
        if(this.target.get(0).tagName.lcase() == "form")
        {
            this.formbindMethod = "tag";
            this.target.bind("submit", function(event){
                cfg.onsubmit();
                return false;
            });

            if(cfg.onkeydown) {
                if(cfg.keydown_check_classname){
                    this.target.find("."+cfg.keydown_check_classname).bind("keydown.axsearch", function (event) {
                        cfg.onkeydown(event);
                    });
                }
                else
                {
                    this.target.bind("keydown", function (event) {
                        cfg.onkeydown(event);
                    });
                }
            }
            if(cfg.onkeyup) {
                if(cfg.keyup_check_classname){
                    this.target.find("."+cfg.keyup_check_classname).bind("keyup.axsearch", function (event) {
                        cfg.onkeyup(event);
                    });
                }
                else
                {
                    this.target.bind("keyup", function (event) {
                        cfg.onkeyup(event);
                    });
                }
            }
            if(cfg.onreturn) {
                if(cfg.return_check_classname){
                    this.target.find("."+cfg.return_check_classname).bind("keydown.axsearch", function (event) {
                        if(event.keyCode == axf.Event.KEY_RETURN) cfg.onreturn(event);
                    });
                }
                else
                {
                    this.target.bind("keydown", function (event) {
                        if(event.keyCode == axf.Event.KEY_RETURN) cfg.onreturn(event);
                    });
                }
            }
            // onchange 연결
            if(cfg.onchange){
                if(cfg.change_check_classname){
                    this.target.find("."+cfg.change_check_classname).bind("change.axsearch", function (event) {
                        cfg.onchange(event);
                    });
                }
                else
                {
                    this.target.find("input, select, textarea").bind("change.axsearch", function(event){
                        cfg.onchange(event);
                    });
                }
            }
            // onfocus 연결
            if(cfg.onfocus){
                if(cfg.focus_check_classname){
                    this.target.find("."+cfg.focus_check_classname).bind("focus.axsearch", function (event) {
                        cfg.onfocus(event);
                    });
                }
                else
                {
                    this.target.find("input, select, textarea").bind("focus.axsearch", function(event){
                        cfg.onfocus(event);
                    });
                }
            }
        }
    },
    windowResizeApply: function () {
        var cfg = this.config;

        if (cfg.mediaQuery) {
            var _viewMode = "", clientWidth = axf.clientWidth();
            axf.each(cfg.mediaQuery, function (k, v) {
                if (Object.isObject(v)) {

                    if(v.min != undefined && v.max != undefined){
                        if (v.min <= clientWidth && clientWidth <= v.max) {
                            _viewMode = (k == "dx") ? "dx" : "mx";
                            return false;
                        }
                    }else{
                        if (v.min <= clientWidth) {
                            _viewMode = (k == "dx") ? "dx" : "mx";
                            return false;
                        }
                    }
                }
            });
            if (_viewMode != "") {
                cfg.viewMode = _viewMode;
            }
        }
        this.target.find("."+cfg.theme).removeClass("dx");
        this.target.find("."+cfg.theme).removeClass("mx");
        this.target.find("."+cfg.theme).addClass(cfg.viewMode);
    },
    getItemHtml: function(gr, itemIndex, item){
        var cfg = this.config;
        var po = [];
        var itemAddClass = [];
        var itemAddStyles = [];
        var poAttr = [];
        if(item.addClass) itemAddClass.push(item.addClass);
        if(item.style) itemAddStyles.push(item.style);
        if(item.addAttr){
            axdom.each(item.addAttr, function(idx, attr){
                poAttr.push(attr.attrKey + "=" + attr.attrValue);
            });
        }
        if(item.type == "label"){

            po.push("<div class=\"searchItem searchLabel ", itemAddClass.join(" "),"\" style=\"width:", (item.width||""),"px;text-align:", (item.align||"center"),";", itemAddStyles.join(''),"\">");
            po.push(item.value);
            po.push("</div>");

        }
        else
        if(item.type == "link"){

            po.push("<div class=\"searchItem searchLink ", itemAddClass.join(" "),"\" style=\"width:", (item.width||""),"px;text-align:", (item.align||"center"),";", itemAddStyles.join(''),"\">");
            po.push("<input type=\"hidden\" name=\"", item.key,"\" id=\"", cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key, "\" value=\"", item.value,"\" />");
            po.push("<label class=\"itemTable\">");
            if(item.label) {
                po.push("<span class=\"th\" style=\"min-width:", (item.labelWidth || 100), "px;\">");
                po.push(item.label);
                po.push("</span>");
            }else{
                //po.push("<span class=\"th none\">&nbsp;</span>");
            }
            po.push("<span class=\"td\" style=\"",(item.valueBoxStyle||""),"\" title=\"", (item.title||""),"\">");
            axdom.each(item.options, function(idx, Opt){
                if(idx > 0) po.push(" | ");
                var classOn = "";
                if(item.value == Opt.optionValue){
                    classOn = " on";
                    item.selectedIndex = idx;
                }
                po.push("<a href=\"#Axexec\" class=\"searchLinkItem", classOn, "\" id=\"", cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key + "_AX_" + idx, "\" title=\"", (Opt.title||""),"\">", Opt.optionText,"</a>");
            });
            po.push("</span>");
            po.push("</label>");
            po.push("</div>");

        }
        else
        if(item.type == "checkBox"){

            po.push("<div class=\"searchItem searchCheckbox ", itemAddClass.join(" "),"\" style=\"width:", (item.width||""),"px;text-align:", (item.align||"center"),";", itemAddStyles.join(''),"\">");
            po.push("<span class=\"itemTable\">");
            if(item.label) {
                po.push("<span class=\"th\" style=\"min-width:", (item.labelWidth || 100), "px;\">");
                po.push(item.label);
                po.push("</span>");
            }else{
                //po.push("<span class=\"th none\">&nbsp;</span>");
            }
            po.push("<span class=\"td\" style=\"",(item.valueBoxStyle||""),"\" title=\"", (item.title||""),"\">");

            var values = item.value.split(/,/g);
            axdom.each(item.options, function(idx, Opt){
                var isCheck = false;
                axdom.each(values, function(){
                    if(this == Opt.optionValue){
                        isCheck = true;
                        return false;
                    }
                });
                po.push("<input type=\"checkbox\" class=\"searchCheckboxItem ", itemAddClass.join(" "),"\" name=\"", item.key,"\" id=\"", cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key,"_AX_", idx, "\" title=\"", (Opt.title||""),"\" value=\"", Opt.optionValue,"\" ");
                if(isCheck) po.push(" checked=\"checked\" ");
                po.push(">");
                po.push("<label for=\"", cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key,"_AX_", idx, "\">", Opt.optionText," </label>");
            });

            po.push("</span>");
            po.push("</span>");
            po.push("</div>");

        }
        else
        if(item.type == "radioBox"){

            po.push("<div class=\"searchItem searchCheckbox ", itemAddClass.join(" "),"\" style=\"width:", (item.width||""),"px;text-align:", (item.align||"center"),";", itemAddStyles.join(''),"\">");
            po.push("<label class=\"itemTable\">");
            if(item.label) {
                po.push("<span class=\"th\" style=\"min-width:", (item.labelWidth || 100), "px;\">");
                po.push(item.label);
                po.push("</span>");
            }else{
                //po.push("<span class=\"th none\">&nbsp;</span>");
            }
            po.push("<span class=\"td\" style=\"",(item.valueBoxStyle||""),"\" title=\"", (item.title||""),"\">");

            var values = item.value.split(/,/g);
            axdom.each(item.options, function(idx, Opt){
                var isCheck = false;
                axdom.each(values, function(){
                    if(this == Opt.optionValue){
                        isCheck = true;
                        return false;
                    }
                });
                po.push("<input type=\"radio\" class=\"searchCheckboxItem ", itemAddClass.join(" "),"\" name=\"", item.key,"\" id=\"", cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key,"_AX_", idx,"\" title=\"", (item.title||""),"\" value=\"", Opt.optionValue,"\" ");
                if(isCheck) po.push(" checked=\"checked\" ");
                po.push(">");
                po.push("<label for=\"", cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key,"_AX_", idx,"\">", Opt.optionText," </label>");
            });

            po.push("</span>");
            po.push("</label>");
            po.push("</div>");

        }else if(item.type == "selectBox"){

            po.push("<div class=\"searchItem searchSelectbox ", itemAddClass.join(" "),"\" style=\"text-align:", (item.align||"center"),";", itemAddStyles.join(''),"\">");
            po.push("<label class=\"itemTable\">");
            if(item.label) {
                po.push("<span class=\"th\" style=\"min-width:", (item.labelWidth || 100), "px;\">");
                po.push(item.label);
                po.push("</span>");
            }else{
                //po.push("<span class=\"th none\">&nbsp;</span>");
            }
            po.push("<span class=\"td selectBox\" style=\"",(item.valueBoxStyle||""),"\" title=\"", (item.title||""),"\">");
            var selectWidth = (item.width) ? item.width+"px" : "auto";
            po.push("	<select name=\"", item.key,"\" id=\"", cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key, "\" title=\"", (item.title||""),"\" class=\"AXSelect searchSelectboxItem ", itemAddClass.join(" "),"\" style=\"width:", selectWidth,";\" "+poAttr.join(' ')+" >");

            var values = item.value.split(/,/g);
            axdom.each(item.options, function(idx, Opt){
                var isCheck = false;
                axdom.each(values, function(){
                    if(this == Opt.optionValue){
                        isCheck = true;
                        return false;
                    }
                });

                po.push("<option value=\"", Opt.optionValue,"\"");
                if(isCheck) po.push(" selected=\"selected\"");
                po.push(">", Opt.optionText, "</option>");
            });
            po.push("	</select>");
            po.push("</span>");
            po.push("</label>");
            po.push("</div>");

        }else if(item.type == "inputText"){

            po.push("<div class=\"searchItem ", itemAddClass.join(" "),"\" style=\"text-align:", (item.align||"center"),";", itemAddStyles.join(''),"\">");
            po.push("<label class=\"itemTable\">");
            if(item.label) {
                po.push("<span class=\"th\" style=\"min-width:", (item.labelWidth || 100), "px;\">");
                po.push(item.label);
                po.push("</span>");
            }else{
                //po.push("<span class=\"th none\">&nbsp;</span>");
            }
            po.push("<span class=\"td inputText\" style=\"",(item.valueBoxStyle||""),"\" title=\"", (item.title||""),"\">");
            var inputWidth = (item.width||100).number();
            po.push("				<input type=\"text\" name=\"", item.key,"\" id=\"", cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key, "\" title=\"", (item.title||""),"\" placeholder=\""+ (item.placeholder||"") +"\" value=\"", item.value,"\" class=\"AXInput searchInputTextItem ", itemAddClass.join(" "),"\" style=\"width:", inputWidth,"px;\" "+poAttr.join(' ')+" />");
            po.push("</span>");
            po.push("</label>");
            po.push("</div>");

        }else if(item.type == "hidden"){
            po.push("<input type=\"hidden\" name=\"", item.key,"\" id=\"", cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key, "\" value=\"", item.value,"\" />");
        }else if(item.type == "button" || item.type == "submit"){
            po.push("<div class=\"searchItem ", itemAddClass.join(" "),"\" style=\"text-align:", (item.align||"center"),";", itemAddStyles.join(''),"\">");
            po.push("<label class=\"itemTable\">");
            if(item.label) {
                po.push("<span class=\"th\" style=\"min-width:", (item.labelWidth || 100), "px;\">");
                po.push(item.label);
                po.push("</span>");
            }else{
                //po.push("<span class=\"th none\">&nbsp;</span>");
            }
            po.push("<span class=\"td button\" style=\"",(item.valueBoxStyle||""),"\" title=\"", (item.title||""),"\">");
            var inputWidth = (item.width||100).number();
            po.push("<button type=\""+ item.type +"\" id=\"", cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key, "\" title=\"", (item.title||""),"\" placeholder=\"", (item.placeholder||""),"\" style=\"width:", inputWidth,"px;\" class=\"AXButton searchButtonItem ", itemAddClass.join(" "),"\">", item.value,"</button>");
            po.push("</span>");
            po.push("</label>");
            po.push("</div>");
        }
        return po.join('');
    },
    setBody: function(){
        var cfg = this.config;
        var getItemHtml = this.getItemHtml.bind(this);
        var po = [];
        var AXBinds = [];

        po.push("<div class=\"" + cfg.theme + " " + cfg.viewMode + "\">");
        po.push("<form name=\"", cfg.targetID+"_AX_form", "\" onsubmit=\"return false;\">");
        var gr = 0;
        var hasHide = false;
        for(;gr<cfg.rows.length;){
            var styles = [];
            var classs = [];
            if(!cfg.rows[gr].display){
                styles.push("display:none;");
                classs.push("expandGroup");
                hasHide = true;
            }
            if(cfg.rows[gr].addClass) classs.push(cfg.rows[gr].addClass);
            po.push("<div class=\"searchGroup ", classs.join(" "),"\" style=\"", styles.join(";"),"\">");
            axdom.each(cfg.rows[gr].list, function(itemIndex, item){
                po.push(getItemHtml(gr, itemIndex, item));
                if(item.AXBind){
                    AXBinds.push({display:cfg.rows[gr].display, gr:gr, itemIndex:itemIndex, item:item});
                }
                po.push("<div class=\"itemClear\"></div>");
            });
            po.push("<div class=\"groupClear\"></div>");
            po.push("</div>");
            gr++;
        }
        if(hasHide){
            po.push("<a href=\"#axexec\" class=\"expandHandle\" id=\"",cfg.targetID,"_AX_expandHandle\">");
            po.push("상세검색");
            po.push("</a>");
        }
        po.push("</form>");
        po.push("</div>");

        this.target.html(po.join(''));

        if(cfg.onsubmit){
            document[cfg.targetID+"_AX_form"].onsubmit = function(){
                cfg.onsubmit();
                return false;
            };
        }

        axdom("#"+cfg.targetID+"_AX_expandHandle").bind("click", this.expandToggle.bind(this));
        this.target.find(".searchLinkItem").bind("click", this.onclickLinkItem.bind(this));
        this.target.find(".searchCheckboxItem").bind("click", this.onclickCheckboxItem.bind(this));
        this.target.find(".searchSelectboxItem").bind("change", this.onChangeSelect.bind(this));
        this.target.find(".searchInputTextItem").bind("change", this.onChangeInput.bind(this));
        this.target.find(".searchButtonItem").bind("click", this.onclickButton.bind(this));

        this.target.find(".searchInputTextItem").bind("focus", this.onFocusInput.bind(this));
	    this.target.find(".searchInputTextItem").bind("keydown", this.onKeyDownInput.bind(this));
	    this.target.find(".searchInputTextItem").bind("keyup", this.onKeyUpInput.bind(this));

        this.AXBinds = AXBinds;

        var _this = this;
        setTimeout(function(){
            _this.AXBindItems();
        }, 10);
    },
    AXBindItems: function(){
        var cfg = this.config;
        axdom.each(this.AXBinds, function(){
            var gr = this.gr, itemIndex = this.itemIndex, item = this.item;
            var display = this.display;
            var itemID = cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key;

            if(display){
                if(item.AXBind.type == "selector"){
                    axdom("#"+itemID).bindSelector(item.AXBind.config);
                }else if(item.AXBind.type == "select"){
                    try{
                        axdom("#"+itemID).bindSelect(item.AXBind.config);
                    }catch(e){
                    }
                }else if(item.AXBind.type == "date"){
                    axdom("#"+itemID).bindDate(item.AXBind.config);
                }else if(item.AXBind.type == "twinDate"){
                    var startTargetID = item.AXBind.config.startTargetID;
                    var findItemID = "";
                    axdom.each(cfg.rows, function(gidx, G){
                        axdom.each(this.list, function(itemIndex, item){
                            if(item.key == startTargetID){
                                findItemID = cfg.targetID + "_AX_" + gidx + "_AX_" + itemIndex + "_AX_" + item.key;
                            }
                        });
                    });
                    item.AXBind.config.startTargetID = findItemID;
                    axdom("#"+itemID).bindTwinDate(item.AXBind.config);
                }
            }
        });
    },
    expandToggle: function(){
        var cfg = this.config;
        if(this.expanded){
            axdom("#"+cfg.targetID+"_AX_expandHandle").html("상세검색");
            this.target.find(".expandGroup").hide();
            this.expanded = false;
        }else{
            axdom("#"+cfg.targetID+"_AX_expandHandle").html("상세검색창 닫기");
            this.target.find(".expandGroup").show();
            this.expanded = true;

            axdom.each(this.AXBinds, function(){
                var gr = this.gr, itemIndex = this.itemIndex, item = this.item;
                var display = this.display;
                var itemID = cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key;
                if(!display){
                    if(item.AXBind.type == "selector"){
                        axdom("#"+itemID).bindSelector(item.AXBind.config);
                    }else if(item.AXBind.type == "select"){
                        axdom("#"+itemID).bindSelect(item.AXBind.config);
                    }else if(item.AXBind.type == "date"){
                        axdom("#"+itemID).bindDate(item.AXBind.config);
                    }else if(item.AXBind.type == "twinDate"){

                        var startTargetID = item.AXBind.config.startTargetID.split(/_AX_/g).last();
                        var findItemID = "";
                        axdom.each(cfg.rows, function(gidx, G){
                            axdom.each(this.list, function(itemIndex, item){
                                if(item.key == startTargetID){
                                    findItemID = cfg.targetID + "_AX_" + gidx + "_AX_" + itemIndex + "_AX_" + item.key;
                                }
                            });
                        });

                        item.AXBind.config.startTargetID = findItemID;
                        axdom("#"+itemID).bindTwinDate(item.AXBind.config);

                    }
                }
            });

        }
    },
    onclickLinkItem: function(event){
        var cfg = this.config;
        var ids = (event.target.id).split(/_AX_/g);
        var index = ids.pop();
        var gr = ids[ids.length-3];
        var itemIndex = ids[ids.length-2];
        var item = cfg.rows[gr].list[itemIndex];
        //trace({itemIndex:itemIndex, item:item});

        var targetID = "";
        axdom.each(ids, function(ii, io){
            if(ii > 0) targetID += "_AX_";
            targetID += this;
        });
        //trace(item.options[index].optionValue);

        if(item.selectedIndex != undefined){
            axdom("#"+targetID+"_AX_"+item.selectedIndex).removeClass("on");
        }

        item.selectedIndex = index;
        item.value = item.options[index].optionValue;
        axdom("#"+targetID+"_AX_"+index).addClass("on");
        axdom("#"+targetID).val(item.options[index].optionValue);

        if(item.onChange){
            item.onChange.call(item, item.options[index], item.options[index].optionValue);
        }
    },
    onclickCheckboxItem: function(event){
        var cfg = this.config;
        var ids = (event.target.id).split(/_AX_/g);
        var index = ids.pop();
        var gr = ids[ids.length-3];
        var itemIndex = ids[ids.length-2];
        var item = cfg.rows[gr].list[itemIndex];

        var frm = document[cfg.targetID+"_AX_form"];
        var selectedIndex = 0;
        var selectedValue = "";

        if(isNaN(frm[item.key].length)){
            if(frm[item.key].checked){
                selectedValue = frm[item.key].value;
            }
        }else{
            for(var i=0;i<frm[item.key].length;i++){
                if(frm[item.key][i].checked){
                    selectedValue += (selectedValue == "") ? frm[item.key][i].value : "," + frm[item.key][i].value;
                }
            }
        }

        item.selectedIndex = index;
        item.value = selectedValue;

        if(item.onChange){
            item.onChange.call(item, item.options[index], selectedValue);
        }
    },
    onChangeSelect: function(event){
        var cfg = this.config;
        var ids = (event.target.id).split(/_AX_/g);
        var gr = ids[ids.length-3];
        var itemIndex = ids[ids.length-2];
        var item = cfg.rows[gr].list[itemIndex];

        var frm = document[cfg.targetID+"_AX_form"];
        var selectedIndex = frm[item.key].selectedIndex;
        var selectedValue = frm[item.key].options[selectedIndex].value;

        if(item.onChange){
            item.onChange.call(item, item.options[selectedIndex], selectedValue);
        }
    },
    onChangeInput: function(event){
        var cfg = this.config;
        var ids = (event.target.id).split(/_AX_/g);
        var gr = ids[ids.length-3];
        var itemIndex = ids[ids.length-2];
        var item = cfg.rows[gr].list[itemIndex];

        var frm = document[cfg.targetID+"_AX_form"];
        var changeValue = frm[item.key].value;

        if(item.onChange){
            item.onChange.call(item, changeValue);
        }
    },
    onFocusInput: function(event){
        var cfg = this.config;
        var ids = (event.target.id).split(/_AX_/g);
        var gr = ids[ids.length-3];
        var itemIndex = ids[ids.length-2];
        var item = cfg.rows[gr].list[itemIndex];

        var frm = document[cfg.targetID+"_AX_form"];
        var focusValue = frm[item.key].value;

        if(item.onFocus){
            item.onFocus.call(item, focusValue, frm[item.key]);
        }
    },
    onclickButton: function(event){
        var cfg = this.config;
        var target = axf.get_event_target(event.target, function(el){
            if((el.tagName||"").ucase() == "BUTTON"){
                return true;
            }
        });
        if(target){
            var ids = (target.id).split(/_AX_/g);
            var gr = ids[ids.length-3];
            var itemIndex = ids[ids.length-2];
            var item = cfg.rows[gr].list[itemIndex];

            if(item.onclick){
                item.onclick.call(item);
            }
        }
    },
	onKeyDownInput: function(event){
		var cfg = this.config;
		var ids = (event.target.id).split(/_AX_/g);
		var gr = ids[ids.length-3];
		var itemIndex = ids[ids.length-2];
		var item = cfg.rows[gr].list[itemIndex];

		var frm = document[cfg.targetID+"_AX_form"];
		var changeValue = frm[item.key].value;

		if(item.onkeydown){
			item.onkeydown.call(item, event, changeValue);
		}
	},
	onKeyUpInput: function(event){
		var cfg = this.config;
		var ids = (event.target.id).split(/_AX_/g);
		var gr = ids[ids.length-3];
		var itemIndex = ids[ids.length-2];
		var item = cfg.rows[gr].list[itemIndex];

		var frm = document[cfg.targetID+"_AX_form"];
		var changeValue = frm[item.key].value;

		if(item.onkeyup){
			item.onkeyup.call(item, event, changeValue);
		}
	},
    /**
     * @method AXSearch.getParam
     * @returns {string}
     * @description 파라미터 형태로 값을 반환합니다.
     * @example
     * ```js
     * var pars = mySearch.getParam();
     * trace(pars);
     * // a=11&b=22&c=33
     * ```
     */
    getParam: function(){
        var cfg = this.config;
        var frm = (this.formbindMethod == "script") ? document[cfg.targetID+"_AX_form"] : this.target;
        return axdom(frm).serialize();
    },
    /**
     * @method AXSearch.reset
     * @returns {AXSearch}
     * @description search폼 입력 정보를 리셋합니다.
     * @example
     * ```js
     * mySearch.reset();
     * ```
     */
    reset: function(){
        var cfg = this.config;
        var frm = (this.formbindMethod == "script") ? document[cfg.targetID+"_AX_form"] : this.target;
        axdom(frm).get(0).reset();

        axdom(frm).find("[data-axbind=select]").bindSelectUpdate();
        //.trigger("change");

        return this;
    },

    /**
     * @method AXSearch.getItemId
     * @param {String} key - item key name
     * @description AXSearch내 엘리먼트 id를 반환합니다.
     * @example
     * ```js
     * mySearch.getItemId("type");
     * // element id;
     * ```
     */
    getItemId: function(key, value){
        var cfg = this.config;
        var gr = 0;
        var itemID;
        for(;gr<cfg.rows.length;){
            axdom.each(cfg.rows[gr].list, function(itemIndex, item){
                if(item.key == key){
                    if(item.type == "checkBox" || item.type == "radioBox"){
                        itemID = [];
                        axdom.each(item.options, function(idx, Opt){
                            itemID.push(cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key + "_AX_" + idx);
                        });
                    }else{
                        itemID = cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key;
                        return false;
                    }
                }
            });
            gr++;
        }
        return itemID;
    },
    /**
     * @method AXSearch.setItemValue
     * @param {String} key - item key name
     * @param {String|Array} value - item key name
     * @description 단일 속성인 대상에는 String, 다중 속성인 대상에는 Array 로 값을 지정할 수 있습니다. value 가 지정되지 않은 경우 빈 값으로 처리합니다.
     * @example
     * ```js
     * mySearch.setItemValue("checkbox", ["all","open"]);
     * mySearch.setItemValue("radiobox");
     * mySearch.setItemValue("inputText2"); // 빈값을 입력함으로써 입력된 값을 지울 수 있습니다.
     * ```
     */
    setItemValue: function(key, value){
        var cfg = this.config;
        var gr = 0;
        for(;gr<cfg.rows.length;){
            axdom.each(cfg.rows[gr].list, function(itemIndex, item){
                if(item.key == key){
                    if(item.type == "checkBox" || item.type == "radioBox"){
                        var values = [];
                        if(Object.isArray(value)){
                            values = value;
                        }else if(value == ""){

                        }else{
                            values.push(value);
                        }
                        axdom.each(item.options, function(idx, Opt){
                            var itemID = cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key + "_AX_" + idx;
                            var isCheck = false;
                            axdom.each(values, function(){ if(this == Opt.optionValue){ isCheck = true; return false; } });
                            AXgetId(itemID).checked = isCheck;
                            itemID = null;
                        });
                    }
                    else
                    if(item.type == "selectBox"){
                        var itemID = cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key;
                        var item_dom = axdom("#"+itemID);
                        if(item_dom.attr("data-axbind")){
                            item_dom.bindSelectSetValue((value||""));
                        }else{
                            item_dom.val((value||""));
                        }
                    }
                    else
                    {
                        var itemID = cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key;
                        axdom("#"+itemID).val((value||""));
                        itemID = null;
                    }
                }
            });
            gr++;
        }
    },

	/**
	 * @method AXSearch.submit
	 */
	submit: function(){
		var cfg = this.config;
		if(cfg.onsubmit) cfg.onsubmit();
		return this;
	}
});
/* ---------------------------- */
var AXSelectConverter = Class.create(AXJ, {
	initialize: function (AXJ_super) {
		AXJ_super();
		this.objects = [];
		this.config.anchorClassName = "AXanchor";
		this.config.anchorSelectClassName = "AXanchorSelect";
	},
	init: function () {
		var browser = AXUtil.browser;
		this.isMobile = browser.mobile;
		//axdom(window).resize(this.windowResize.bind(this));
		axdom(window).resize(this.alignAllAnchor.bind(this));
		
		this.config.reserveKeys = {
			options: (AXConfig.AXSelect && AXConfig.AXSelect.keyOptions) || "options",
			optionValue: (AXConfig.AXSelect && AXConfig.AXSelect.keyOptionValue) || "optionValue",
			optionText: (AXConfig.AXSelect && AXConfig.AXSelect.keyOptionText) || "optionText",
			optionData: (AXConfig.AXSelect && AXConfig.AXSelect.keyOptionData) || "optionData"
		};
	},
	windowResize: function () {
		// 사용안함
		var windowResizeApply = this.windowResizeApply.bind(this);
		if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
		this.windowResizeObserver = setTimeout(function () {
			windowResizeApply();
		}, 10);
	},
	windowResizeApply: function(){
		// 사용안함
		if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
		this.alignAllAnchor();
	},
	alignAllAnchor: function () {
		for(var i=0;i<this.objects.length;i++){
			this.alignAnchor(this.objects[i].id, i);
		}
	},
	bindSetConfig: function (objID, configs) {
		var findIndex = null;
		for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
			if (O.id == objID && O.isDel != true) {
				findIndex = index;
				break;
			}
		}
		if (findIndex == null) {
			//trace("바인드 된 오브젝트를 찾을 수 없습니다.");
		} else {
			var _self = this.objects[findIndex];
            axdom.each(configs, function (k, v) {
				_self.config[k] = v;
			});
		}
	},
	unbind: function (obj) {
		//var collect = [];
		var removeAnchorId;
		var removeIdx;
		//trace(this.objects);
		for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
			if (O.id != obj.id) {
				// collect.push(this);

			} else {
				if (O.isDel != true) {
					removeAnchorId = O.anchorID;
					removeIdx = index;
				}
			}
		}
		//this.objects = collect;

		if (removeAnchorId) {
			var objDom = axdom("#" + obj.id), objAnchorDom = axdom("#" + removeAnchorId);
			this.objects[removeIdx].isDel = true;
			objDom.removeAttr("data-axbind");
			objDom.css({visibility:"visible"});

			if (this.isMobile) {
				objAnchorDom.before(axdom("#" + obj.id));
				objAnchorDom.remove();
			} else {
				objAnchorDom.remove();
				objDom.show();
			}
		}
	},
	bind: function (obj) {
		var cfg = this.config;
		if (!AXgetId(obj.id)) {
			obj.id = "AXSelect-" + axf.getUniqueId();
		}

		var objID = obj.id, objSeq = null, objConfig = {}, reserveKeys = jQuery.extend({}, cfg.reserveKeys);
		objConfig = jQuery.extend(objConfig, obj, true);
		if(typeof objConfig.reserveKeys == "undefined") objConfig.reserveKeys = {};
		objConfig.reserveKeys = jQuery.extend(reserveKeys, objConfig.reserveKeys, true);
		
		for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
			if (O.id == objID && O.isDel != true) {
				objSeq = index;
				break;
			}
		}

		if (typeof objConfig.href == "undefined") objConfig.href = cfg.href;

		if (objSeq == null) {
			objSeq = this.objects.length;
			this.objects.push({ id: objID, anchorID: cfg.targetID + "_AX_" + objID, config: objConfig });
		} else {
			this.objects[objSeq].isDel = undefined;
			this.objects[objSeq].config = objConfig;
		}

		this.appendAnchor(objID, objSeq);
		this.bindSelect(objID, objSeq);
		this.windowResize();
	},
	appendAnchor: function (objID, objSeq) {
		var cfg = this.config, _this = this;
		var obj = this.objects[objSeq];

		if (AXgetId(cfg.targetID + "_AX_" + objID)) {
            axdom("#" + cfg.targetID + "_AX_" + objID).remove();
		}
		var anchorNode = axdom("<div id=\"" + cfg.targetID + "_AX_" + objID + "\" class=\"" + cfg.anchorClassName + "\" style=\"display:none;\"></div>");
		var iobj = axdom("#" + objID);
		iobj.attr("data-axbind", "select");
		if(this.isMobile) iobj.before(anchorNode);
		else iobj.after(anchorNode);

		var iobjPosition = iobj.position();
		var l = iobjPosition.left, t = iobjPosition.top, w = 0, h = 0;

		w = iobj.outerWidth();
		h = iobj.outerHeight();

		var css = { left: l, top: t, width: w, height: h }, objDom = axdom("#" + cfg.targetID + "_AX_" + objID);
		objDom.css(css);
		objDom.data("height", h);

		obj.iobj = iobj;
		obj.objDom = objDom;
		// TODO : obj에 iobj, objDom 연결
	},
	alignAnchor: function (objID, objSeq){
		var cfg = this.config, _this = this;
		var obj = this.objects[objSeq];

		var iobj = obj.iobj;
		var iobjPosition = iobj.position();
		var l = iobjPosition.left, t = iobjPosition.top, w = 0, h = 0;

		var borderW = iobj.css("border-left-width").number();
		var borderT = iobj.css("border-top-width").number();
		var borderB = iobj.css("border-bottom-width").number();
		var marginW = iobj.css("margin-left").number();
		var marginH = iobj.css("margin-top").number();
		l = l + marginW;

		//t = t;
		w = iobj.outerWidth();
		h = iobj.outerHeight();

		var css = { left: l, top: t, width: w, height: h };
		obj.objDom.css(css);
		obj.objDom.data("height", h);

		obj.objDom.find("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectBox").css({width:w, height:h});
		obj.objDom.find("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectTextBox").css({height:(h-(borderT+borderB))+"px"});

		obj.objDom.find("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectText").css({"line-height":(h-(borderT+borderB))+"px"});
		obj.objDom.find("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectBoxArrow").css({height:h});
	},
	bindSelect: function (objID, objSeq) {
		var cfg = this.config, _this = this;
		var obj = this.objects[objSeq], options, sendObj;

		var iobj = obj.iobj;
		var objDom = obj.objDom;
		
		if(!obj.config.onChange) obj.config.onChange = obj.config.onchange;
		if(!obj.config.onLoad) obj.config.onLoad = obj.config.onload;

		var w = objDom.width();
		var h = objDom.data("height");
		var borderT = iobj.css("border-top-width").number();
		var borderB = iobj.css("border-bottom-width").number();
		//trace(obj.config);

		var fontSize = iobj.css("font-size").number();
		var tabIndex = iobj.attr("tabindex");

		var po = [];
		po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SelectBox\" class=\"" + cfg.anchorSelectClassName + "\" style=\"width:" + w + "px;height:" + h + "px;\">");
		po.push("<a " + obj.config.href + " class=\"selectedTextBox\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SelectTextBox\" style=\"height:" + (h - (borderT+borderB)) + "px;\"");
		if(tabIndex != undefined) po.push(" tabindex=\""+tabIndex+"\"");
		po.push(">");
		po.push("	<div class=\"selectedText\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SelectText\" style=\"line-height:" + (h - (borderT+borderB)) + "px;padding:0px 4px;font-size:" + fontSize + "px;\"></div>");
		po.push("	<div class=\"selectBoxArrow\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SelectBoxArrow\" style=\"height:" + h + "px;\"></div>");
		po.push("</a>");
		po.push("</div>");

		//append to anchor
		objDom.empty();
		objDom.append(po.join(''));
		objDom.show();

		var objDom_selectTextBox = objDom.find("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectTextBox");

		obj.selectedIndex = AXgetId(objID).options.selectedIndex;
		var options = [];
		for (var oi = 0; oi < AXgetId(objID).options.length; oi++) {
			options.push({ optionValue: AXgetId(objID).options[oi].value, optionText: AXgetId(objID).options[oi].text.enc() });
		}
		obj.options = AXUtil.copyObject(options);

		if (this.isMobile) {

			// mobile 브라우저인 경우
			iobj.css({opacity:0});
			var bindSelectChange = this.bindSelectChange.bind(this);
			obj.objOnChange = function () {
				bindSelectChange(objID, objSeq);

				if (obj.config.onChange) {
					obj.selectedIndex = AXgetId(objID).options.selectedIndex;
					AXgetId(objID).options[obj.selectedIndex].selected = true;
					obj.config.selectedObject = obj.options[obj.selectedIndex];

					options = AXgetId(objID).options[obj.selectedIndex];
					sendObj = {
						optionIndex:obj.selectedIndex, optionValue:options.value, optionText:options.text,
						value:options.value, text:options.text
					};
					obj.config.onChange.call(sendObj, sendObj);
				}

			};
			objDom_selectTextBox.unbind("click.AXSelect").bind("click.AXSelect", function (event) {
				axdom("#" + objID).click();
			});

			iobj.addClass("rootSelectBox");
			iobj.bind("change.AXSelect", obj.objOnChange);

		} else {
			//AXUtil.alert(obj.options);

			// PC 브라우저인 경우
			iobj.css({visibility:"hidden"});
			var bindSelectExpand = this.bindSelectExpand.bind(this);
			var bindSelectClose = this.bindSelectClose.bind(this);
			var bindSelectFocus = this.bindSelectFocus.bind(this);
			var bindSelectBlur = this.bindSelectBlur.bind(this);

			objDom_selectTextBox.bind("click.AXSelect", function (event) {
				axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectTextBox").focus();
				bindSelectExpand(objID, objSeq, true, event);
			});

			objDom_selectTextBox.bind("keydown.AXSelect", function (event) {
				if(event.keyCode == AXUtil.Event.KEY_SPACE) bindSelectExpand(objID, objSeq, true, event);
				if(event.keyCode == AXUtil.Event.KEY_TAB || event.keyCode == AXUtil.Event.KEY_RETURN) return;
				//trace(String.fromCharCode(event.keyCode));

				if(_this.selectTextBox_onkeydown_obj){
					clearTimeout(_this.selectTextBox_onkeydown_obj);
					_this.selectTextBox_onkeydown_data += String.fromCharCode(event.keyCode);
				}else{
					_this.selectTextBox_onkeydown_data = String.fromCharCode(event.keyCode);
				}

				_this.selectTextBox_onkeydown_obj = setTimeout(function(){
					_this.selectTextBox_onkeydown(objID, objSeq, event);
				}, 300);
			});

            objDom_selectTextBox.bind("focus.AXSelect", function (event) {
                bindSelectFocus(objID);
            });

            objDom_selectTextBox.bind("blur.AXSelect", function (event) {
                bindSelectBlur(objID);
            });
		}

		if (obj.config.ajaxUrl) {

			var bindSelectChangeBind = this.bindSelectChange.bind(this);
			var bindSelectChange = function () {
				bindSelectChangeBind(objID, objSeq, "load");
			};

			var url = obj.config.ajaxUrl;
			var pars = obj.config.ajaxPars;
			var _method = "post";
			var _headers = {};
			var _contentType = AXConfig.AXReq.contentType;
			var _responseType = AXConfig.AXReq.responseType;
			var _dataType = AXConfig.AXReq.dataType;
			var _async = AXConfig.AXReq.async; 
				
			// ajax 옵션 확장
			if (obj.config.method) _method = obj.config.method;
			if (obj.config.headers) _headers = obj.config.headers;
			if (obj.config.contentType) _contentType = obj.config.contentType;
			if (obj.config.responseType) _responseType = obj.config.responseType;
			if (obj.config.dataType) _dataType = obj.config.dataType;
			if (obj.config.ajaxAsync) _async = obj.config.ajaxAsync;
			
			obj.selectedIndex = null;

			iobj.html("<option></option>");

			obj.inProgress = true; //진행중 상태 변경

			
			new AXReq(url, {
				type: _method,
				headers: _headers,
				contentType: _contentType,
				responseType: _responseType,
				dataType: _dataType,
				async: _async,
				debug: ((typeof obj.config.debug !== "undefined") ? obj.config.debug : false),
				pars: pars, 
				onsucc: function (res) {
					if ((res.result && res.result == AXConfig.AXReq.okCode) || (res.result == undefined && !res.error)) {

						var po = [], adj = 0;
						//obj.config.options = res.options;
						obj.config.options = res[obj.config.reserveKeys.options];
						
						if (obj.config.isspace) {
							po.push("<option value='"+(obj.config.isspaceValue||"")+"'");
							if (obj.selectedIndex == 0) po.push(" selected=\"selected\"");
							po.push(">" + (obj.config.isspaceTitle||"&nbsp;") + "</option>");
							adj =-1;
						}
						for (var opts, oidx = 0; (oidx < res[obj.config.reserveKeys.options].length && (opts = res[obj.config.reserveKeys.options][oidx])); oidx++) {
							//trace(opts);
							po.push("<option value=\"" + opts[obj.config.reserveKeys.optionValue] + "\" data-option=\"" + opts[obj.config.reserveKeys.optionData] + "\" ");
							if (obj.config.setValue == opts[obj.config.reserveKeys.optionValue] || opts.selected || (obj.selectedIndex||0).number()+adj == oidx) po.push(" selected=\"selected\"");
							po.push(">" + opts[obj.config.reserveKeys.optionText].dec() + "</option>");
						}
						axdom("#" + objID).html(po.join(''));

						var options = [];
						for (var oi = 0; oi < AXgetId(objID).options.length; oi++) {
							options.push({ optionValue: AXgetId(objID).options[oi].value, optionText: AXgetId(objID).options[oi].text.enc(), optionData:AXgetId(objID).options[oi].getAttribute("data-option") });
						}
						obj.options = AXUtil.copyObject(options);
						obj.selectedIndex = AXgetId(objID).options.selectedIndex;

						if (obj.config.onChange && obj.config.alwaysOnChange) {
							obj.config.focusedIndex = obj.selectedIndex;
							obj.config.selectedObject = obj.options[obj.selectedIndex];
							sendObj = {
								optionIndex: obj.selectedIndex,
								optionValue: obj.options[obj.selectedIndex].optionValue,
								optionText : obj.options[obj.selectedIndex].optionText,
								optionData : obj.options[obj.selectedIndex].optionData,
								value      : obj.options[obj.selectedIndex].optionValue,
								text       : obj.options[obj.selectedIndex].optionText,
								data       : obj.options[obj.selectedIndex].optionData
							};
							obj.config.onChange.call(sendObj, sendObj, "isPostBack");
						}
						bindSelectChange();

						if (obj.config.onLoad) {
							sendObj = {
								selectedIndex: obj.selectedIndex,
								selectedObject: obj.options[obj.selectedIndex],
								options: obj.options,
								response: res
							};
							obj.config.onLoad.call(sendObj, sendObj);
						}
						_this.alignAnchor(objID, objSeq);
					} else {
						//trace(res);
					}
					obj.inProgress = false;
				}
			});
		}
		else
		if (obj.config.options) {

			iobj.html("<option></option>");

			var po = [], adj = 0;
			if (obj.config.isspace) {
				po.push("<option value='"+(obj.config.isspaceValue||"")+"'");
				if (obj.selectedIndex == 0) po.push(" selected=\"selected\"");
				po.push(">" + (obj.config.isspaceTitle||"&nbsp;") + "</option>");
				adj = -1;
			}

			for (var opts, oidx = 0; (oidx < obj.config.options.length && (opts = obj.config.options[oidx])); oidx++) {
				//[obj.config.reserveKeys.optionValue]
				//[obj.config.reserveKeys.optionText]
				var optionText = (opts[obj.config.reserveKeys.optionText]||"").dec();
				po.push("<option value=\"" + opts[obj.config.reserveKeys.optionValue] + "\"");
				if (obj.config.setValue == opts[obj.config.reserveKeys.optionValue] || opts.selected || obj.selectedIndex.number()+adj == oidx) po.push(" selected=\"selected\"");
				po.push(">" + optionText + "</option>");
			}
			iobj.html(po.join(''));

			var options = [];
			for (var oi = 0; oi < AXgetId(objID).options.length; oi++) {
				options.push({ optionValue: AXgetId(objID).options[oi].value, optionText: AXgetId(objID).options[oi].text.enc() });
			}
			obj.options = AXUtil.copyObject(options);
			obj.selectedIndex = AXgetId(objID).options.selectedIndex;

			this.bindSelectChange(objID, objSeq, "load");

			if (obj.config.onChange && obj.config.alwaysOnChange) {
				obj.config.focusedIndex = obj.selectedIndex;
				obj.config.selectedObject = obj.options[obj.selectedIndex];

				options = AXgetId(objID).options[obj.selectedIndex];
				if(!options) {
					options = {value: "", text: ""};
				}
				sendObj = {
					optionIndex:obj.selectedIndex, optionValue:options.value, optionText:options.text,
					value:options.value, text:options.text
				};
				obj.config.onChange.call(sendObj, sendObj, "isPostBack");
			}

			if (obj.config.onLoad) {
				var selectedOption = this.getSelectedOption(objID, objSeq);
				obj.config.onLoad.call({selectedIndex:obj.selectedIndex, selectedObject:{optionValue:selectedOption.value, optionText:selectedOption.text}});
			}
			this.alignAnchor(objID, objSeq);
		}
		else
		{
			this.bindSelectChange(objID, objSeq, "load");
			if (obj.config.onChange && obj.config.alwaysOnChange) {
				var selectedOption = this.getSelectedOption(objID, objSeq);
				if (selectedOption) {
					sendObj = {
						optionIndex:selectedOption.index, 
						optionValue:selectedOption.value, 
						optionText:selectedOption.text,
						value:selectedOption.value, 
						text:selectedOption.text
					};
					obj.config.onChange.call(sendObj, sendObj, "isPostBack");
				}
			}
			if (obj.config.onLoad) {
				var selectedOption = this.getSelectedOption(objID, objSeq);
				obj.config.onLoad.call({selectedIndex:obj.selectedIndex, selectedObject:{optionValue:selectedOption.value, optionText:selectedOption.text}});
			}
			this.alignAnchor(objID, objSeq);
		}
	},
	selectTextBox_onkeydown: function(objID, objSeq, event){
		var cfg = this.config, _this = this;
		var obj = this.objects[objSeq];

		var bindSelectClose = this.bindSelectClose.bind(this);
		var chkVal = (_this.selectTextBox_onkeydown_data || ""), chkIndex = null;

		for (var O, index = 0; (index < obj.options.length && (O = obj.options[index])); index++) {
			if(O.optionValue.left(chkVal.length).lcase() == chkVal.lcase() || O.optionText.left(chkVal.length).lcase() == chkVal.lcase()){
				chkIndex = index;
				break;
			}
		};
		if(chkIndex != null){
			obj.selectedIndex = chkIndex;
			obj.config.focusedIndex = chkIndex;
			obj.config.selectedObject = obj.options[chkIndex];
			obj.config.isChangedSelect = true;
			bindSelectClose(objID, objSeq, event); // 값 전달 후 닫기
		}
		_this.selectTextBox_onkeydown_data = "";
	},
	getSelectedOption: function (objID, objSeq) {
		var cfg = this.config;
		var obj = this.objects[objSeq];

		if(AXgetId(objID) && AXgetId(objID).options.selectedIndex > -1){
			try{
				if(obj.selectedIndex != AXgetId(objID).options.selectedIndex) obj.selectedIndex = AXgetId(objID).options.selectedIndex;
			}catch(e){
			}
			var options = AXgetId(objID).options[AXgetId(objID).options.selectedIndex];
			return {
				value:options.value, text:options.text, data:options.getAttribute("data-option"), index:AXgetId(objID).options.selectedIndex
			}
		}else{
			obj.selectedIndex = 0;
			var options = AXgetId(objID).options[0];
			options = (options) ? {value:options.value,text:options.text, data:options.getAttribute("data-option")} : {value:"",text:"", data:""};
			return {
				value:options.value, text:options.text, data:options.data, index:0
			}
		}

	},
	bindSelectChange: function (objID, objSeq, isLoad) {
		var cfg = this.config;
		var obj = this.objects[objSeq];
		var selectedOption = this.getSelectedOption(objID, objSeq);
		if (selectedOption) {
			axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectText").html(selectedOption.text);
		}
		if(obj && !this.isMobile){
			if(!obj.iobj) obj.iobj = axdom("#" + objID);
			if(isLoad != "load") obj.iobj.trigger( "change" ); // change 이벤트 발생
		}
	},
	bindSelectExpand: function (objID, objSeq, isToggle, event) {
		var _this = this;
		var cfg = this.config;
		var obj = this.objects[objSeq];
		var jqueryTargetObjID = axdom("#"+ cfg.targetID + "_AX_" + objID);
		//Selector Option box Expand

		if(jqueryTargetObjID.data("disabled")) return;

		if (isToggle) { // 활성화 여부가 토글 이면
			if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
				if (obj.config.isChangedSelect) {
					this.bindSelectClose(objID, objSeq, event); // 닫기
				} else {
					axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리
					axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectBoxArrow").removeClass("on");
					//비활성 처리후 메소드 종료
					axdom(document).unbind("click.AXSelect");
					axdom(document).unbind("keydown.AXSelect");
				}
				return;
			}
		}
		axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 활성화 전에 개체 삭제 처리
		axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectBoxArrow").removeClass("on");

		//Expand Box 생성 구문 작성
		var anchorWidth = axdom("#" + cfg.targetID + "_AX_" + objID).width() - 2; // anchor width
		var anchorHeight = axdom("#" + cfg.targetID + "_AX_" + objID).data("height") - 1;
		var styles = [];
		//styles.push("top:"+anchorHeight+"px");
		styles.push("width:" + anchorWidth + "px");

		var po = [];
		po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandBox\" class=\"AXselectExpandBox\" style=\"" + styles.join(";") + "\">");
		po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandScroll\" class=\"AXselectExpandScroll\">");
		po.push("	<div class=\"AXLoadingSmall\"></div>");
		po.push("</div>");
		po.push("</div>");
		axdom(document.body).append(po.join(''));
		axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectBoxArrow").addClass("on");

		var expandBox = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox");
		if(obj.config.positionFixed){
			expandBox.css({"position":"fixed"});
		}
		var expBoxHeight = expandBox.outerHeight();
		var offset = (obj.config.positionFixed) ? jqueryTargetObjID.position() : jqueryTargetObjID.offset();

		if(obj.config.position){
			offset = jqueryTargetObjID.offset();
			if(obj.config.position.top != undefined){
				offset.top = obj.config.position.top;
			}
		}
		var css = {};
		css.top = offset.top + anchorHeight;
		//css.top = offset.top;
		css.left = offset.left;

		var bodyHeight;
		(AXUtil.docTD == "Q") ? bodyHeight = document.body.scrollHeight : bodyHeight = document.documentElement.scrollHeight;
		//trace({bodyHeight:bodyHeight, top:css.top});

		if(!obj.config.positionFixed){
			if (bodyHeight < css.top.number() + expBoxHeight) {
				css = {
					top: offset.top - expBoxHeight,
					left: offset.left
				}
			}
		}

		expandBox.css(css);

		// onexpand 함수가 존재 한다면
		if(obj.config.onexpand){
			obj.config.onexpand.call({
				obj: obj,
				objID: objID,
				objSeq: objSeq
			}, function(args){
				if(typeof args != "undefined") {
					obj.options = obj.config.options = axf.copyObject(args.options);

					var po = [], adj = 0;
					if (obj.config.isspace) {
						po.push("<option value='"+(obj.config.isspaceValue||"")+"'");
						if (obj.selectedIndex == 0) po.push(" selected=\"selected\"");
						po.push(">" + (obj.config.isspaceTitle||"&nbsp;") + "</option>");
						adj =-1;
					}
					for (var opts, oidx = 0; oidx < obj.options.length; oidx++) {
						var opts = obj.options[oidx];
						po.push("<option value=\"" + opts[obj.config.reserveKeys.optionValue] + "\" data-option=\"" + opts[obj.config.reserveKeys.optionData] + "\" ");
						if (obj.config.setValue == opts[obj.config.reserveKeys.optionValue] || opts.selected || (obj.selectedIndex||0).number()+adj == oidx) po.push(" selected=\"selected\"");
						po.push(">" + opts[obj.config.reserveKeys.optionText].dec() + "</option>");
					}
					axdom("#" + objID).html( po.join('') );

					_this.bindSelectSetOptions(objID, objSeq);
					_this.alignAnchor(objID, objSeq);
				}
			});
		}else{
			this.bindSelectSetOptions(objID, objSeq);
		}
	},
	bindSelectClose: function (objID, objSeq, event) {
		var obj = this.objects[objSeq], options, sendObj;
		//trace("bindSelectorClose");
		var cfg = this.config;
		if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
			axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리
			axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectBoxArrow").removeClass("on");

			//비활성 처리후 메소드 종료
			axdom(document).unbind("click", obj.documentclickEvent);
			axdom(document).unbind("keydown", obj.documentKeyup);

			if (obj.config.isChangedSelect) {
				AXgetId(objID).options[obj.selectedIndex].selected = true;
				if (obj.config.onChange) {
					options = AXgetId(objID).options[obj.selectedIndex];
					sendObj = {
						optionIndex:obj.selectedIndex, optionValue:options.value, optionText:options.text, optionData: options.getAttribute("data-option"),
						value: options.value, text: options.text, data: options.data
					};
					obj.config.onChange.call(sendObj, sendObj);
				}
				obj.config.isChangedSelect = false;
				this.bindSelectChange(objID, objSeq);
			}

			if(event) event.stopPropagation(); // disableevent
			return;
		}else{
			if (obj.config.isChangedSelect) {
				AXgetId(objID).options[obj.selectedIndex].selected = true;
				if (obj.config.onChange) {
					options = AXgetId(objID).options[obj.selectedIndex];
					sendObj = {
						optionIndex:obj.selectedIndex, optionValue:options.value, optionText:options.text, optionData: options.getAttribute("data-option"),
						value: options.value, text: options.text, data: options.data
					};
					obj.config.onChange.call(sendObj, sendObj);
				}
				obj.config.isChangedSelect = false;

				this.bindSelectChange(objID, objSeq);

			}
		}
	},
	bindSelectSetOptions: function (objID, objSeq) {
		var obj = this.objects[objSeq];
		var cfg = this.config;
		var jqueryTargetObjID = axdom("#" + cfg.targetID + "_AX_" + objID);
		var maxHeight = obj.config.maxHeight || 200;

		if (!obj.options) return;
		if (obj.options.length == 0) {
			axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").hide();
		}

		var po = [];
		for (var O, index = 0; (index < obj.options.length && (O = obj.options[index])); index++) {
			po.push("<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_" + index + "_AX_option\">" + O.optionText.dec() + "</a>");
		}
		axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandScroll").html(po.join(''));

		var expandScrollHeight = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandScroll").height();
		if (expandScrollHeight > maxHeight) expandScrollHeight = maxHeight;
		axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").css({ height: expandScrollHeight + "px" });

		var bindSelectOptionsClick = this.bindSelectOptionsClick.bind(this);
		obj.documentclickEvent = function (event) {
			bindSelectOptionsClick(objID, objSeq, event);
		};
		var bindSelectKeyup = this.bindSelectKeyup.bind(this);
		obj.documentKeyup = function (event) {
			bindSelectKeyup(objID, objSeq, event);
		};
		axdom(document).bind("click.AXSelect", obj.documentclickEvent);
		axdom(document).bind("keydown.AXSelect", obj.documentKeyup);

		if (obj.myUIScroll) obj.myUIScroll.unbind();
		obj.myUIScroll = new AXScroll();
		obj.myUIScroll.setConfig({
			CT_className: "AXScrollSmall",
			targetID: cfg.targetID + "_AX_" + objID + "_AX_expandBox",
			scrollID: cfg.targetID + "_AX_" + objID + "_AX_expandScroll",
			touchDirection: false
		});

		if (obj.selectedIndex != undefined) {
			axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + obj.selectedIndex + "_AX_option").addClass("on");
			obj.myUIScroll.focusElement(cfg.targetID + "_AX_" + objID + "_AX_" + obj.selectedIndex + "_AX_option"); //focus
			obj.config.focusedIndex = obj.selectedIndex;
		}

		// 위치 재 정의 필요하면 정의 할 것 ----------------------------------
		var bodyHeight;
		(AXUtil.docTD == "Q") ? bodyHeight = document.body.clientHeight : bodyHeight = document.documentElement.clientHeight;
		//trace({bodyHeight:bodyHeight, top:css.top});

		var anchorHeight = jqueryTargetObjID.data("height") - 1;
		var expandBox = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox");
		var expBoxHeight = expandBox.outerHeight();

		var offset = (obj.config.positionFixed) ? jqueryTargetObjID.position() : jqueryTargetObjID.offset();

		if(obj.config.position){
			offset = jqueryTargetObjID.offset();
			if(obj.config.position.top != undefined){
				offset.top = obj.config.position.top;
			}
		}

		var css = {};
		css.top = offset.top + anchorHeight;
		if(!obj.config.positionFixed){
			if (bodyHeight < css.top.number() + expBoxHeight) {
				css = {
					top: offset.top - expBoxHeight,
					left: offset.left
				}
				expandBox.css(css);
			}
		}
		// 위치 재 정의 필요하면 정의 할 것 ----------------------------------

	},
	bindSelectOptionsClick: function (objID, objSeq, event) {
		var obj = this.objects[objSeq];
		var cfg = this.config;
		var isSelectorClick = false;
		var eid = event.target.id.split(/_AX_/g);
		var tgid = event.target.id;

		if (event.target.id == "") isSelectorClick = false;
		else {
			if (event.target.id == objID || (eid[0] == cfg.targetID && tgid.substr(eid[0].length + 4, objID.length) == objID)) {
				isSelectorClick = true;
			}
		}

		if (!isSelectorClick) {
			this.bindSelectClose(objID, objSeq, event); // 셀럭터 외의 영역이 므로 닫기
		} else {
			if (eid.last() == "option") {
				var selectedIndex = eid[eid.length - 2];
				obj.selectedIndex = selectedIndex;
				obj.config.focusedIndex = selectedIndex;
				obj.config.selectedObject = obj.options[selectedIndex];

				obj.config.isChangedSelect = true;
				this.bindSelectClose(objID, objSeq, event); // 값 전달 후 닫기
			}
		}
	},
	bindSelectKeyup: function (objID, objSeq, event) {
		var obj = this.objects[objSeq];
		var cfg = this.config;
		if (event.keyCode == AXUtil.Event.KEY_TAB || event.keyCode == AXUtil.Event.KEY_ESC) {
			this.bindSelectClose(objID, objSeq, event); // 닫기
			return;
		} else if (event.keyCode == AXUtil.Event.KEY_UP) {
			if (!obj.options) return;
			if (obj.options.length == 0) return;
			var focusIndex = obj.options.length - 1;
			if (obj.config.focusedIndex == undefined || obj.config.focusedIndex == 0) {

			} else {
				focusIndex = (obj.config.focusedIndex) - 1;
			}
			this.bindSelectorSelect(objID, objSeq, focusIndex);
		} else if (event.keyCode == AXUtil.Event.KEY_DOWN) {
			if (!obj.options) return;
			if (obj.options.length == 0) return;
			var focusIndex = 0;
			if (obj.config.focusedIndex == undefined || obj.config.focusedIndex == obj.options.length - 1) {

			} else {
				focusIndex = (obj.config.focusedIndex).number() + 1;
			}
			this.bindSelectorSelect(objID, objSeq, focusIndex);
		} else if (event.keyCode == AXUtil.Event.KEY_RETURN) {
			//alert("RETURN");
			/*
			 axdom(document).unbind("click", obj.documentclickEvent);
			 axdom(document).unbind("keydown", obj.documentKeyup);
			 */
			/*
			 var selectedIndex = eid[eid.length - 2];
			 obj.selectedIndex = selectedIndex;
			 obj.config.focusedIndex = selectedIndex;
			 obj.config.selectedObject = obj.options[selectedIndex];

			 obj.config.isChangedSelect = true;
			 this.bindSelectClose(objID, objSeq, event); // 값 전달 후 닫기
			 */

		}
	},
	/* ~~~~~~~~~~~~~ */

	bindSelectorSelect: function (objID, objSeq, index, changeValue) {
		var obj = this.objects[objSeq];
		var cfg = this.config;
		if (obj.config.focusedIndex != undefined) {
			axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + obj.config.focusedIndex + "_AX_option").removeClass("on");
		}
		axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + index + "_AX_option").addClass("on");
		obj.config.focusedIndex = index;
		obj.selectedIndex = index;
		obj.config.selectedObject = obj.options[index];
		obj.config.isChangedSelect = true;
		obj.myUIScroll.focusElement(cfg.targetID + "_AX_" + objID + "_AX_" + index + "_AX_option"); //focus
	},
	bindSelectorSelectClear: function (objID, objSeq) {

		var obj = this.objects[objSeq];
		var cfg = this.config;
		if (obj.selectedIndex != undefined) {
			axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + obj.selectedIndex + "_AX_option").removeClass("on");
		}
		obj.selectedIndex = null;
		obj.config.focusedIndex = null;
		obj.config.selectedObject = null;
		obj.config.isChangedSelect = true;
	},

	/* ~~~~~~~~~~~~~ */
	bindSelectChangeValue: function (objID, value, onEnd) {
		var findIndex = null;

		for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
			if (O.id == objID && O.isDel != true) {
				findIndex = index;
				break;
			}
		};

		if (findIndex == null) {
			//trace("바인드 된 오브젝트를 찾을 수 없습니다.");
			return;
		} else {

			var obj = this.objects[findIndex], options, sendObj;
			var cfg = this.config;

			if (this.isMobile) {
				for (var oi = 0; oi < AXgetId(objID).options.length; oi++) {
					if (AXgetId(objID).options[oi].value == value) {
						var selectedIndex = oi;
						AXgetId(objID).options[oi].selected = true;
						obj.config.selectedObject = { optionIndex: oi, optionValue: AXgetId(objID).options[oi].value, optionText: AXgetId(objID).options[oi].text.enc() };
						this.bindSelectChange(objID, findIndex);
						if (obj.config.onChange) {
							options = AXgetId(objID).options[oi];
							sendObj = {
								optionIndex:oi, optionValue:options.value, optionText:options.text,
								value: options.value, text: options.text
							};
							obj.config.onChange.call(sendObj, sendObj);
						}
						break;
					}
				}
			} else {

				var selectedIndex = null;
				for (var O, oidx = 0; (oidx < obj.options.length && (O = obj.options[oidx])); oidx++) {
					if ((O.optionValue || O.value || "") == value) {
						selectedIndex = oidx;
						break;
					}
				};

				if (selectedIndex != null) {

					obj.selectedIndex = selectedIndex;
					obj.config.focusedIndex = selectedIndex;

					AXgetId(objID).options[obj.selectedIndex].selected = true;
					obj.config.selectedObject = obj.options[selectedIndex];
					this.bindSelectChange(objID, findIndex);

					if (obj.config.onChange) {
						options = AXgetId(objID).options[selectedIndex];
						sendObj = {
							optionIndex:selectedIndex, optionValue:options.value, optionText:options.text,
							value: options.value, text: options.text
						};
						obj.config.onChange.call(sendObj, sendObj);
					}

				} else {
					//trace("일치하는 값을 찾을 수 없습니다.");
				}
			}
		}
	},
	bindSelectDisabled: function(objID, _disabled){
		var findIndex = null;
		for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
			if (O.id == objID && O.isDel != true) {
				findIndex = index;
				break;
			}
		};

		if (findIndex == null) {
			//trace("바인드 된 오브젝트를 찾을 수 없습니다.");
			return;
		} else {
			var obj = this.objects[findIndex];
			var cfg = this.config;

			if(typeof _disabled == "boolean"){
				axf.getId(objID).disabled = _disabled;
			}else{
				axf.getId(objID).disabled = !AXgetId(objID).disabled;
			}

			if (this.isMobile) {

			} else {

				var bindTarget = axdom("#"+ cfg.targetID + "_AX_" + objID);
				bindTarget.data("disabled", axf.getId(objID).disabled);

				if(axf.getId(objID).disabled){
					bindTarget.find(".AXanchorSelect").addClass("disable");
				}else{
					bindTarget.find(".AXanchorSelect").removeClass("disable");

				}
			}
		}
	},
	bindSelectUpdate: function(objID){
		var findIndex = null;
		for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
			if (O.id == objID && O.isDel != true) {
				findIndex = index;
				break;
			}
		}

		if(findIndex != null){
			var obj = this.objects[findIndex], selectedIndex, options, sendObj;
			if (obj.config.onChange) {
				selectedIndex = AXgetId(objID).options.selectedIndex;
				options = AXgetId(objID).options[selectedIndex];
				sendObj = {
					optionIndex:selectedIndex,
					optionValue:options.value, optionText:options.text,
					value: options.value,
					text: options.text
				};
				obj.config.onChange.call(sendObj, sendObj);
			}
			this.bindSelectChange(objID, findIndex);
		}
	},
	bindSelectFocus: function(objID){
		var cfg = this.config;
		var findIndex = null;
		for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
			if (O.id == objID && O.isDel != true) {
				findIndex = index;
				break;
			}
		}
		if(findIndex != null){
			axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectTextBox").addClass("focus");
		}
	},
	bindSelectBlur: function(objID){
		var cfg = this.config;
		var findIndex = null;
		for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
			if (O.id == objID && O.isDel != true) {
				findIndex = index;
				break;
			}
		}
		if(findIndex != null){
			axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectTextBox").removeClass("focus");
		}
	},
	bindSelectGetAnchorObject: function(objID){
		var cfg = this.config;
		var findIndex = null;
		for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
			if (O.id == objID && O.isDel != true) {
				findIndex = index;
				break;
			}
		};
		if(findIndex != null){
			return axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectTextBox");
		}
	},
	bindSelectGetValue: function(objID, onEnd){
		var findIndex = null;
		for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
			if (O.id == objID && O.isDel != true) {
				findIndex = index;
				break;
			}
		};

		if (findIndex == null) {
			return { optionValue: null, optionText: null, error:"바인드 된 오브젝트를 찾을 수 없습니다." };
		} else {
			var obj = this.objects[findIndex];
			var cfg = this.config;

			if (obj.selectedIndex != undefined) {
				var options = AXgetId(objID).options[obj.selectedIndex];
				return { optionValue: options.value, optionText: options.text, optionData:options.getAttribute("data-option") };
			}else{
				return { optionValue: null, optionText: null };
			}
		}
	},

/**
 * @method AXSelectConverter.bindSelectAddOptions
 * @param {String} objID - element select id
 * @param {Array} options - 추가하려는 옵션 배열
 * @returns {Array} options
 * @description 설명
 * @example
 ```
mySelect.bindSelectAddOptions("objID", [{optionValue:"1", optionText:"액시스제이"}]);
 ```
 */
	bindSelectAddOptions: function(objID, options){
		var cfg = this.config, _this = this;
		var objSeq = null;
		for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
			if (O.id == objID && O.isDel != true) {
				objSeq = index;
				break;
			}
		}
		if(objSeq == null) {
			trace("not found element id");
			return;
		}
		var obj = this.objects[objSeq];
		var iobj = obj.iobj;

		if(!Object.isArray(options)){
			trace("options 아규먼트가 없습니다.");
			return;
		}

		var newOptions = obj.options;
		for(var i = 0; i < options.length; i++){
			var hasValue = false;
			for(var oi = 0; oi < obj.options.length; oi++) {
				if( obj.options[oi].optionValue == options[i].optionValue ){
					hasValue = true;
				}
			}
			if(!hasValue){
				newOptions.push({optionText:options[i].optionText.enc(), optionValue:options[i].optionValue});
			}
		}
		obj.options = newOptions;

		iobj.css({opacity:100});
		//trace(obj.options);
		var po = [];
		for (var opts, oidx = 0; (oidx < obj.options.length && (opts = obj.options[oidx])); oidx++) {
			var optionText = (opts.optionText||"").dec();
			po.push("<option value=\"" + opts.optionValue + "\"");
			if (obj.selectedIndex == oidx) po.push(" selected=\"selected\"");
			po.push(">" + optionText + "</option>");
		}
		iobj.empty();
		iobj.append(po.join(''));

		//this.bindSelectChangeValue(objID, obj.config.setValue);
		this.alignAnchor(objID, objSeq);

		return obj.options;
	},

/**
 * @method AXSelectConverter.bindSelectRemoveOptions
 * @param objID {String} element select id
 * @param options {Array} 추가하려는 옵션 배열
 * @returns {Array} options
 * @description 설명
 * @example
 ```
mySelect.bindSelectRemoveOptions("objID", [{optionValue:"1", optionText:"액시스제이"}]);
 ```
 */
	bindSelectRemoveOptions: function(objID, options){
		var cfg = this.config, _this = this;
		var objSeq = null;
		for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
			if (O.id == objID && O.isDel != true) {
				objSeq = index;
				break;
			}
		}
		if(objSeq == null) {
			trace("not found element id");
			return;
		}
		var obj = this.objects[objSeq];
		var iobj = obj.iobj;

		if(!Object.isArray(options)){
			trace("options 아규먼트가 없습니다.");
			return;
		}

		var newOptions = [];

		for(var oi = 0; oi < obj.options.length; oi++) {
			var hasValue = false;
			for(var i = 0; i < options.length; i++) {
				if( obj.options[oi].optionValue == options[i].optionValue ){
					hasValue = true;
				}
			}
			if(!hasValue){
				newOptions.push({optionText:obj.options[oi].optionText, optionValue:obj.options[oi].optionValue});
			}
		}
		obj.options = newOptions;

		//trace(obj.options);
		iobj.css({opacity:100});
		var po = [];
		for (var opts, oidx = 0; (oidx < obj.options.length && (opts = obj.options[oidx])); oidx++) {
			var optionText = (opts.optionText||"").dec();
			po.push("<option value=\"" + opts.optionValue + "\"");
			if (obj.selectedIndex == oidx) po.push(" selected=\"selected\"");
			po.push(">" + optionText + "</option>");
		}
		iobj.empty();
		iobj.append(po.join(''));

		this.alignAnchor(objID, objSeq);

		return obj.options;
	},


	/**
	 * @method AXSelectConverter.bindSelectUpdateOptions
	 * @param {String} objID - element select id
	 * @param {Array|Object} options - 옵션 배열
	 * @param {Number} optionIndex - 변경하려는 옵션 인덱스
	 * @returns {AXSelectConverter}
	 * @description 설명
	 * @example
 ```
 jQuery("#AXSelect1").bindSelectUpdateOptions([
	 {optionValue:1, optionText:"abc-1 : ABCDEFG"},
	 {optionValue:2, optionText:"abc-2 : 09123123"},
	 {optionValue:3, optionText:"abc-3 : 1222"},
	 {optionValue:4, optionText:"abc-4 : AXISJ"},
	 {optionValue:5, optionText:"abc-5 : 액시스 제이"}
 ]);

 jQuery("#AXSelect1").bindSelectUpdateOptions({optionValue:3, optionText:"특별한 값으로 변경"}, 3);
 ```
	 */
	bindSelectUpdateOptions: function(objID, options, optionIndex){
		var cfg = this.config, _this = this;
		var objSeq = null;
		for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
			if (O.id == objID && O.isDel != true) {
				objSeq = index;
				break;
			}
		}
		if(objSeq == null) {
			trace("not found element id");
			return;
		}
		var obj = this.objects[objSeq];
		var iobj = obj.iobj;

		if(typeof optionIndex === "undefined" && !Object.isArray(options)){
			trace("options 아규먼트가 없습니다.");
			return;
		}

		var newOptions = [];
		if(typeof optionIndex === "undefined"){
			for(var i = 0; i < options.length; i++){
				newOptions.push(jQuery.extend({optionText:options[i].optionText.enc(), optionValue:options[i].optionValue}, options[i]));
			}
			obj.selectedIndex = 0;
		}else{
			var _adj = 0;
			if (obj.config.isspace) _adj = 1;
			for (var i = 0; i < obj.config.options.length; i++) {
				if(i+_adj == optionIndex){
					newOptions.push(jQuery.extend({optionText:options.optionText.enc(), optionValue:options.optionValue}, options));
				}else{
					newOptions.push(obj.config.options[i]);
				}
			}
		}

		obj.config.options = newOptions;
		iobj.css({opacity:100});
		iobj.html("<option></option>");

		var po = [], adj = 0;
		if (obj.config.isspace) {
			po.push("<option value='"+(obj.config.isspaceValue||"")+"'");
			if (obj.selectedIndex == 0) po.push(" selected=\"selected\"");
			po.push(">" + (obj.config.isspaceTitle||"&nbsp;") + "</option>");
			adj = -1;
		}

		for (var opts, oidx = 0; (oidx < obj.config.options.length && (opts = obj.config.options[oidx])); oidx++) {
			var optionText = (opts.optionText||"").dec();
			po.push("<option value=\"" + opts.optionValue + "\"");
			if (obj.config.setValue == opts.optionValue || opts.selected || (obj.selectedIndex||0).number()+adj == oidx) po.push(" selected=\"selected\"");
			po.push(">" + optionText + "</option>");
		}

		iobj.html(po.join(''));

		var options = [];
		for (var oi = 0; oi < AXgetId(objID).options.length; oi++) {
			options.push({ optionValue: AXgetId(objID).options[oi].value, optionText: AXgetId(objID).options[oi].text.enc() });
		}
		obj.options = AXUtil.copyObject(options);
		obj.selectedIndex = AXgetId(objID).options.selectedIndex;

		this.bindSelectChange(objID, objSeq, "load");

		if (obj.config.onChange && obj.config.alwaysOnChange) {
			obj.config.focusedIndex = obj.selectedIndex;
			obj.config.selectedObject = obj.options[obj.selectedIndex];

			options = AXgetId(objID).options[obj.selectedIndex];
			sendObj = {
				optionIndex:obj.selectedIndex, optionValue:options.value, optionText:options.text,
				value:options.value, text:options.text
			};
			obj.config.onChange.call(sendObj, sendObj, "isPostBack");
		}

		this.alignAnchor(objID, objSeq);
		iobj.css({opacity:0});

		return this;
	}
});

var AXSelect = new AXSelectConverter();
AXSelect.setConfig({ targetID: "AXselect" });

/**
 * @method jQueryExtends.unbindSelect
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description select 엘리먼트에 select 콘트롤을 언바인드(제거) 합니다.
 * @example
 ```js
 axdom("Selector").unbindSelect();
 ```
 **/
axdom.fn.unbindSelect = function (config) {
	axdom.each(this, function () {
		if (config == undefined) config = {};
		config.id = this.id;
		AXSelect.unbind(config);
	});
	return this;
};

/**
 * @method jQueryExtends.bindSelect
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description
 * select 엘리먼트에 select 콘트롤을 바인드 합니다.
 * @example
 ```
axdom("Selector").bindSelect(configs);
 ```
 */
axdom.fn.bindSelect = function (config) {
	axdom.each(this, function () {
		if(!this.id) this.id = "AXInput-" + axf.getUniqueId();
		if (config == undefined) config = {};
		config.id = this.id;
		AXSelect.bind(config);
	});
	return this;
};
/**
 * @method jQueryExtends.setConfigSelect
 * @param {jsObject} config - select 설정
 * @returns {jQueryObject}
 * @description
 * select 콘트롤에 설정을 변경합니다.
 * @example
 ```
axdom("Selector").bindSelect(configs);
 ```
 */
axdom.fn.setConfigSelect = function (config) {
	axdom.each(this, function () {
		AXSelect.bindSetConfig(this.id, config);
	});
	return this;
};

/**
 * @method jQueryExtends.bindSelectSetValue
 * @param {String} value
 * @param {fn} [onEnd] - 끝나고 실행될 함수 / 예정
 * @returns {jQueryObject}
 * @description
 * 해당 셀렉트 컨트롤에 값을 입력하고 onEnd 함수가 있는 경우 실행합니다.
 * @example
 ```
axdom("Selector").bindSelectSetValue('test');
 ```
 */

axdom.fn.bindSelectSetValue = function (value, onEnd) {
	axdom.each(this, function () {
		AXSelect.bindSelectChangeValue(this.id, value, onEnd);
	});
	return this;
};

axdom.fn.bindSelectGetValue = function (onEnd) {
	return AXSelect.bindSelectGetValue(this[0].id, onEnd);
};

//SetText

//getText
/**
 * @method jQueryExtends.setValueSelect
 * @param {String} value
 * @param {fn} [onEnd] - 끝나고 실행될 함수 / 예정
 * @returns {jQueryObject}
 * @description
 * 해당 셀렉트 컨트롤에 값을 입력하고 onEnd 함수가 있는 경우 실행합니다.
 * @example
 ```
axdom("Selector").setValueSelect('test');
 ```
 */

axdom.fn.setValueSelect = function (value, onEnd) {
	axdom.each(this, function () {
		AXSelect.bindSelectChangeValue(this.id, value, onEnd);
	});
	return this;
};

/**
 * @method jQueryExtends.bindSelectDisabled
 * @param {Boolean} Disabled
 * @returns {jQueryObject}
 * @description
 * 해당 셀렉트 컨트롤의 Disabled 속성을 컨트롤 합니다.
 * @example
 ```
 axdom("Selector").bindSelectDisabled(true);
 ```
 */
axdom.fn.bindSelectDisabled = function (Disabled) {
	axdom.each(this, function () {
		AXSelect.bindSelectDisabled(this.id, Disabled);
	});
	return this;
};

/**
 * @method jQueryExtends.bindSelectUpdate
 * @returns {jQueryObject}
 * @description
 * 해당 셀렉트 컨트롤의 view 를 value 기준으로 변경합니다.
 * @example
 ```
axdom("Selector").bindSelectUpdate();
 ```
 */
axdom.fn.bindSelectUpdate = function () {
	axdom.each(this, function () {
		AXSelect.bindSelectUpdate(this.id);
	});
	return this;
};

/**
 * @method jQueryExtends.bindSelectFocus
 * @returns {jQueryObject}
 * @description
 * 해당 셀렉트 컨트롤에 focus를 줍니다.
 * @example
 ```
 axdom("Selector").bindSelectFocus();
 ```
 */
axdom.fn.bindSelectFocus = function () {
	axdom.each(this, function () {
		AXSelect.bindSelectFocus(this.id);
	});
	return this;
};

/**
 * @method jQueryExtends.bindSelectBlur
 * @returns {jQueryObject}
 * @description
 * 해당 셀렉트 컨트롤을 blur 상태로 변경합니다.(비활성 처리후 메소드 종료)
 * @example
 ```
 axdom("Selector").bindSelectBlur();
 ```
 */
axdom.fn.bindSelectBlur = function () {
	axdom.each(this, function () {
		AXSelect.bindSelectBlur(this.id);
	});
	return this;
};

/**
 * @method jQueryExtends.bindSelectGetAnchorObject
 * @returns {jQueryObject}
 * @description
 * 해당 셀렉트 컨트롤의 view html element를 반환합니다.
 * @example
 ```
axdom("Selector").bindSelectGetAnchorObject();
 ```
 */

axdom.fn.bindSelectGetAnchorObject = function(){
	var returnObj;
	axdom.each(this, function () {
		returnObj = AXSelect.bindSelectGetAnchorObject(this.id);
	});
	return returnObj;
};

/**
 * @method jQueryExtends.bindSelectAddOptions
 * @param {Array} options - 추가하려는 옵션 배열
 * @description 배열로 지정한 객체를 해당 셀렉트의 option 에 추가합니다.
 * @example
 ```
$("#mySelect").bindSelectAddOptions([
    {optionValue:"1", optionText:"액시스제이"}
]);
 ```
 */
axdom.fn.bindSelectAddOptions = function (options) {
	var returnObj;
	axdom.each(this, function () {
		returnObj = AXSelect.bindSelectAddOptions(this.id, options);
	});
	return returnObj;
};

/**
 * @method jQueryExtends.bindSelectRemoveOptions
 * @param {Array} options - 삭제하려는 옵션 배열
 * @description 배열로 지정한 객체를 해당 셀렉트의 option 에서 제거합니다.
 * @example
 ```

 ```
 */
axdom.fn.bindSelectRemoveOptions = function (options) {
	var returnObj;
	axdom.each(this, function () {
		returnObj = AXSelect.bindSelectRemoveOptions(this.id, options);
	});
	return returnObj;
};


/**
 * @method jQueryExtends.bindSelectUpdateOptions
 * @param {Array} options - 삭제하려는 옵션 배열
 * @description 배열로 지정한 객체를 해당 셀렉트의 option 에서 제거합니다.
 * @example
 ```
 jQuery("#AXSelect1").bindSelectUpdateOptions([
	 {optionValue:1, optionText:"abc-1 : ABCDEFG"},
	 {optionValue:2, optionText:"abc-2 : 09123123"},
	 {optionValue:3, optionText:"abc-3 : 1222"},
	 {optionValue:4, optionText:"abc-4 : AXISJ"},
	 {optionValue:5, optionText:"abc-5 : 액시스 제이"}
 ]);

 jQuery("#AXSelect1").bindSelectUpdateOptions({optionValue:3, optionText:"특별한 값으로 변경"}, 3);
 ```
 */
axdom.fn.bindSelectUpdateOptions = function (options, oidx) {
	var returnObj;
	axdom.each(this, function () {
		returnObj = AXSelect.bindSelectUpdateOptions(this.id, options, oidx);
	});
	return returnObj;
};
/* ---------------------------- */
var AXSlideViewer = Class.create(AXJ, {
    initialize: function(AXJ_super) {
        AXJ_super();
		this.config.theme = "AXSlideViewer";
		/*this.uniqueId = axf.getUniqueId();*/
		this.config.id = axf.getUniqueId();
		this.config.fitToHeight = false;
		var _parent = this, cfg = this.config;
		this.touchUpdater = {
			firstTouch:{}, firstBoxModel:{}, moveType:"", item:{}, lastTouch:{},
			watch: function(){
				var _this = this;
				
				if(axf.browser.mobile){
					axdom(document.body).bind("touchmove.axsliderviewer", function(){
						_this.update(window.event);
					});
					axdom(document.body).bind("touchend.axsliderviewer", function(){
						_this.watchEnd(window.event);
					});
				}else{
					axdom(document.body).bind("mousemove.axsliderviewer", function(event){
						_this.update(event);
					});
					axdom(document.body).bind("mouseup.axsliderviewer", function(event){
						_this.watchEnd(event);
					});
					axdom(document.body).bind("mouseleave.axsliderviewer", function(event){
						_this.watchEnd(event);
					});
				}
			},
			update: function(event){
				var touch = {};
				
				if(axf.browser.mobile){
					touch.pageX1 = event.touches[0].pageX - this.item._boxModel.dL;
					touch.pageY1 = event.touches[0].pageY - this.item._boxModel.dT;
	
					if(event.touches.length == 2){
						touch.pageX2 = event.touches[1].pageX - this.item._boxModel.dL;
						touch.pageY2 = event.touches[1].pageY - this.item._boxModel.dT;
						touch.centerX = (touch.pageX2 + touch.pageX1) / 2;
						touch.centerY = (touch.pageY2 + touch.pageY1) / 2;
					}else{
						touch.centerX = touch.pageX1;
						touch.centerY = touch.pageY1;
					}
						
	
					this.lastTouch = touch;
					_parent.imgTouchUpdate( {firstTouch:this.firstTouch, firstBoxModel:this.firstBoxModel, touch:touch, moveType:this.moveType, item:this.item}, event );
	
					if (event.stopPropagation) event.stopPropagation();
					if (event.preventDefault) event.preventDefault();
					return false;
					
				}else{
					touch.pageX1 = event.pageX - this.item._boxModel.dL;
					touch.pageY1 = event.pageY - this.item._boxModel.dT;
					touch.centerX = touch.pageX1;
					touch.centerY = touch.pageY1;

					this.lastTouch = touch;
					_parent.imgTouchUpdate( {firstTouch:this.firstTouch, firstBoxModel:this.firstBoxModel, touch:touch, moveType:this.moveType, item:this.item}, event );

				}
				
			},
			watchEnd: function(event){				
				if(axf.browser.mobile){
					axdom(document.body).unbind("touchmove.axsliderviewer");
					axdom(document.body).unbind("touchend.axsliderviewer");
				}else{
					axdom(document.body).unbind("mousemove.axsliderviewer");
					axdom(document.body).unbind("mouseup.axsliderviewer");
					axdom(document.body).unbind("mouseleave.axsliderviewer");
				}
				//관성 적용 법칙...
				_parent.imgTouchEnd( {firstTouch:this.firstTouch, firstBoxModel:this.firstBoxModel, moveType:this.moveType, item:this.item}, event );	
			}
		};
		this.touchClicked = false;
		this.touchDblClicked = false;
		this.touchAndMoved = false;
    },
/**
 * 선언된 클래스를 사용하기 위해 속성을 정의합니다.
 * @method AXSliderViewer.setConfig
 * @param {Object} Config of Class
 * @example
```js
var myViewer = new AXSlideViewer();
myViewer.setConfig({
	id:"myViewer01", // 뷰어 이름
	fitToHeight: false, // 이미지의 높이를 브라우저 높이에 맞추기. 브라우저보다 작은 이미지를 늘리는 효과가 있습니다.
	reserveKeys: { // 이미지 아이템의 키이름 사용자 정의
		title: "title",
		description: "description",
		url: "url"
	}
});
```
 */
    init: function() {
		var cfg = this.config;
		var reserveKeys = {
			title: "title",
			description: "description",
			url: "url"
		};
		if (cfg.reserveKeys) {
			axf.overwriteObject(reserveKeys, cfg.reserveKeys, true);
			cfg.reserveKeys = reserveKeys;
		} else {
			cfg.reserveKeys = reserveKeys;
		}
    },
/**
 * 슬라이더에 이미지 아이템과 오픈할 이미지 인덱스 정보를 전달합니다.
 * @method AXSliderViewer.open
 * @param {Object} slideObject
 * @example
```js
 var mySliderObj = {}
 jQuery(".sliderIcons").each(function(){
    // 클래스 sliderIcons 노드를 찾아요
    var thisId = this.id;
    mySliderObj[thisId] = []; //배열을 만들었어요.

    jQuery(this).find(".findImg").each(function(fidx, F){
        // 배열에 수집된 정보를 연결 해요.
        var imgNode = jQuery(F);
        // 만약 부모에 접근 한다면 parent() 로 해결
		mySliderObj[thisId].push(
			{
				title: imgNode.attr("title")||"untitle", // alt ? title ? 적당히
				description: imgNode.attr("longDesc")||"..", // alt ? title ? 적당히
				url: F.src.replace("/thumb", "").replace("\.png", ".jpg"),
				thumb: F.src
			}
		);
		// 클릭이벤트 장착~
		jQuery(F).bind("click", function(){
			myViewer.open({id:"myViewer01", list:mySliderObj[thisId], selectedIndex:fidx});
		});
	});
 });
```
 */
    open: function(jsObject){ // jsArray, jsObject
     	var cfg = this.config, _this = this;
     	
     	this.isOpend = true;
     	
     	axdom(document.body).data("scrollTop", axdom(document.body).scrollTop());
     	//axdom(document.body).children().hide();
     	//this.bodyElement = axdom(document.body).children().not("script");
     	//axdom(document.body).children().not("script").remove();
     	
		this.screenSize = {
			width:axf.clientWidth(),
			height:axf.clientHeight()
		};
     	var po = [];
     	po.push('<div id="'+ cfg.id +'_AX_viewer" class="' + cfg.theme + ' AXUserSelectNone" onselectstart="return false">');
     	
     		po.push('<div class="background" id="'+ cfg.id +'_AX_background"></div>');
     		
     		po.push('<div class="slideItemGroup" id="'+ cfg.id +'_AX_slideItemGrop">');
	     	po.push('</div>');	
     		
     		po.push('<div class="controller" id="'+ cfg.id +'_AX_controller">');
	     			
	     			po.push('<div class="hgroup">');
	     				po.push('<h1></h1>');
	     				po.push('<span></span>');
	     			po.push('</div>');

	     			po.push('<div class="navigation"></div>');

     				po.push('<div class="buttonGroup">');
	     				po.push('<a class="ToggleHandle" type="button">Toggle</a>');
	     				po.push('<a class="Prev" type="button">Prev</a>');
		     			po.push('<a class="Next" type="button">Next</a>');
		     			po.push('<a class="ZoomIn" type="button">Next</a>');
		     			po.push('<a class="ZoomOut" type="button">Next</a>');
		     		po.push('</div>');

	     			po.push('<a class="Close" type="button">Close</a>');
     		po.push('</div>');
     		
     	po.push('</div>');
     	
     	axdom(document.body).append( po.join('') );
     	
     	this.target = axdom( '#' + cfg.id +'_AX_viewer' );
     	this.background = axdom( '#' + cfg.id +'_AX_background' );
     	this.slideItemGrop = axdom( '#' + cfg.id +'_AX_slideItemGrop' );
     	this.controller = axdom( '#' + cfg.id +'_AX_controller' );
     	
     	this.controller.find(".Close").bind("click.AXSlideViewer", function(event){
     		_this.close();
     	});

     	this.controller.find(".ToggleHandle").bind("click.AXSlideViewer", function(event){
     		_this.controller.find(".buttonGroup").toggleClass("open");
     	});
     	this.controller.find(".Prev").bind("click.AXSlideViewer", function(event){
     		_this.prev();
     	});
     	this.controller.find(".Next").bind("click.AXSlideViewer", function(event){
     		_this.next();
     	});
     	
     	this.controller.find(".ZoomIn").bind("click.AXSlideViewer", function(event){
     		_this.zoomIn();
     	});
     	this.controller.find(".ZoomOut").bind("click.AXSlideViewer", function(event){
     		_this.zoomOut();
     	});
     	
     	this.list = jsObject.list;
     	this.selectedIndex = (jsObject.selectedIndex || 0);

     	this.openImage(this.selectedIndex);
     	axdom(window).bind("resize.AXSliderViewer", this.windowResize.bind(this));
     	
		if(axf.browser.mobile){
			
			var eventBodyID = cfg.id +'_AX_slideItemGrop';
			if (document.addEventListener) { // 터치 이벤트 시작
				AXgetId(eventBodyID).addEventListener("touchstart", function(event){
					var touch = {};
					var item = _this.list[_this.selectedIndex];
					
					if (_this.touhEndObserver) clearTimeout(_this.touhEndObserver);
					_this.velocityDX = 0;
					_this.velocityDY = 0;
					touch.pageX1 = event.touches[0].pageX - item._boxModel.dL;
					touch.pageY1 = event.touches[0].pageY - item._boxModel.dT;
					if(event.touches.length == 2){
						touch.pageX2 = event.touches[1].pageX - item._boxModel.dL;
						touch.pageY2 = event.touches[1].pageY - item._boxModel.dT;
						touch.centerX = (touch.pageX2 + touch.pageX1) / 2;
						touch.centerY = (touch.pageY2 + touch.pageY1) / 2;
						_this.touchUpdater.moveType = "zoom";
					}else{
						touch.centerX = touch.pageX1;
						touch.centerY = touch.pageY1;
						_this.touchUpdater.moveType = "move";
					}
					_this.touchUpdater.firstTouch = touch;
					_this.touchUpdater.firstBoxModel = axf.copyObject(item._boxModel);
					_this.touchUpdater.item = item;
					_this.touchUpdater.watch();
				}, false);
			}
			
		}else{ // deskTop
			
			var eventBodyID = cfg.id +'_AX_slideItemGrop';

				axdom("#" +eventBodyID).bind("mousedown.axsliderviewer", function(event){
					var touch = {};
					var item = _this.list[_this.selectedIndex];
					
					if (_this.touhEndObserver) clearTimeout(_this.touhEndObserver);
					_this.velocityDX = 0;
					_this.velocityDY = 0;
					touch.pageX1 = event.pageX - item._boxModel.dL;
					touch.pageY1 = event.pageY - item._boxModel.dT;

					touch.centerX = touch.pageX1;
					touch.centerY = touch.pageY1;
					
					_this.touchUpdater.moveType = "move";

					_this.touchUpdater.firstTouch = touch;
					_this.touchUpdater.firstBoxModel = axf.copyObject(item._boxModel);
					_this.touchUpdater.item = item;
					_this.touchUpdater.watch();
				});
				
				var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel";
				var contentScrollScrollWheel = function(){
					if (_this.wheelEndObserver) clearTimeout(_this.wheelEndObserver);
					var event = window.event;
					var delta = event.detail ? event.detail * (-1) : event.wheelDelta;
			    	var item = _this.list[_this.selectedIndex];
			    	
			    	var cx = event.pageX  - item._boxModel.dL;
			    	var cy = event.pageY  - item._boxModel.dT;
			    	var dLen = (delta > 0) ? 50 : -50;
			    	_this.imgResize(item, item._boxModel, dLen, cx, cy);
			    	_this.wheelEndObserver = setTimeout(function(){
						var pos = item._axdom.position();						
				    	var sL = 0, eL = 0, sT = 0, eT = 0, scW = _this.screenSize.width, scH = _this.screenSize.height, iW = item._axdom.width(), iH = item._axdom.height();
				    	
				    	var imgAnmate = false;
				    	var css = {left:pos.left, top:pos.top, opacity:1};
				    	var __left = css.left, __top = css.top;
				    	
				    	if(iW < scW && iH < scH){
				    		iW = css.width = item._boxModel.width;
				    		iH = css.height  = item._boxModel.height;
				    	}
				
				    	if(iW < scW){
				    		sL = (scW - iW) / 2;
				    		eL = sL;
				    	}else{
				    		sL = 0;
				    		eL = scW - iW;
				    	}
				    	if(iH < scH){
				    		sT = (scH - iH) / 2;
				    		eT = sT;
				    	}else{
				    		sT = 0;
				    		eT = scH - iH;
				    	}
				
				    	if(css.left > sL ){
				    		css.left = sL;
				    		imgAnmate = true;
				    	}else if(css.left < eL ){
				    		css.left = eL;
				    		imgAnmate = true;
				    	}
				    	if(css.top > sT ){
				    		css.top = sT;imgAnmate = true;
				    	}else if(css.top < eT ){
				    		css.top = eT;imgAnmate = true;
				    	}
				    	if(imgAnmate){
				    		item._axdom.stop();
				    		item._axdom.animate(css);
					    	if(!isNaN(css.left)) item._boxModel.dL = css.left;
					    	if(!isNaN(css.top)) item._boxModel.dT = css.top;

					    	if(!isNaN(css.width)) item._boxModel.dW = css.width;
					    	if(!isNaN(css.height)) item._boxModel.dH = css.height;
				    	}

			    		
			    	}, 300);
				};
				if (document.attachEvent) { /*if IE (and Opera depending on user setting) */
					AXgetId(eventBodyID).attachEvent("on" + mousewheelevt, contentScrollScrollWheel);
				} else if (document.addEventListener) { /*WC3 browsers */
					AXgetId(eventBodyID).addEventListener(mousewheelevt, contentScrollScrollWheel, false);
				}
				
			
		}
    },
	windowResizeApply: function () {
		var cfg = this.config, _this = this;
		this.screenSize = {
			width:axf.clientWidth(),
			height:axf.clientHeight()
		};
		
		var selectedIndex = this.selectedIndex;
		if(selectedIndex > 0){
			axdom('#' + cfg.id +'_AX_slide_AX_' + (selectedIndex-1)).css({left:-this.screenSize.width});
		}
		if(selectedIndex < this.list.length-1){
			axdom('#' + cfg.id +'_AX_slide_AX_' + (selectedIndex.number()+1)).css({left:this.screenSize.width});
		}
		
		var item = this.list[selectedIndex];
		_this.renderImage( axdom('#' + cfg.id +'_AX_slide_AX_' + selectedIndex), item);
	},
    openImage: function(selectedIndex){
    	var cfg = this.config, _this = this;
    	selectedIndex = selectedIndex.number();
    	var item = this.list[selectedIndex];

		//this.slideItemGrop
		var slides = [];
		if(selectedIndex > 0) slides.push( {id:cfg.id +'_AX_slide_AX_' + (selectedIndex-1), index:(selectedIndex-1), left:-this.screenSize.width} );
		slides.push( {id:cfg.id +'_AX_slide_AX_' + (selectedIndex), index:(selectedIndex), left:0} );
		if(selectedIndex < this.list.length-1) slides.push( {id:cfg.id +'_AX_slide_AX_' + (selectedIndex.number()+1), index:(selectedIndex.number()+1), left:this.screenSize.width} );	
		
		this.slideItemGrop.find(".slideItem").each(function(){
			for (var ii, i = 0; (i < slides.length && (ii = slides[i])); i++) {
				if(ii.id != this.id) axdom(this).remove();
			}
		});
		
		for (var ii, i = 0; (i < slides.length && (ii = slides[i])); i++) {
			if( !AXgetId(ii.id) ) this.slideItemGrop.append( '<div class="slideItem AXLoadingBlack" id="'+ ii.id +'" style="left:'+ ii.left +'px;"></div>' );
		}
		
		var hgroup = this.controller.find(".hgroup");
		hgroup.find("h1").html( item[cfg.reserveKeys.title] );
		hgroup.find("span").html( item[cfg.reserveKeys.description] );
		
		if(selectedIndex == 0){
			this.controller.find(".Prev").addClass("disabled");
			this.controller.find(".Next").removeClass("disabled");
		}else if(selectedIndex == this.list.length-1){
			this.controller.find(".Prev").removeClass("disabled");
			this.controller.find(".Next").addClass("disabled");
		}else{
			this.controller.find(".Prev").removeClass("disabled");
			this.controller.find(".Next").removeClass("disabled");
		}
		
		this.controller.find(".navigation").html( (selectedIndex+1) + " / " + this.list.length  );
		
		var mySlide = axdom('#' + cfg.id +'_AX_slide_AX_' + (selectedIndex));
		var myImg = new Image();

		if(!item._boxModel){
			myImg.onload = function(){
				item._boxModel = {originalWidth:this.width, originalHeight:this.height};
				_this.renderImage( mySlide , item);
			}
			myImg.src = item[cfg.reserveKeys.url];
		}else{
			myImg.src = item[cfg.reserveKeys.url];
			_this.renderImage( mySlide, item);
		}
    },
    renderImage: function( target, item ){
    	
		var cfg = this.config, _this = this;
		var imgRatio = (item._boxModel.originalHeight / item._boxModel.originalWidth).round(2);
		var imgWidth = item._boxModel.originalWidth; imgHeight = item._boxModel.originalHeight;
		
		if(cfg.fitToHeight == true){
			imgHeight = this.screenSize.height; imgWidth = imgHeight / imgRatio;
			if(this.screenSize.width > imgWidth){
				imgWidth = this.screenSize.width; imgHeight = imgWidth * imgRatio;
			}
		}else{
			if(imgRatio < 1){
				if(this.screenSize.width < imgWidth){
					imgWidth = this.screenSize.width; imgHeight = imgWidth * imgRatio;
				}
				if(this.screenSize.height < imgHeight){
					imgHeight = this.screenSize.height; imgWidth = imgHeight / imgRatio;
				}
			}else{
				if(this.screenSize.height < imgHeight){
					imgHeight = this.screenSize.height; imgWidth = imgHeight / imgRatio;
				}
				if(this.screenSize.width < imgWidth){
					imgWidth = this.screenSize.width; imgHeight = imgWidth * imgRatio;
				}
			}
		}
		
		item._boxModel.width = item._boxModel.dW = imgWidth;
		item._boxModel.height = item._boxModel.dH = imgHeight;
		
		var styles = [];
		styles.push("width:"+imgWidth+"px");
		styles.push("height:"+imgHeight+"px");

		item._boxModel.left = item._boxModel.dL = (this.screenSize.width / 2 - imgWidth / 2);
		item._boxModel.top = item._boxModel.dT = (this.screenSize.height / 2 - imgHeight / 2);
		
		styles.push("left:"+ item._boxModel.left +"px");
		styles.push("top:"+ item._boxModel.top +"px");
		
		var po = [];
		po.push('<div class="img" style="' + styles.join(";") + '">');
		po.push('<img src="' + item[cfg.reserveKeys.url] + '" style="width:100%;" ondragstart="return false;" />');
		po.push('</div>');
		
		target.empty();
		target.append( po.join('') );
		
		target.find(".img").fadeIn();
		target.removeClass("AXLoadingBlack");
		
		item._axdom = target.find(".img");
    },

/**
 * 이미지 슬라이더를 닫습니다.
 * @method AXSliderViewer.close
 */
    close: function(){
        var cfg = this.config, _this = this;
    	//axdom(document.body).children().show(); //테스트 필요
    	axdom(document.body).scrollTop( axdom(document.body).data("scrollTop") );
        if(cfg.onClose) cfg.onClose.call(cfg);
    	this.target.fadeOut(function(){
    		_this.target.remove();
    	});
    	this.isOpend = false;
    	axdom(window).unbind("resize.AXSliderViewer");
    },
/**
 * 이전 이미지로 이동합니다.
 * @method AXSliderViewer.prev
 * @returns {Boolean}
 */
    prev: function(){
   		var cfg = this.config, _this = this;
    	var screenWidth = this.screenSize.width;
    	var selectedIndex = this.selectedIndex;
    	if(selectedIndex <= 0) return false;
    	var prevIndex = selectedIndex.number() - 1;
    	
    	var nowDomTarget = axdom('#' + cfg.id +'_AX_slide_AX_' + selectedIndex);
    	var prevDomTarget = axdom('#' + cfg.id +'_AX_slide_AX_' + prevIndex);

    	nowDomTarget.animate({left:screenWidth}, 500, "expoOut", function(){
    		
    	});
    	prevDomTarget.animate({left:0}, 300, "expoOut", function(){
			_this.selectedIndex = prevIndex;
			_this.openImage(prevIndex);
    	});
    	return true;
    },
/**
 * 다음 이미지로 이동합니다.
 * @method AXSliderViewer.next
 * @returns {Boolean}
 */
    next: function(){
    	var cfg = this.config, _this = this;
    	var screenWidth = this.screenSize.width;
    	var selectedIndex = this.selectedIndex;
    	if(selectedIndex >= this.list.length-1) return false;
    	var nextIndex = selectedIndex.number() + 1;
    	
    	var nowDomTarget = axdom('#' + cfg.id +'_AX_slide_AX_' + selectedIndex);
    	var nextDomTarget = axdom('#' + cfg.id +'_AX_slide_AX_' + nextIndex);

    	nowDomTarget.animate({left:-screenWidth}, 500, "expoOut", function(){
    		
    	});
    	nextDomTarget.animate({left:0}, 300, "expoOut", function(){
			_this.selectedIndex = nextIndex;
			_this.openImage(nextIndex);
    	});
    	 return true;
    },
	/**
	 * 현재 이미지를 확대 합니다.
	 * @method AXSliderViewer.zoomIn
	 * @returns {AXSliderViewer}
	 */
    zoomIn: function(){
    	var cfg = this.config, _this = this;
    	var item = this.list[this.selectedIndex];
    	
    	var cx = this.screenSize.width/2  - item._boxModel.dL;
    	var cy = this.screenSize.height/2  - item._boxModel.dT;
    	var dLen = (this.screenSize.width>this.screenSize.height) ? this.screenSize.height : this.screenSize.width;
    	this.imgResize(item, item._boxModel, dLen, cx, cy, "animate");
		return this;
    },
	/**
	 * 현재 이미지를 축소 합니다.
	 * @method AXSliderViewer.zoomOut
	 * @returns {AXSliderViewer}
	 */
    zoomOut: function(){
    	var cfg = this.config, _this = this;
    	var item = this.list[this.selectedIndex];
    	var cx = this.screenSize.width/2  - item._boxModel.dL;
    	var cy = this.screenSize.height/2  - item._boxModel.dT;
    	var dLen = (this.screenSize.width>this.screenSize.height) ? this.screenSize.height : this.screenSize.width;
    	this.imgResize(item, item._boxModel, -dLen, cx, cy, "animate");
		return this;
    },
    
    imgResize: function(item, firstBoxModel, dLen, cx, cy, animate){
		//trace(firstBoxModel.dW);
    	//trace(item._boxModel.dW, item._boxModel.dH, item._boxModel.dL, item._boxModel.dT); 조작해야할 변수들
    	var cfg = this.config, _this = this;
    	var css = {}, newW, newH, newL, newT, imgRatio = (item._boxModel.originalHeight / item._boxModel.originalWidth).round(3);
    	
    	if(dLen == null){
    		
    		newL = item._boxModel.left
    		newT = item._boxModel.top
    		newW = item._boxModel.width
    		newH = item._boxModel.height
    		
    	}else{
	    	newW = firstBoxModel.dW + dLen;
	    	newH = newW * imgRatio;
	    	
	    	//firstBoxModel.dW : newW = cx : newL
	    	if(cx == null){
	    		newL = (this.screenSize.width/2);
	    		mewT = (this.screenSize.width/2);
		    	//newL = -(newW * cx / firstBoxModel.dW - cx) + firstBoxModel.dL;
		    	//newT = -(newH * cy / firstBoxModel.dH - cy) + firstBoxModel.dT;
	    	}else{
		    	newL = -(newW * cx / firstBoxModel.dW - cx) + firstBoxModel.dL;
		    	newT = -(newH * cy / firstBoxModel.dH - cy) + firstBoxModel.dT;
		    }
	    }
    	
    	// 영역을 벗어나는 변경에 대해서 감지
    	
    	css = {left:newL, top:newT, width:newW, height:newH, opacity:1};
    	if( this.changeImgCss(item._axdom, css, animate) ){	
	    	//현재아이템에 이동정보 기록
	    	item._boxModel.dL = newL;
	    	item._boxModel.dT = newT;
	    	item._boxModel.dW = newW;
	    	item._boxModel.dH = newH;
	    }
    },
    imgTouchUpdate: function(args){
    	var cfg = this.config;
    	this.touchAndMoved = true;
    	if (this.touhEndObserver) clearTimeout(this.touhEndObserver);
		if(args.moveType == "zoom"){
			var l1dx, l1dy, l2dx, l2dy, l1, l2, dLen;
			l1dx = (args.firstTouch.pageX2 > args.firstTouch.pageX1) ? args.firstTouch.pageX2 - args.firstTouch.pageX1 : args.firstTouch.pageX1 - args.firstTouch.pageX2;
			l1dy = (args.firstTouch.pageY2 > args.firstTouch.pageY1) ? args.firstTouch.pageY2 - args.firstTouch.pageY1 : args.firstTouch.pageY1 - args.firstTouch.pageY2;
			
			l2dx = (args.touch.pageY2 > args.touch.pageY1) ? args.touch.pageY2 - args.touch.pageY1 : args.touch.pageY1 - args.touch.pageY2;
			l2dy = (args.touch.pageY2 > args.touch.pageY1) ? args.touch.pageY2 - args.touch.pageY1 : args.touch.pageY1 - args.touch.pageY2;
			
	    	l1 = Math.sqrt(Math.pow(l1dx, 2) + Math.pow(l1dy, 2)); // 첫번째 터치의 선분의 길이
	    	l2 = Math.sqrt(Math.pow(l2dx, 2) + Math.pow(l2dy, 2)); // 이동중인 터치의 선분의 길이
			
			dLen = ((l2-l1)*1.2).round(3); // 크기 변화량
			if(!isNaN(dLen)){
				//이동량 만큼 이미지를 크게 하거나 줄이기.
				//trace(args.firstTouch.centerX, args.firstTouch.centerY);
				this.imgResize(args.item, args.firstBoxModel, dLen, args.firstTouch.centerX, args.firstTouch.centerY);
			}
	    }else{
	    	var mx, my, newL, newT;
    		mx = (args.firstTouch.centerX - args.touch.centerX).round();
    		my = (args.firstTouch.centerY - args.touch.centerY).round();
    		
    		if(this._mx == null){
    			this.velocityDX = 0;
				this.velocityDY = 0;
    		}else{
				this.velocityDX = this._mx - mx;
				this.velocityDY = this._my - my;
			}
    		
    		this._mx = mx;
    		this._my = my;
    		
    		if(args.item._boxModel.width == args.item._boxModel.dW){ // zoom 이 되지 않았을 때
    			if(mx.abs() > my.abs()){
					newL = args.firstBoxModel.dL - mx;
					newT = args.firstBoxModel.dT;
    			}else{
					newL = args.firstBoxModel.dL;
					newT = args.firstBoxModel.dT - my;
    			}
    		}else{
				newL = args.firstBoxModel.dL - mx;
				newT = args.firstBoxModel.dT - my;
    		}
			
			if( this.changeImgCss(args.item._axdom, {left:newL, top:newT}) ){
				
			}
	    }
    },
    imgTouchEnd: function(args, event){
    	var cfg = this.config, _this = this;
    	var pos = args.item._axdom.position();
    	
    	args.item._boxModel.dL = pos.left;
    	args.item._boxModel.dT = pos.top;
    	
    	var sL = 0, eL = 0, sT = 0, eT = 0, scW = this.screenSize.width, scH = this.screenSize.height, iW = args.item._axdom.width(), iH = args.item._axdom.height();
    	
    	//trace(pos.left, this.velocityDX);
    	
    	var imgAnmate = false;
    	if(args.moveType == "move"){
    		var css = {left:pos.left + (this.velocityDX||0)*10, top:pos.top + (this.velocityDY||0)*10, opacity:1};
    	}else{
    		var css = {left:pos.left, top:pos.top, opacity:1};
    	}
    	var __left = css.left, __top = css.top;
    	
    	if(iW < scW && iH < scH){
    		iW = css.width = args.item._boxModel.width;
    		iH = css.height  = args.item._boxModel.height;
    	}

    	if(iW < scW){
    		sL = (scW - iW) / 2;
    		eL = sL;
    	}else{
    		sL = 0;
    		eL = scW - iW;
    	}
    	if(iH < scH){
    		sT = (scH - iH) / 2;
    		eT = sT;
    	}else{
    		sT = 0;
    		eT = scH - iH;
    	}

    	if(css.left > sL ){
    		if(args.moveType == "move"){
    			if( (css.left + iW) - scW > scW * 0.35 ){
    				if(this.prev()) return "prev";
    			}
    		}
    		css.left = sL;
    		imgAnmate = true;
    	}else if(css.left < eL ){
    		if(args.moveType == "move"){
    			if( (css.left + iW) < scW * 0.35 ){
    				if(this.next()) return "next";
    			}
    		}
    		css.left = eL;
    		imgAnmate = true;
    	}
    	if(css.top > sT ){
    		if(args.moveType == "move" && args.item._boxModel.width == args.item._boxModel.dW){
    			if( (css.top + iH) - scH > scH * 0.35 ){
    				this.close();
    				return "close";
    			}
    		}
    		css.top = sT;imgAnmate = true;
    	}else if(css.top < eT ){
    		if(args.moveType == "move" && args.item._boxModel.width == args.item._boxModel.dW){
    			if( (css.top + iH) < scH * 0.35 ){
    				this.close();
    				return "close";
    			}
    		}
    		css.top = eT;imgAnmate = true;
    	}
    	if(imgAnmate){
    		args.item._axdom.stop();
    		args.item._axdom.animate(css);
	    	if(!isNaN(css.left)) args.item._boxModel.dL = css.left;
	    	if(!isNaN(css.top)) args.item._boxModel.dT = css.top;
	    	if(args.moveType == "zoom"){
		    	if(!isNaN(css.width)) args.item._boxModel.dW = css.width;
		    	if(!isNaN(css.height)) args.item._boxModel.dH = css.height;
	    	}
    	}
    	
    	this._mx = null;
    	this._my = null;

		if( !this.touchAndMoved ){
			if(this.touchClicked){
				//trace("dbl click");
				this.imgDblClick(args.item, event);
				this.touchDblClicked = true;
			}else{
				this.touchClicked = true;
			}
		}

		this.touhEndObserver = setTimeout(function () {
	    	if( !_this.touchAndMoved && !_this.touchDblClicked && _this.touchClicked){
	    		_this.imgClick(args.item, event);
	    	}
			_this.touchClicked = false; // 0.3후에 이전 터치 상태 해제
			_this.touchDblClicked = false;
			_this.touchAndMoved = false;
		}, 200);
    },
    changeImgCss: function(img, css, animate){
    	if(css.width != undefined && css.width < 100) return;
    	//img.stop();
    	if(animate){
    		img.animate(css);
    	}else{
    		img.css(css);
    	}
    	return css;
    },
    imgClick: function(item, event){
    	//trace("imgClick");
    	var cfg = this.config;
    	this.controller.toggle();
		this.touchClicked = false; // 0.3후에 이전 터치 상태 해제
		this.touchDblClicked = false;
    },
    imgDblClick: function(item, event){
    	//trace("imgDblClick");
    	var cfg = this.config;
    	
    	if(item._boxModel.dW > this.screenSize.width){
    		this.imgResize(item, this.touchUpdater.firstBoxModel, null, this.touchUpdater.firstTouch.centerX, this.touchUpdater.firstTouch.centerY, "animate");
    		//this.renderImage( axdom('#' + cfg.id +'_AX_slide_AX_' + this.selectedIndex), item);
    	}else{
	    	var dLen = this.screenSize.width * 2;
	    	this.imgResize(item, this.touchUpdater.firstBoxModel, dLen, this.touchUpdater.firstTouch.centerX, this.touchUpdater.firstTouch.centerY, "animate");
	    }
		this.touchClicked = false; // 0.3후에 이전 터치 상태 해제
		this.touchDblClicked = false;
    }
});
/* ---------------------------- */
var AXTabClass = Class.create(AXJ, {
    initialize: function(AXJ_super) {
        AXJ_super();
        this.objects = [];
        this.config.handleWidth = 22;
        this.config.responsiveMobile = AXConfig.mobile.responsiveWidth;
        this.config.bounces = true;
        this.config.closable = ( (AXConfig && AXConfig.AXTab && AXConfig.AXTab.closable) ? AXConfig.AXTab.closable : false );
    },
    init: function(){
        axdom(window).bind("resize", this.windowResize.bind(this));
    },
    windowResize: function () {
        var windowResizeApply = this.windowResizeApply.bind(this);
        if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
        this.windowResizeObserver = setTimeout(function () {
            windowResizeApply();
        }, 500);
    },
    windowResizeApply: function(){
        this.resizeCheck();
    },
    /**
     * @method AXTabClass.bind
     * @param {Object} obj - config
     * @description 대상에 탭 속성을 부여 합니다.
     * @returns {AXTab}
     * @example
     * ```js
     * $("#myTab01").bindTab({
     *     theme : "AXTabs",
     *     value:"2",
     *     closable: false,
     *     options:[
     *         {optionValue:"1", optionText:"1살", closable: true},
     *         {optionValue:"2", optionText:"2살", closable: true},
     *         {optionValue:"3", optionText:"3살", addClass:"Red"},
     *         {optionValue:"4", optionText:"4살", addClass:"Blue"},
     *         {optionValue:"5", optionText:"5살", addClass:"Green"},
     *         {optionValue:"6", optionText:"6살", addClass:"Classic"},
     *         {optionValue:"7", optionText:"7살"}
     *     ],
     *     onchange: function(selectedObject, value){
     *         //toast.push(Object.toJSON(this));
     *         //toast.push(Object.toJSON(selectedObject));
     *         toast.push(Object.toJSON(value));
     *     },
     *     onclose: function(selectedObject, value) {
     *         //toast.push(Object.toJSON(this));
     *         //toast.push(Object.toJSON(selectedObject));
     *         toast.push(Object.toJSON(value));
     *     }
     * });
     * ```
     */
    bind: function (obj) {
        var cfg = this.config;

        if (!obj.id) {
            trace("bind 대상 ID가 없어 bind 처리할 수 없습니다.");
            return;
        }
        if (!AXgetId(obj.id)) {
            trace("bind 대상이 없어 bind 처리할 수 없습니다.");
            return;
        }

		var objID = obj.id;
		var objSeq = null;

		obj.theme = (obj.theme || "AXTabs");
		obj.overflow = (obj.overflow || "visible");
		obj.scrollAmount = (obj.scrollAmount || 5);
		obj.options = (obj.options || [{optionValue:"null", optionText:"빈 탭"}]);

        axdom.each(this.objects, function (idx, O) {
            if (this.id == objID){
            	objSeq = idx;
            	return false;
            }
        });
		if (objSeq == null) {
			objSeq = this.objects.length;
			this.objects.push({ id: objID, config: obj});
		}else{
			this.objects[objSeq].isDel = undefined;
			this.objects[objSeq].config = obj;
		}

		if(objSeq != null){
			this.initTab(objID, objSeq);
		}else{
			trace("object find error");
		}
    },
    /**
     * @method AXTabClass.initTab
     * @param {String} objID - 탭 대상 ID
	 * @param {Number} objSeq - 대상 순서 seq
     * @description 탭을 초기화 합니다.
     * @returns {AXTab}
	 */
    initTab: function(objID, objSeq){
    	//trace({objID:objID, objSeq:objSeq});
    	var cfg = this.config, _this = this;
    	var obj = this.objects[objSeq];

		var po = [];
	    var subOptions = [];
		po.push("<div class=\"" + obj.config.theme + "\" id=\"" + objID + "_AX_tabContainer\">");
			po.push("<div class=\"AXTabsTray\" id=\"" + objID + "_AX_tabTray\">");
				if(obj.config.overflow != "visible"){
				po.push("	<div class=\"trayScroll\" id=\"" + objID + "_AX_tabScroll\">");
				}
				po.push("	<div class=\"clear\"></div>");
			if(obj.config.overflow != "visible"){
			po.push("	</div>");
			po.push("	<div class=\"leftArrowHandleBox\" style=\"display:none;\"><a href=\"javascript:;\" class=\"tabArrow\" id=\"" + objID + "_AX_Arrow_AX_Left\">arrow</a></div>");
			po.push("	<div class=\"rightArrowHandleBox\" style=\"display:none;\"><a href=\"javascript:;\" class=\"tabArrow\" id=\"" + objID + "_AX_Arrow_AX_Right\">arrow</a></div>");
			po.push("	<div class=\"rightArrowMoreBox\" style=\"display:none;\"><a href=\"javascript:;\" class=\"tabArrow\" id=\"" + objID + "_AX_Arrow_AX_More\">arrow</a></div>");
			}
			po.push("</div>");

			if(subOptions.length > 0){
				// subOptions :
			}
		po.push("</div>");

		obj.jQueryObjID = axdom("#"+objID);
		obj.jQueryObjID.html(po.join(''));
		obj.jQueryObjID.data("objSeq", objSeq); /* memory objSeq */

		obj.tabTray = axdom("#" + objID + "_AX_tabTray");
		obj.tabScroll = axdom("#" + objID + "_AX_tabScroll");
		obj.tabContainer = axdom("#" + objID + "_AX_tabContainer");

		AXContextMenu.bind({
			id:objID + "_AX_tabMore",
			theme:"AXContextMenu", // 선택항목
			width:"200", // 선택항목
			menu:[]
		});

		this.addTabs(objID, obj.config.options);

		var bindTabMove = this.bindTabMove.bind(this);
		var bindTabMoveClick = this.bindTabMoveClick.bind(this);
		var bindTabMoreClick = this.bindTabMoreClick.bind(this);

		axdom("#" + objID + "_AX_Arrow_AX_Left").bind("mouseover", function(event){
			bindTabMove(objID, objSeq, "left", event);
		});
		axdom("#" + objID + "_AX_Arrow_AX_Right").bind("mouseover", function(event){
			bindTabMove(objID, objSeq, "right", event);
		});
		axdom("#" + objID + "_AX_Arrow_AX_Left, #" + objID + "_AX_Arrow_AX_Right").bind("mouseout", function(event){
			if(obj.moveobj) clearTimeout(obj.moveobj);
		});
		axdom("#" + objID + "_AX_Arrow_AX_Left").bind("mousedown", function(event){
			bindTabMoveClick(objID, objSeq, "left", event);
		});
		axdom("#" + objID + "_AX_Arrow_AX_Right").bind("mousedown", function(event){
			bindTabMoveClick(objID, objSeq, "right", event);
		});
		axdom("#" + objID + "_AX_Arrow_AX_More").bind("click", function(event){
			bindTabMoreClick(objID, objSeq, "right", event);
		});

		if(obj.overflow != "visible"){
			setTimeout(function(){
				var tabsWidth = (axf.clientWidth() < cfg.responsiveMobile) ? 40 : 30;
				var tabsMargin = (axf.clientWidth() < cfg.responsiveMobile) ? 5 : 5;
				obj.tabContainer.find(".AXTab").each(function(){
					tabsWidth += (axdom(this).outerWidth().number() + axdom(this).css("marginLeft").number() + axdom(this).css("marginRight").number() + tabsMargin);
				});

				obj.tabScroll.css({width:tabsWidth, left:cfg.handleWidth});
				obj.tabTray.css({height:obj.tabScroll.outerHeight()});

				var trayWidth = obj.tabTray.outerWidth();
				var scrollWidth = obj.tabScroll.outerWidth();

				if(trayWidth > scrollWidth){
					obj.tabContainer.find(".leftArrowHandleBox").hide();
					obj.tabContainer.find(".rightArrowHandleBox").hide();
					obj.tabContainer.find(".rightArrowMoreBox").hide();
					obj.tabScroll.css({left:0});
				}else if(obj.config.selectedIndex != null){
					obj.tabContainer.find(".leftArrowHandleBox").show();
					obj.tabContainer.find(".rightArrowHandleBox").show();
					obj.tabContainer.find(".rightArrowMoreBox").show();
					_this.focusingItem(objID, objSeq, obj.config.selectedIndex);
				}

				if(trayWidth < scrollWidth && AXUtil.clientWidth() < cfg.responsiveMobile){
					obj.tabContainer.find(".leftArrowHandleBox").hide();
					obj.tabContainer.find(".rightArrowHandleBox").hide();
					obj.tabScroll.css({left:0});
				}else{

				}

				/* touch event */
				var touchstart = _this.touchstart.bind(_this);
				if(AXUtil.browser.mobile){
					var touchBodyID = obj.tabTray.get(0).id;
					_this.touchstartBind = function () { touchstart(objID, objSeq); };
					if (document.addEventListener) AXgetId(touchBodyID).addEventListener("touchstart", _this.touchstartBind, false);
				}else{
					_this.touchstartBind = function (event) { touchstart(objID, objSeq, event); };
					obj.tabTray.unbind("mousedown.AXMobileTouch").bind("mousedown.AXMobileTouch", _this.touchstartBind);
				}
				obj.tabTray.attr("onselectstart", "return false");
				obj.tabTray.addClass("AXUserSelectNone");

				obj.tabTray.unbind("dragstart.AXMobileTouch").bind("dragstart.AXMobileTouch", _this.cancelEvent.bind(_this));
				/* touch event */
			}, 50);
		}
	},
	/**
	 * @method AXTabClass.addTabs
	 * @param {String} objID - 탭 대상 ID
	 * @param {Array} options - 대상 순서 seq
	 * @description 탭을 추가 합니다.
	 * @returns {AXTab}
	 * @example
	 * ```js
	 * $("#myTab01").addTabs([
	 *     {optionValue:"1", optionText:"1살", closable: true},
	 *     {optionValue:"2", optionText:"2살", closable: true},
	 *     {optionValue:"3", optionText:"3살", addClass:"Red"},
	 *     {optionValue:"4", optionText:"4살", addClass:"Blue"},
	 *     {optionValue:"5", optionText:"5살", addClass:"Green"},
	 *     {optionValue:"6", optionText:"6살", addClass:"Classic"},
	 *     {optionValue:"7", optionText:"7살"}
	 * ]);
	 * ```
	 */
	addTabs: function(objID, options){
		var cfg = this.config;
		var objSeq = axdom("#" + objID).data("objSeq");
		var obj = this.objects[objSeq];
		var po = [];
		var target;
		if(obj.config.overflow == "visible"){
			target = axdom("#" + objID + "_AX_tabTray div.clear");
		}else{
			target = axdom("#" + objID + "_AX_tabScroll div.clear");
		}

		var tabsCnt = obj.tabContainer.find(".AXTab").length;
		var selectedIndex = null;
		axdom.each(options, function(oidx, O){
			var closable = O.closable || obj.config.closable || cfg.closable;
			oidx += tabsCnt;

			po.push("<a href=\"javascript:;\" id=\"" + objID + "_AX_Tabs_AX_"+oidx+"\" class=\"AXTab " + (O.addClass || ""));
			if(closable){
				po.push(" closable");
			}
			if(O.optionValue == obj.config.value){
				selectedIndex = oidx;
				po.push(" on");
			}
			po.push("\">");
			po.push(O.optionText.dec());
			if(closable){
				po.push("<span class=\"AXTabClose\"></span>");
			}
			po.push("</a>");
			//if(AXUtil.browser.mobile){
				po.push("<span class='AXTabSplit'></span>");
			//}
		});

		if(selectedIndex != null){
			obj.config.selectedIndex = selectedIndex;
		}
		target.before(po.join(""));

		var tabsWidth = (axf.clientWidth() < cfg.responsiveMobile) ? 40 : 30;
		var tabsMargin = (axf.clientWidth() < cfg.responsiveMobile) ? 5 : 5;
		obj.tabContainer.find(".AXTab").each(function(){
			tabsWidth += (axdom(this).outerWidth().number() + axdom(this).css("marginLeft").number() + axdom(this).css("marginRight").number() + tabsMargin);
		});
		obj.tabScroll.css({width:tabsWidth});

		var setValueTab = this.setValueTab.bind(this);
		var myMenu = [];
		axdom.each(obj.config.options, function(oidx, O){
			myMenu.push({label:O.optionText, value:O.optionValue, className:"", onclick:function(){
				//trace(this);
				setValueTab(objID, this.menu.value);
			}});
		});

		var tabMoreID = objID + "_AX_tabMore";
		axdom.each(AXContextMenu.objects, function(oidx, O){
			if(O.id == tabMoreID){
				O.menu = myMenu;
				return false; // break;
			}
		});

		var bindTabClick = this.bindTabClick.bind(this);
		obj.tabContainer.find(".AXTab").unbind("click").bind("click", function(event){
			bindTabClick(objID, objSeq, event);
		});

		var closeTab = this.closeTab.bind(this);
		obj.tabContainer.find(".AXTabClose").unbind("click").bind("click", function(event){
			var tabIndex = obj.tabContainer.find(".AXTab").index(axdom(event.target).parent());
			if (tabIndex === -1) { return; }
			closeTab(objID, tabIndex, event);
		});

    this.resizeCheck();
	},
	/**
	 * @method AXTabClass.closeTab
	 * @param {String} objID - 탭 대상 ID
	 * @param {Number|String} [tabIndex or options] - 탭 인덱스(Number) or optionValue(String)
	 * @description 탭을 닫습니다.
	 * @returns {AXTab}
	 * @example
 	 * ```js
 	 * $("#myTab01").closeTab(2);
 	 * $("#myTab01").closeTab("optionValue");
 	 * ```
	 */
	closeTab: function(objID, tabIndex, event) {
		var objSeq = axdom("#" + objID).data("objSeq");
		var obj    = this.objects[objSeq];

        if (!obj.config.options) { return; }

        tabIndex = (tabIndex === undefined ? (obj.config.options.length - 1) : tabIndex);
        // find tabIndex by optionValue
        if (typeof(tabIndex) != "number") {
            axdom.each(obj.config.options, function(oidx, O){
                if (O.optionValue === tabIndex) {
                    tabIndex = oidx;
                    return false;
                }
            });
        }

        var removeTargetOption = obj.config.options.splice(tabIndex, 1)[0]; // remove and store target optoin

        // selected tab update
        if(obj.config.selectedIndex == tabIndex){
            var selectedIndex = tabIndex - 1;
            if (selectedIndex > -1) {
                this.setValueTab(objID, obj.config.options[selectedIndex].optionValue);
            } else {
                this.setValueTab(objID, obj.config.options[0].optionValue);
            }
        }else if(obj.config.selectedIndex > tabIndex){
            var selectedIndex = obj.config.selectedIndex - 1;
            if (selectedIndex > -1) {
                obj.config.selectedIndex = selectedIndex;
            }
        }

        // reinit tabs
		this.initTab(objID, objSeq);

        // fire onclose event
        if (axdom.isFunction(obj.config.onclose)) {
            obj.config.onclose.call({
                options:obj.config.options,
                item:removeTargetOption,
                index:tabIndex
            }, removeTargetOption, removeTargetOption.optionValue);
        }
	},
    /**
     * @method AXTabClass.bindTabClick
     * @param {String} objID - 탭 대상 ID
	 * @param {Number} objSeq - 대상 순서 seq
	 * @param {Event} event - Click event
     * @description 탭을 클릭 할때 처리를 합니다.
     * @returns {AXTab}
	 */
    bindTabClick: function(objID, objSeq, event){
    	//trace({objID:objID, objSeq:objSeq, e:event.target.id});
    	var cfg = this.config;
    	var obj = this.objects[objSeq];

		// event target search -
		var eid = event.target.id.split(/_AX_/g);
		var eventTarget = event.target;
		var myTarget = this.getEventTarget({
			evt: eventTarget, evtIDs: eid,
			until: function (evt, evtIDs) { return (axdom(evt.parentNode).hasClass("AXTabsTray")) ? true : false; },
			find: function (evt, evtIDs) { return (axdom(evt).hasClass("AXTab")) ? true : false; }
		});
		// event target search ------------------------


	    if (myTarget) {
		    //colHeadTool ready
		    var targetID = myTarget.id;
		    var itemIndex = targetID.split(/_AX_/g).last();

		    //trace(obj.config.options[itemIndex]);

		    var selectedObject = obj.config.options[itemIndex];
		    if(selectedObject && obj.config.value != selectedObject.optionValue){

			    axdom("#" + objID + "_AX_Tabs_AX_"+obj.config.selectedIndex).removeClass("on");
			    axdom("#" + objID + "_AX_Tabs_AX_"+itemIndex).addClass("on");

			    obj.config.value = selectedObject.optionValue;
			    obj.config.selectedIndex = itemIndex;

			    this.focusingItem(objID, objSeq, obj.config.selectedIndex);
			    if(obj.config.onclick){
				    obj.config.onclick.call({
					    options:obj.config.options,
					    item:obj.config.options[itemIndex],
					    index:itemIndex
				    }, obj.config.options[itemIndex], obj.config.options[itemIndex].optionValue);
			    }

			    if(obj.config.onchange){
				    obj.config.onchange.call({
					    options:obj.config.options,
					    item:obj.config.options[itemIndex],
					    index:itemIndex
				    }, obj.config.options[itemIndex], obj.config.options[itemIndex].optionValue);
			    }
		    }else{
			    if(obj.config.onclick){
				    obj.config.onclick.call({
					    options:obj.config.options,
					    item:obj.config.options[itemIndex],
					    index:itemIndex
				    }, obj.config.options[itemIndex], obj.config.options[itemIndex].optionValue);
			    }
		    }

	    }
    },
    /**
     * @method AXTabClass.setValueTab
     * @param {String} objID - 탭 대상 ID
     * @param {String} value - 값
     * @description 탭의 선택값을 변경 합니다.
     * @returns {AXTab}
     * @example
     * ```js
     * AXTab.setValueTab('myTab01','F');
     * ```
     */
    setValueTab: function(objID, value){
    	//trace({objID:objID, value:value});
		var cfg = this.config;
		var objSeq = null;
		axdom.each(this.objects, function(index, O){
			if(O.id == objID){
				objSeq = index;
				return false;
			}
		});
		if(objSeq == null){
			//trace("바인드 된 오브젝트를 찾을 수 없습니다.");
			return;
		}else{

			var obj = this.objects[objSeq];

			var itemIndex = null;
			axdom.each(obj.config.options, function(oidx, O){
				if(O.optionValue == value){
					itemIndex = oidx;
					return false;
				}
			});

			if(itemIndex == null) return;

			var selectedObject = obj.config.options[itemIndex];
			if(obj.config.value != selectedObject.optionValue){

				var tabs = obj.tabContainer.find(".AXTab");
				tabs.eq(obj.config.selectedIndex).removeClass("on");
				tabs.eq(itemIndex).addClass("on");
				/*  */
				this.focusingItem(objID, objSeq, itemIndex);

				obj.config.value = selectedObject.optionValue;
				obj.config.selectedIndex = itemIndex;

				if(obj.config.onchange){
					obj.config.onchange.call({
						options:obj.config.options,
						item:obj.config.options[itemIndex],
						index:itemIndex
					}, obj.config.options[itemIndex], obj.config.options[itemIndex].optionValue);
				}
			}

		}
    },
    /**
     * @method AXTabClass.bindTabMove
     * @param {String} objID - 탭 대상 ID
	 * @param {Number} objSeq - 대상 순서 seq
 	 * @param {String} direction - "left"||"right"
	 * @param {Event} event - "mouseover"
     * @description 탭의 양이 많아질때 생성되는 좌우 이동 화살표의 mouseover 이벤트를 처리 합니다.
     * @returns {AXTab}
	 */
    bindTabMove: function(objID, objSeq, direction, event){
    	//trace({objID:objID, objSeq:objSeq});
    	var cfg = this.config;
    	var obj = this.objects[objSeq];

		var trayWidth = obj.tabTray.outerWidth();
    	if(AXUtil.clientWidth() < cfg.responsiveMobile){
    		var rightMargin = 40;
    	}else{
    		var rightMargin = 29 + cfg.handleWidth;
    	}
    	trayWidth -= rightMargin;
		var scrollWidth = obj.tabScroll.outerWidth();
		var scrollLeft = obj.tabScroll.position().left;

		//trace({trayWidth:trayWidth, scrollWidth:scrollWidth, scrollLeft:scrollLeft});

		var animateStyles = {};
		if(direction == "left"){
			if(scrollLeft < cfg.handleWidth){
				scrollLeft += obj.config.scrollAmount;
				animateStyles = {left:scrollLeft};
			}else{
				return;
			}
			if(scrollLeft > cfg.handleWidth){
				//trace({trayWidth:(trayWidth - cfg.handleWidth), scrollWidth:scrollWidth, scrollLeft:scrollLeft});
				scrollLeft = cfg.handleWidth;
				animateStyles = {left:scrollLeft};
			}
		}else{
			if(trayWidth < (scrollWidth + scrollLeft)){
				scrollLeft -= obj.config.scrollAmount;
				animateStyles = {left:scrollLeft};
			}else{

			}

			if((trayWidth) > (scrollWidth + scrollLeft)){
				/*trace({trayWidth:(trayWidth - cfg.handleWidth), scrollWidth:scrollWidth, scrollLeft:scrollLeft}); */
				scrollLeft = trayWidth - scrollWidth - cfg.handleWidth;
				animateStyles = {left:scrollLeft};
			}else{
				//return;
			}

		}

		obj.tabScroll.css(animateStyles);

		var bindTabMove = this.bindTabMove.bind(this);

		if(obj.moveobj) clearTimeout(obj.moveobj);

		//trace("move");

		obj.moveobj = setTimeout(function(){
			bindTabMove(objID, objSeq, direction, event);
		}, 20);


		/*
		obj.tabScroll.animate(
			animateStyles,
			500,
			"sineInOut",
			function(){
			}
		);
		*/

    },
    /**
     * @method AXTabClass.bindTabMove
     * @param {String} objID - 탭 대상 ID
	 * @param {Number} objSeq - 대상 순서 seq
 	 * @param {String} direction - "left"||"right"
	 * @param {Event} event - "mousedown"
     * @description 탭의 양이 많아질때 생성되는 좌우 이동 화살표의 mousedown 이벤트를 처리 합니다.
     * @returns {AXTab}
	 */
	bindTabMoveClick: function(objID, objSeq, direction, event){
    	var cfg = this.config;
    	var obj = this.objects[objSeq];

    	if(obj.moveobj) clearTimeout(obj.moveobj);

		var scrollAmount = 500;

		var trayWidth = obj.tabTray.outerWidth();
    	if(AXUtil.clientWidth() < cfg.responsiveMobile){
    		var rightMargin = 40;
    	}else{
    		var rightMargin = 29 + cfg.handleWidth;
    	}
    	trayWidth -= rightMargin;
		var scrollWidth = obj.tabScroll.outerWidth();
		var scrollLeft = obj.tabScroll.position().left;

		//trace({trayWidth:trayWidth, scrollWidth:scrollWidth, scrollLeft:scrollLeft});

		var animateStyles = {};
		if(direction == "left"){
			if(scrollLeft < cfg.handleWidth){
				scrollLeft += scrollAmount;
				animateStyles = {left:scrollLeft};
			}else{
				return;
			}
			if(scrollLeft > cfg.handleWidth){
				scrollLeft = cfg.handleWidth;
				animateStyles = {left:scrollLeft};
			}
		}else{
			if(trayWidth < (scrollWidth + scrollLeft)){
				scrollLeft -= scrollAmount;
				animateStyles = {left:scrollLeft};
			}else{

			}

			if((trayWidth-cfg.handleWidth) > (scrollWidth + scrollLeft)){
				//trace({trayWidth:(trayWidth - cfg.handleWidth), scrollWidth:scrollWidth, scrollLeft:scrollLeft});
				scrollLeft = trayWidth - scrollWidth - cfg.handleWidth;
				animateStyles = {left:scrollLeft};
			}else{
				//return;
			}

		}

		obj.tabScroll.stop();
		obj.tabScroll.animate(
			animateStyles,
			500,
			"sineInOut",
			function(){
			}
		);

		if (event.preventDefault) event.preventDefault();
		if (event.stopPropagation) event.stopPropagation();
		event.cancelBubble = true;
		return false;
    },
    /**
     * @method AXTabClass.bindTabMoreClick
     * @param {String} objID - 탭 대상 ID
	 * @param {Number} objSeq - 대상 순서 seq
 	 * @param {String} direction - "left"||"right"
	 * @param {Event} event - "click"
     * @description 탭의 양이 많아질때 생성되는 탭 리스트 툴 화살표에 대한 "click" 이벤트를 처리 합니다.
     * @returns {AXContextMenu}
	 */
    bindTabMoreClick: function(objID, objSeq, direction, event){
    	var cfg = this.config;
    	var obj = this.objects[objSeq];
        if(axf.clientWidth() < cfg.responsiveMobile) {
            AXContextMenu.setConfig({responsiveMobile: 640});
            /* mobile 너비 지정 */
        }
    	AXContextMenu.open({id:objID + "_AX_tabMore", title:AXConfig.AXContextMenu.title}, event);
    },
    /**
     * @method AXTabClass.resizeCheck
     * @description 윈도우 창 크기가 변경 되었을때를 감지하여 처리 합니다.
     * @returns {AXTab}
	 */
    resizeCheck: function(){
    	var cfg = this.config;
    	var focusingItem = this.focusingItem.bind(this);

    	axdom.each(this.objects, function(objSeq, O){
    		var objID = this.id;
    		var obj = this;
			var trayWidth = obj.tabTray.outerWidth();
			var scrollWidth = obj.tabScroll.outerWidth();
			if(trayWidth > scrollWidth){
				obj.tabContainer.find(".leftArrowHandleBox").hide();
				obj.tabContainer.find(".rightArrowHandleBox").hide();
				obj.tabContainer.find(".rightArrowMoreBox").hide();
				obj.tabScroll.css({left:0});
			}else{
				if(AXUtil.clientWidth() < cfg.responsiveMobile){
					obj.tabContainer.find(".leftArrowHandleBox").hide();
					obj.tabContainer.find(".rightArrowHandleBox").hide();
				}else{
					obj.tabContainer.find(".leftArrowHandleBox").show();
					obj.tabContainer.find(".rightArrowHandleBox").show();
				}
				obj.tabContainer.find(".rightArrowMoreBox").show();
				if(!AXUtil.isEmpty(obj.config.selectedIndex)) focusingItem(objID, objSeq, obj.config.selectedIndex);
			}
			obj.tabTray.css({height:obj.tabScroll.outerHeight()});
    	});
    },
	/**
	 * @method AXTabClass.focusingItem
	 * @param {String} objID - 탭 대상 ID
	 * @param {Number} objSeq - 대상 순서 seq
	 * @param {Number} optionIndex - 탭 아이템 index
	 * @description 대상의 해당 index에 해당하는 탭에 focus를 줍니다.
	 * @returns {AXTab}
	 */
	focusingItem: function(objID, objSeq, optionIndex){
		var cfg = this.config;
		var obj = this.objects[objSeq];

		if(!obj.tabScroll.position()) return;

		if(obj.tabTray.outerWidth() > obj.tabScroll.outerWidth()){
			return;
		}

		var tabs = obj.tabContainer.find(".AXTab");
		var targetTab = tabs.eq(optionIndex);
		if(AXUtil.clientWidth() < cfg.responsiveMobile){
			var scrollLeft = (targetTab.position().left);
			var itemWidth = (targetTab.outerWidth());
			var handleWidth = 0;
			var rightMargin = 40;
		}else{
			var scrollLeft = (targetTab.position().left - cfg.handleWidth);
			var itemWidth = (targetTab.outerWidth());
			var handleWidth = cfg.handleWidth;
			var rightMargin = 29 + cfg.handleWidth;
		}

		/*trace({scrollLeft:scrollLeft, tsLeft:obj.tabScroll.position().left.abs(), trayWidth:obj.tabTray.outerWidth(), itemWidth:itemWidth, tt:(obj.tabScroll.position().left.abs() + obj.tabTray.outerWidth() - rightMargin - handleWidth	)});*/
		if(scrollLeft > (obj.tabScroll.position().left).abs() && (scrollLeft + itemWidth) <= (obj.tabScroll.position().left.abs() + obj.tabTray.outerWidth() - rightMargin - handleWidth)){
			//trace(11);
		}else{
			//trace(obj.tabTray.outerWidth(), handleWidth, obj.tabScroll.outerWidth(), scrollLeft);
			if(obj.tabTray.outerWidth() - handleWidth > (obj.tabScroll.outerWidth() - scrollLeft)){
				//trace(scrollLeft);
				scrollLeft = (obj.tabScroll.outerWidth() - obj.tabTray.outerWidth()) + rightMargin;
			}
			//trace({left:-scrollLeft});
			setTimeout(function(){
				obj.tabScroll.css({left:-scrollLeft});
			}, 10);
		}
    },

    /* 터치 이동관련 함수 - s */
	touchstart: function (objID, objSeq, e) {
		if (this.touhEndObserver) clearTimeout(this.touhEndObserver);
		if (this.touhMoveObserver) clearTimeout(this.touhMoveObserver);

		var cfg = this.config;
		var obj = this.objects[objSeq];

		var trayWidth = obj.tabTray.outerWidth();
		var scrollWidth = obj.tabScroll.outerWidth();

		if(trayWidth > scrollWidth){
			return;
		}

		var touch;
		var event = window.event;
		if (AXUtil.browser.mobile){
			touch = event.touches[0];
			if (!touch.pageX) return;
		}else{
			var event = e;
			touch = {
				pageX : e.pageX,
				pageY : e.pageY
			};
		}

		this.touchStartXY = {
			sTime: ((new Date()).getTime() / 1000),
			sLeft:  obj.tabScroll.position().left,
			x: touch.pageX,
			y: touch.pageY
		};

		var touchEnd = this.touchEnd.bind(this);
		var touchMove = this.touchMove.bind(this);

		if(AXUtil.browser.mobile){
			var event = window.event;
			this.touchEndBind = function () {
				touchEnd(objID, objSeq);
			};
			this.touchMoveBind = function () {
				touchMove(objID, objSeq);
			};
			if (document.addEventListener) {
				document.addEventListener("touchend", this.touchEndBind, false);
				document.addEventListener("touchmove", this.touchMoveBind, false);
			}
		}else{

			this.touchEndBind = function (event) {
				touchEnd(objID, objSeq, event);
			};
			this.touchMoveBind = function (event) {
				touchMove(objID, objSeq, event);
			};

			axdom(document.body).bind("mouseup.AXMobileTouch", this.touchEndBind);
			axdom(document.body).bind("mousemove.AXMobileTouch", this.touchMoveBind);
		}

		var minLeft = 0;
		var maxLeft = - (this.touchStartXY.scrollWidth - this.touchStartXY.targetWidth);
		var scrollPosition = obj.tabScroll.position();

		if(scrollPosition.left < minLeft && scrollPosition.left > maxLeft){
			obj.tabScroll.stop();
		}
	},
	touchMove: function (objID, objSeq, e) {
		if (this.touhEndObserver) clearTimeout(this.touhEndObserver);
		if (this.touhMoveObserver) clearTimeout(this.touhMoveObserver);

		var cfg = this.config;
		var obj = this.objects[objSeq];

		var touch;
		var event = window.event;
		if (AXUtil.browser.mobile){
			touch = event.touches[0];
			if (!touch.pageX) return;
		}else{
			var event = e;
			touch = {
				pageX : e.pageX,
				pageY : e.pageY
			};
		}

		if ((this.touchStartXY.x - touch.pageX).abs() < (this.touchStartXY.y - touch.pageY).abs()) {
			//this.touchMode = ((this.touchStartXY.y - touch.pageY) <= 0) ? "up" : "dn"; /* 위아래 이동 */
		} else if ((this.touchStartXY.x - touch.pageX).abs() > (this.touchStartXY.y - touch.pageY).abs()) {
			//this.touchMode = ((this.touchStartXY.x - touch.pageX) <= 0) ? "lt" : "rt"; /* 좌우 이동 */
			this.moveBlock(objID, objSeq, touch.pageX - this.touchStartXY.x);
			if (event.preventDefault) event.preventDefault();
			else return false;
		}
		if (((this.touchStartXY.x - touch.pageX).abs() - (this.touchStartXY.y - touch.pageY).abs()).abs() < 5) {
			//this.touchSelecting = true;
		}

		var touchMoveAfter = this.touchMoveAfter.bind(this);
		this.touhMoveObserver = setTimeout(function () {
			touchMoveAfter(touch, objID, objSeq);
		}, 50);
	},
	touchMoveAfter: function(touch, objID, objSeq){
		var cfg = this.config;
		var obj = this.objects[objSeq];
		try{
			this.touchStartXY.sTime = ((new Date()).getTime() / 1000);
			this.touchStartXY.sLeft = obj.tabScroll.position().left;
			this.touchStartXY.x = touch.pageX;
			this.touchStartXY.y = touch.pageY;
		}catch(e){
			//trace(e);
		}
	},
	touchEnd: function (objID, objSeq, e) {
		var cfg = this.config;
		var obj = this.objects[objSeq];
		var event = window.event || e;

		if(AXUtil.browser.mobile){
			if (document.removeEventListener) {
				document.removeEventListener("touchend", this.touchEndBind, false);
				document.removeEventListener("touchmove", this.touchMoveBind, false);
			}
		}else{
			axdom(document.body).unbind("mouseup.AXMobileTouch");
			axdom(document.body).unbind("mousemove.AXMobileTouch");
		}

		var moveEndBlock = this.moveEndBlock.bind(this);
		this.touhEndObserver = setTimeout(function () {
			moveEndBlock(objID, objSeq);
		}, 10);
	},
	/* 터치 이동관련 함수 - e */

	moveBlock: function(objID, objSeq, moveX){
		var cfg = this.config;
		var obj = this.objects[objSeq];

		var newLeft = (this.touchStartXY.sLeft + (moveX));
		/*
			obj.tabTray
			obj.tabScroll
		*/
		//trace(newLeft);

		var newLeft = (this.touchStartXY.sLeft + (moveX));
		var minLeft = 0;
		var maxLeft = - (this.touchStartXY.scrollWidth - this.touchStartXY.targetWidth);
		if(cfg.bounces){
			minLeft = this.touchStartXY.targetWidth * 0.4;
			maxLeft = -((this.touchStartXY.scrollWidth - this.touchStartXY.targetWidth) * 1.2);
		}

		if(newLeft > minLeft){
			newLeft = minLeft;
		}else if(newLeft < maxLeft){
			newLeft = maxLeft;
		}
		obj.tabScroll.css({left: newLeft});
	},
	moveEndBlock: function(objID, objSeq){
		var cfg = this.config;
		var obj = this.objects[objSeq];

		/* 관성발동여부 체크 */
		if(!this.touchStartXY) return;
		var sTime = this.touchStartXY.sTime;
		var eTime = ((new Date()).getTime() / 1000);
		var dTime = eTime - sTime;
		var eLeft = obj.tabScroll.position().left;
		var dLeft = eLeft - this.touchStartXY.sLeft;

		var velocity = Math.ceil((dLeft/dTime)/5); // 속력= 거리/시간
		var endLeft = Math.ceil(eLeft + velocity); //스크롤할때 목적지
		/*trace({eLeft: eLeft, velocity:velocity, endLeft:endLeft});*/
		if(endLeft > 0) endLeft = 0;
		var newLeft = endLeft.abs();
   		if(AXUtil.clientWidth() < cfg.responsiveMobile){
    		var handleWidth = 0;
    		var rightMargin = 40;
    	}else{
    		var handleWidth = cfg.handleWidth;
    		var rightMargin = 29 + cfg.handleWidth;
    	}
		if(obj.tabTray.outerWidth() - handleWidth > (obj.tabScroll.outerWidth() - newLeft)){
			newLeft = (obj.tabScroll.outerWidth() - obj.tabTray.outerWidth()) + rightMargin;
		}

		//trace(absPage);
		this.touchStartXY.sLeft = -newLeft;
		obj.tabScroll.animate({left: -newLeft}, (obj.tabScroll.position().left + newLeft).abs(), "cubicOut", function () {});
		//trace({left: -newLeft});

		this.touchStartXY = null;
	},
	cancelEvent: function (event) {
		event.stopPropagation(); // disable  event
		return false;
	},
	/**
	 * @method AXTabClass.updateTabOption
	 * @description 입력된 value값과 같은 optionValue를 가진탭의 option 을 입력된 option으로 대체합니다.
	 * @param {String} objID - 탭 대상 ID
	 * @param {String} value - 대상 탭 값
	 * @param {String} option  - 변경될 option
	 * @returns {AXTab}
	 * @example
	 * ```js
	 * AXTab.updateTabOption('myTab01','F',{optionText:"신여성",addClass:"Classic"});
	 * ```
	 */
	updateTabOption: function(objID, value, option){
    	//trace({objID:objID, value:value});
		var cfg = this.config;
		var objSeq = null;
		axdom.each(this.objects, function(index, O){
			if(O.id == objID){
				objSeq = index;
				return false;
			}
		});
		if(objSeq == null){
			//trace("바인드 된 오브젝트를 찾을 수 없습니다.");
			return;
		}else{

			var obj = this.objects[objSeq];

			var itemIndex = null;
			axdom.each(obj.config.options, function(oidx, O){
				if(O.optionValue == value){
					itemIndex = oidx;
					return false;
				}
			});

			if(itemIndex == null) return;

			var OriginalOption = obj.config.options[itemIndex];

			for(var idx in option){
				OriginalOption[idx]=option[idx];
			}

			this.initTab(objID, objSeq);

		}
    }
});

var AXTab = new AXTabClass();
AXTab.setConfig({});

/**
 * @method jQueryExtends.unbindTab
 * @param {Object} [configs]
 * @returns {jQueryObject}
 * @description 탭을 언바인드 합니다.
 * @example
 * ```js
 * axdom("#myTab01").unbindTab();
 * ```
 **/
axdom.fn.unbindTab = function (config) {
    axdom.each(this, function () {
        if (config == undefined) config = {};
        config.id = this.id;
        AXTab.unbind(config);
    });
	return this;
};

/**
 * @method jQueryExtends.bindTab
 * @param {Object} configs
 * @returns {jQueryObject}
 * @description 탭을 바인드 합니다.
 * @example
 * ```js
 * $("#myTab01").bindTab({
 *    theme : "AXTabs",
 *    value:"",
 *    overflow:"scroll", // "visible"
 *    options:[
 *        {optionValue:"M", optionText:"남성", closable:true},
 *        {optionValue:"F", optionText:"여성", closable:true},
 *        {optionValue:"N", optionText:"선택안함"},
 *        {optionValue:"", optionText:"모두"}
 *    ],
 *    onchange: function(selectedObject, value){
 *        //toast.push(Object.toJSON(this));
 *        //toast.push(Object.toJSON(selectedObject));
 *        toast.push("onchange: "+Object.toJSON(value));
 *    },
 *    onclose: function(selectedObject, value){
 *        //toast.push(Object.toJSON(this));
 *        //toast.push(Object.toJSON(selectedObject));
 *        toast.push("onclose: "+Object.toJSON(value));
 *    }
 * });
 * ```
 **/
axdom.fn.bindTab = function (config) {
    axdom.each(this, function () {
        if (config == undefined) config = {};
        config.id = this.id;
        AXTab.bind(config);
    });
	return this;
};

/**
 * @method jQueryExtends.setValueTab
 * @param {String|Number} value
 * @returns {jQueryObject}
 * @description 탭의 value를 지정하고 지정된 value로 탭을 선택합니다.
 * @example
 * ```js
 * $("#"+tabID).setValueTab(tabValue);
 * ```
 **/
axdom.fn.setValueTab = function (value) {
    axdom.each(this, function () {
        AXTab.setValueTab(this.id, value);
    });
	return this;
};

/**
 * @method jQueryExtends.addTabs
 * @param {Array} options
 * @returns {jQueryObject}
 * @description 탭 아이템을 추가합니다.
 * @example
 * ```js
 * var options = [];
 * var index;
 * for(var i = 0; i < addCount; i++){
 *     index = "0" + (i + 1);
 *     options.push({optionText: "add " + index, optionValue: index, closable:true});
 * }
 * $("#" + tabID).addTabs(options);
 * ```
 **/
axdom.fn.addTabs = function (options) {
	axdom.each(this, function () {
		var objSeq = axdom("#" + this.id).data("objSeq");
		if(objSeq == null){
			return;
		}

		var obj = AXTab.objects[objSeq];
		obj.config.options = obj.config.options.concat(options);

		AXTab.addTabs(this.id, options);
	});
	return this;
};

/**
 * @method jQueryExtends.closeTab
 * @param {Number} tabIndex
 * @returns {jQueryObject}
 * @description 탭 아이템을 제거합니다.
 * @example
 * ```js
 * $("#" + tabID).closeTab(tabValue);
 * ```
 **/
axdom.fn.closeTab = function(tabValue) {
	axdom.each(this, function () {
		AXTab.closeTab(this.id, tabValue);
	});
	return this;
};

/**
 * @method jQueryExtends.updateTabs
 * @param {Array} options
 * @returns {jQueryObject}
 * @description 탭 아이템을 재설정합니다.
 * @example
 * ```js
 * var options = [];
 * var index;
 * for(var i = 0; i < addCount; i++){
 *     index = "0" + (i + 1);
 *     options.push({optionText: "O " + index, optionValue: index, closable:true});
 * }
 * $("#" + tabID).updateTabs(options);
 * ```
 **/
axdom.fn.updateTabs = function (options) {
	axdom.each(this, function () {
		var objSeq = axdom("#" + this.id).data("objSeq");
		if(objSeq == null){
			return;
		}

		var obj = AXTab.objects[objSeq];
		//obj.config.options = obj.config.options.concat(options);
		obj.config.options = options;
		obj.config.value = options[0].optionValue;
		AXTab.initTab(this.id, objSeq);
	});
	return this;
};

axdom.fn.updateTabOption = function (value,option) {
	axdom.each(this, function () {
		AXTab.updateTabOption(this.id, value, option);
	});
	return this;
};

/**
 * @method AXTabClass.getOptions
 * @param {String} objID - 탭 대상 ID
 * @returns {AXTab.options}
 * @example
 * ```js
 * AXTab.getOptions('myTab01');
 * ```
 */
axdom.fn.getOptions = function (){
	var returnValue = null;
	axdom.each(this, function(){
		var objSeq = axdom("#" + this.id).data("objSeq");
		if(objSeq == null){
			return;
		}

		var obj = AXTab.objects[objSeq];
		//obj.config.options = obj.config.options.concat(options);
		returnValue = obj.config.options;
	})
	return returnValue;
};

/* ---------------------------- */
var AXToolBar = Class.create(AXJ, {
	initialize: function (AXJ_super) {
		AXJ_super();
		this.config.theme = "AXToolBar";
		this.config.reserveKeys = { "subMenu": "subMenu" };
		this.opened = false; // expand submenu 상태 값
		this.open_midx = null;
	},
/**
 * 툴바의 환경을 설정합니다
 * @method AXToolBar.setConfig
 * @param {Object} config of toolbar
 * @example
```js
 <div class="toolBar" id="tool-bar" style="border-bottom: 1px solid #d6d6d6;border-top: 1px solid #d6d6d6;"></div>
 <script>
 var menu = [
 {
	label   : "<i class='axi axi-axisj'></i> 액시스제이", addClass: "",
	onclick : function (menu, event) {
		//trace("1", menu);
	},
	menu    : [
		{
			label: "<i class=\"axi axi-box\"></i>  Common", onclick: function (event) {},
			menu    : [
				{
					label: "<i class=\"axi axi-box\"></i> AXCore", onclick: function (event) {}
				},
				{
					label: "<i class=\"axi axi-box\"></i> AXValidator", onclick: function () {}
				},
				{
					label: "<i class=\"axi axi-box\"></i> AXAddress", onclick: function () {}
				},
				{
					label: "<i class=\"axi axi-box\"></i> Table CSS Guide", onclick: function () {}
				}
			]
		},
		{
			label: "<i class=\"axi axi-box\"></i>  UI-Unique", onclick: function () {},
			menu    : [
				{
					label: "<i class=\"axi axi-box\"></i> AXButton", onclick: function (event) {}
				},
				{
					label: "<i class=\"axi axi-box\"></i> AXInput", onclick: function () {}
				},
				{
					label: "<i class=\"axi axi-box\"></i> AXSelect", onclick: function () {}
				},
				{
					label: "<i class=\"axi axi-box\"></i> AXNotification", onclick: function () {}
				},
				{
					label: "<i class=\"axi axi-box\"></i> AXProgress", onclick: function () {}
				},
				{
					label: "<i class=\"axi axi-box\"></i> AXScroll", onclick: function () {}
				},
				{
					label: "<i class=\"axi axi-box\"></i> AXTabs", onclick: function () {}
				},
				{
					label: "<i class=\"axi axi-box\"></i> AXToolBar", onclick: function () {}
				}
			]
		},
		{
			label: "<i class=\"axi axi-box\"></i>  UI-Complex", onclick: function () {},
			underLine: true
		},
		{
			label: "<i class='axi axi-accessibility'></i> Material Design Icons", onclick: function () {}
		},
		{
			label: "<i class=\"axi axi-glass\"></i> FontAwesome", onclick: function () {}
		},
		{
			label: "<i class=\"axi axi-axicon-o\"></i> AXIcon", onclick: function (event) {}
		},
		{
			label: "<i class='axi axi-accessibility'></i> Material Design Icons", onclick: function () {}
		},
		{
			label: "<i class=\"axi axi-glass\"></i> FontAwesome", onclick: function () {}
		}
	]
 },
 {
	label   : "<i class='axi axi-axu'></i> 악수", addClass: "",
	onclick : function (event) {

	},
	menu    : [
		{
			label: "<i class=\"axi axi-box\"></i> Archon", onclick: function (event) {}
		},
		{
			label: "<i class=\"axi axi-box\"></i> Barracks", onclick: function () {}
		},
		{
			label: "<i class=\"axi axi-box\"></i> Barracks-2", onclick: function () {}
		}
	]
 },
 {
	label   : "<i class='axi axi-axicon'></i> 액시콘", addClass: "",
	onclick : function (event) {

	},
	menu    : [
		{
			label: "<i class=\"axi axi-axicon-o\"></i> AXIcon", onclick: function (event) {}
		},
		{
			label: "<i class='axi axi-accessibility'></i> Material Design Icons", onclick: function () {}
		},
		{
			label: "<i class=\"axi axi-glass\"></i> FontAwesome", onclick: function () {}
		},
		{
			label: "<i class=\"axi axi-axicon-o\"></i> AXIcon", onclick: function (event) {},
			underLine: true
		},
		{
			label: "<i class='axi axi-accessibility'></i> Material Design Icons", onclick: function () {}
		},
		{
			label: "<i class=\"axi axi-glass\"></i> FontAwesome", onclick: function () {}
		},
		{
			label: "<i class=\"axi axi-axicon-o\"></i> AXIcon", onclick: function (event) {}
		},
		{
			label: "<i class='axi axi-accessibility'></i> Material Design Icons", onclick: function () {}
		},
		{
			label: "<i class=\"axi axi-glass\"></i> FontAwesome", onclick: function () {}
		}
	]
 },
 {
	label   : "<i class='axi axi-jsongum'></i> 제이슨껌", addClass: "",
	onclick : function (event) {

	},
	menu    : [
		{
			label: "<i class=\"axi axi-box\"></i> $4.99", onclick: function (event) {}
		},
		{
			label: "껌팔이 앱인데 하나도 안팔리고..", onclick: function () {
				alert(this.menu.label);
			}
		},
		{
			label: "그래도 액시스제이는 포기하지 않아~ 열심히 돈을 벌어서 오픈소스를", onclick: function () {
				alert(this.menu.label);
			}
		}
	]
 }
 ];
 var myToolbar = new AXToolBar();
 myToolbar.setConfig({
    targetID: "tool-bar",
    theme   : "AXToolBar",
    menu    : menu,
    reserveKeys: {
        subMenu: "menu"
    }
 });
 </script>
```
 */
	init: function(){
		var cfg = this.config;
		if (Object.isUndefined(cfg.targetID)) {
			trace("need targetID - setConfig({targetID:''})");
			return;
		}
		this.target = jQuery("#" + cfg.targetID);
		this.setBody();
	},
	filter: function (menu) {
		var cfg = this.config, that;
		if (cfg.filter) {
			that = menu;
			return cfg.filter.call(that,  that);
		} else {
			return true;
		}
	},
	setBody: function(){
		var cfg = this.config, _this = this, po = [];

		po.push('<div class="',cfg.theme,'">');
		$.each(cfg.menu, function (midx, M) {
			if(M && _this.filter(M) ) {
				var addClass = [];
				addClass.push(this.addClass);
				if (!this[cfg.reserveKeys.subMenu]) {
					addClass.push("noexpand");
				}

				po.push('<div class="ax-root-menu-item" data-item-idx="', midx, '">');
				po.push('<a href="#axexec" class="ax-menu-item ', addClass.join(" "), '" data-item-idx="', midx, '">', this.label, '</a>');
				if (this[cfg.reserveKeys.subMenu]) {
					po.push('<a href="#axexec" class="ax-menu-handel" data-item-idx="', midx, '"></a>');
				}
				po.push('</div>');
			}
		});
		po.push('<div class="clear"></div>');
		po.push('</div>');

		this.target.html(po.join(''));

		this.target.find(".ax-menu-item").bind("click", function(e){
			var target = axf.get_event_target(e.target, {tagname:"a", clazz:"ax-menu-item"});
			var midx = target.getAttribute("data-item-idx");
			if(cfg.menu[midx].onclick) _this.exec(midx, cfg.menu[midx], e);
			else _this.expand(midx, cfg.menu[midx], e);
		});
		this.target.find(".ax-root-menu-item").bind("mouseover", function(e){
			var target = axf.get_event_target(e.target, {tagname:"div", clazz:"ax-root-menu-item"});
			var midx = target.getAttribute("data-item-idx");
			_this.overitem(midx, cfg.menu[midx], e);
		});
		this.target.find(".ax-root-menu-item").bind("mouseout", function(e){
			//var target = axf.get_event_target(e.target, {tagname:"div", clazz:"ax-root-menu-item"});
			//var midx = target.getAttribute("data-item-idx");
			_this.outitem();
		});
		this.target.find(".ax-menu-handel").bind("click", function(e){
			var target = axf.get_event_target(e.target, {tagname:"a", clazz:"ax-menu-handel"});
			var midx = target.getAttribute("data-item-idx");
			//console.log(cfg.menu[midx]);
			_this.expand(midx, cfg.menu[midx], e);
		});
	},
	reset: function(){
		this.setBody();
	},
	exec: function(midx, menu, event){
		var cfg = this.config,
			that = menu;

		that.targetID = cfg.targetID;
		menu.onclick.call(that, menu, event);
	},
	overitem: function(midx, menu, event){
		var cfg = this.config, _target = this.target.find("[data-item-idx='"+midx+"']");
		this.target.find(".ax-root-menu-item").removeClass("hover");
		_target.addClass("hover");
		if(this.opened){
			this.expand(midx, menu);
		}
	},
	outitem: function(){
		if(this.opened) return;
		var cfg = this.config;
		this.target.find(".ax-root-menu-item").removeClass("hover");
	},
	expand: function(midx, menu, event){

		var cfg = this.config, _this = this,
			that = menu, offset, _target = this.target.find("[data-item-idx='"+midx+"']");

		if(this.closing){
			AXContextMenu.close({id: cfg.targetID + "_AX_expand_AX_" + this.open_midx});
			this.expand_end();
			return;
		}
		else
		if(this.open_midx != midx){
			AXContextMenu.close({id: cfg.targetID + "_AX_expand_AX_" + this.open_midx});
		}

		this.open_midx = midx;
		if(menu[cfg.reserveKeys.subMenu]) {
			if (!menu.context_menu) {

				if(typeof menu.width == "undefined") menu.width = 150;
				menu.context_menu = AXContextMenu.bind({
					id         : cfg.targetID + "_AX_expand_AX_" + midx,
					theme      : "AXContextMenu", // 선택항목
					width      : menu.width, // 선택항목
					reserveKeys: cfg.reserveKeys,
					menu       : menu[cfg.reserveKeys.subMenu],
					onclose    : function () {
						//trace(event.type);
						_this.expand_end(this);
					}
				});
			}
			offset = _target.offset();
			AXContextMenu.open({id: cfg.targetID + "_AX_expand_AX_" + midx, filter:menu.filter}, {
				left: offset.left,
				top : offset.top + _target.outerHeight()
			});
			this.opened = true;
		}else{
			this.opened = false;
		}
	},
	expand_end: function(){
		var _this = this;
		this.opened = false;
		this.open_midx = null;
		this.closing = true;
		this.outitem();
		setTimeout(function(){
			_this.closing = false;
		}, 100);
	}
});
/* ---------------------------- */
var AXTopDownMenu = Class.create(AXJ, {
	initialize: function(AXJ_super) {
		AXJ_super();

		this.tree = [];
		this.poi = "";
		this.config.easing = {
			open: {duraing: 200, easing: "expoOut"},
			close: {duration: 200, easing: "expoOut"}
		};
		//this.config.menuBoxID = "menuBox";
		this.config.parentMenu = {
			className: "parentMenu"
		};
		this.config.childMenu = {
			className: "childMenu",
			arrowClassName: "varrow",
			align: "center",
			valign: "top",
			margin: {top: 10, left: 0, bottom: 0},
			arrowMargin: {top: 10, left: 0, bottom: 0}
		};
		this.config.childsMenu = {
			className: "childsMenu",
			arrowClassName: "harrow",
			align: "left",
			valign: "top",
			margin: {top: 10, left: 0, bottom: 0},
			arrowMargin: {top: 10, left: 0, bottom: 0}
		};
		this.config.parentOutResetChild = true;
		this.config.childOutClose = true;
		this.config.childOutCloseTime = 700;
	},
	init: function() {
		var cfg = this.config;

		if (cfg.menuBoxID) {
			this.menuBox = axdom("#" + cfg.menuBoxID);

			//서브 메뉴를 숨김 처리 합니다.
			this.menuBox.find("." + cfg.childMenu.className).hide();
			this.menuBox.find("." + cfg.childsMenu.className).hide();

			this.initParents();
			this.initChild();
			if (cfg.onComplete) cfg.onComplete.call(this);
		}
		else if (cfg.targetID) {

		}
		axdom(window).bind("resize", this.windowResize.bind(this));
	},
	windowResizeApply: function() {
		var cfg = this.config, menuBoxWidth = 0;
		axf.each(this.tree, function() {
			this.width = axdom("#" + this.id).outerWidth();
			this.height = axdom("#" + this.id).outerHeight();
			menuBoxWidth += axdom("#" + this.id).parent().outerWidth().number() + 2;
		});
		//trace(menuBoxWidth);
		//this.menuBox.css({width:menuBoxWidth});
	},
	/**
	 * @method AXTopDownMenu.setTree
	 * @param {jsObject} obj - example code 참고
	 * @description
	 * 메뉴타겟 엘리먼트 아이디 안에 메뉴 대상 HTML 엘리먼트가 있는 경우 자동으로 메뉴를 구성합니다. setTree 메소드는 타겟을 빈 노드로 선언하고 setTree 메소드를 통해 동적으로 메뉴를 구성하는 메소드입니다.
	 * @example
	 ```
	 var sampleTreeItem = {
    label: "Bottom Menu",			//{string} - 메뉴의 라벨
    url: "http://www.axisj.com", 	//{string} - 연결URL
    addClass: "myMenuClass", 		//{string} - 메뉴아이템에 추가할 CSS 클래스
    cn: [sampleTreeItem, ...., sampleTreeItem]	//[array] - 자식 메뉴 Array
};

	 var myMenu = new AXTopDownMenu();

	 var tree = [
	 {label:"Bottom Menu", url:"http://www.axisj.com", cn:[
       {label:"valign - bottom", url:"http://www.axisj.com"},
       {label:"margin - bootom", url:"http://www.axisj.com"},
       {label:"margin - top X", url:"http://www.axisj.com"}
   ]},
	 {label:"Script Control Way", url:"http://www.axisj.com", cn:[
        {label:"Script Way Use setTree", url:"abhttp://www.axisj.comc"},
        {label:"setHighLightMenu", url:"http://www.axisj.com", cn:[
            {label:"first : String", url:"http://www.axisj.com"},
            {label:"second : Array", url:"http://www.axisj.com"},
            {label:"third : setHighLightOriginID", url:"http://www.axisj.com"}
        ]},
       {label:"myMenu2", url:"http://www.axisj.com"}
   ]},
	 {label:"no Expand Menu", url:"http://www.axisj.combc"},
	 {label:"no Expand Menu", url:"http://www.axisj.com"},
	 {label:"no Expand Menu", url:"http://www.axisj.com"}
	 ];
	 myMenu.setTree(Tree);

	 ```
	 */
	setTree: function(tree) {
		var cfg = this.config;
		cfg.menuBoxID = cfg.targetID, _this = this;

		if (!this.menuBox) this.menuBox = axdom("#" + cfg.menuBoxID);

		var po = [];

		var treeFn = function(subTree) {
			axdom.each(subTree, function(pi, T) {
				po.push("<li>");
				var addClass = (T.cn && T.cn.length > 0 ) ? " class = \"" + cfg.childsMenu.hasChildClassName + "\"" : "";
				if (cfg.onclick) {
					po.push("<a data-href=\"" + (T.url || cfg.href) + "\"" + addClass + " data-id=\"" + (T._id || "") + "\" id=\"" + (T._id || "") + "\" data-label=\"" + (T.label || "").dec().delHtml() + "\">" + (T.label || "").dec() + "</a>");
				}
				else {
					po.push("<a href=\"" + (T.url || cfg.href) + "\"" + addClass + " id=\"" + (T._id || "") + "\">" + (T.label || "").dec() + "</a>");
				}
				if (T.cn && T.cn.length > 0) {
					po.push("<div class=\"" + cfg.childsMenu.className + "\">");
					po.push("	<ul>");
					po.push(treeFn(T.cn));
					po.push("	</ul>");
					po.push("</div>");
				}
				po.push("</li>");
			});
		};

		po.push("<ul>");
		axdom.each(tree, function(pi, T) {
			var addClass = [];
			if (T.addClass) {
				addClass.push(T.addClass);
			}
			po.push("<li>");
			po.push("	<div class=\"" + cfg.parentMenu.className + " " + addClass.join(" ") + "\">");
			var addClass = (T.cn) ? " class = \"" + cfg.childMenu.hasChildClassName + "\"" : "";

			if (cfg.onclick) {
				po.push("<a data-href=\"" + (T.url || cfg.href) + "\"" + addClass + " data-id=\"" + (T._id || "") + "\" id=\"" + (T._id || "") + "\" data-label=\"" + (T.label || "").dec().delHtml() + "\">" + (T.label || "").dec() + "</a>");
			}
			else {
				po.push("<a href=\"" + (T.url || cfg.href) + "\"" + addClass + " id=\"" + (T._id || "") + "\">" + (T.label || "").dec() + "</a>");
			}

			if (T.cn && T.cn.length > 0) {
				po.push("<div class=\"" + cfg.childMenu.className + "\">");
				po.push("	<ul>");
				po.push(treeFn(T.cn));
				po.push("	</ul>");
				po.push("</div>");
			}
			po.push("	</div>");
			po.push("</li>");
		});
		po.push("</ul>");
		po.push("<div class=\"clear\"></div>");

		this.menuBox.empty();
		this.menuBox.append(po.join(''));

		if (cfg.onclick) {
			this.menuBox.find('[data-href]').bind("click", function() {
				cfg.onclick({
					id: this.getAttribute("data-id"),
					href: this.getAttribute("data-href"),
					label: this.getAttribute("data-label")
				});
				_this.outChild();
			});
		}

		//서브 메뉴를 숨김 처리 합니다.
		this.menuBox.find("." + cfg.childMenu.className).hide();
		this.menuBox.find("." + cfg.childsMenu.className).hide();

		setTimeout(function() {
			_this.initParents();
			_this.initChild();
			if (cfg.onComplete) cfg.onComplete.call(this);
		}, 300);
	},
	initParents: function() {
		var cfg = this.config;
		var parents = [], menuBoxWidth = 0;
		this.menuBox.find("." + cfg.parentMenu.className).each(function(pi, EL) {
			EL.id = cfg.menuBoxID + "_PM_" + pi;
			var _id = "";

			var ELA = axdom(EL).children("A");

			if (ELA.get(0).id) _id = axdom(EL).children("A").get(0).id;
			ELA.get(0).id = cfg.menuBoxID + "_PMA_" + pi;
			ELA.attr("data-axmenuid", _id);

			parents.push({
				_id: _id,
				id: EL.id,
				width: axdom(EL).outerWidth(),
				height: axdom(EL).outerHeight(),
				cn: [],
				coi: ""
			});
			menuBoxWidth += axdom(EL).parent().outerWidth().number() + 2;
		});
		this.tree = parents;
		//this.menuBox.css({width:menuBoxWidth});

		//trace(this.menuBox.find("." + cfg.parentMenu.className + ">a"));
		this.menuBox.find("." + cfg.parentMenu.className + ">a").bind("mouseover", this.onoverParent.bind(this));
		this.menuBox.find("." + cfg.parentMenu.className + ">a").bind("focus", this.onoverParent.bind(this));
		this.menuBox.find("." + cfg.parentMenu.className + ">a").bind("click", this.onclickParent.bind(this));

		if (cfg.childOutClose) {
			var onoutChild = this.onoutChild.bind(this);
			this.menuBox.find("." + cfg.parentMenu.className + ">a").bind("mouseout", onoutChild);
		}
	},
	onoverParent: function(event) {
		if (this.childObserver) clearTimeout(this.childObserver); //닫기 명령 제거
		var cfg = this.config;

		var target = axf.get_event_target(event.target, {tagname: "a"});
		var poi = target.id.split(/\_/g).last();
		if (this.poi != "" && this.poi != poi) {
			axdom("#" + cfg.menuBoxID + "_PMA_" + this.poi).removeClass("on");
			axdom("#" + cfg.menuBoxID + "_PMC_" + this.poi).slideUp(
				{
					duration: cfg.easing.close.duration,
					easing: cfg.easing.close.easing,
					complete: function() {

					}
				}
			);
			if (cfg.parentOutResetChild) this.closeSubMenu(this.tree[this.poi]);
		}

		//slideDown check
		if (this.dfPoi != undefined) axdom("#" + cfg.menuBoxID + "_PMA_" + this.dfPoi).removeClass("on");
		axdom("#" + cfg.menuBoxID + "_PMA_" + poi).addClass("on");
		//trace("#" + cfg.menuBoxID + "_PMC_" + poi);

		var tgDiv = axdom("#" + cfg.menuBoxID + "_PMC_" + poi);
		if (this.tree[poi] && !this.tree[poi].divDim) {
			tgDiv.show();
			this.tree[poi].divDim = {width: tgDiv.outerWidth(), height: tgDiv.outerHeight()};
			if (this.tree[poi].height == null) {
				for (var index = 0; index < this.tree.length; index++) {
					this.tree[index].height = axdom("#" + this.tree[index].id).outerHeight();
				}
				//trace(poi, this.tree[poi]);
			}
			var topDim = {width: this.tree[poi].width, height: this.tree[poi].height};

			/* subMenu positioning */
			if (cfg.childMenu.align == "center") {
				var posLeft = topDim.width / 2 - this.tree[poi].divDim.width / 2 + cfg.childMenu.margin.left;
			}
			else if (cfg.childMenu.align == "left") {
				var posLeft = 0 + cfg.childMenu.margin.left;
			}
			else if (cfg.childMenu.align == "right") {
				var posLeft = topDim.width - this.tree[poi].divDim.width + cfg.childMenu.margin.left;
			}
			if (cfg.childMenu.valign == "top") {
				var posTop = topDim.height + cfg.childMenu.margin.top;
				if (cfg.childMenu.float) {
					tgDiv.css({top: posTop, left: posLeft});
				}
				else {
					tgDiv.css({top: posTop, left: posLeft, width: this.tree[poi].divDim.width});
				}
			}
			else if (cfg.childMenu.valign == "bottom") {
				var posTop = topDim.height + cfg.childMenu.margin.bottom;
				if (cfg.childMenu.float) {
					tgDiv.css({top: posTop, left: posLeft});
				}
				else {
					tgDiv.css({top: "auto", bottom: posTop, left: posLeft, width: this.tree[poi].divDim.width});
				}
			}
			/* -------------------- */

			/* subMenu Arrow positioning */
			if (cfg.childMenu.arrowClassName) {
				var arrow = tgDiv.find("." + cfg.childMenu.arrowClassName);
				if (cfg.childMenu.align == "center") {
					var aLeft = tgDiv.outerWidth() / 2 - arrow.outerWidth() / 2 + cfg.childMenu.arrowMargin.left;
				}
				else if (cfg.childMenu.align == "left") {
					var aLeft = 0 + cfg.childMenu.arrowMargin.left;
				}
				else if (cfg.childMenu.align == "right") {
					var aLeft = tgDiv.outerWidth() - arrow.outerWidth() + cfg.childMenu.arrowMargin.left;
				}
				if (cfg.childMenu.valign == "top") {
					var aTop = -arrow.outerHeight() + cfg.childMenu.arrowMargin.top;
					arrow.css({top: aTop, left: aLeft});
				}
				else if (cfg.childMenu.valign == "bottom") {
					var aTop = -arrow.outerHeight() + cfg.childMenu.arrowMargin.bottom;
					arrow.css({bottom: aTop, left: aLeft});
				}
			}
			/* -------------------- */

			tgDiv.hide();
			topDim = null;
			posTop = null;
			posLeft = null;
		}

		tgDiv.fadeIn(
			{
				duration: cfg.easing.open.duration,
				easing: cfg.easing.open.easing,
				complete: function() {
				}
			}
		);

		this.poi = poi;
	},
	onclickParent: function(event) {
		var cfg = this.config;
		var poi = event.target.id.split(/\_/g).last();

		//trace(this.tree[poi]);
	},
	initChild: function() {
		var cfg = this.config;
		var initChilds = this.initChilds.bind(this);
		var tree = this.tree;
		this.menuBox.find("." + cfg.parentMenu.className).each(function(pi, EL) {
			var child = axdom(EL).children("." + cfg.childMenu.className).get(0);
			if (child) {
				child.id = cfg.menuBoxID + "_PMC_" + pi;
				if (cfg.childMenu.arrowClassName) {
					var arrow = axdom("<div class=\"" + cfg.childMenu.arrowClassName + "\"></div>");
					axdom(child).prepend(arrow);
				}
				initChilds(child.id, tree[pi]);
			}
			else {

			}
		});
	},
	initChilds: function(cid, rTree) {
		var initChilds = this.initChilds.bind(this);
		var cfg = this.config;
		var tree = rTree.cn;

		var onoverChild = this.onoverChild.bind(this);
		var onoutChild = this.onoutChild.bind(this);
		//trace(cid);
		axdom("#" + cid + ">ul>li").each(function(pi, EL) {
			var linkA = axdom(EL).children("A");
			var _id = "";
			if (linkA.get(0).id) _id = linkA.get(0).id;
			linkA.get(0).id = cid.replace("PMC", "PMA") + "_" + pi;
			linkA.attr("data-axmenuid", _id);
			linkA.bind("mouseover", onoverChild);
			if (cfg.childOutClose) {
				linkA.bind("mouseout", onoutChild);
			}

			//axdom(EL).children("A").html(cid.replace("PMC", "PMA") + "_" + pi);
			var childDiv = axdom(EL).children("." + cfg.childsMenu.className).get(0);
			if (childDiv) {
				childDiv.id = cid + "_" + pi;

				if (cfg.childsMenu.arrowClassName) {
					var arrow = axdom("<div class=\"" + cfg.childsMenu.arrowClassName + "\"></div>");
					axdom(childDiv).prepend(arrow);
				}

				tree.push({
					_id: _id,
					id: cid + "_" + pi,
					cn: [],
					coi: ""
				});
				initChilds(cid + "_" + pi, tree[pi]);
			}
			else {
				tree.push({
					_id: _id,
					id: cid + "_" + pi,
					cn: [],
					coi: ""
				});
			}
		});
	},
	closeSubMenu: function(pitem) {
		if (!pitem) return;
		if (pitem.coi == "") return;
		var cfg = this.config;
		axdom("#" + pitem.coi).slideUp(
			{
				duration: cfg.easing.close.duration,
				easing: cfg.easing.close.easing,
				complete: function() {
				}
			}
		);
		pitem.coi = "";
		//하위 자식들의 poi 모두 닫기

		var closeAllSubMenu = function(stree) {
			axdom.each(stree, function() {
				if (this.coi != "") {
					axdom("#" + this.coi).hide();
				}
				closeAllSubMenu(this.cn);
			});
		};
		closeAllSubMenu(pitem.cn);
	},
	onoverChild: function(event) {
		if (this.childObserver) clearTimeout(this.childObserver); //닫기 명령 제거
		var cfg = this.config;
		var target = axf.get_event_target(event.target, {tagname: "a"});
		var eid = target.id;
		var ids = target.id.split(/\_/g);
		var tree = this.tree;
		var item = {};
		var pitem = {};
		for (var a = 2; a < ids.length; a++) {
			if (a == ids.length - 2) {
				pitem = tree[ids[a]];
			}
			if (tree[ids[a]]) {
				if (tree[ids[a]].cn) {
					item = tree[ids[a]];
					tree = tree[ids[a]].cn;
				}
			}
		}

		if (pitem) {
			if (pitem.coi != "" && pitem.coi != item.id) {
				this.closeSubMenu(pitem);
			}
		}

		if (item) {
			if (item.id) {

				var tgDiv = axdom("#" + item.id);

				//slideDown check
				if (!item.divDim) {
					axdom("#" + item.id).show();
					item.divDim = {width: tgDiv.outerWidth(), height: tgDiv.outerHeight()};
					var pDim = {
						width: axdom("#" + eid).outerWidth(),
						height: axdom("#" + eid).outerHeight(),
						pos: axdom("#" + eid).position()
					};

					if (cfg.childsMenu.align == "left") {
						var posLeft = pDim.width + cfg.childsMenu.margin.left;
					}
					else {
						var posLeft = -item.divDim.width + cfg.childsMenu.margin.left;
					}

					if (cfg.childsMenu.valign == "top") {
						var posTop = pDim.pos.top + cfg.childsMenu.margin.top;
						tgDiv.css({top: posTop, left: posLeft, width: item.divDim.width});
					}
					else {
						var posTop = (pitem.divDim.height - pDim.pos.top) - pDim.height + cfg.childsMenu.margin.bottom;
						tgDiv.css({bottom: posTop, left: posLeft, width: item.divDim.width});
					}

					/* subMenu Arrow positioning */
					if (cfg.childsMenu.arrowClassName) {

						var arrow = tgDiv.find("." + cfg.childsMenu.arrowClassName);
						if (cfg.childsMenu.align == "left") {
							var aLeft = -arrow.outerWidth() + cfg.childsMenu.arrowMargin.left;
						}
						else {
							var aLeft = tgDiv.outerWidth() - arrow.outerWidth() + cfg.childsMenu.arrowMargin.left;
						}
						if (cfg.childsMenu.valign == "top") {
							var aTop = 0 + cfg.childsMenu.arrowMargin.top;
							arrow.css({top: aTop, left: aLeft});
						}
						else if (cfg.childsMenu.valign == "bottom") {
							var aTop = 0 + cfg.childsMenu.arrowMargin.bottom;
							arrow.css({bottom: aTop, left: aLeft});
						}
					}
					/* -------------------- */

					tgDiv.hide();
					pDim = null;
					posTop = null;
					posLeft = null;
				}

				tgDiv.fadeIn(
					{
						duration: cfg.easing.open.duration,
						easing: cfg.easing.open.easing,
						complete: function() {
						}
					}
				);
				if (pitem) pitem.coi = item.id.replace("PMA", "PMC");
			}

		}

	},
	onoutChild: function(event) {
		var cfg = this.config;
		var outChild = this.outChild.bind(this);
		this.childObserver = setTimeout(function() {
			outChild();
		}, cfg.childOutCloseTime);
	},
	outChild: function() {
		var cfg = this.config;
		this.closeSubMenu(this.tree[this.poi]);

		axdom("#" + cfg.menuBoxID + "_PMA_" + this.poi).removeClass("on");
		if (this.dfPoi != undefined) axdom("#" + cfg.menuBoxID + "_PMA_" + this.dfPoi).addClass("on");
		axdom("#" + cfg.menuBoxID + "_PMC_" + this.poi).slideUp(
			{
				duration: cfg.easing.close.duration,
				easing: cfg.easing.close.easing,
				complete: function() {
				}
			}
		);
	},
	setHighLightMenu: function(poi) {
		var cfg = this.config;
		this.menuBox.find(".parentMenu").removeClass("on");
		this.menuBox.find(".parentMenu a").removeClass("on");
		this.menuBox.find(".childMenu a").removeClass("on");

		if (axdom.isArray(poi)) {
			this.poi = this.dfPoi = poi;
			var tree = this.tree;
			axdom.each(poi, function(idx, T) {
				if (idx == 0) tree = tree[T.number()];
				else  tree = tree.cn[T.number()];
				if (tree) {
					if (idx == 0) {
						axdom("#" + tree.id).addClass("on");
						axdom("#" + tree.id).children("A").addClass("on");
					}
					else {
						axdom("#" + tree.id.replace("_PMC_", "_PMA_")).addClass("on");
					}
				}
			});
		}
		else {
			this.poi = this.dfPoi = poi;
			axdom("#" + cfg.menuBoxID + "_PMA_" + this.dfPoi).addClass("on");
		}
	},
	/**
	 * @method AXTopDownMenu.setHighLightOriginID
	 * @param {string} - 메뉴 엘리먼트에 사용자가 정의한 ID
	 * @description
	 * 타겟 엘리먼트안에 Html 엘리먼트로 메뉴를 정의한 경우 엘리먼트 안에 사용자가 정의해 둔 아이디로 메뉴의 하이라이트를 처리해줍니다.
	 * @example
	 ```
	 myMenu.setHighLightOriginID("ID1245");
	 ```
	 */

	setHighLightOriginID: function(_id) {
		var cfg = this.config;
		var tree = this.tree;
		var findedID = "";

		var treeFn = function(subTree) {
			axdom.each(subTree, function(idx, T) {
				if (T._id == _id) {
					findedID = T.id;
					return false;
				}
				else {
					if (T.cn) treeFn(T.cn);
				}
			});
		};

		axdom.each(this.tree, function(idx, T) {
			if (T._id == _id) {
				findedID = T.id;
				return false;
			}
			else {
				if (T.cn) treeFn(T.cn);
			}
		});

		if (findedID) {
			this.findedID = findedID;
			var pos = findedID.split(/_PM[C]?_/g).last();
			var selectedMenus = pos.split(/_/g);
			this.setHighLightMenu(selectedMenus);
			return selectedMenus;
		}else{
			this.menuBox.find(".parentMenu").removeClass("on");
			this.menuBox.find(".parentMenu a").removeClass("on");
			this.menuBox.find(".childMenu a").removeClass("on");
		}

	},

	/**
	 * @method AXTopDownMenu.setHighLightID
	 * @param {array} - [0, 1] 와 같이 각 뎁스의 순번을 전달합니다.
	 * @description
	 * 메뉴의 포지션 값으로 포지션에 해당하는 메뉴를 하이라이트 처리해 줍니다.
	 * @example
	 ```
	 myMenu.setHighLightMenu([2, 1]); // 3번째 아이템(1depth)의 2번째 아이템(2depth)을 하이라이트 처리합니다.
	 ```
	 */
	setHighLightID: function(_id) {
		var cfg = this.config;
		var tree = this.tree;
		var findedID = "";

		var treeFn = function(subTree) {
			axdom.each(subTree, function(idx, T) {
				if (T.id == _id) {
					findedID = T.id;
					return false;
				}
				else {
					if (T.cn) treeFn(T.cn);
				}
			});
		};
		axdom.each(tree, function(idx, T) {
			if (T.id == _id) {
				findedID = T.id;
				return false;
			}
			else {
				if (T.cn) treeFn(T.cn);
			}
		});

		if (findedID) {
			this.findedID = findedID;
			var pos = findedID.split(/_PM[C]?_/g).last();
			var selectedMenus = pos.split(/_/g);
			this.setHighLightMenu(selectedMenus);
			return selectedMenus;
		}
	}
});
/* ---------------------------- */
var AXTree = Class.create(AXJ, {
	initialize: function (AXJ_super) {
		AXJ_super();
		this.Observer = null;
		this.tree = [];
		this.list = [];

		this.pageActive = false;
		this.page = {}; /*{pageNo:0, pageSize:100, pageCount:"", listCount:0};*/

		this.moveSens = 0;

		this.config.moveSens = 1;
		this.config.formPaddingRight = "11px";
		this.config.sort = true;
		this.config.xscroll = true;
		this.config.showConnectionLine = false;
		this.config.iconWidth = 23;
		this.config.indentWidth = 20;
		this.config.indentRatio = 1;

		this.config.fitToWidth = (AXConfig.AXTree.fitToWidth || false);
		this.config.fitToWidthRightMargin = (AXConfig.AXTree.fitToWidthRightMargin || 10);
		this.config.checkboxRelationFixed = true;

		this.selectedCells = [];
		this.selectedRow = [];
		this.config.hashDigit = 3;

		this.isMobile = AXUtil.browser.mobile;

        this.config.persistExpanded  = (AXConfig.AXTree.persistExpanded || false);
        this.config.persistSelected  = (AXConfig.AXTree.persistSelected || false);
        this.config.cookiePrefix     = (AXConfig.AXTree.cookiePrefix || "axtree-");
        this.config.cookieExpiredays = (AXConfig.AXTree.cookieExpiredays || 7);

        window.AXTree_instances = window.AXTree_instances || [];
		window.AXTree_instances.push(this);
	},
	/* 공통 영역 */
	defineConfig: function (rewrite) {
		var cfg = this.config;
		if (cfg.colGroup.length == 0) {
			trace("colGrpup is empty)");
			return;
		}

		/* col너비 합계 구하기 */
		var colWidth = 0;
		var hasHiddenCell = false;
		var showColLen = 0;
		if (!rewrite) this.fixedColSeq = cfg.fixedColSeq;
		var bodyWidth = this.body.width();
		var astricCount = 0;

		for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
			if (CG.colSeq == undefined) CG.colSeq = cidx;
			if (CG.display == undefined) CG.display = true;
			if (CG.display) {
				if (!rewrite) {
					if (CG.width == "*") {
						CG.width = 0;
						CG.widthAstric = true;
						astricCount++;
					}
					CG._owidth = CG.width;
					/* 최초의 너비값 기억 하기 */
				} else {
					if (CG.widthAstric) {
						CG.width = 0;
						CG._owidth = CG.width;
						astricCount++;
					}
				}

				colWidth += (CG._owidth || 0).number();
				showColLen += 1;
			} else {
				hasHiddenCell = true;
			}
		}
		if (!cfg.fitToWidth) {
			/* width * 예외처리 구문 ------------ s */
			if ((bodyWidth - cfg.fitToWidthRightMargin) > (colWidth + 100 * astricCount)) {
				var remainsWidth = (bodyWidth - cfg.fitToWidthRightMargin) - colWidth;
				for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
					if (CG.display && CG.widthAstric) {
						CG._owidth = (remainsWidth / astricCount).ceil();
						CG.width = CG._owidth;
						colWidth += (CG._owidth || 0).number();
					}
				}
			} else {
				for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
					if (CG.display && CG.widthAstric) {
						CG._owidth = 100;
						CG.width = 100;
						colWidth += (CG._owidth || 0).number();
					}
				}
			}
			/* width * 예외처리 구문 ------------ e */
		} else {
			for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
				if (CG.display && CG.widthAstric) {
					CG.width = 100;
					CG._owidth = 100;
					colWidth += (CG._owidth || 0).number();
				}
			}
		}
		this.colWidth = colWidth;

		if (cfg.fitToWidth) { /*너비 자동 맞춤버전의 경우 */
			if (bodyWidth > this.colWidth) {
				var _bodyWidth = bodyWidth - cfg.fitToWidthRightMargin;
				var zoomRatio = bodyWidth / this.colWidth;
				colWidth = 0;
				for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
					CG.width = (CG._owidth * zoomRatio).ceil();
					if (_bodyWidth > CG.width) _bodyWidth -= CG.width;
					else CG.width = _bodyWidth;
					if (CG.display) colWidth += CG.width.number();
				}
				this.colWidth = colWidth;
			} else {
				colWidth = 0;
				for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
					if (CG._owidth == undefined) CG._owidth = (CG.width || 0).number();
					CG.width = CG._owidth.number();
					if (CG.display) colWidth += CG.width.number();
				}
				this.colWidth = colWidth;
			}
		}

		this.showColLen = showColLen;
		/* col너비 합계 구하기 ~~~~~~~~~~~~~~ 구해진 너비합은 그리드 head, body 의 너비로 지정됨. */

		if (!cfg.colHead) cfg.colHead = { display: false };
		if (!cfg.body) cfg.body = {};

		if (cfg.colHead.rowsEmpty) cfg.colHead.rows = undefined;
		if (cfg.body.rowsEmpty) cfg.body.rows = undefined;

		// colHead rows -----------------------------------------------------------------------------------------------------
		if (cfg.colHead.rows) {
			// colHeadRow 정해진 경우
			cfg.colHead._maps = new Array(cfg.colHead.rows.length);
			var colMaxLen = 0;
			for (var r = 0; r < cfg.colHead.rows.length; r++) {
				var colLen = 0;
				axf.each(cfg.colHead.rows[r], function (CHidx, CH) {
					if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
					if (CH.colspan == undefined || CH.colspan == null) {
						CH.colspan = 1;
						CH._colspan = 1;
					} else {
						if (!rewrite) {
							CH._colspan = CH.colspan;
						} else {
							CH.colspan = CH._colspan;
						}
					}
					if (CH.valign == undefined || CH.valign == null) CH.valign = "bottom";
					if (cfg.colHeadAlign) CH.align = "center";
					colLen += CH.colspan.number();
				});
				if (colMaxLen < colLen) colMaxLen = colLen;
			}
			for (var _m = 0; _m < cfg.colHead._maps.length; _m++) { cfg.colHead._maps[_m] = new Array(colMaxLen); }
			// colEndPosition 관련 처리 함수
			var appendPosToColHeadMap = function (r, c, posR, position) { //
				var nC = position.c; //시작 컬럼 위치
				for (var rr = posR; rr < (posR + r) ; rr++) {
					var tC = c; //컬럼 루프횟수
					var isWhile = true; // 루프유지변수
					while (isWhile) {
						try {
							if (tC == 0) {
								isWhile = false;
							} else {
								if (!cfg.colHead._maps[rr][nC]) {
									cfg.colHead._maps[rr][nC] = position;
									tC--;
								} else {
									nC++;
								}
							}
						} catch (e) {
							isWhile = false;
						}
					}
				}
			}
			for (var r = 0; r < cfg.colHead.rows.length; r++) {
				axf.each(cfg.colHead.rows[r], function (CHidx, CH) {
					if (CH.colSeq != undefined) {
						var myCG = cfg.colGroup.getToSeq(CH.colSeq);
					} else {
						var myCG = cfg.colGroup.searchObject(function () {
							return this.item.key == CH.key;
						}).first();
					}
					if (myCG != null) {
						if (rewrite) AXUtil.overwriteObject(CH, myCG, true);
						else AXUtil.overwriteObject(CH, myCG, false);
					} else {
						AXUtil.overwriteObject(CH, { align: "left", valign: "bottom", display: true, rowspan: 1, colspan: 1 }, false);
					}
					appendPosToColHeadMap(CH.rowspan, CH.colspan, r, { r: r, c: CHidx });
				});
			}
			//colHead._maps 마지막 줄에 해당하는 cfg.colHead.rows 에 속성부여
			axf.each(cfg.colHead._maps.last(), function (midx, m) {
				if (m) cfg.colHead.rows[m.r][m.c].isLastCell = true;
			});

			if (hasHiddenCell) { // colGroup 중에 숨겨진 col 이 존재하는 경우
				// colspan 감소 시키기
				axf.each(cfg.colGroup, function (cidx, CG) {
					if (!CG.display) {
						for (var a = 0; a < cfg.colHead._maps.length; a++) {
							var rowPosition = cfg.colHead._maps[a][cidx];
							cfg.colHead.rows[rowPosition.r][rowPosition.c].colspan--;
						}
					}
				});
			}
			//trace(cfg.colHead._maps); _maps check

			// colHeadRow 정해진 경우 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		} else {
			// colHeadRow 정해지지 않은 경우
			cfg.colHead._maps = [[]];
			var colHeadRows = [[]];
			axf.each(cfg.colGroup, function (cidx, CG) {
				var adder = {
					key: CG.key,
					colSeq: CG.colSeq,
					label: CG.label,
					align: (CG.align || (cfg.colHeadAlign || "left")), rowspan: 1, colspan: 1,
					valign: "bottom", isLastCell: true, display: CG.display, formatter: CG.formatter, checked: CG.checked,
					sort: CG.sort,
					tooltip: CG.tooltip
				};
				colHeadRows[0].push(adder);
				cfg.colHead._maps[0].push({ r: 0, c: cidx });
			});
			cfg.colHead.rows = colHeadRows;
			cfg.colHead.rowsEmpty = true;
			// colHeadRow 정해지지 않은 경우 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		}
		// colHead rows -----------------------------------------------------------------------------------------------------

		// body rows -----------------------------------------------------------------------------------------------------
		if (cfg.body.rows) {
			// bodyRow 정해진 경우

			cfg.body._maps = new Array(cfg.body.rows.length);
			var colMaxLen = 0;
			for (var r = 0; r < cfg.body.rows.length; r++) {
				var colLen = 0;
				axf.each(cfg.body.rows[r], function (CHidx, CH) {
					if (CH.colspan == undefined || CH.colspan == null) {
						CH.colspan = 1;
						CH._colspan = 1;
					} else {
						if (!rewrite) CH._colspan = CH.colspan;
						else CH.colspan = CH._colspan;
					}
					if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
					if (CH.valign == undefined || CH.valign == null) CH.valign = "middle";
					//if(CH.align == undefined || CH.align == null) CH.align = "left";
					colLen += CH.colspan.number();
				});
				if (colMaxLen < colLen) colMaxLen = colLen;
			}
			for (var _m = 0; _m < cfg.body._maps.length; _m++) { cfg.body._maps[_m] = new Array(colMaxLen); }
			// colEndPosition 관련 처리 함수
			var appendPosToBodyMap = function (r, c, posR, position) {
				var nC = position.c; //시작 컬럼 위치
				for (var rr = posR; rr < (posR + r) ; rr++) {
					var tC = c; //컬럼 루프횟수
					var isWhile = true; // 루프유지변수
					while (isWhile) {
						try {
							if (tC == 0) { isWhile = false; } else {
								if (!cfg.body._maps[rr][nC]) {
									cfg.body._maps[rr][nC] = position;
									tC--;
								} else {
									nC++;
								}
							}
						} catch (e) { isWhile = false; }
					}
				}
			};
			for (var r = 0; r < cfg.body.rows.length; r++) {
				axf.each(cfg.body.rows[r], function (CHidx, CH) {
					if (CH.colSeq != undefined) {
						var myCG = cfg.colGroup.getToSeq(CH.colSeq);
					} else {
						var myCG = cfg.colGroup.searchObject(function () {
							return this.item.key == CH.key;
						}).first();
					}
					if (myCG != null) {
						if (rewrite) AXUtil.overwriteObject(CH, myCG, true);
						else AXUtil.overwriteObject(CH, myCG, false);
					} else {
						AXUtil.overwriteObject(CH, { align: "left", valign: "bottom", display: true, rowspan: 1, colspan: 1 }, false);
					}
					appendPosToBodyMap(CH.rowspan, CH.colspan, r, { r: r, c: CHidx });
				});
			}
			//body._maps 마지막 줄에 해당하는 cfg.body.rows 에 속성부여
			axf.each(cfg.body._maps.last(), function (midx, m) {
				if (m) cfg.body.rows[m.r][m.c].isLastCell = true;
			});

			if (hasHiddenCell) { // colGroup 중에 숨겨진 col 이 존재하는 경우
				// colspan 감소 시키기
				axf.each(cfg.colGroup, function (cidx, CG) {
					if (!CG.display) {
						for (var a = 0; a < cfg.body._maps.length; a++) {
							var rowPosition = cfg.body._maps[a][cidx];
							cfg.body.rows[rowPosition.r][rowPosition.c].colspan--;
						}
					}
				});
			}

			// bodyRow 정해진 경우 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		} else {
			// bodyRow 정해지지 않은 경우
			cfg.body._maps = [[]];
			var bodyRows = [[]];
			axf.each(cfg.colGroup, function (cidx, CG) {
				var adder = {
					key: CG.key, colSeq: CG.colSeq, label: CG.label, align: (CG.align || "left"), rowspan: 1, colspan: 1, valign: "middle", isLastCell: true,
					display: CG.display, formatter: CG.formatter, checked: CG.checked, disabled: CG.disabled, indent: CG.indent, getIconClass: CG.getIconClass,
					tooltip: CG.tooltip
				};
				bodyRows[0].push(adder);
				cfg.body._maps[0].push({ r: 0, c: cidx });
			});
			cfg.body.rows = bodyRows;
			cfg.body.rowsEmpty = true;
			// bodyRow 정해지지 않은 경우 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		}
		// body rows -----------------------------------------------------------------------------------------------------

		//marker 관련 데이터 정리
		if (cfg.body.marker) {
			if (cfg.body.marker.rows) {
				this.bodyHasMarker = true;
				cfg.body.marker._maps = new Array(cfg.body.marker.rows.length);
				colMaxLen = 0;
				for (var r = 0; r < cfg.body.marker.rows.length; r++) {
					var colLen = 0;
					axf.each(cfg.body.marker.rows[r], function (CHidx, CH) {
						if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
						if (CH.colspan == undefined || CH.colspan == null) {
							CH.colspan = 1;
							CH._colspan = 1;
						} else {
							if (!rewrite) CH._colspan = CH.colspan;
							else CH.colspan = CH._colspan;
						}
						if (CH.valign == undefined || CH.valign == null) CH.valign = "bottom";
						colLen += CH.colspan.number();
					});
					if (colMaxLen < colLen) colMaxLen = colLen;
				}
				for (var _m = 0; _m < cfg.body.marker._maps.length; _m++) { cfg.body.marker._maps[_m] = new Array(colMaxLen); }
				// colEndPosition 관련 처리 함수
				var appendPosToEditorMap = function (r, c, posR, position) { //
					var nC = position.c; //시작 컬럼 위치
					for (var rr = posR; rr < (posR + r) ; rr++) {
						var tC = c; //컬럼 루프횟수
						var isWhile = true; // 루프유지변수
						while (isWhile) {
							try {
								if (tC == 0) {
									isWhile = false;
								} else {
									if (!cfg.body.marker._maps[rr][nC]) {
										cfg.body.marker._maps[rr][nC] = position;
										tC--;
									} else { nC++; }
								}
							} catch (e) { isWhile = false; }
						}
					}
				};
				for (var r = 0; r < cfg.body.marker.rows.length; r++) {
					axf.each(cfg.body.marker.rows[r], function (CHidx, CH) {
						if (CH.colSeq != undefined) {
							var myCG = cfg.colGroup.getToSeq(CH.colSeq);
						} else {
							var myCG = cfg.colGroup.searchObject(function () {
								return this.item.key == CH.key;
							}).first();
						}
						if (myCG != null) AXUtil.overwriteObject(CH, myCG, false);
						else AXUtil.overwriteObject(CH, { align: "left", valign: "bottom", display: true, rowspan: 1, colspan: 1 }, false);
						appendPosToEditorMap(CH.rowspan, CH.colspan, r, { r: r, c: CHidx });
					});
				}
				//colHead._maps 마지막 줄에 해당하는 cfg.colHead.rows 에 속성부여
				axf.each(cfg.body.marker._maps.last(), function (midx, m) {
					if (m) cfg.body.marker.rows[m.r][m.c].isLastCell = true;
				});

				if (hasHiddenCell) { // colGroup 중에 숨겨진 col 이 존재하는 경우
					// colspan 감소 시키기
					axf.each(cfg.colGroup, function (cidx, CG) {
						if (!CG.display) {
							for (var a = 0; a < cfg.body.marker._maps.length; a++) {
								var rowPosition = cfg.body.marker._maps[a][cidx];
								cfg.body.marker.rows[rowPosition.r][rowPosition.c].colspan--;
							}
						}
					});
				}
			}
		}
		//marker 관련 데이터 정리 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


		//head 관련 데이터 정리
		if (cfg.head) {
			cfg.head._maps = new Array(cfg.head.rows.length);
			colMaxLen = 0;
			for (var r = 0; r < cfg.head.rows.length; r++) {
				var colLen = 0;
				axf.each(cfg.head.rows[r], function (CHidx, CH) {
					if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
					if (CH.colspan == undefined || CH.colspan == null) {
						CH.colspan = 1;
						CH._colspan = 1;
					} else {
						if (!rewrite) CH._colspan = CH.colspan;
						else CH.colspan = CH._colspan;
					}
					if (CH.valign == undefined || CH.valign == null) CH.valign = "bottom";
					//if(CH.align == undefined || CH.align == null) CH.align = "left";
					colLen += CH.colspan.number();
				});
				if (colMaxLen < colLen) colMaxLen = colLen;
			}
			for (var _m = 0; _m < cfg.head._maps.length; _m++) { cfg.head._maps[_m] = new Array(colMaxLen); }
			// colEndPosition 관련 처리 함수
			var appendPosToHeadMap = function (r, c, posR, position) { //
				var nC = position.c; //시작 컬럼 위치
				for (var rr = posR; rr < (posR + r) ; rr++) {
					var tC = c; //컬럼 루프횟수
					var isWhile = true; // 루프유지변수
					while (isWhile) {
						try {
							if (tC == 0) {
								isWhile = false;
							} else {
								if (!cfg.head._maps[rr][nC]) {
									cfg.head._maps[rr][nC] = position;
									tC--;
								} else {
									nC++;
								}
							}
						} catch (e) {
							isWhile = false;
						}
					}
				}
			};
			for (var r = 0; r < cfg.head.rows.length; r++) {
				axf.each(cfg.head.rows[r], function (CHidx, CH) {
					if (CH.colSeq != undefined) {
						var myCG = cfg.colGroup.getToSeq(CH.colSeq);
					} else {
						var myCG = cfg.colGroup.searchObject(function () {
							return this.item.key == CH.key;
						}).first();
					}
					if (myCG != null) AXUtil.overwriteObject(CH, myCG, false);
					else AXUtil.overwriteObject(CH, { align: "left", valign: "bottom", display: true, rowspan: 1, colspan: 1 }, false);
					appendPosToHeadMap(CH.rowspan, CH.colspan, r, { r: r, c: CHidx });
				});
			}

			//colHead._maps 마지막 줄에 해당하는 cfg.colHead.rows 에 속성부여
			axf.each(cfg.head._maps.last(), function (midx, m) {
				if (m) cfg.head.rows[m.r][m.c].isLastCell = true;
			});

			if (hasHiddenCell) { // colGroup 중에 숨겨진 col 이 존재하는 경우
				// colspan 감소 시키기
				axf.each(cfg.colGroup, function (cidx, CG) {
					if (!CG.display) {
						for (var a = 0; a < cfg.head._maps.length; a++) {
							var rowPosition = cfg.head._maps[a][cidx];
							cfg.head.rows[rowPosition.r][rowPosition.c].colspan--;
						}
					}
				});
			}
		}
		//head 관련 데이터 정리 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		//foot 관련 데이터 정리
		if (cfg.foot) {
			cfg.foot._maps = new Array(cfg.foot.rows.length);
			colMaxLen = 0;
			for (var r = 0; r < cfg.foot.rows.length; r++) {
				var colLen = 0;
				axf.each(cfg.foot.rows[r], function (CHidx, CH) {
					if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
					if (CH.colspan == undefined || CH.colspan == null) {
						CH.colspan = 1;
						CH._colspan = 1;
					} else {
						if (!rewrite) CH._colspan = CH.colspan;
						else CH.colspan = CH._colspan;
					}
					if (CH.valign == undefined || CH.valign == null) CH.valign = "bottom";
					colLen += CH.colspan.number();
				});
				if (colMaxLen < colLen) colMaxLen = colLen;
			}
			for (var _m = 0; _m < cfg.foot._maps.length; _m++) { cfg.foot._maps[_m] = new Array(colMaxLen); }
			// colEndPosition 관련 처리 함수
			var appendPosToFootMap = function (r, c, posR, position) { //
				var nC = position.c; //시작 컬럼 위치
				for (var rr = posR; rr < (posR + r) ; rr++) {
					var tC = c; //컬럼 루프횟수
					var isWhile = true; // 루프유지변수
					while (isWhile) {
						try {
							if (tC == 0) {
								isWhile = false;
							} else {
								if (!cfg.foot._maps[rr][nC]) {
									cfg.foot._maps[rr][nC] = position;
									tC--;
								} else {
									nC++;
								}
							}
						} catch (e) {
							isWhile = false;
						}
					}
				}
			};
			for (var r = 0; r < cfg.foot.rows.length; r++) {
				axf.each(cfg.foot.rows[r], function (CHidx, CH) {
					if (CH.colSeq != undefined) {
						var myCG = cfg.colGroup.getToSeq(CH.colSeq);
					} else {
						var myCG = cfg.colGroup.searchObject(function () {
							return this.item.key == CH.key;
						}).first();
					}
					if (myCG != null) AXUtil.overwriteObject(CH, myCG, false);
					else AXUtil.overwriteObject(CH, { align: "left", valign: "bottom", display: true, rowspan: 1, colspan: 1 }, false);
					appendPosToFootMap(CH.rowspan, CH.colspan, r, { r: r, c: CHidx });
				});
			}
			//colHead._maps 마지막 줄에 해당하는 cfg.colHead.rows 에 속성부여
			axf.each(cfg.foot._maps.last(), function (midx, m) {
				if (m) cfg.foot.rows[m.r][m.c].isLastCell = true;
			});

			if (hasHiddenCell) { // colGroup 중에 숨겨진 col 이 존재하는 경우
				// colspan 감소 시키기
				axf.each(cfg.colGroup, function (cidx, CG) {
					if (!CG.display) {
						for (var a = 0; a < cfg.foot._maps.length; a++) {
							var rowPosition = cfg.foot._maps[a][cidx];
							cfg.foot.rows[rowPosition.r][rowPosition.c].colspan--;
						}
					}
				});
			}
		}
		//foot 관련 데이터 정리 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		//editor 관련 데이터 정리
		if (cfg.editor) {
			if (cfg.editor.rows) {
				this.hasEditor = true;
				cfg.editor._maps = new Array(cfg.editor.rows.length);
				colMaxLen = 0;
				for (var r = 0; r < cfg.editor.rows.length; r++) {
					var colLen = 0;
					axf.each(cfg.editor.rows[r], function (CHidx, CH) {
						if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
						if (CH.colspan == undefined || CH.colspan == null) {
							CH.colspan = 1;
							CH._colspan = 1;
						} else {
							if (!rewrite) CH._colspan = CH.colspan;
							else CH.colspan = CH._colspan;
						}
						if (CH.valign == undefined || CH.valign == null) CH.valign = "bottom";
						colLen += CH.colspan.number();
					});
					if (colMaxLen < colLen) colMaxLen = colLen;
				}
				for (var _m = 0; _m < cfg.editor._maps.length; _m++) { cfg.editor._maps[_m] = new Array(colMaxLen); }
				// colEndPosition 관련 처리 함수
				var appendPosToEditorMap = function (r, c, posR, position) { //
					var nC = position.c; //시작 컬럼 위치
					for (var rr = posR; rr < (posR + r) ; rr++) {
						var tC = c; //컬럼 루프횟수
						var isWhile = true; // 루프유지변수
						while (isWhile) {
							try {
								if (tC == 0) {
									isWhile = false;
								} else {
									if (!cfg.editor._maps[rr][nC]) {
										cfg.editor._maps[rr][nC] = position;
										tC--;
									} else { nC++; }
								}
							} catch (e) { isWhile = false; }
						}
					}
				};
				for (var r = 0; r < cfg.editor.rows.length; r++) {
					axf.each(cfg.editor.rows[r], function (CHidx, CH) {
						if (CH.colSeq != undefined) {
							var myCG = cfg.colGroup.getToSeq(CH.colSeq);
						} else {
							var myCG = cfg.colGroup.searchObject(function () {
								return this.item.key == CH.key;
							}).first();
						}
						if (myCG != null) AXUtil.overwriteObject(CH, myCG, false);
						else AXUtil.overwriteObject(CH, { align: "left", valign: "bottom", display: true, rowspan: 1, colspan: 1 }, false);
						appendPosToEditorMap(CH.rowspan, CH.colspan, r, { r: r, c: CHidx });
					});
				}
				//colHead._maps 마지막 줄에 해당하는 cfg.colHead.rows 에 속성부여
				axf.each(cfg.editor._maps.last(), function (midx, m) {
					if (m) cfg.editor.rows[m.r][m.c].isLastCell = true;
				});

				if (hasHiddenCell) { // colGroup 중에 숨겨진 col 이 존재하는 경우
					// colspan 감소 시키기
					axf.each(cfg.colGroup, function (cidx, CG) {
						if (!CG.display) {
							for (var a = 0; a < cfg.editor._maps.length; a++) {
								var rowPosition = cfg.editor._maps[a][cidx];
								cfg.editor.rows[rowPosition.r][rowPosition.c].colspan--;
							}
						}
					});
				}
			}
		}
		//editor 관련 데이터 정리 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		//fixedColSeq가 설정된 경우
		if (cfg.fixedColSeq != undefined && cfg.fixedColSeq != null) {

			var fixedColSeq = this.fixedColSeq;
			axf.each(cfg.colHead._maps, function (midx, m) {
				axf.each(m, function (cidx, c) {
					if (c) {
						if ((fixedColSeq + 1) > cidx) cfg.colHead.rows[c.r][c.c].isFixedCell = true;
					}
				});
			});
			axf.each(cfg.body._maps, function (midx, m) {
				axf.each(m, function (cidx, c) {
					if (c) {
						if (fixedColSeq == cidx) cfg.body.rows[c.r][c.c].isFixedEndCell = true;
						if ((fixedColSeq + 1) > cidx) cfg.body.rows[c.r][c.c].isFixedCell = true;
					}
				});
			});
			if (cfg.head) {
				axf.each(cfg.head._maps, function (midx, m) {
					axf.each(m, function (cidx, c) {
						if (c) {
							if (fixedColSeq == cidx) cfg.head.rows[c.r][c.c].isFixedEndCell = true;
							if ((fixedColSeq + 1) > cidx) cfg.head.rows[c.r][c.c].isFixedCell = true;
						}
					});
				});
			}
			if (cfg.foot) {
				axf.each(cfg.foot._maps, function (midx, m) {
					axf.each(m, function (cidx, c) {
						if (c) {
							if (fixedColSeq == cidx) cfg.foot.rows[c.r][c.c].isFixedEndCell = true;
							if ((fixedColSeq + 1) > cidx) cfg.foot.rows[c.r][c.c].isFixedCell = true;
						}
					});
				});
			}

			if (cfg.body.marker) {
				if (cfg.body.marker.rows) {
					axf.each(cfg.body.marker._maps, function (midx, m) {
						axf.each(m, function (cidx, c) {
							if (c) {
								if (fixedColSeq == cidx) cfg.body.marker.rows[c.r][c.c].isFixedEndCell = true;
								if ((fixedColSeq + 1) > cidx) cfg.body.marker.rows[c.r][c.c].isFixedCell = true;
							}
						});
					});
				}
			}

			if (cfg.editor) {
				if (cfg.editor.rows) {
					axf.each(cfg.editor._maps, function (midx, m) {
						axf.each(m, function (cidx, c) {
							if (c) {
								if (fixedColSeq == cidx) cfg.editor.rows[c.r][c.c].isFixedEndCell = true;
								if ((fixedColSeq + 1) > cidx) cfg.editor.rows[c.r][c.c].isFixedCell = true;
							}
						});
					});
				}
			}
			this.hasFixed = true;
			if (hasHiddenCell) {
				var minusFixedCol = 0;
				var fixedColSeq = this.fixedColSeq;
				axf.each(cfg.colGroup, function (cidx, CG) {
					if (!CG.display) {
						if ((fixedColSeq + 1) > cidx) minusFixedCol++;
					}
				});
				cfg.fixedColSeq = this.fixedColSeq - minusFixedCol;
			} else {
				cfg.fixedColSeq = this.fixedColSeq;
			}

			if (cfg.fixedColSeq == -1) {
				//fixed 제거
				this.hasFixed = false;
			}

			var fixedColSeq = this.fixedColSeq;
			fixedColWidth = 0;
			axf.each(cfg.colGroup, function (cidx, CG) {
				if (CG.display && cidx < (fixedColSeq + 1)) {
					fixedColWidth += CG.width.number();
				}
			});
			this.fixedColWidth = fixedColWidth;
		}


	},
	init: function () {
		var cfg = this.config;

		if (Object.isUndefined(cfg.targetID)) {
			trace("need targetID - setConfig({targetID:''})");
			return;
		}
		if (!cfg.colGroup) {
			trace("need colGroup - setConfig({colGroup:[]})");
			return;
		}

		cfg.emptyListMSG = cfg.emptyListMSG || AXConfig.AXTree.emptyListMSG;

		var reserveKeys = {
			parentHashKey: "pHash", // 부모 트리 포지션
			hashKey: "hash", // 트리 포지션
			openKey: "open", // 확장여부
			subTree: "subTree", // 자식개체키
			displayKey: "display" // 표시여부
		};
		var relation = {
			parentKey: "pno",
			childKey: "no"
		}
		if (cfg.reserveKeys) {
			AXUtil.overwriteObject(reserveKeys, cfg.reserveKeys, true);
		} else {
			cfg.reserveKeys = reserveKeys;
		}
		if (cfg.relation) {
			AXUtil.overwriteObject(relation, cfg.relation, true);
		} else {
			cfg.relation = relation;
		}

		var targetInnerHeight = axdom("#" + cfg.targetID).innerHeight();
		//if (targetInnerHeight == 0) targetInnerHeight = (AXConfig.AXTree.pageHeight || 400);
		this.theme = (cfg.theme) ? cfg.theme : "AXTree"; // 테마기본값 지정
		cfg.height = (cfg.height) ? cfg.height : targetInnerHeight + "px"; // 그리드 높이 지정

		this.target = axdom("#" + cfg.targetID);
		var theme = this.theme;
		var treeCss = [];

		if (cfg.width) treeCss.push("width:" + cfg.width + ";");
		if (cfg.height) treeCss.push("height:" + cfg.height + ";");

		// tree 뼈대 그리기 -----------------------------------------------------------------------------------------------------
		var ol = [];
		ol.push("<a id=\"" + cfg.targetID + "_AX_tree_focus\" href=\"#axtree\" ></a>");
		ol.push("<div class=\"" + theme + "\" id=\"" + cfg.targetID + "_AX_tree\" style=\"" + treeCss.join('') + "\">");
		ol.push("	<div class=\"AXTreeScrollBody\" id=\"" + cfg.targetID + "_AX_treeScrollBody\" style=\"z-index:2;\">");
		ol.push("		<div class=\"AXTreeColHead AXUserSelectNone\" id=\"" + cfg.targetID + "_AX_treeColHead\" onselectstart=\"return false;\"></div>");
		ol.push("		<div class=\"AXTreeBody\" id=\"" + cfg.targetID + "_AX_treeBody\"></div>");
		ol.push("		<div class=\"AXTreeEditor\" id=\"" + cfg.targetID + "_AX_treeEditor\"></div>");
		ol.push("	</div>");
		ol.push("</div>");
		this.target.html(ol.join(''));
		// tree 뼈대 그리기 -----------------------------------------------------------------------------------------------------

		// 주요 타깃 설정
		this.gridBody = axdom("#" + cfg.targetID + "_AX_tree");
		this.scrollBody = axdom("#" + cfg.targetID + "_AX_treeScrollBody");
		this.colHead = axdom("#" + cfg.targetID + "_AX_treeColHead");
		this.body = axdom("#" + cfg.targetID + "_AX_treeBody");
		this.editor = axdom("#" + cfg.targetID + "_AX_treeEditor");

		/// define part -----------------------------------------------------------------------------------------------------
		this.defineConfig(); // config object define
		/// define part -----------------------------------------------------------------------------------------------------

		if (cfg.colHead.display) {
			//colHead setting
			this.setColHead();
		} else {
			this.colHead.hide();
		}

		//body setting
		this.setBody();

		//editor setting
		this.editor.hide();

		this.treeTargetSetSize();

		/* body event bind */
		if (cfg.height != "auto") {

			var contentScrollTouchstart = this.contentScrollTouchstart.bind(this);
			this.contentScrollTouchstartBind = function (event) {
				contentScrollTouchstart(event);
			};


			var contentScrollScrollWheel = this.contentScrollScrollWheel.bind(this);
			this.contentScrollScrollWheelBind = function (event) {
				contentScrollScrollWheel(event);
			};

			var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel";
			if (document.attachEvent) { //if IE (and Opera depending on user setting)
				//axf.getId(cfg.targetID+"_AX_treeBody").detachEvent("on"+mousewheelevt, this.contentScrollScrollWheelBind);
				if (axf.getId(cfg.targetID + "_AX_treeBody")) axf.getId(cfg.targetID + "_AX_treeBody").attachEvent("on" + mousewheelevt, contentScrollScrollWheel);
			} else if (document.addEventListener) { //WC3 browsers
				///axf.getId(cfg.targetID+"_AX_treeBody").removeEventListener(mousewheelevt, this.contentScrollScrollWheelBind, false);
				if (axf.getId(cfg.targetID + "_AX_treeBody")) axf.getId(cfg.targetID + "_AX_treeBody").addEventListener(mousewheelevt, contentScrollScrollWheel, false);
			}

			if (document.addEventListener) {
				//axf.getId(cfg.targetID+"_AX_treeBody").removeEventListener("touchstart", this.contentScrollTouchstartBind, false);
				if (axf.getId(cfg.targetID + "_AX_treeBody")) axf.getId(cfg.targetID + "_AX_treeBody").addEventListener("touchstart", contentScrollTouchstart, false);
			}
		}

		axdom("#" + cfg.targetID).bind("click", function(event){
			axdom("#" + cfg.targetID + "_AX_tree_focus").focus();
		});
		axdom("#" + cfg.targetID + "_AX_tree_focus").bind("keyup.axtree", this.onKeydown.bind(this));

		//TODO : 포커스인 상태인지 파악이 필요..

		if (cfg.contextMenu) {
			AXContextMenu.bind({
				id: cfg.targetID + "ContextMenu",
				theme: cfg.contextMenu.theme, // 선택항목
				width: cfg.contextMenu.width, // 선택항목
				menu: cfg.contextMenu.menu
			});
			axdom("#" + cfg.targetID).bind("contextmenu", this.onContextmenu.bind(this));
		}
		/* body event bind */
		axdom(window).bind("resize", this.windowResize.bind(this));
	},
	/**
	 * @method AXTree.setConfig
	 * @param {Object} config - gridConfig
	 * @description
	 * 선언된 클래스를 사용하기 위해 속성을 정의합니다.
	 * @example
	 * ```js
	 * var myTree = new AXTree();
	 * myTree.setConfig({
	 *     targetID : "AXTreeTarget",  //{String} - HTML 엘리먼트 타겟아이디
	 *     theme: "AXTree_none",   //[String] - ("AXTree","AXTree_none") CSS Class 이름
	 *     relation:{  //무보자식 키 정의
	 *         parentKey:"pno",    //부모아이디 키
	 *         childKey:"no"   //자식아이디 키
	 *     },
	 *     persistExpanded: true, // 쿠키를 이용해서 트리의 확장된 상태를 유지합니다.
	 *     persistSelected: true, // 쿠키를 이용해서 트리의 선택된 상태를 유지합니다.
	 *     colGroup: [ //트리 헤드정의
	 *         {
	 *             key:"nodeName", //{String} - 컬럼에 매치될 item 의 키
	 *             label:"제목", //{String} - 컬럼에 표시할 라벨
	 *             width:"100%",   //[Number["px", "%"] = "auto"] - "100%", "500px", "auto"지정하면 트리의 너비만큼 단일 컬럼의 너비가 자동 맞춤 처리됩니다.
	 *             align:"left",   //[String = "left"[left, center, right]] - 정렬방식 지정
	 *             indent:true,    //[Boolean = true]
	 *             getIconClass: function(){   // [Function] - indent 속성 정의된 대상에 아이콘을 지정할 수 있습니다.
	 *                 var iconNames = "folder, AXfolder, movie, img, zip, file, fileTxt, fileTag".split(/, /g);
	 *                 var iconName = "";
	 *                 if(this.item.type) iconName = iconNames[this.item.type];
	 *                 return iconName;
	 *             },
	 *             formatter:function(){   // [Function] - 컬럼값의 표현형식 각각 화폐표현식, urlDecode, input.Checkbox, input.radioBox, 사용자 정의 함수
	 *                 return "<b>"+this.item.no.setDigit(2) + "</b> : " + this.item.nodeName + " (" + this.item.writer + ")";
	 *             }
	 *         }
	 *     ],
	 *     body: {
	 *         onclick:function(idx, item){ //[Function] 바디 클릭 이벤트 콜백함수
	 *             toast.push(Object.toJSON(item));
	 *         },
	 *         ondblclick:function(idx, item){ //[Function] 바디 더블클릭 이벤트 콜백함수
	 *             toast.push(Object.toJSON(item));
	 *         },
	 *         oncheck:function(idx, item){ //[Function] 트리 체크박스클릭시 함수연결
	 *             toast.push(Object.toJSON(item));
	 *         },
	 *         onexpand:function(idx, item){ //[Function] 트리 아이템 확장 이벤트 콜백함수
	 *             toast.push(Object.toJSON(item));
	 *         },
	 *         oncontract:function(idx, item){ //[Function] 트리 아이템 축소 이벤트 콜백함수
	 *             toast.push(Object.toJSON(item));
	 *         },
	 *         addClass:function(idx, item){ //[Function] 트리 아이템에 사용자 CSS 클래스를 추가할 수 있는 사용자 함수 추가하려는 클래스명을 return 으로 반환하십시요
	 *             toast.push(Object.toJSON(item));
	 *         }
	 *     }
	 * });
	 *
	 * ```
	 */
	windowResize: function () {
		var windowResizeApply = this.windowResizeApply.bind(this);
		if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
		this.windowResizeObserver = setTimeout(function () {
			windowResizeApply();
		}, 100);
	},
	windowResizeApply: function () {
		var cfg = this.config;

		if (cfg.mediaQuery) {
			var _viewMode = "", clientWidth = axf.clientWidth();
			axf.each(cfg.mediaQuery, function (k, v) {
				if (Object.isObject(v)) {

					if(v.min != undefined && v.max != undefined){
						if (v.min <= clientWidth && clientWidth <= v.max) {
							_viewMode = (k == "dx") ? "grid" : "mobile";
							return false;
						}
					}else{
						if (v.min <= clientWidth) {
							_viewMode = (k == "dx") ? "grid" : "mobile";
							return false;
						}
					}
				}
			});
			if (_viewMode != "") {
				cfg.viewMode = _viewMode;
			}
		}

		this.redrawGrid();
	},
	treeTargetSetSize: function (react) {
		var cfg = this.config;
		//cfg.height
		if (cfg.height == "auto") {
			this.target.css({ height: "auto", "max-height": "auto" });
			var colHeadHeight = this.colHead.outerHeight();
			var scrollBodyHeight = axdom("#" + cfg.targetID + "_AX_scrollContent").height();
			this.scrollBody.css({ height: scrollBodyHeight + colHeadHeight }); //colhead + body height
			this.body.css({ top: colHeadHeight, height: (scrollBodyHeight) }); // body Height
		} else {
			var colHeadHeight = (cfg.colHead.display) ? this.colHead.outerHeight() : 0;
			var scrollBodyHeight = cfg.height.number();
			//trace({top:colHeadHeight, scrollBodyHeight:scrollBodyHeight});
			this.scrollBody.css({ height: scrollBodyHeight }); //colhead + body height
			this.body.css({ top: colHeadHeight, height: (scrollBodyHeight - colHeadHeight) }); // body Height
		}
		if (!react) axdom(window).bind("resize", this.contentScrollResize.bind(this));
	},
	resetHeight: function () {
		var cfg = this.config;

		var targetInnerHeight = axdom("#" + cfg.targetID).innerHeight();
		//if (targetInnerHeight == 0) targetInnerHeight = 400;
		cfg.height = targetInnerHeight + "px"; // 그리드 높이 지정
		this.gridBody.css({height:targetInnerHeight-2});
		this.redrawGrid("");
	},
	getColGroup: function (suffix) {
		var cfg = this.config;
		var fixedColSeq = this.fixedColSeq;
		//{colID:0, key:"no", label:"번호", width:"100", align:"left", addClassNames:"", style:"", display:true, sort:null}
		var po = [];
		po.push("<colgroup>");
		if (suffix != "FC" && suffix != "FB" && suffix != "FE") {
			axf.each(cfg.colGroup, function (cidx, CG) {
				if (CG.display) {
					if (cfg.width == "auto" || cfg.width == "*") {
						po.push("<col style=\"\" id=\"" + cfg.targetID + "_AX_col_AX_" + CG.colSeq + "_AX_" + suffix + "\" />");
					} else {
						po.push("<col width=\"" + (CG.width || "") + "\" style=\"\" id=\"" + cfg.targetID + "_AX_col_AX_" + CG.colSeq + "_AX_" + suffix + "\" />");
					}
				}
			});
			if(cfg.colHead.display) po.push("<col />");

			//if (suffix == "CB") po.push("<col />");
		} else {
			//fixedCol 존재
			axf.each(cfg.colGroup, function (cidx, CG) {
				if (CG.display && cidx < (fixedColSeq + 1)) {
					if (cfg.width == "auto" || cfg.width == "*") {
						po.push("<col style=\"\" id=\"" + cfg.targetID + "_AX_col_AX_" + CG.colSeq + "_AX_" + suffix + "\" />");
					} else {
						po.push("<col width=\"" + (CG.width || "") + "\" style=\"\" id=\"" + cfg.targetID + "_AX_col_AX_" + CG.colSeq + "_AX_" + suffix + "\" />");
					}
				}
			});
		}
		po.push("</colgroup>");
		return po.join('');
	},
	getColSeqToHead: function (r, c) {
		//trace("getColSeqToHead:"+r+","+c);
		var cfg = this.config;
		var colSeq = null;
		for (var a = cfg.colHead._maps[r].length - 1; a > -1; a--) {
			if (cfg.colHead._maps[r][a].r == r && cfg.colHead._maps[r][a].c == c) {
				colSeq = a;
				break;
			}
		}
		return colSeq;
	},
	redrawGrid: function () {
		var cfg = this.config;
		this.defineConfig(true);
		if (cfg.colHead.display) this.setColHead();
		this.setBody();

		if (cfg.head) this.printHead();
		if (cfg.foot) this.printFoot();

		this.treeTargetSetSize(true);
		this.contentScrollResize();
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 바디 재구성 기능 포함
	},
	checkedColSeq: function (colSeq, checked, itemIndex) {
		var cfg = this.config;
		var gridCheckClick = this.gridCheckClick.bind(this);
		if (typeof itemIndex === "undefined") {
			this.colHead.find(".treeCheckBox_colHead_colSeq" + colSeq).each(function() {
				this.checked = checked;
			});
			axdom("#" + cfg.targetID + "_AX_fixedColHead").find(".treeCheckBox_colHead_colSeq" + colSeq).each(function() {
				this.checked = checked;
			});
			this.body.find(".treeCheckBox_body_colSeq" + colSeq).each(function() {
				this.checked = checked;
			});
		} else {
			if(cfg.colGroup[colSeq].formatter === "radio") {
				var ii= 0, ll = this.list.length;
				for(;ii<ll;ii++) {
					if(typeof _this.list[ii].__checked === "undefined") _this.list[ii].__checked = false;
					_this.list[ii].__checked = false;
				}
			}
			this.body.find(".gridBodyTr_" + itemIndex + " .treeCheckBox_body_colSeq" + colSeq).each(function () {
				if (checked == null) {
					this.checked = !this.checked;
				} else {
					this.checked = checked;
				}
				gridCheckClick(null, this.id);
			});
		}
	},
	/**
	 * @method AXTree.getCheckedList
	 * @param {number} colSeq - checkbox가 있는 colGroup index
	 * @returns {Array} - checked 된 아이템의 배열
	 * @description
	 * colGroup의 배열순번으로 해당 col의 checked 된 아이템을 반환하여 줍니다.
	 * @example
	 ```
	 var myArray = myTree.getCheckedList(0);
	 ```
	 */
	getCheckedList: function (colSeq) {
		var cfg = this.config;
		var collect = [];
		var list = this.list;
		this.body.find(".treeCheckBox_body_colSeq" + colSeq).each(function () {
			if (this.checked) {
				var itemIndex = this.id.split(/_AX_/g).last();
				collect.push(list[itemIndex]);
			}
		});
		return collect;
	},
	onKeydown: function (event) {
		if (event.keyCode == 67 && event.ctrlKey) {
			//this.copyData();
		}
		//TODO 키보드 컨트롤 시작

		if(this.selectedRow.length > 0) {
			var rIndex = this.selectedRow.first().number();
			if (event.keyCode == axf.Event.KEY_RETURN) {
				this.click( rIndex );
			}
			else if (event.keyCode == axf.Event.KEY_UP) {
				rIndex -= 1;
				while ( this.list[rIndex] && this.list[rIndex].AXTreeSplit ) {
					rIndex -= 1;
				}
				this.setFocus( rIndex );
			}
			else if (event.keyCode == axf.Event.KEY_DOWN) {
				rIndex += 1;
				while ( this.list[rIndex] && this.list[rIndex].AXTreeSplit ) {
					rIndex += 1;
				}
				this.setFocus( rIndex );
			}
			else if (event.keyCode == axf.Event.KEY_LEFT) {
				this.expandToggleList(rIndex, this.list[rIndex]);
				this.setFocus( rIndex );
			}
			else if (event.keyCode == axf.Event.KEY_RIGHT) {
				this.expandToggleList(rIndex, this.list[rIndex]);
				this.setFocus( rIndex );
			}
		}
	},
	onBodyKeydown: function (event) {
		//this.readyMoved = true;
		//this.moveTarget = {itemIndex:itemIndex};
		if (event.keyCode == AXUtil.Event.KEY_ESC) {
			if (this.readyMoved) {
				this.cancelMove();
			}
		}
	},
	onContextmenu: function (event) {
		var cfg = this.config;

		if (this.readyMoved) return false;

		// event target search -
		if(event.target.id == "") return;
		var eid = event.target.id.split(/_AX_/g);
		var eventTarget = event.target;
		if (eventTarget.tagName.toLowerCase() == "input") return; //input 인 경우 제외
		var myTarget = this.getEventTarget({
			evt: eventTarget, evtIDs: eid,
			until: function (evt, evtIDs) { return (axdom(evt.parentNode).hasClass("gridBodyTr")) ? true : false; },
			find: function (evt, evtIDs) { return (axdom(evt).hasClass("bodyTd") || axdom(evt).hasClass("bodyNodeIndent")) ? true : false; }
		});
		// event target search ------------------------

		if (myTarget) {
			//colHeadTool ready
			var targetID = myTarget.id;
			var itemIndex = targetID.split(/_AX_/g).last();
			var ids = targetID.split(/_AX_/g);

			if (this.selectedCells.length > 0) {
				axf.each(this.selectedCells, function () {
					axdom("#" + this).removeClass("selected");
				});
				this.selectedCells.clear();
			}
			if (this.selectedRow.length > 0) {
				var body = this.body;
				axf.each(this.selectedRow, function () {
					body.find(".gridBodyTr_" + this).removeClass("selected");
				});
			}

			this.selectedRow.clear();
			this.body.find(".gridBodyTr_" + itemIndex).addClass("selected");
			this.selectedRow.push(itemIndex);

			var item = this.list[itemIndex];
			AXContextMenu.open({ id: cfg.targetID + "ContextMenu", filter: cfg.contextMenu.filter, sendObj: item }, event); // event 직접 연결 방식
		}
		return false;
	},
	copyData: function () {
		var cfg = this.config;
		var copyOut = [];
		axf.each(this.selectedCells, function (index, n) {
			var html = axdom("#" + n).find(".bodyNode").html();
			copyOut.push(html + '\t');
		});

		if (window.clipboardData) {
			window.clipboardData.setData('Text', copyOut.join(''));
			toast.push("데이터가 복사되었습니다. 원하시는 곳에 붙여넣기 하세요.");
		} else {
			dialog.push({ title: "Copy Data", body: copyOut.join(''), type: "alert" });
		}
	},
	/* 공통 영역 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

	/* colHead 영역  */
	getHeadMousePosition: function (event) {
		var pos = this.colHead.offset();
		var x = (event.pageX - pos.left);
		var y = (event.pageY - pos.top);
		return { x: x, y: y };
	},
	getColHeadTd: function (arg) {
		var cfg = this.config;
		var po = [];

		if (arg.ghost) {
			po.push("<td" + arg.valign + arg.rowspan + arg.colspan + " class=\"colHeadTd" + arg.bottomClass + "\">");
			po.push("<div class=\"tdRelBlock\">");
			po.push("<div class=\"colHeadNode colHeadTdText\">&nbsp;</div>");
			po.push("</div>");
			po.push("</td>");
		} else {

			var colHeadTdText = " colHeadTdText";
			var toolUse = true;

			if (arg.formatter == "html" || arg.formatter == "checkbox" || arg.formatter == "radio") {
				colHeadTdText = " colHeadTdHtml";
				toolUse = false;
				if (arg.formatter == "checkbox") {
					colHeadTdText = " colHeadTdCheck";
					arg.tdHtml = "<input type=\"checkbox\" name=\"checkAll\" class=\"gridCheckBox gridCheckBox_colHead_colSeq" + arg.colSeq + "\" id=\"" + cfg.targetID + "_AX_checkAll_AX_" + arg.r + "_AX_" + arg.CHidx + "\" />";
				}
			}

			var sortClass = ""; if (arg.sort) sortClass = (arg.sort == "desc") ? " sortDesc" : " sortAsc";

			po.push("<td" + arg.valign + arg.rowspan + arg.colspan + " id=\"" + cfg.targetID + "_AX_colHead_AX_" + arg.r + "_AX_" + arg.CHidx + "\" class=\"colHeadTd" + arg.bottomClass + sortClass + "\">");
			po.push("<div class=\"tdRelBlock\">");
			po.push("<div class=\"colHeadNode" + colHeadTdText + "\" align=\"" + arg.align + "\" id=\"" + cfg.targetID + "_AX_colHeadText_AX_" + arg.r + "_AX_" + arg.CHidx + "\">");
			po.push(arg.tdHtml);
			po.push("</div>");
			if (toolUse && arg.colSeq != null && arg.colSeq != undefined) po.push("<a href=\"#AXexec\" class=\"colHeadTool\" id=\"" + cfg.targetID + "_AX_colHeadTool_AX_" + arg.r + "_AX_" + arg.CHidx + "\">T</a>");
			po.push("<div class=\"colHeadResizer\" id=\"" + cfg.targetID + "_AX_colHeadResizer_AX_" + arg.r + "_AX_" + arg.CHidx + "\"></div>");
			po.push("</div>");
			po.push("</td>");

			if (arg.sort) {
				var myColHead = cfg.colHead.rows[arg.r][arg.CHidx];
				var tdID = cfg.targetID + "_AX_colHead_AX_" + arg.r + "_AX_" + arg.CHidx;

				this.nowSortHeadID = tdID;
				this.nowSortHeadObj = myColHead;
			}

		}
		return po.join('');
	},
	setColHead: function () {
		var cfg = this.config;
		var po = [];

		//trace("fixedCol : " +  cfg.fixedColSeq);

		var getColHeadTd = this.getColHeadTd.bind(this);
		if (!this.hasFixed) {  ////////////////////////////////////////////////////////////////////////////////////////////// 일반 colHead 구현

			po.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"colHeadTable\" style=\"width:" + this.colWidth + "px;\">");
			po.push(this.getColGroup("CH")); //colGroup 삽입
			po.push("<tbody>");
			for (var r = 0; r < cfg.colHead.rows.length; r++) {
				var isLastTR = (cfg.colHead.rows.length - 1 == r);
				po.push("<tr>");
				axf.each(cfg.colHead.rows[r], function (CHidx, CH) {
					if (CH.display && CH.colspan > 0) {
						//radio, check exception
						var tdHtml = CH.label || "untitle";
						var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
						var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
						var valign = " valign=\"" + CH.valign + "\"";
						var bottomClass = (CH.isLastCell) ? "" : " colHeadBottomBorder";

						po.push(getColHeadTd({
							valign: valign, rowspan: rowspan, colspan: colspan, bottomClass: bottomClass, r: r, CHidx: CHidx,
							align: CH.align, colSeq: CH.colSeq, formatter: CH.formatter, sort: CH.sort, tdHtml: tdHtml,
							ghost: false
						}));
					}
				});
				po.push("</tr>");
			}
			po.push("</tbody>");
			po.push("</table>");

		} else { ////////////////////////////////////////////////////////////////////////////////////////////// fixedCol 구현

			po.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"colHeadTable\" style=\"width:" + this.colWidth + "px;\">");
			po.push(this.getColGroup("CH")); //colGroup 삽입
			po.push("<tbody>");
			for (var r = 0; r < cfg.colHead.rows.length; r++) {
				var isLastTR = (cfg.colHead.rows.length - 1 == r);
				po.push("<tr>");
				var colCount = 0;
				axf.each(cfg.colHead.rows[r], function (CHidx, CH) {
					if (CH.display && CH.colspan > 0) {
						//radio, check exception
						var tdHtml = CH.label || "untitle";
						var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
						var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
						var valign = " valign=\"" + CH.valign + "\"";
						var bottomClass = (CH.isLastCell) ? "" : " colHeadBottomBorder";

						po.push(getColHeadTd({
							valign: valign, rowspan: rowspan, colspan: colspan, bottomClass: bottomClass, r: r, CHidx: CHidx,
							align: CH.align, colSeq: CH.colSeq, formatter: CH.formatter, sort: CH.sort, tdHtml: tdHtml,
							ghost: (colCount < (cfg.fixedColSeq + 1))
						}));

						colCount += CH.colspan;
					}
				});
				po.push("</tr>");
			}
			po.push("</tbody>");
			po.push("</table>");

			var fpo = [];
			fpo.push("<div class=\"AXGridColHead fixedColHead\" id=\"" + cfg.targetID + "_AX_fixedColHead\" style=\"width:" + this.fixedColWidth + "px;\">");
			fpo.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"colHeadTable\" style=\"width:" + this.fixedColWidth + "px;\">");
			fpo.push(this.getColGroup("FC")); //colGroup 삽입
			fpo.push("<tbody>");
			for (var r = 0; r < cfg.colHead.rows.length; r++) {
				var isLastTR = (cfg.colHead.rows.length - 1 == r);
				fpo.push("<tr>");
				var colCount = 0;
				axf.each(cfg.colHead.rows[r], function (CHidx, CH) {
					if (CH.display && CH.isFixedCell && CH.colspan > 0) {
						//trace({CHidx:CHidx, fixedColSeq:(cfg.fixedColSeq+1)});
						//radio, check exception
						var tdHtml = CH.label || "untitle";
						var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
						var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
						var valign = " valign=\"" + CH.valign + "\"";
						var bottomClass = (CH.isLastCell) ? "" : " colHeadBottomBorder";

						fpo.push(getColHeadTd({
							valign: valign, rowspan: rowspan, colspan: colspan, bottomClass: bottomClass, r: r, CHidx: CHidx,
							align: CH.align, colSeq: CH.colSeq, formatter: CH.formatter, sort: CH.sort, tdHtml: tdHtml,
							ghost: false
						}));
					}
					colCount += CH.colspan;
				});
				fpo.push("</tr>");
			}
			fpo.push("</tbody>");
			fpo.push("</table>");
			fpo.push("</div>");
		}
		////////////////////////////////////////////////////////////////////////////////////////////// fixedCol 구현

		this.colHead.html(po.join(''));
		axdom("#" + cfg.targetID + "_AX_fixedColHead").remove();
		if (fpo) this.colHead.after(fpo.join(''));

		//resizer 를 찾아 resizer의 부모와 같은 높이값을 가지도록 변경 합니다.
		//또 그와 관련된 개체의 높이와 패딩을 지정합니다.
		this.colHead.find(".colHeadResizer").each(function () {
			var resizerID = this.id;
			var tdID = resizerID.replace("colHeadResizer", "colHead");
			var txtID = resizerID.replace("colHeadResizer", "colHeadText");
			var toolID = resizerID.replace("colHeadResizer", "colHeadTool");
			var rowspan = axdom("#" + tdID).attr("rowspan");
			var valign = axdom("#" + tdID).attr("valign");
			if (!rowspan) rowspan = 1;
			var tdHeight = axdom("#" + tdID).height();
			axdom(this).css({ height: tdHeight });
			axdom(this).parent().css({ height: tdHeight });
			if (rowspan > 1) {
				var cellMarginTop = 0;
				if (valign == "bottom") cellMarginTop = (tdHeight - axdom("#" + txtID).outerHeight()) + 5;
				if (valign == "middle") cellMarginTop = (tdHeight - axdom("#" + txtID).outerHeight()) / 2 + 5;
				axdom("#" + txtID).css({ "padding-top": cellMarginTop + "px" });
				axdom("#" + toolID).css({ "top": (cellMarginTop - 5) + "px" });
			}
		});

		this.colHead.bind("mouseover", this.colHeadMouseOver.bind(this));
		this.colHead.bind("mouseout", this.colHeadMouseOut.bind(this));
		this.colHead.find(".colHeadNode").bind("click", this.colHeadNodeClick.bind(this));
		this.colHead.find(".colHeadTool").bind("click", this.colHeadToolClick.bind(this));
		this.colHead.find(".colHeadResizer").bind("mousedown", this.colHeadResizerMouseDown.bind(this));
		this.colHead.find(".gridCheckBox").bind("click", this.colHeadCheckBoxClick.bind(this));

		if (this.hasFixed) { //fixedColHead에 대한 바인딩 및 처리
			this.fixedColHead = axdom("#" + cfg.targetID + "_AX_fixedColHead");

			this.fixedColHead.find(".colHeadResizer").each(function () {
				var resizerID = this.id;
				var tdID = resizerID.replace("colHeadResizer", "colHead");
				var txtID = resizerID.replace("colHeadResizer", "colHeadText");
				var toolID = resizerID.replace("colHeadResizer", "colHeadTool");
				var rowspan = axdom("#" + tdID).attr("rowspan");
				var valign = axdom("#" + tdID).attr("valign");
				if (!rowspan) rowspan = 1;
				var tdHeight = axdom("#" + tdID).height();
				axdom(this).css({ height: tdHeight });
				axdom(this).parent().css({ height: tdHeight });
				if (rowspan > 1) {
					var cellMarginTop = 0;
					if (valign == "bottom") cellMarginTop = (tdHeight - axdom("#" + txtID).outerHeight()) + 5;
					if (valign == "middle") cellMarginTop = (tdHeight - axdom("#" + txtID).outerHeight()) / 2 + 5;
					axdom("#" + txtID).css({ "padding-top": cellMarginTop + "px" });
					axdom("#" + toolID).css({ "top": (cellMarginTop - 5) + "px" });
				}
			});

			this.fixedColHead.bind("mouseover", this.colHeadMouseOver.bind(this));
			this.fixedColHead.bind("mouseout", this.colHeadMouseOut.bind(this));
			this.fixedColHead.find(".colHeadNode").bind("click", this.colHeadNodeClick.bind(this));
			this.fixedColHead.find(".colHeadTool").bind("click", this.colHeadToolClick.bind(this));
			this.fixedColHead.find(".colHeadResizer").bind("mousedown", this.colHeadResizerMouseDown.bind(this));
			this.fixedColHead.find(".gridCheckBox").bind("click", this.colHeadCheckBoxClick.bind(this));
		}
	},
	/* colHead events */
	colHeadMouseOver: function (event) {
		var cfg = this.config;
		// event target search -
		if(event.target.id == "") return;
		var eid = event.target.id.split(/_AX_/g);
		var eventTarget = event.target;
		var myTarget = this.getEventTarget({
			evt: eventTarget, evtIDs: eid,
			until: function (evt, evtIDs) { return (axdom(evt.parentNode).hasClass("AXGridColHead")) ? true : false; },
			find: function (evt, evtIDs) { return (axdom(evt).hasClass("colHeadTd")) ? true : false; }
		});
		// event target search ------------------------

		if (myTarget) {
			//colHeadTool ready
			var targetID = myTarget.id;
			var toolID = targetID.replace("colHead", "colHeadTool");
			axdom("#" + toolID).addClass("readyTool");
		}
	},
	colHeadMouseOut: function (event) {
		var cfg = this.config;
		// event target search -
		if(event.target.id == "") return;
		var eid = event.target.id.split(/_AX_/g);
		var eventTarget = event.target;
		var myTarget = this.getEventTarget({
			evt: eventTarget, evtIDs: eid,
			until: function (evt, evtIDs) { return (axdom(evt.parentNode).hasClass("AXGridColHead")) ? true : false; },
			find: function (evt, evtIDs) { return (axdom(evt).hasClass("colHeadTd")) ? true : false; }
		});
		// event target search ------------------------

		if (myTarget) {
			//colHeadTool unready
			var targetID = myTarget.id;
			var toolID = targetID.replace("colHead", "colHeadTool");
			axdom("#" + toolID).removeClass("readyTool");
		}
	},
	colHeadResizerMouseDown: function (event) {
		var cfg = this.config;
		if(event.target.id == "") return;
		var eid = event.target.id.split(/_AX_/g);
		var eventTarget = event.target;
		var lastIdx = eid.length - 1;
		var colHeadR = eid[lastIdx - 1];
		var colHeadC = eid[lastIdx];
		var colSeq = this.getColSeqToHead(colHeadR, colHeadC);
		if (colSeq == null) return; // 예상할 수 없는 오류
		//resize 상태 해제
		if (this.colResizing) {
			this.colHeadResizerEnd();
		}
		var offset = axdom("#" + cfg.targetID + "_AX_colHead_AX_" + colHeadR + "_AX_" + colHeadC).find(".tdRelBlock").position();
		var relBlockWidth = axdom("#" + cfg.targetID + "_AX_colHead_AX_" + colHeadR + "_AX_" + colHeadC).find(".tdRelBlock").width();
		var rightPosition = offset.left.number() + relBlockWidth.number();
		var blockWidth = axdom("#" + cfg.targetID + "_AX_col_AX_" + colSeq + "_AX_CH").attr("width");
		this.colResizeTarget = { colSeq: colSeq, leftPosition: (rightPosition - blockWidth), blockWidth: blockWidth, newWidth: blockWidth };
		//trace(this.colResizeTarget);

		/* resize event bind */
		var colHeadResizerMouseMove = this.colHeadResizerMouseMove.bind(this);
		this.colHeadResizerMouseMoveBind = function (event) {
			colHeadResizerMouseMove(event);
		}
		var colHeadResizerMouseUp = this.colHeadResizerMouseUp.bind(this);
		this.colHeadResizerMouseUpBind = function (event) {
			colHeadResizerMouseUp(event);
		}
		axdom(document.body).bind("mousemove.AXTree", this.colHeadResizerMouseMoveBind);
		axdom(document.body).bind("mouseup.AXTree", this.colHeadResizerMouseUpBind);
		axdom(document.body).bind("mouseleave.AXTree", this.colHeadResizerMouseUpBind);
		axdom("iframe").bind("mouseover.AXTree", this.colHeadResizerMouseUpBind);

		axdom(document.body).attr("onselectstart", "return false");
		//axdom(document.body).addClass("AXUserSelectNone");
		/* resize event bind ~~~~~~~~~~~~~~~~~~~ */
	},
	colHeadResizerMouseMove: function (event) {
		if (!event.pageX) return;
		//드래그 감도 적용
		if (this.config.moveSens > this.moveSens) this.moveSens++;
		if (this.moveSens == this.config.moveSens) this.colHeadResizerMove(event);
	},
	colHeadResizerMove: function (event) {
		var cfg = this.config;
		var mouse = this.getHeadMousePosition(event);
		var newWidth = (this.colResizeTarget.leftPosition - mouse.x).abs();
		if (newWidth < 31) return;
		/* colHead/colBody colGroup width 조정 */
		axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_CH").attr("width", newWidth);
		axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_CB").attr("width", newWidth);
		axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_EB").attr("width", newWidth);

		cfg.colGroup[this.colResizeTarget.colSeq].width = newWidth;

		if (this.hasFixed) {
			var fixedColSeq = this.fixedColSeq;

			axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_FC").attr("width", newWidth);
			axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_FB").attr("width", newWidth);
			axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_FE").attr("width", newWidth);

			//if(this.colResizeTarget.colSeq < fixedColSeq+1){

			var fixedColWidth = 0;
			axf.each(cfg.colGroup, function (cidx, CG) {
				if (CG.display && cidx < (fixedColSeq + 1)) {
					fixedColWidth += CG.width.number();
				}
			});
			this.fixedColWidth = fixedColWidth;

			axdom("#" + cfg.targetID + "_AX_fixedColHead").css({ width: fixedColWidth });
			axdom("#" + cfg.targetID + "_AX_fixedColHead").find(".colHeadTable").css({ width: fixedColWidth });
			axdom("#" + cfg.targetID + "_AX_fixedScrollContent").css({ width: fixedColWidth });
			axdom("#" + cfg.targetID + "_AX_fixedScrollContent").find(".gridFixedBodyTable").css({ width: fixedColWidth });
			axdom("#" + cfg.targetID + "_AX_fixedEditorContent").css({ width: fixedColWidth });
			axdom("#" + cfg.targetID + "_AX_fixedEditorContent").find(".gridFixedBodyTable").css({ width: fixedColWidth });
			//}

		}

		if (this.editorOpend) {
			var colSeq = this.colResizeTarget.colSeq;
			//
			for (var _m = 0; _m < cfg.editor._maps.length; _m++) {
				var rc = cfg.editor._maps[_m][colSeq];
				var CH = cfg.editor.rows[rc.r][rc.c];
				var formID = (CH.form.id) ? CH.form.id : cfg.targetID + "_AX_" + CH.key + "_AX_" + rc.r + "_AX_" + rc.c;
				//trace(formID);
				if (axf.getId(formID)) if (axf.getId(formID).tagName == "INPUT") AXInput.alignAnchor(formID);
			}
		}


		/* colHead colGroup width 조정 ------------------------------ */
		this.colResizeTarget.newWidth = newWidth;
		var newColWidth = this.colWidth - (this.colResizeTarget.blockWidth - this.colResizeTarget.newWidth);
		this.colHead.find(".colHeadTable").css({ "width": newColWidth + "px" });
		//this.body.find(".gridBodyTable").css({"width":newColWidth+"px"});
	},
	colHeadResizerMouseUp: function (event) {
		if (this.colResizeTarget.blockWidth != this.colResizeTarget.newWidth) {
			this.colWidth = this.colWidth - (this.colResizeTarget.blockWidth - this.colResizeTarget.newWidth);
		}
		this.colHeadResizerEnd();
		this.contentScrollResize(false);
	},
	colHeadResizerEnd: function () {
		this.moveSens = 0;
		this.colResizing = false;
		axdom(document.body).unbind("mousemove.AXTree");
		axdom(document.body).unbind("mouseup.AXTree");
		axdom(document.body).unbind("mouseleave.AXTree");
		axdom("iframe").unbind("mouseover.AXTree");

		axdom(document.body).removeAttr("onselectstart");
		//axdom(document.body).removeClass("AXUserSelectNone");
	},
	colHeadNodeClick: function (event) {
		var cfg = this.config;
		if(event.target.id == "") return;
		var eid = event.target.id.split(/_AX_/g);
		var eventTarget = event.target;

		if (this.editorOpend) {
			toast.push("Editor 활성화 상태에서는 기능을 사용할 수 없습니다.");
			return; // 에디터가 오픈된 상태이면 비활성화
		}

		if (axdom(eventTarget).hasClass("colHeadTdCheck")) {
			this.colHeadCheckBoxClick(event);
			return; // checkbox block click
		}
		if (axdom(eventTarget).hasClass("gridCheckBox")) return; // checkbox click

		var lastIdx = eid.length - 1;
		var colHeadR = eid[lastIdx - 1];
		var colHeadC = eid[lastIdx];
		var myColHead = cfg.colHead.rows[colHeadR][colHeadC];
		var tdID = cfg.targetID + "_AX_colHead_AX_" + colHeadR + "_AX_" + colHeadC;
		//trace(myColHead);

		if (myColHead.colSeq == undefined || myColHead.colSeq == null) {
			trace("정렬할 수 없는 컬럼 입니다.");
		} else {
			/* -- 현재 기술로는 정렬 지원 어려움
             if(this.nowSortHeadID){
             if(this.nowSortHeadID != tdID){
             axdom("#"+this.nowSortHeadID).removeClass("sortDesc");
             axdom("#"+this.nowSortHeadID).removeClass("sortAsc");
             this.nowSortHeadObj.sort = undefined;
             }
             }
             //trace(myColHead);
             if(cfg.colHead.rows[colHeadR][colHeadC].sort == "desc") axdom("#"+tdID).removeClass("sortDesc");
             else axdom("#"+tdID).removeClass("sortAsc");

             var nsort = "";
             if(myColHead.sort == "desc") nsort = "asc";
             else nsort = "desc";
             cfg.colHead.rows[colHeadR][colHeadC].sort = nsort;

             //sort 처리하기
             if(nsort == "desc"){
             axdom("#"+tdID).addClass("sortDesc");
             }else{
             axdom("#"+tdID).addClass("sortAsc");
             }

             this.list = this.sortList(nsort, myColHead, this.list);
             this.printList();

             this.nowSortHeadID = tdID;
             this.nowSortHeadObj = myColHead;
             */
		}

		if (cfg.colHead.onclick) { // onclick bind
			var sendObj = {
				index: null,
				r: colHeadR,
				c: colHeadC,
				list: this.list,
				colHead: myColHead,
				page: this.page
			};
			cfg.colHead.onclick.call(sendObj);
		}

	},
	colHeadToolClick: function (event) {
		var cfg = this.config;
		if(event.target.id == "") return;
		var eid = event.target.id.split(/_AX_/g);
		var eventTarget = event.target;

		if (this.editorOpend) {
			toast.push("Editor 활성화 상태에서는 기능을 사용할 수 없습니다.");
			return; // 에디터가 오픈된 상태이면 비활성화
		}

		var lastIdx = eid.length - 1;
		var colHeadR = eid[lastIdx - 1];
		var colHeadC = eid[lastIdx];
		var myColHead = cfg.colHead.rows[colHeadR][colHeadC];
		//toast.push("클릭된 colGroup seq : " + myColHead.colSeq);

		axdom("#" + cfg.targetID + "_AX_colHeadMenu").remove();

		var po = [];
		po.push("<div id=\"" + cfg.targetID + "_AX_colHeadMenu\" class=\"AXTreeColGroupListBox\">");
		axf.each(cfg.colGroup, function (cidx, CG) {
			var addClass = (CG.display) ? " on" : "";
			var lastClass = (cidx == cfg.colGroup.length - 1) ? " last" : "";
			po.push("<a href=\"#AXexec\" class=\"AXTreeColGroupListBoxItem" + addClass + lastClass + "\" id=\"" + cfg.targetID + "_AX_colHeadMenu_AX_" + CG.colSeq + "\">");
			po.push(CG.label);
			po.push("</a>");
		});
		po.push("</div>");
		axdom(document.body).append(po.join(''));

		var offset = axdom(eventTarget).offset();
		var css = {};
		css.top = offset.top - 5;
		css.left = offset.left - 20;
		axdom("#" + cfg.targetID + "_AX_colHeadMenu").css(css);

		/* colGroup click event bind */
		var colGroupListClick = this.colGroupListClick.bind(this);
		this.colGroupListClickBind = function (event) {
			colGroupListClick(event);
		}
		axdom(document).bind("click", this.colGroupListClickBind);
		axdom(document).bind("keydown", this.colGroupListClickBind);
		/* colGroup click bind ~~~~~~~~~~~~~~~~~~~ */
	},
	colGroupListClick: function (event) {
		var cfg = this.config;

		if (event.keyCode == AXUtil.Event.KEY_ESC) {
			axdom("#" + cfg.targetID + "_AX_colHeadMenu").remove();
			axdom(document).unbind("keydown", this.colGroupListClickBind);
			axdom(document).unbind("click", this.colGroupListClickBind);
			return;
		}

		// event target search -
		if(event.target.id == "") return;
		var eid = event.target.id.split(/_AX_/g);
		var eventTarget = event.target;
		var myTarget = this.getEventTarget({
			evt: eventTarget, evtIDs: eid,
			find: function (evt, evtIDs) { return (axdom(evt).hasClass("AXTreeColGroupListBoxItem") || axdom(evt).hasClass("colHeadTool")) ? true : false; }
		});
		// event target search ------------------------

		if (myTarget) {
			if (axdom(myTarget).hasClass("colHeadTool")) return;
			//colHeadTool ready
			var targetID = myTarget.id;
			var colSeq = targetID.split(/_AX_/g).last();
			//trace(cfg.colGroup[colSeq]);
			if (cfg.colGroup[colSeq].display) {
				cfg.colGroup[colSeq].display = false;
				axdom("#" + targetID).removeClass("on");
			} else {
				cfg.colGroup[colSeq].display = true;
				axdom("#" + targetID).addClass("on");
			}
			//redraw grid
			this.redrawGrid();
		} else {
			axdom("#" + cfg.targetID + "_AX_colHeadMenu").remove();
			axdom(document).unbind("keydown", this.colGroupListClickBind);
			axdom(document).unbind("click", this.colGroupListClickBind);
		}
	},
	colHeadCheckBoxClick: function (event) {
		var cfg = this.config;
		if(event.target.id == "") return;
		var eid = event.target.id.split(/_AX_/g);
		var eventTarget = event.target;

		if (axdom(eventTarget).hasClass("colHeadTdCheck")) {
			eventTarget = axdom(eventTarget).find("input").get(0);
			eventTarget.checked = !eventTarget.checked;
		}
		var lastIdx = eid.length - 1;
		var colHeadR = eid[lastIdx - 1];
		var colHeadC = eid[lastIdx];
		var myColHead = cfg.colHead.rows[colHeadR][colHeadC];

		this.checkedColSeq(myColHead.colSeq, eventTarget.checked);
	},
	/* colHead events ~~~~~~~~~~~~~~~~~*/
	/* colHead 영역  ~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	/* body */
	sortList: function (nsort, myColHead, list) {
		var cfg = this.config;

		var getValueForSort = function (item, itemIndex) {
			if (myColHead.formatter) {
				var result;
				if (myColHead.formatter == "money") {
					result = item[myColHead.key];
				} else if (myColHead.formatter == "dec") {
					result = item[myColHead.key].dec();
				} else if (myColHead.formatter == "html") {
					result = item[myColHead.key];
				} else if (myColHead.formatter == "checkbox") {
					result = item[myColHead.key];
				} else {
					var sendObj = {
						index: itemIndex,
						list: list,
						item: item,
						page: this.page
					}
					result = myColHead.formatter.call(sendObj);
					//result 값이 money 형식인지 체크 합니다.
					var moneyCheck = result.replace(/,/g, "");
					if (axdom.isNumeric(moneyCheck)) result = result.number();
				}
				return result;
			} else {
				return item[myColHead.key];
			}
		};

		if (nsort == "desc") {
			var listIndex = 0;
			list = list.sort(function (prevItem, nowItem) {
				if (prevItem[cfg.reserveKeys.hashKey].length == nowItem[cfg.reserveKeys.hashKey].length) {
					var v1 = getValueForSort(prevItem, listIndex);
					var v2 = getValueForSort(nowItem, listIndex);
					listIndex++;
					if (v1 < v2) return 1;
					else if (v1 > v2) return -1;
					else if (v1 == v2) return 0;
				} else {
					return 0;
				}
			});
		} else {
			var listIndex = 0;
			list = list.sort(function (prevItem, nowItem) {
				if (prevItem[cfg.reserveKeys.hashKey].length == nowItem[cfg.reserveKeys.hashKey].length) {
					var v1 = getValueForSort(prevItem, listIndex);
					var v2 = getValueForSort(nowItem, listIndex);
					listIndex++;
					if (v1 < v2) return -1;
					else if (v1 > v2) return 1;
					else if (v1 == v2) return 0;
				} else {
					return 0;
				}
			});
		}

		return list;
	},
	setBody: function (list) {
		var cfg = this.config;
		if (list) {
			this.list = list;
		}

		var po = [];
		po.push("<div id=\"" + cfg.targetID + "_AX_scrollContent\" class=\"treeScrollContent\">");
		po.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"treeBodyTable\" style=\"\">");
		po.push(this.getColGroup("CB")); //colGroup 삽입
		po.push("<thead id=\"" + cfg.targetID + "_AX_thead\"></thead>");
		po.push("<tbody id=\"" + cfg.targetID + "_AX_tbody\">");
		po.push("<tr class=\"noListTr\">");
		po.push("<td colspan=\"" + (this.showColLen) + "\">");
		po.push("<div class=\"tdRelBlock\">");
		po.push("<div class=\"bodyNode bodyTdText\" align=\"center\">");
		po.push(cfg.emptyListMSG);
		po.push("</div>");
		po.push("</div>");
		po.push("</td>");
		po.push("<td class=\"bodyNullTd\"><div class=\"tdRelBlock\">&nbsp;</div></td>");
		po.push("</tr>");
		po.push("</tbody>");
		po.push("<tfoot id=\"" + cfg.targetID + "_AX_tfoot\"></tfoot>");
		po.push("</table>");
		po.push("</div>");
		if (this.hasFixed) {
			po.push("<div id=\"" + cfg.targetID + "_AX_fixedScrollContent\" class=\"treeFixedScrollContent\" style=\"width:" + this.fixedColWidth + "px;\">");
			po.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"treeFixedBodyTable\" style=\"width:" + this.fixedColWidth + "px;\">");
			po.push(this.getColGroup("FB")); //colGroup 삽입
			po.push("<thead id=\"" + cfg.targetID + "_AX_fixedThead\"></thead>");
			po.push("<tbody id=\"" + cfg.targetID + "_AX_fixedTbody\">");
			po.push("<tr class=\"noListTr\">");
			po.push("<td colspan=\"" + (this.showColLen) + "\">");
			po.push("</td>");
			po.push("</tr>");
			po.push("</tbody>");
			po.push("<tfoot id=\"" + cfg.targetID + "_AX_fixedTfoot\"></tfoot>");
			po.push("</table>");
			po.push("</div>");
		}
		//po.push("<div id=\"" + cfg.targetID + "_AX_scrollTrackXY\" class=\"treeScrollTrackXY\"></div>");
		po.push("<div id=\"" + cfg.targetID + "_AX_scrollTrackY\" class=\"treeScrollTrackY\"><div id=\"" + cfg.targetID + "_AX_scrollYHandle\" class=\"treeScrollHandle\"></div></div>");
		po.push("<div id=\"" + cfg.targetID + "_AX_scrollTrackX\" class=\"treeScrollTrackX\"><div id=\"" + cfg.targetID + "_AX_scrollXHandle\" class=\"treeScrollHandle\"></div></div>");
		po.push("<div style=\"display:none;\">");
		po.push("<div id=\"" + cfg.targetID + "_AX_Selector\" class=\"AXtreeSelector\"></div>");
		po.push("</div>");
		this.body.html(po.join(''));

		if (this.list.length > 0) {
			this.setList(this.list, false);
		}

		// scroll event bind
		axdom("#" + cfg.targetID + "_AX_scrollYHandle").bind("mousedown", this.contentScrollScrollReady.bind(this));
		axdom("#" + cfg.targetID + "_AX_scrollXHandle").bind("mousedown", this.contentScrollScrollReady.bind(this));
		// scroll event bind ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	},
	listLoadingDisplay: function () {
		var cfg = this.config;
		var po = [];
		po.push("<tr class=\"noListTr\">");
		po.push("<td colspan=\"" + (this.showColLen) + "\">");
		po.push("<div class=\"tdRelBlock\">");
		po.push("<div class=\"bodyNode bodyTdText\" align=\"center\">");
		po.push("	<div class=\"AXLoading\"></div>");
		po.push("</div>");
		po.push("</div>");
		po.push("</td>");
		po.push("<td class=\"bodyNullTd\"><div class=\"tdRelBlock\">&nbsp;</div></td>");
		po.push("</tr>");
		axdom("#" + cfg.targetID + "_AX_tbody").html(po.join(''));

		po = [];
		po.push("<tr class=\"noListTr\">");
		po.push("<td colspan=\"" + (this.showColLen) + "\">");
		po.push("</td>");
		po.push("</tr>");
		axdom("#" + cfg.targetID + "_AX_fixedTbody").html(po.join(''));
	},
	getAXTreeSplit: function(isFix){
		var cfg = this.config;
		var po = [];
		if(isFix == "n"){
			po.push("<tr class=\"AXTreeSplit\">");
			po.push("<td colspan=\"" + (this.showColLen) + "\">");
			po.push("</td>");
			po.push("<td class=\"bodyNullTd\"><div class=\"tdRelBlock\">&nbsp;</div></td>");
			po.push("</tr>");
		}else{
			po.push("<tr class=\"AXTreeSplit\">");
			po.push("<td colspan=\"" + (this.showColLen) + "\">");
			po.push("</td>");
			po.push("</tr>");
		}
		return po.join('');
	},
	/**
	 * @method AXTree.setList
	 * @param {Array | Object} obj - example code 참고
	 * @param {String} [positioning] - 특정 자식개채를 지정해서 하위의 자식노드를 업데이트 합니다.
	 * @description
	 * 트리에 데이터를 전달합니다. 비동기 방식의 경우 직접데이터를 전달하지 않고 데이터의 전달자 정보를 정의하여 처리합니다.
	 * @example
	 * ```js
	 * //Array - list Array setConfig 에서 정의한 relation 의 부모, 자식키 값을 이용하여 list형 데이터를 tree형 데이터로 변환하여 트리를 구성합니다.
	 * var List = [
	 * 	 {no:1, nodeName:"LEVEL 1-1", writer:"tom", type:"0", pno:0},
	 * 	 {no:11, nodeName:"LEVEL 1-1-1", writer:"tom", type:"0", pno:1},
	 * 	 {no:2, nodeName:"LEVEL 2-1", writer:"tom", type:"0", pno:0},
	 * 	 {no:21, nodeName:"LEVEL 2-1-1", writer:"tom", type:"0", pno:2},
	 * 	 {no:24, nodeName:"LEVEL 2-1-4", writer:"tom", type:"0", pno:2},
	 * 	 {no:241, nodeName:"LEVEL 2-1-4-1", writer:"tom", type:"0", pno:24},
	 * 	 {no:2411, nodeName:"LEVEL 2-1-4-1-1", writer:"tom", type:"0", pno:241},
	 * 	 {no:2412, nodeName:"LEVEL 2-1-4-1-1", writer:"tom", type:"0", pno:241},
	 * 	 {no:25, nodeName:"LEVEL 2-1-2", writer:"tom", type:"0", pno:2},
	 * 	 {no:26, nodeName:"LEVEL 2-1-3", writer:"tom", type:"0", pno:2},
	 * 	 {no:3, nodeName:"LEVEL 3-1", writer:"tom", type:"0", pno:0},
	 * 	 {no:11, nodeName:"LEVEL 3-1", writer:"tom", type:"0", pno:0}
	 * 	 ];
	 * 	 myTree.setList(List);
	 *
	 * 	 var AJAXconfigs = {
	 *     ajaxUrl:"loadTree.php", //{String} - AJAX 호출 URL
	 *     ajaxPars:"param1=1&param2=2",   //{String} - AJAX 호출 URL 파라미터 (전송은 post 방식으로 이루어집니다.)
	 *     onLoad: function(){ //[Function] - AJAX 호출완료 이벤트 콜백함수
	 *     ...
	 *     }
	 * };
	 * myTree.setList(AJAXconfigs);
	 * ```
	 */
	setList: function (obj, positioning) {
		var cfg = this.config;
		var nowSortHeadID = this.nowSortHeadID;
		var nowSortHeadObj = this.nowSortHeadObj;

		this.listLoadingDisplay();

		axdom("#" + cfg.targetID + "_AX_scrollContent").css({ width: "auto" });

		if (obj.ajaxUrl)
		{
			this.ajaxInfo = obj;
			this.ajax_sortDisable = positioning;
			var sortDisable = positioning;
			this.pageActive = true;

			var url = obj.ajaxUrl;
			var appendPars = [
				"pageNo=" + this.page.pageNo,
				"pageSize=" + this.page.pageSize
			];
			var pars = (obj.ajaxPars) ? obj.ajaxPars + "&" + appendPars.join('&') : appendPars.join('&');

			var _method = "post";
			var _contentType = AXConfig.AXReq.contentType;
			var _headers = {};
			var _responseType = AXConfig.AXReq.responseType;
			var _dataType = AXConfig.AXReq.dataType;

			if (obj.method) _method = obj.method;
			if (obj.contentType) _contentType = obj.contentType;
			if (obj.headers) _headers = obj.headers;

			var ajaxGetList = this.ajaxGetList.bind(this);
			new AXReq(url, {
				type: _method,
				contentType: _contentType,
				responseType: _responseType,
				dataType: _dataType,
				headers: _headers,
				debug: obj.debug,
				pars: pars,
				debug: false,
                pars: pars,
                onsucc: function (res) {
					if (res.result == AXConfig.AXReq.okCode) {
						res._sortDisable = sortDisable;
						if (obj.response) {
							obj.response.call(res);
						} else {
							ajaxGetList(res, positioning);
						}
						if (obj.onLoad) obj.onLoad.call(res);
					} else {
						AXUtil.alert(res);
					}
				}
			});

		}
		else
		{
			this.ajaxInfo = null;
			if (axdom.isArray(obj)) {
				if (obj.length == 0) {

					/*
                     var po = [];
                     po.push("<div class=\"bodyNode bodyTdText\" align=\"center\">");
                     po.push("목록이 없습니다.");
                     po.push("</div>");
                     axdom("#" + cfg.targetID + "_AX_tbody").html(po.join(''));
                     */
					//return;
				}

				if (typeof positioning === "undefined") {
					this.list = this.positioningHashList(obj);
				} else {
					this.list = obj;
				}

				this.printList();
				this.pageActive = false;
			}
		}
	},
	reloadList: function () {
		var cfg = this.config;
		var nowSortHeadID = this.nowSortHeadID;
		var nowSortHeadObj = this.nowSortHeadObj;

		if (this.ajaxInfo) {
			var obj = this.ajaxInfo;
			var sortDisable = this.ajax_sortDisable;
			this.pageActive = true;

			this.listLoadingDisplay();

			var url = obj.ajaxUrl;
			var appendPars = [
				"pageNo=" + this.page.pageNo,
				"pageSize=" + this.page.pageSize
			];
			var pars = (obj.ajaxPars) ? obj.ajaxPars + "&" + appendPars.join('&') : appendPars.join('&');

			var ajaxGetList = this.ajaxGetList.bind(this);
			new AXReq(url, {
				debug: false, pars: pars, onsucc: function (res) {
					if (res.result == AXConfig.AXReq.okCode) {
						res._sortDisable = sortDisable;
						if (obj.response) {
							obj.response.call(res);
						} else {
							ajaxGetList(res);
						}
					} else {
						AXUtil.alert(res);
					}
				}
			});

		}
	},
	ajaxGetList: function (res, positioning) {
		var cfg = this.config;
		var nowSortHeadID = this.nowSortHeadID;
		var nowSortHeadObj = this.nowSortHeadObj;

		if (res._sortDisable || !cfg.sort) {
			this.list = res[AXConfig.AXTree.keyList];
		} else {
			if (nowSortHeadID) {
				this.list = this.sortList(nowSortHeadObj.sort, nowSortHeadObj, res[AXConfig.AXTree.keyList]);
			} else {
				this.list = res[AXConfig.AXTree.keyList];
			}
		}
		//trace(this.list);
		if (positioning == undefined) {
			this.list = this.positioningHashList(this.list);
		} else {
			//this.list = obj;
		}

		//AXUtil.overwriteObject(this.page, res.page, true);
		this.printList();
	},
	/**
	 * @method AXTree.getFormatterValue
	 * @param {String|Function} formatter - config 의 colGroup이나 colHead에서 지정된 formatter
	 * @param {Object} item  - 대상 인덱스의 리스트 1개 열
	 * @param {Number} itemIndex  - 대상 인덱스
	 * @param {String} value - 표현 대상 값.
	 * @param {Object} key - config 의 colGroup 내부 key 값
	 * @param {Object} CH - 대상 그리드의 [열][행]
	 * @param {Number} CHidx - 대상 그리드의 [열][행] 중 행의 index
	 * @returns {String}
	 * @description 지정된 표현 형식으로 데이터를 HTML String 으로 변환 시킵니다.
	 */
	getFormatterValue: function (formatter, item, itemIndex, value, key, CH, CHidx) {
		var cfg = this.config;
		var result;
		if(CH.editor && (CH.editor.type == "checkbox" || CH.editor.type == "radio")){
			//
			// editCell 처리
			var checkedStr = "", disabled = "",
				that = {
					index: itemIndex,
					list: this.list,
					item: item,
					page: this.page,
					key: key,
					value: value
				};

			if(value && value.__checked) checkedStr = ' checked="checked"';
			else if(value == true || value == 1 || value == "1" || value == "Y") checkedStr = ' checked="checked"';
			if(CH.editor.disabled){
				if(CH.editor.disabled.call(that)){
					disabled = ' disabled="disabled"';
				}
			}

			result = '<input type="'+CH.editor.type+'" name="'+ key +'" data-editor-key="'+itemIndex+','+CHidx+'" class="inline-editor-checkbox" ' +
				checkedStr + disabled + ' onfocus="this.blur();" />';
			//"<input type=\"checkbox\" name=\"" + CH.label + "\" class=\"treeCheckBox_body_colSeq" + CH.colSeq + "\" id=\"" + cfg.targetID + "_AX_checkboxItem_AX_" + CH.colSeq + "_AX_" + itemIndex + "\" value=\"" + value + "\" " + checkedStr + disabled + " onfocus=\"this.blur();\" />";
		}
		else
		if (formatter == "money") {
			if (value == "" || value == "null" || value == null || value == undefined) {
				result = "0";
			} else {
				result = (value || 0).number().money();
			}
		} else if (formatter == "dec") {
			result = (value == undefined) ? "" : value.toString().dec();
		} else if (formatter == "html") {
			result = value;
		} else if (formatter == "checkbox" || formatter == "radio") {
			var checkedStr = "";
			var disabled = "";
			var sendObj = {
				index: itemIndex,
				list: this.list,
				item: item,
				page: this.page,
				key: key,
				value: value
			};

			/*
			if(this.list[itemIndex].___checked && this.list[itemIndex].___checked[CHidx]){
				if(this.list[itemIndex].___checked[CHidx]) checkedStr = " checked=\"checked\" ";
				//if(itemIndex == 0) console.log(this.list[itemIndex].___checked[CHidx], checkedStr);
			}
			*/
			if(this.list[itemIndex].__checked){
				checkedStr = " checked=\"checked\" ";
			}
			else if (Object.isFunction(CH.checked)) {
				if (CH.checked.call(sendObj)) {
					checkedStr = " checked=\"checked\" ";
					if(!this.list[itemIndex].___checked) this.list[itemIndex].___checked = {};
					this.list[itemIndex].___checked[CHidx] = true;
				}
			}

			if (CH.disabled) {
				if (CH.disabled.call(sendObj)) {
					disabled = " disabled=\"disabled\" ";
					if(!this.list[itemIndex].___checked) this.list[itemIndex].___disabled = {};
					this.list[itemIndex].___disabled[CHidx] = true;
				}
			}
			/*
			 result = "<label class=\"gridCheckboxLabel\">" +
			 "<input type=\"" + formatter + "\" name=\"" + CH.label + "\" class=\"treeCheckBox_body_colSeq" + CH.colSeq + "\" id=\"" + cfg.targetID + "_AX_checkboxItem_AX_" + CH.colSeq + "_AX_" + itemIndex + "\" value=\"" + value + "\" " + checkedStr + disabled + " onfocus=\"this.blur();\" />" +
			 "</label>";
			 */
			result = "<input type=\"" + formatter + "\" name=\"" + CH.label + "\" class=\"treeCheckBox_body_colSeq" + CH.colSeq + "\" id=\"" + cfg.targetID + "_AX_checkboxItem_AX_" + CH.colSeq + "_AX_" + itemIndex + "\" value=\"" + value + "\" " + checkedStr + disabled + " onfocus=\"this.blur();\" />";
		} else {
			if(Object.isFunction(formatter)){
				var sendObj = {
					index: itemIndex,
					list: this.list,
					item: item,
					page: this.page,
					key: key,
					value: value
				};
				result = formatter.call(sendObj, itemIndex, item);
			} else {
				result = ((String(value) == "null") ? "" : value);
			}
		}
		return result;
	},
	getIconClassValue: function (getIconClass, item, itemIndex, value, key, CH) {
		var cfg = this.config;
		var iconClass;
		var sendObj = {
			index: itemIndex,
			list: this.list,
			item: item,
			page: this.page
		}
		iconClass = getIconClass.call(sendObj, itemIndex, item);
		return iconClass;
	},
	getTooltipValue: function (formatter, item, itemIndex, value, key, CH) {
		var cfg = this.config;
		var result;
		if (formatter == "money") {
			if (value == "" || value == "null") {
				result = "";
			} else {
				result = value.number().money();
			}
		} else if (formatter == "dec") {
			result = value.dec();
		} else if (formatter == "html") {
			result = value;
		} else if (formatter == "checkbox") {
			var checked = "";
			var disabled = "";

			var sendObj = {
				index: itemIndex,
				list: this.list,
				item: item
			}

			if (CH.checked) {
				var callCheckedResult = CH.checked.call(sendObj);
				if (callCheckedResult) {
					checked = " checked=\"checked\" ";
				}
			}

			if (CH.disabled) {
				var callDisabledResult = CH.disabled.call(sendObj);
				if (callDisabledResult) {
					disabled = " disable=\"disable\" ";
				}
			}
			result = "<input type=\"checkbox\" name=\"" + CH.label + "\" class=\"treeCheckBox_body_colSeq" + CH.colSeq + "\" id=\"" + cfg.targetID + "_AX_checkboxItem_AX_" + itemIndex + "\" value=\"" + value + "\" " + checked + disabled + " />";
		} else {
			var sendObj = {
				index: itemIndex,
				list: this.list,
				item: item,
				page: this.page
			}
			result = formatter.call(sendObj);
		}
		return result;
	},
	getItem: function (itemIndex, item, isfix, hasTr) {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var tpo = [];
		var evenClassName = "line" + (itemIndex % 2);
		var hashClassName = "parentHash" + item[cfg.reserveKeys.parentHashKey];

		var getFormatterValue = this.getFormatterValue.bind(this);
		var getTooltipValue = this.getTooltipValue.bind(this);
		var getIconClassValue = this.getIconClassValue.bind(this);
		var hasFixed = this.hasFixed;
		var hasTrValue = (hasTr == undefined) ? true : false;
		var trAddClass = "";
		if (cfg.body.addClass) {
			try {
				trAddClass = cfg.body.addClass.call({
					index: itemIndex,
					item: item,
					list: this.list
				});
			} catch (e) {
				trace(e);
			}
		}
		var trStyles = [];
		var isDisplay = item[reserveKeys.displayKey];
		if (!isDisplay) trStyles.push("display:none;");

		var _tree = this.tree;

		for (var r = 0; r < cfg.body.rows.length; r++) {
			var isLastTR = (cfg.body.rows.length - 1 == r);
			if (hasTrValue) tpo.push("<tr class=\"gridBodyTr gridBodyTr_" + itemIndex + " " + evenClassName + " " + hashClassName + " " + trAddClass + "\" id=\"" + cfg.targetID + "_AX_tr_" + r + "_AX_" + (isfix || "n") + "_AX_" + itemIndex + "\" style=\"" + trStyles.join('') + "\">");
			var colCount = 0;
			axf.each(cfg.body.rows[r], function (CHidx, CH) {
				if (CH.display && CH.colspan > 0) {

					if (isfix == "n" || (isfix != undefined && colCount < (cfg.fixedColSeq + 1))) {

						colCount += CH.colspan;

						//radio, check exception
						var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
						var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
						var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";
						var bottomClass = (CH.isLastCell) ? "" : " bodyBottomBorder";
						var fixedClass = (CH.isFixedEndCell) ? " fixedLine" : "";
						var bodyNodeStyles = [];
						var indentWidth = 0;
						var iconWidth = 0;
						if (CH.indent) {
							var hash = item[cfg.reserveKeys.hashKey];
							var re = new RegExp(cfg.hashSpliter, "g");
							indentWidth = ((hash.split(re).length - 1) * cfg.indentWidth) + 3;

							if (indentWidth > (cfg.indentWidth.number() + 3)) {
								indentWidth = indentWidth * cfg.indentRatio;
							}

							if (CH.getIconClass) {
								iconWidth = cfg.iconWidth;
							}
							if (CH.align == "left") {
								bodyNodeStyles.push("padding-left:" + (indentWidth + iconWidth) + "px;");
							} else {
								bodyNodeStyles.push("padding-right:" + (indentWidth + iconWidth) + "px;text-align:right;");
							}
						}
						/*trace({r:r, CHidx:CHifixedColSeq:cfg.fixedColSeq, colCount:colCount});*/

						var bodyNodeClass = "";
						if (CH.formatter == "checkbox") bodyNodeClass = " bodyTdCheckBox";
						else if (CH.formatter == "html") bodyNodeClass = " bodyTdHtml";

						var expandNodeClass = "";
						if (item[cfg.reserveKeys.openKey]) expandNodeClass = " expand";

						var iconClass = "";
						var tooltipValue = "";
						if (CH.tooltip) {
							tooltipValue = getTooltipValue(CH.tooltip, item, itemIndex, item[CH.key], CH.key, CH);
						}
						tpo.push("<td" + valign + rowspan + colspan + " id=\"" + cfg.targetID + "_AX_" + (isfix || "n") + "body_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\" class=\"bodyTd" + bottomClass + fixedClass + "\">");
						tpo.push("<div class=\"tdRelBlock\" title=\"" + tooltipValue + "\">");
						tpo.push("<div class=\"bodyNode bodyTdText" + bodyNodeClass + "\" style=\"" + bodyNodeStyles.join(";") + "\" align=\"" + CH.align + "\" id=\"" + cfg.targetID + "_AX_bodyText_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\">");

						if (CH.indent) {

							/*CH.align : left*/
							/*indentWidth : left position;*/
							if(cfg.showConnectionLine){
								/* line 표시 박스 구현	*/
								tpo.push("<span class=\"connectionLineContainer\">");
								var hashPosition = item[cfg.reserveKeys.hashKey].split(/_/g);
								for(var hp=2;hp<hashPosition.length;hp++){
									var hpLeft = ((hp - 2) * cfg.indentWidth) + 3;

									var hpIndentWidth = cfg.indentWidth * cfg.indentRatio;
									var connectionLineClass = [];
									var subTreeStr = "";
									if(hp < (hashPosition.length-1)){
										for (var i = 1; i < hp+1; i++) {
											if (i == 1) {
												subTreeStr += "[" + hashPosition[i].number() + "]";
											} else {
												subTreeStr += "[reserveKeys.subTree][" + hashPosition[i].number() + "]";
											}
										}
										var parentTree = null;
										try{
											eval("parentTree = _tree" + subTreeStr);
											if(parentTree.__isLastChild){
												connectionLineClass.push("isParentOutside");
											}else{
												connectionLineClass.push("isParentInside");
											}
										}catch(e){
											trace(e);
										}
									}else if(item.__isLastChild && hp == (hashPosition.length-1)){
										connectionLineClass.push("isLastChild");
									}
									tpo.push("<span class=\"connectionLine " + connectionLineClass.join(" ") + "\" style=\"" + CH.align + ":"+hpLeft+"px;width:" + hpIndentWidth + "px;\"></span>");
								}
								tpo.push("</span>");

								if (item.__subTreeLength == 0){
									expandNodeClass += " noChild";
								}

								tpo.push("<a class=\"bodyNodeIndent" + expandNodeClass + "\" id=\"" + cfg.targetID + "_AX_bodyNodeIndent_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\" style=\"" + CH.align + ":" + (indentWidth - 20) + "px;");
								//if (item.__subTreeLength == 0) tpo.push("display:none;");
								tpo.push("\"></a>");
							}else{
								tpo.push("<a class=\"bodyNodeIndent" + expandNodeClass + "\" id=\"" + cfg.targetID + "_AX_bodyNodeIndent_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\" style=\"" + CH.align + ":" + (indentWidth - 20) + "px;");
								if (item.__subTreeLength == 0) tpo.push("display:none;");
								tpo.push("\"></a>");
							}
						}
						if (CH.getIconClass) {
							iconClass = getIconClassValue(CH.getIconClass, item, itemIndex, item[CH.key], CH.key, CH);
							if(Object.isString(iconClass)){
								tpo.push("<a class=\"bodyNodeIcon " + iconClass + "\" id=\"" + cfg.targetID + "_AX_bodyNodeIcon_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\" style=\"" + CH.align + ":" + (indentWidth) + "px;\"></a>");
							}else{
								tpo.push("<a class=\"bodyNodeIcon " + iconClass.addClass + "\" id=\"" + cfg.targetID + "_AX_bodyNodeIcon_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\" style=\"" + CH.align + ":" + (indentWidth) + "px;\">"+ iconClass.html +"</a>");
							}
						}

						if ((hasFixed && !CH.isFixedCell) || !hasFixed || isfix != undefined) {
							if (CH.formatter) {
								tpo.push(getFormatterValue(CH.formatter, item, itemIndex, item[CH.key], CH.key, CH));
							} else {
								tpo.push(item[CH.key]);
							}
						} else {
							tpo.push("&nbsp;");
						}

						tpo.push("</div>");
						tpo.push("</div>");
						tpo.push("</td>");
					}
				}
			});
			if (r == 0 && isfix == "n" && cfg.colHead.display) {
				tpo.push("<td class=\"bodyNullTd\" id=\"" + cfg.targetID + "_AX_null_AX_" + itemIndex + "\" rowspan=\"" + cfg.body.rows.length + "\"><div class=\"tdRelBlock\" id=\"" + cfg.targetID + "_AX_tdRelBlock_AX_" + itemIndex + "\">&nbsp;</div></td>");
			}
			if (hasTrValue) tpo.push("</tr>");
		}
		return tpo.join('');
	},
	getItemMarker: function (itemIndex, item, isfix) {
		var cfg = this.config;
		var tpo = [];
		var evenClassName = "gridBodyMarker";
		var getFormatterValue = this.getFormatterValue.bind(this);
		var hasFixed = this.hasFixed;

		for (var r = 0; r < cfg.body.marker.rows.length; r++) {
			var isLastTR = (cfg.body.marker.rows.length - 1 == r);
			tpo.push("<tr class=\"gridBodyTr gridBodyMarkerTr_" + itemIndex + " " + evenClassName + "\" id=\"" + cfg.targetID + "_AX_marker_" + r + "_AX_" + (isfix || "n") + "_AX_" + itemIndex + "\">");
			var colCount = 0;
			axf.each(cfg.body.marker.rows[r], function (CHidx, CH) {
				if (CH.display && CH.colspan > 0) {

					if (isfix == "n" || (isfix != undefined && colCount < (cfg.fixedColSeq + 1))) {

						colCount += CH.colspan;

						//radio, check exception
						var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
						var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
						var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";
						var bottomClass = (CH.isLastCell) ? "" : " bodyBottomBorder";
						var fixedClass = (CH.isFixedEndCell) ? " fixedLine" : "";

						//trace({r:r, CHidx:CHifixedColSeq:cfg.fixedColSeq, colCount:colCount});

						var bodyNodeClass = "";
						if (CH.formatter == "checkbox") bodyNodeClass = " bodyTdCheckBox";
						else if (CH.formatter == "html") bodyNodeClass = " bodyTdHtml";

						tpo.push("<td" + valign + rowspan + colspan + " id=\"" + cfg.targetID + "_AX_" + (isfix || "n") + "bodyMarker_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\" class=\"bodyTd" + bottomClass + fixedClass + "\">");
						tpo.push("<div class=\"tdRelBlock\">");
						tpo.push("<div class=\"bodyNode bodyTdText" + bodyNodeClass + "\" align=\"" + CH.align + "\" id=\"" + cfg.targetID + "_AX_bodyMarkerText_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\">");
						if ((hasFixed && !CH.isFixedCell) || !hasFixed || isfix != undefined) {
							if (CH.formatter) {
								tpo.push(getFormatterValue(CH.formatter, item, itemIndex, item[CH.key], CH.key, CH));
							} else {
								tpo.push(item[CH.key]);
							}
						} else {
							tpo.push("&nbsp;");
						}
						tpo.push("</div>");
						tpo.push("</div>");
						tpo.push("</td>");
					}
				}
			});
			if (r == 0 && isfix == "n") {
				tpo.push("<td class=\"bodyNullTd\" id=\"" + cfg.targetID + "_AX_nullMarker_AX_" + itemIndex + "\" rowspan=\"" + cfg.body.rows.length + "\"><div class=\"tdRelBlock\" id=\"" + cfg.targetID + "_AX_tdRelBlockMarker_AX_" + itemIndex + "\">&nbsp;</div></td>");
			}
			tpo.push("</tr>");
		}
		return tpo.join('');
	},
	getMarkerDisplay: function (itemIndex, item) {
		var cfg = this.config;
		var bodyHasMarker = this.bodyHasMarker;

		if (!bodyHasMarker) return false;
		var sendObj = {
			index: itemIndex,
			list: this.list,
			item: item,
			page: this.page
		}
		var markerDisplay = cfg.body.marker.display.call(sendObj);
		return markerDisplay;
	},
	printList: function () {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var bodyHasMarker = this.bodyHasMarker;
		var getItem = this.getItem.bind(this);
		var getItemMarker = this.getItemMarker.bind(this);
		var getMarkerDisplay = this.getMarkerDisplay.bind(this);

		this.gridBodyOverBind = this.gridBodyOver.bind(this);
		this.gridBodyOutBind = this.gridBodyOut.bind(this);
		this.gridBodyClickBind = this.gridBodyClick.bind(this);
		this.gridBodyDBLClickBind = this.gridBodyDBLClick.bind(this);

		var getAXTreeSplit = this.getAXTreeSplit.bind(this);

		var po = [];
		axf.each(this.list, function (itemIndex, item) {
			if (!item.isRoot && !item._isDel) {
				if(item.AXTreeSplit){
					po.push(getAXTreeSplit("n"));
				}else{
					po.push(getItem(itemIndex, item, "n"));
					if (bodyHasMarker && getMarkerDisplay(itemIndex, item)) {
						po.push(getItemMarker(itemIndex, item, "n"));
					}
				}
			}
		});
		axdom("#" + cfg.targetID + "_AX_tbody").empty();
		axdom("#" + cfg.targetID + "_AX_tbody").append(po.join(''));

		if (this.hasFixed) {
			po = [];
			axf.each(this.list, function (itemIndex, item) {
				if (!item.isRoot && item[cfg.reserveKeys.displayKey] && !item._isDel) {
					if(item.AXTreeSplit){
						po.push(getAXTreeSplit("fix"));
					}else{
						po.push(getItem(itemIndex, item, "fix"));
						if (bodyHasMarker && getMarkerDisplay(itemIndex, item)) {
							po.push(getItemMarker(itemIndex, item, "fix"));
						}
					}
				}
			});
			axdom("#" + cfg.targetID + "_AX_fixedTbody").empty();
			axdom("#" + cfg.targetID + "_AX_fixedTbody").append(po.join(''));
		}

		this.selectedCells.clear(); // selectedCells clear

		//trace(this.list);
		//trace(this.tree);

		var _tree = this.tree;
		var list_pointer = {};
		axf.each(this.list, function (lidx, L) {
			list_pointer[L[cfg.reserveKeys.hashKey]] = lidx;
		});
		//trace(list_pointer);

		var _list = this.list;
		axf.each(this.list, function (lidx, L) {
			if(L.__checked){
				var hashs = L[cfg.reserveKeys.hashKey].split(/_/g);
				hashs.shift();
				//trace(hashs);
				for (var l = hashs.length - 1; l > -1; l--) {
					//trace(l);
					var subTreeStr = "";
					var checkHash = [];

					for (var i = 0; i < l + 1; i++) {
						checkHash.push(hashs[i]);
						if (i == 0) {
							subTreeStr += "[" + hashs[i].number() + "]";
						} else {
							subTreeStr += "[reserveKeys.subTree][" + hashs[i].number() + "]";
						}
					}
					//trace(checkHash);
					//trace(checkHash.join("_"));
					//trace(subTreeStr);
					var myTree = null;
					try{
						eval("myTree = _tree" + subTreeStr);
					}catch(e){

					}

					if(myTree != null){
						myTree.__checked = true;
						var findHash = "0".setDigit(cfg.hashDigit)+"_"+checkHash.join("_");
						//trace(findHash);
						if(list_pointer[findHash] != undefined){
							_list[list_pointer[findHash]].__checked = true;
						}
					}

				};
			}
		});

        for (var sr = 0; sr < this.selectedRow.length; sr++) {
			this.body.find(".gridBodyTr_" + this.selectedRow[sr]).addClass("selected");
		}
		this.body.find(".gridBodyTr").bind("mouseover", this.gridBodyOverBind);
		this.body.find(".gridBodyTr").bind("mouseout", this.gridBodyOutBind);
		this.body.find(".gridBodyTr").bind("click", this.gridBodyClickBind);
		if (AXUtil.browser.name == "ie" && AXUtil.browser.version == 8) this.body.find(".gridBodyTr").bind("dblclick", this.gridBodyDBLClickBind);
		this.contentScrollResize();

		this.contentScrollXAttr = null;
		this.contentScrollYAttr = null;

        if (cfg.persistExpanded) {
            var expandedIndexs = axf.getCookie(cfg.cookiePrefix + cfg.targetID + "-expanded-index").split(/,/g);
            var expand = this.click.bind(this);
            axf.each(expandedIndexs, function(idx, item){
                expand(item, "expand", true);
            });
        }
        if (cfg.persistSelected) {
            var selectedIndex = axf.getCookie(cfg.cookiePrefix + cfg.targetID + "-selected-index");
            if (selectedIndex !== undefined) {
                this.click(selectedIndex);
            }
        }
	},
	updateList: function (itemIndex, item) {
		var cfg = this.config;

		var trAddClass = "";
		if (cfg.body.addClass) {
			try {
				trAddClass = cfg.body.addClass.call({
					index: itemIndex,
					item: item,
					list: this.list
				});
			} catch (e) {
				trace(e);
			}
		}

		var npo = this.getItem(itemIndex, item, "n", "notr");
		if (this.hasFixed) {
			var fpo = this.getItem(itemIndex, item, "fix", "notr");
		}

		axdom("#" + cfg.targetID + "_AX_tbody").find(".gridBodyTr_" + itemIndex).html(npo);
		if (this.hasFixed) {
			axdom("#" + cfg.targetID + "_AX_fixedTbody").find(".gridBodyTr_" + itemIndex).html(npo);
		}

		if (trAddClass) {
			axdom("#" + cfg.targetID + "_AX_tbody").find(".gridBodyTr_" + itemIndex).addClass(trAddClass);
			if (this.hasFixed) {
				axdom("#" + cfg.targetID + "_AX_fixedTbody").find(".gridBodyTr_" + itemIndex).addClass(trAddClass);
			}
		}

		this.body.find(".gridBodyTr").unbind("mouseover", this.gridBodyOverBind);
		this.body.find(".gridBodyTr").unbind("mouseout", this.gridBodyOutBind);
		this.body.find(".gridBodyTr").unbind("click", this.gridBodyClickBind);
		if (AXUtil.browser.name == "ie" && AXUtil.browser.version == 8) this.body.find(".gridBodyTr").unbind("dblclick", this.gridBodyDBLClickBind);

		this.body.find(".gridBodyTr").bind("mouseover", this.gridBodyOverBind);
		this.body.find(".gridBodyTr").bind("mouseout", this.gridBodyOutBind);
		this.body.find(".gridBodyTr").bind("click", this.gridBodyClickBind);
		if (AXUtil.browser.name == "ie" && AXUtil.browser.version == 8) this.body.find(".gridBodyTr").bind("dblclick", this.gridBodyDBLClickBind);

		this.redrawDataSet();
	},
	/**
	 * @method AXTree.expandToggleList
	 * @param {Number} itemIndex - 아이템 인덱스
	 * @param {JSObject} item - 아이템 json
	 * @param {Boolean} expandStat - 트리 아이템 오픈 여부
	 * @description
	 * 아이템의 확장/축소 상태를 토글처리 합니다.
	 * @example
	 * ```js
	 * var iwantItemIndex = 10;
	 * var myitem = myTree.list[iwantItemIndex];
	 * myTree.expandToggleList(iwantItemIndex, myitem);
	 * myTree.expandToggleList(iwantItemIndex, myitem, true); // 노드를 열린 상태로 바꾸어 줍니다.
	 * ```
	 */
	expandToggleList: function (itemIndex, item, expandStat) {
		var cfg = this.config;

		this.gridBodyOverBind;
		this.gridBodyOutBind;
		this.gridBodyClickBind;
		this.gridBodyDBLClickBind;


		if (item[cfg.reserveKeys.openKey] && (typeof expandStat == "undefined" || expandStat == false)) {

			//자식 개체 모두 닫기 체크하기
			var pHash = item[cfg.reserveKeys.hashKey];
			var hashs = item[cfg.reserveKeys.hashKey].split(/_/g);
			var lastR = cfg.body.rows.length - 1;
			for (var r = 0; r < cfg.body.rows.length; r++) {
				axdom("#" + cfg.targetID + "_AX_tr_" + r + "_AX_n_AX_" + itemIndex).find(".bodyNodeIndent").removeClass("expand");
			}

			//trace(pHash);
			var removepHashs = [];
			axf.each(this.list, function (itemIndex, item) {
				if(!item.AXTreeSplit){
					if (pHash == item[cfg.reserveKeys.parentHashKey].left(pHash.length)) {
						removepHashs.push(item[cfg.reserveKeys.parentHashKey]);
						item[cfg.reserveKeys.displayKey] = false;
					}
				}
			});
			var _body = this.body;
			axf.each(removepHashs, function () {
				_body.find(".gridBodyTr.parentHash" + this).hide();
			});
			item[cfg.reserveKeys.openKey] = false;

			var myTree = this.tree;
			axf.each(hashs, function (hidx, HH) {
				if (hidx == 0) {

				} else if (hidx == 1) {
					myTree = myTree[HH.number()];
				} else {
					myTree = myTree[cfg.reserveKeys.subTree][HH.number()];
				}
			});
			myTree[cfg.reserveKeys.openKey] = false;

			this.contentScrollResize();

			this.contentScrollXAttr = null;
			this.contentScrollYAttr = null;

			//clear select

			this.clearFocus();

            if (cfg.persistExpanded) {
                var persistKey      = cfg.cookiePrefix + cfg.targetID + "-expanded-index";
                var expandedIndices = axf.getCookie(persistKey).split(/,/g);

                if (expandedIndices[0] === "") { expandedIndices.shift(); }

                for (var ei = expandedIndices.length - 1; ei >= 0; ei--) {
                    // 하위 노드 키도 삭제하기 위해서 hash로 비교한다.
                    var itemHash      = item[cfg.reserveKeys.hashKey];
                    var expandedIndex = expandedIndices[ei].number();
                    var expandedHash  = this.list[expandedIndex][cfg.reserveKeys.hashKey];
                    if (expandedHash.indexOf(itemHash) === 0) {
                        expandedIndices.splice(ei, 1);
                    }
                }

                axf.setCookie(persistKey, expandedIndices.join(","), cfg.cookieExpiredays);
            }

			if (cfg.body.oncontract) {
				//itemIndex, item, subTree
				//dialog.push(Object.toJSON(subTree));
				var sendObj = {
					index: itemIndex,
					list: this.list,
					list: this.tree,
					item: item,
					subTree: subTree,
					itemID: this.body.find(".gridBodyTr_" + itemIndex).attr("id")
				};
				cfg.body.oncontract.call(sendObj, itemIndex, item);
			}
		}
		else
		if(typeof expandStat == "undefined" || expandStat == true)
		{ // 자식개체 열기

			item[cfg.reserveKeys.openKey] = true;

			for (var r = 0; r < cfg.body.rows.length; r++) {
				axdom("#" + cfg.targetID + "_AX_tr_" + r + "_AX_n_AX_" + itemIndex).find(".bodyNodeIndent").addClass("expand");
			}

			var hashs = item[cfg.reserveKeys.hashKey].split(/_/g);

			//findTree Position


			var myTree = this.tree;
			axf.each(hashs, function (hidx, HH) {
				if (hidx == 0) {

				} else if (hidx == 1) {
					myTree = myTree[HH.number()];
				} else {
					myTree = myTree[cfg.reserveKeys.subTree][HH.number()];
				}
			});

			var addHashs = [];
			var preFixHash = hashs.join("_");
			var getAddHashs = function (_tree, pfHash) {
				addHashs.push(pfHash);
				axf.each(_tree, function (treeIndex, nTree) {
					if (nTree[cfg.reserveKeys.subTree].length > 0 && nTree[cfg.reserveKeys.openKey]) getAddHashs(nTree[cfg.reserveKeys.subTree], pfHash + "_" + treeIndex.setDigit(cfg.hashDigit));
				});
			};
			getAddHashs(myTree[cfg.reserveKeys.subTree], preFixHash);

			myTree[cfg.reserveKeys.openKey] = true;

			var subTree = [];
			var _list = this.list;
			var itemChangeDisplay = this.itemChangeDisplay.bind(this);
			var _body = this.body;
			axf.each(addHashs, function () {
				_body.find(".gridBodyTr.parentHash" + this).each(function () {
					var trIndex = this.id.split(/_AX_/g).last();
					itemChangeDisplay(trIndex, true);
					subTree.push(_list[trIndex]);
				});
				_body.find(".gridBodyTr.parentHash" + this).show();
			});

			this.contentScrollResize();

			this.contentScrollXAttr = null;
			this.contentScrollYAttr = null;

            if (cfg.persistExpanded) {
                var persistKey     = cfg.cookiePrefix + cfg.targetID + "-expanded-index";
                var expandedIndexs = axf.getCookie(persistKey).split(/,/g);

                if (expandedIndexs[0] === "") { expandedIndexs.shift(); }

                var isInclude = false;
                axf.each(expandedIndexs, function(idx, expandedIndex){
                    if (expandedIndex == item.__index) {
                        isInclude = true;
                        return false;
                    }
                });

                if (!isInclude) {
                    expandedIndexs.push(item.__index);
                }

                axf.setCookie(persistKey, expandedIndexs.join(","), cfg.cookieExpiredays);
            }

			if (cfg.body.onexpand) {
				//itemIndex, item, subTree
				//dialog.push(Object.toJSON(subTree));
				var sendObj = {
					index: itemIndex,
					list: this.list,
					list: this.tree,
					item: item,
					subTree: subTree,
					itemID: this.body.find(".gridBodyTr_" + itemIndex).attr("id")
				};
				cfg.body.onexpand.call(sendObj, itemIndex, item);
			}

		}

	},
	itemChangeDisplay: function (itemIndex, status) { // 입력받은 인덱스의 display 상태변경 함수
		var cfg = this.config;
		this.list[itemIndex][cfg.reserveKeys.displayKey] = status;
	},
	gridBodyOver: function (event) {
		var cfg = this.config;
		if (this.overedItemIndex) {
			this.body.find(".gridBodyTr_" + this.overedItemIndex).removeClass("hover");
		}
		var itemIndex = (event.target.id).split(/_AX_/g).last();
		if (itemIndex != "") {
			this.body.find(".gridBodyTr_" + itemIndex).addClass("hover");
			this.overedItemIndex = itemIndex;
		}
	},
	gridBodyOut: function (event) {
		var cfg = this.config;
		if (this.overedItemIndex) {
			this.body.find(".gridBodyTr_" + this.overedItemIndex).removeClass("hover");
		}
	},
	gridBodyClick: function(event){
		var cfg = this.config;
		if (cfg.body.ondblclick) {
			if (AXUtil.browser.name == "ie" && AXUtil.browser.version == 8) {
				this.gridBodyClickAct(event);
			} else {
				if (this.bodyClickObserver){
					clearTimeout(this.bodyClickObserver);
					this.gridBodyDBLClick(event);
					this.bodyClickObserver = null;
					return;
				}
				var gridBodyClickAct = this.gridBodyClickAct.bind(this);
				this.bodyClickObserver = setTimeout(function () {
					gridBodyClickAct(event);
				}, 250);
			}
		}else{
			this.gridBodyClickAct(event);
		}
	},
	gridBodyClickAct: function (event) {
		this.bodyClickObserver = null;
		var cfg = this.config;
		// event target search -

		var eventTarget = event.target;
		var isoncheck = false;
		if (eventTarget.tagName.toLowerCase() == "input") {
			this.gridCheckClick(event);
			if (cfg.body.oncheck) {
				isoncheck = true;
			} else {
				// checkbox event bind
				return; //input 인 경우 제외
			}
		}

		//if(event.target.id == "" && event.target.tagName.toLowerCase() != "span") return;
		//var eid = event.target.id.split(/_AX_/g);
		// event target search ------------------------

		if (isoncheck) { //체크박스 구현
			var targetID = eventTarget.id;
			var itemIndex = targetID.split(/_AX_/g).last();
			var ids = targetID.split(/_AX_/g);
			var item = this.list[itemIndex];
			var r = ids[ids.length - 3];
			var c = ids[ids.length - 2];
			var target = event.target;
			var checked = event.target.checked;
			var sendObj = {
				index: itemIndex,
				target: event.target,
				checked: event.target.checked,
				r: r,
				c: c,
				list: this.list,
				item: item,
				page: this.page
			}
			//trace(sendObj);
			cfg.body.oncheck.call(sendObj, itemIndex, item);
		}
		else
		{

			var myTarget = this.getEventTarget({
				evt: eventTarget, evtIDs: "",
				until: function (evt, evtIDs) { return (axdom(evt.parentNode).hasClass("gridBodyTr")) ? true : false; },
				find: function (evt, evtIDs) { return (axdom(evt).hasClass("bodyTd") || axdom(evt).hasClass("bodyNodeIndent")) ? true : false; }
			});

			if (myTarget) {

				//colHeadTool ready
				var targetID = myTarget.id;
				var itemIndex = targetID.split(/_AX_/g).last();
				var ids = targetID.split(/_AX_/g);

				var clickNodeType = ids[(ids.length - 1) - 3];

				if (clickNodeType == "bodyNodeIndent") {
					var item = this.list[itemIndex];
					var r = ids[ids.length - 3];
					var c = ids[ids.length - 2];
					this.expandToggleList(itemIndex, item);
				} else if (this.readyMoved) {
					//이동명령 대기중 상태인경우 이동 처리
					//this.moveTarget = {itemIndex:itemIndex};
					this.moveTreeExec(this.moveTarget.itemIndex, itemIndex);
				} else {

					//trace({tagName:myTarget.tagName, id:myTarget.id, clickNodeType:clickNodeType});
					if (clickNodeType == "nbody" || clickNodeType == "fbody") {
						if (event.shiftKey) {

						} else if (event.ctrlKey) {
							if (this.selectedRow.length > 0) {
								var body = this.body;
								axf.each(this.selectedRow, function () {
									body.find(".gridBodyTr_" + this).removeClass("selected");
								});
								this.selectedRow.clear();
							}

							var hasID = false;
							var collect = [];
							axf.each(this.selectedCells, function () {
								if (this == targetID) {
									hasID = true;
								} else {
									collect.push(this);
								}
							});
							if (hasID) {
								axdom("#" + targetID).removeClass("selected");
								this.selectedCells = collect;
							} else {
								axdom("#" + targetID).addClass("selected");
								this.selectedCells.push(targetID);
							}
						} else {
							if (this.selectedCells.length > 0) {
								axf.each(this.selectedCells, function () {
									axdom("#" + this).removeClass("selected");
								});
								this.selectedCells.clear();
							}
							if (this.selectedRow.length > 0) {
								var body = this.body;
								axf.each(this.selectedRow, function () {
									body.find(".gridBodyTr_" + this).removeClass("selected");
								});
							}

							this.selectedRow.clear();
							this.body.find(".gridBodyTr_" + itemIndex).addClass("selected");
							this.selectedRow.push(itemIndex);

							var item = this.list[itemIndex];

                            if (cfg.persistSelected) {
                                var persistKey = cfg.cookiePrefix + cfg.targetID + "-selected-index";
                                axf.setCookie(persistKey, item.__index, cfg.cookieExpiredays);
                            }

                            if (cfg.body.onclick) {
								var r = ids[ids.length - 3];
								var c = ids[ids.length - 2];

								var hashs = item[cfg.reserveKeys.hashKey].split(/_/g);
								var subTree = this.tree;
								axf.each(hashs, function (idx, arg) {
									if (idx == 1) {
										subTree = subTree[this.number()];
									} else if (idx > 1) {
										subTree = subTree[cfg.reserveKeys.subTree][this.number()];
									}
								});

								var sendObj = {
									index: itemIndex,
									r: r,
									c: c,
									list: this.list,
									item: item,
									subTree: subTree,
									page: this.page
								};
								//trace(sendObj);

								cfg.body.onclick.call(sendObj, itemIndex, item);
							}
							//2013-01-23 오후 12:26:52 에디트 이벤트 변경
							//if(this.hasEditor) this.setEditor(item, itemIndex);
						}
					}
				}
			}
		}
	},
	gridBodyDBLClick: function (event) {

		//trace(event.type);

		var cfg = this.config;
		// event target search -
		//if(event.target.id == "") return;
		var eid = event.target.id.split(/_AX_/g);
		var eventTarget = event.target;
		if (eventTarget.tagName.toLowerCase() == "input") return; //input 인 경우 제외
		var myTarget = this.getEventTarget({
			evt: eventTarget, evtIDs: eid,
			until: function (evt, evtIDs) { return (axdom(evt.parentNode).hasClass("gridBodyTr")) ? true : false; },
			find: function (evt, evtIDs) { return (axdom(evt).hasClass("bodyTd")) ? true : false; }
		});
		// event target search ------------------------

		if (myTarget) {
			//colHeadTool ready
			//trace({tagName:myTarget.tagName, id:myTarget.id});
			var targetID = myTarget.id;
			var itemIndex = targetID.split(/_AX_/g).last();
			var ids = targetID.split(/_AX_/g);

			if (this.selectedRow.length > 0) {
				var body = this.body;
				axf.each(this.selectedRow, function () {
					body.find(".gridBodyTr_" + this).removeClass("selected");
				});
			}
			this.selectedRow.clear();
			this.body.find(".gridBodyTr_" + itemIndex).addClass("selected");
			this.selectedRow.push(itemIndex);

			if (cfg.body.ondblclick) {
				var r = ids[ids.length - 3];
				var c = ids[ids.length - 2];
				var item = this.list[itemIndex];
				var sendObj = {
					index: itemIndex,
					r: r,
					c: c,
					list: this.list,
					item: item,
					page: this.page
				}
				cfg.body.ondblclick.call(sendObj);
			}
		}

		this.stopEvent(event);
		this.clearRange();
	},
	gridCheckClick: function (event, tgId) {

		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var relation = cfg.relation;
		var _body = this.body;
		var checkboxRelationFixed = cfg.checkboxRelationFixed;
		if (typeof tgId != "undefined") {
			//var target = tgObj;
			var targetID = tgId;
			var checked = _body.find("#" + targetID).get(0).checked;
		} else {
			var targetID = event.target.id;
			var checked = event.target.checked;
		}
		//var target = event.target;
		//var checked = event.target.checked;
		//var targetID = target.id;
		var itemIndex = targetID.split(/_AX_/g).last();
		var ids = targetID.split(/_AX_/g);
		var item = this.list[itemIndex];
		var colSeq = ids[ids.length - 2];

		if (checked) { // 체크박스가 체크 된경우
			// 자식 개체를 찾아 체크 처리 합니다.
			var phash = item[reserveKeys.hashKey];

			var childIndex = [];
			axf.each(this.list, function (lidx, list) {
				if (!this.isRoot) {
					if (this[reserveKeys.hashKey].left(phash.length) == phash && this[reserveKeys.hashKey] != phash) {
						childIndex.push(lidx);
					}
				}
			});
			axf.each(childIndex, function () {
				if (_body.find("#" + cfg.targetID + "_AX_checkboxItem_AX_" + colSeq + "_AX_" + this).get(0)) {
					_body.find("#" + cfg.targetID + "_AX_checkboxItem_AX_" + colSeq + "_AX_" + this).get(0).checked = checked;
				}
			});

			// 해시 변수 준비
			var hashs = phash.split(/_/g);
			hashs.shift();

			// 자식 트리 개체에 checked 속성을 부여 합니다. -------------- s
			var stree = this.tree;
			axf.each(hashs, function (hidx, H) {
				if (hidx == 0) {
					stree = stree[this.number()];
				} else {
					stree = stree[reserveKeys.subTree][this.number()];
				}
			});
			var subTreeChecked = function (T, checked) {
				axf.each(T[cfg.reserveKeys.subTree], function () {
					this.__checked = checked;
					if (this[cfg.reserveKeys.subTree]) subTreeChecked(this, checked);
				});
			};
			stree.__checked = checked;
			subTreeChecked(stree, checked);
			//trace(stree);
			// 자식 트리 개체에 checked 속성을 부여 합니다. -------------- e

			// 부모 트리 찾기 -------------- s
			var ptree = this.tree;
			for (var hidx = 0; hidx < hashs.length - 1; hidx++) {
				if (hidx == 0) {
					ptree = ptree[hashs[hidx].number()];
				} else {
					ptree = ptree[reserveKeys.subTree][hashs[hidx].number()];
				}
			};
			//trace(ptree);

			var parentIsRootTree = false;
			if (this.tree == ptree) {
				parentIsRootTree = true;
			}
			// 부모 트리 찾기 -------------- e

			if (!parentIsRootTree) {
				var childIsAllChecked = true;
				/*
                 axf.each(ptree[reserveKeys.subTree], function(){
                 if(!this.__checked) childIsAllChecked = false;
                 });
                 */
				if (childIsAllChecked) {
					var findhash = ptree[reserveKeys.hashKey];

					var p_tree = this.tree;
					var checkedHashs = [];

					axf.each(hashs, function (hidx, H) {
						if (hidx == 0) {
							p_tree = p_tree[this.number()];
						} else {
							p_tree.__checked = true;
							checkedHashs.push(p_tree[reserveKeys.hashKey]);
							p_tree = p_tree[reserveKeys.subTree][this.number()];
						}
					});

					//ptree.__checked = true;
					//trace(findhash);
					//trace(checkedHashs);
					var _body = this.body;
					axf.each(this.list, function (lidx, list) {
						axf.each(checkedHashs, function () {
							if (list[reserveKeys.hashKey] == this) {
								if (_body.find("#" + cfg.targetID + "_AX_checkboxItem_AX_" + colSeq + "_AX_" + lidx).get(0)) {
									_body.find("#" + cfg.targetID + "_AX_checkboxItem_AX_" + colSeq + "_AX_" + lidx).get(0).checked = checked;
								}
							}
						});
					});

					// 부모가 더이상 없을때까지 찾기
				}
			}

			//trace(this.tree);
			this.list = this.convertHashListToTree(this.tree);

		} else { // 체크박스가 체크 해제 된경우

			if (checkboxRelationFixed != null) {
				var phash = item[reserveKeys.hashKey];
				var childIndex = [];
				axf.each(this.list, function (lidx, list) {
					if (!this.isRoot) {
						if (this[reserveKeys.hashKey].left(phash.length) == phash && this[reserveKeys.hashKey] != phash) {
							childIndex.push(lidx);
						}
					}
				});
				axf.each(childIndex, function () {
					if (_body.find("#" + cfg.targetID + "_AX_checkboxItem_AX_" + colSeq + "_AX_" + this).get(0)) {
						_body.find("#" + cfg.targetID + "_AX_checkboxItem_AX_" + colSeq + "_AX_" + this).get(0).checked = checked;
					}
				});

				// 해시 변수 준비
				var hashs = phash.split(/_/g);
				hashs.shift();

				// 자식 트리 개체에 checked 속성을 부여 합니다. -------------- s
				var stree = this.tree;
				axf.each(hashs, function (hidx, H) {
					if (hidx == 0) {
						stree = stree[this.number()];
					} else {
						stree = stree[reserveKeys.subTree][this.number()];
					}
				});
				var subTreeChecked = function (T, checked) {
					axf.each(T[cfg.reserveKeys.subTree], function () {
						this.__checked = checked;
						if (this[cfg.reserveKeys.subTree]) subTreeChecked(this, checked);
					});
				};
				stree.__checked = checked;
				subTreeChecked(stree, checked);
				// 자식 트리 개체에 checked 속성을 부여 합니다. -------------- e
			}
			//부모개체의 자식이 모두 제거 되었다면 체크를 해제 합니다.
			if (checkboxRelationFixed) {

				var p_tree = this.tree;
				var checkedHashs = [];
				//trace(hashs);

				for (var l = hashs.length - 1; l > -1; l--) {
					var subTreeStr = "";
					for (var i = 0; i < l + 1; i++) {
						if (i == 0) {
							subTreeStr += "[" + hashs[i].number() + "]";
						} else {
							subTreeStr += "[reserveKeys.subTree][" + hashs[i].number() + "]";
						}
					}
					var myTree;
					eval("myTree = this.tree" + subTreeStr);
					//trace(myTree[cfg.reserveKeys.hashKey]);
					var childIsAllUnChecked = true;
					axf.each(myTree[reserveKeys.subTree], function () {
						if (this.__checked) childIsAllUnChecked = false;
					});
					if (childIsAllUnChecked) {
						myTree.__checked = checked;
						checkedHashs.push(myTree[reserveKeys.hashKey]);
					}
				};

				//ptree.__checked = true;
				//trace(findhash);
				//trace(checkedHashs);
				var _body = this.body;
				axf.each(this.list, function (lidx, list) {
					axf.each(checkedHashs, function () {
						if (list[reserveKeys.hashKey] == this) {
							if (_body.find("#" + cfg.targetID + "_AX_checkboxItem_AX_" + colSeq + "_AX_" + lidx).get(0)) {
								_body.find("#" + cfg.targetID + "_AX_checkboxItem_AX_" + colSeq + "_AX_" + lidx).get(0).checked = checked;
							}
						}
					});
				});
			}

			this.list = this.convertHashListToTree(this.tree);
		}

	},
	contentScrollResize: function (resetLeft) {
		var cfg = this.config;

		var bodyHeight = this.body.height();
		var scrollHeight = axdom("#" + cfg.targetID + "_AX_scrollContent").height();

		var bodyWidth = this.body.width();
		var _colWidth = (this.colWidth.number() + cfg.fitToWidthRightMargin);
		var scrollWidth = (_colWidth > bodyWidth) ? _colWidth : bodyWidth;

		if (cfg.width == "auto") scrollWidth = axdom("#" + cfg.targetID + "_AX_scrollContent").find("table.treeBodyTable").width().number();

		axdom("#" + cfg.targetID + "_AX_scrollContent").css({ width: scrollWidth });
		this.colHead.css({ width: scrollWidth });  // colHead width 재정의

		if (this.hasEditor) this.editor.css({ width: scrollWidth });

		if (resetLeft != false) {
			axdom("#" + cfg.targetID + "_AX_scrollContent").css({ left: 0 });
			axdom("#" + cfg.targetID + "_AX_gridColHead").css({ left: 0 });
			axdom("#" + cfg.targetID + "_AX_scrollXHandle").css({ left: 0 });
			if (this.hasEditor) axdom("#" + cfg.targetID + "_AX_editorContent").css({ left: 0 });
		}

		if (bodyHeight < scrollHeight && cfg.height != "auto") {

			if (cfg.width == "auto") {
				//trace(scrollWidth);
				//trace(axdom("#" + cfg.targetID + "_AX_scrollContent").width());
				//scrollWidth += 50;
				axdom("#" + cfg.targetID + "_AX_scrollContent").css({ width: scrollWidth });
				//trace(axdom("#" + cfg.targetID + "_AX_scrollContent").width());
			}

			//axdom("#" + cfg.targetID + "_AX_scrollTrackXY").show();
			axdom("#" + cfg.targetID + "_AX_scrollTrackY").show();

			var scrollTrackYHeight = (cfg.xscroll) ? bodyHeight : bodyHeight;
			axdom("#" + cfg.targetID + "_AX_scrollTrackY").css({ height: scrollTrackYHeight });

			var scrollYHandleHeight = (bodyHeight * scrollTrackYHeight) / scrollHeight;
			axdom("#" + cfg.targetID + "_AX_scrollYHandle").css({ height: scrollYHandleHeight });



		} else {
			//axdom("#" + cfg.targetID + "_AX_scrollTrackXY").hide();
			axdom("#" + cfg.targetID + "_AX_scrollTrackY").hide();
			axdom("#" + cfg.targetID + "_AX_scrollContent").css({ top: 0 });
		}

		if (scrollWidth > bodyWidth && cfg.xscroll) {

			this.show_scrollTrackX = true;

			//axdom("#" + cfg.targetID + "_AX_scrollTrackXY").show();
			axdom("#" + cfg.targetID + "_AX_scrollTrackX").show();

			var scrollTrackXWidth = bodyWidth;
			axdom("#" + cfg.targetID + "_AX_scrollTrackX").css({ width: scrollTrackXWidth });
			var scrollXHandleWidth = ((bodyWidth) * scrollTrackXWidth) / (scrollWidth);

			axdom("#" + cfg.targetID + "_AX_scrollXHandle").css({ width: scrollXHandleWidth });

			// cfg.height == "auto" 길이 늘이기
			if (cfg.height == "auto") {
				var colHeadHeight = this.colHead.outerHeight();
				var scrollBodyHeight = axdom("#" + cfg.targetID + "_AX_scrollContent").height();
				var scrollTrackXHeight = axdom("#" + cfg.targetID + "_AX_scrollTrackX").outerHeight();

				this.scrollBody.css({ height: (scrollBodyHeight + colHeadHeight + scrollTrackXHeight) }); //colhead + body height
				this.body.css({ top: colHeadHeight, height: (scrollBodyHeight + scrollTrackXHeight) }); // body Height
			}
		} else {
			this.show_scrollTrackX = false;
			axdom("#" + cfg.targetID + "_AX_scrollTrackX").hide();
			//axdom("#"+cfg.targetID+"_AX_scrollTrackXY").hide();

			if (cfg.height == "auto") {
				var colHeadHeight = this.colHead.outerHeight();
				var scrollBodyHeight = axdom("#" + cfg.targetID + "_AX_scrollContent").height();

				this.scrollBody.css({ height: (scrollBodyHeight + colHeadHeight) }); //colhead + body height
				this.body.css({ top: colHeadHeight, height: (scrollBodyHeight) }); // body Height
			}
		}

	},
	contentScrollScrollSync: function (pos) {
		var cfg = this.config;

		if (pos.left != undefined) {
			if (!this.contentScrollXAttr) {
				var scrollWidth = (this.colWidth > this.body.width()) ? this.colWidth : this.body.width();
				this.contentScrollXAttr = {
					bodyWidth: this.body.width(),
					scrollWidth: scrollWidth,
					scrollTrackXWidth: axdom("#" + cfg.targetID + "_AX_scrollTrackX").width(),
					scrollXHandleWidth: axdom("#" + cfg.targetID + "_AX_scrollXHandle").outerHeight()
				};
			}

			//x 변경
			var L = (this.contentScrollXAttr.scrollWidth * (pos.left) / this.contentScrollXAttr.scrollTrackXWidth).round(0);
			axdom("#" + cfg.targetID + "_AX_scrollContent").css({ left: -L });
			axdom("#" + cfg.targetID + "_AX_treeColHead").css({ left: -L });
			if (this.hasEditor) axdom("#" + cfg.targetID + "_AX_editorContent").css({ left: -L });
			//trace({top:-L});
		} else {
			if (cfg.height == "auto") return;
			if (!this.contentScrollYAttr) {
				this.contentScrollYAttr = {
					bodyHeight: this.body.height(),
					scrollHeight: axdom("#" + cfg.targetID + "_AX_scrollContent").height(),
					scrollTrackYHeight: axdom("#" + cfg.targetID + "_AX_scrollTrackY").height(),
					scrollYHandleHeight: axdom("#" + cfg.targetID + "_AX_scrollYHandle").outerHeight()
				};
			}

			//y 변경
			var T = (this.contentScrollYAttr.scrollHeight * (pos.top) / this.contentScrollYAttr.scrollTrackYHeight).round(0);
			axdom("#" + cfg.targetID + "_AX_scrollContent").css({ top: -T });
			if (axf.getId(cfg.targetID + "_AX_fixedScrollContent")) axdom("#" + cfg.targetID + "_AX_fixedScrollContent").css({ top: -T });
			if (this.editorOpend) {
				this.editor.css({ top: -T + this.editorOpenTop });
			}
			//trace({top:-T});
		}
	},
	contentScrollContentSync: function (pos) {
		var cfg = this.config;
		if (pos.left != undefined) {

		} else {
			if (cfg.height == "auto") return;
			if (!this.contentScrollYAttr) {
				this.contentScrollYAttr = {
					bodyHeight: this.body.height(),
					scrollHeight: axdom("#" + cfg.targetID + "_AX_scrollContent").height(),
					scrollTrackYHeight: axdom("#" + cfg.targetID + "_AX_scrollTrackY").height(),
					scrollYHandleHeight: axdom("#" + cfg.targetID + "_AX_scrollYHandle").outerHeight()
				};
			}

			//y 변경
			var T = (this.contentScrollYAttr.scrollYHandleHeight * (pos.top) / this.contentScrollYAttr.bodyHeight).round(0);
			var handleTop = -T;
			//trace({h1:(handleTop + this.contentScrollYAttr.handleHeight), trackHeight:this.contentScrollYAttr.trackHeight});
			//if((handleTop + this.contentScrollYAttr.handleHeight) > this.contentScrollYAttr.trackHeight) handleTop = this.contentScrollYAttr.trackHeight - this.contentScrollYAttr.handleHeight;

			axdom("#" + cfg.targetID + "_AX_scrollYHandle").css({ top: handleTop });
			if (axf.getId(cfg.targetID + "_AX_fixedScrollContent")) axdom("#" + cfg.targetID + "_AX_fixedScrollContent").css({ top: pos.top });
			if (this.editorOpend) {
				this.editor.css({ top: pos.top + this.editorOpenTop });
			}

		}
	},
	getMousePositionToContentScroll: function (event, contentScrollID) {
		var pos = axdom("#" + contentScrollID).offset();
		var x = (event.pageX - pos.left);
		var y = (event.pageY - pos.top);
		return { x: x, y: y };
	},
	getTouchPositionToContentScroll: function (event) {
		var cfg = this.config;
		var touch = event.touches[0];
		var pos = this.contentScrollIDOffset;
		if (cfg.touchDirection) {
			var x = (touch.pageX.round(1) - pos.left);
			var y = (touch.pageY.round(1) - pos.top);
		} else {
			var x = (-touch.pageX.round(1) - pos.left);
			var y = (-touch.pageY.round(1) - pos.top);
		}
		return { x: x, y: y };
	},
	contentScrollScrollReady: function (event) {
		var cfg = this.config;
		var handleName = (event.target.id).split(/_AX_/).last();
		//trace(handleName);
		this.contentScrollAttrs = { handleName: handleName };
		this.contentScrollXAttr = null;
		this.contentScrollYAttr = null;

		if (handleName == "scrollYHandle") {
			this.contentScrollAttrs.scrollTrack = cfg.targetID + "_AX_scrollTrackY";
		} else {
			this.contentScrollAttrs.scrollTrack = cfg.targetID + "_AX_scrollTrackX";
		}

		axdom(event.target).addClass("hover");
		var pos = this.getMousePositionToContentScroll(event, this.contentScrollAttrs.scrollTrack);
		this.contentScrollAttrs.x = axdom(event.target).position().left - pos.x;
		this.contentScrollAttrs.y = axdom(event.target).position().top - pos.y;
		this.contentScrollAttrs.handleWidth = axdom(event.target).outerWidth();
		this.contentScrollAttrs.handleHeight = axdom(event.target).outerHeight();
		this.contentScrollAttrs.trackWidth = axdom("#" + this.contentScrollAttrs.scrollTrack).width();
		this.contentScrollAttrs.trackHeight = axdom("#" + this.contentScrollAttrs.scrollTrack).height();

		/* srcoll event bind */
		var contentScrollScrollMove = this.contentScrollScrollMove.bind(this);
		this.contentScrollScrollMoveBind = function (event) {
			contentScrollScrollMove(event);
		};
		var contentScrollScrollEnd = this.contentScrollScrollEnd.bind(this);
		this.contentScrollScrollEndBind = function (event) {
			contentScrollScrollEnd(event);
		};
		axdom(document.body).bind("mousemove.AXTree", this.contentScrollScrollMoveBind);
		axdom(document.body).bind("mouseup.AXTree", this.contentScrollScrollEndBind);
		axdom(document.body).bind("mouseleave.AXTree", this.contentScrollScrollEndBind);
		axdom("iframe").bind("mouseover.AXTree", this.contentScrollScrollEndBind);

		axdom(document.body).attr("onselectstart", "return false");
		//axdom(document.body).addClass("AXUserSelectNone");
		/* scroll event bind ~~~~~~~~~~~~~~~~~~~ */
	},
	contentScrollScrollMove: function (event) {
		var cfg = this.config;
		try {
			var pos = this.getMousePositionToContentScroll(event, this.contentScrollAttrs.scrollTrack);
			var handleName = this.contentScrollAttrs.handleName;

			var handleTop = 0;
			var handleLeft = 0;
			if (handleName == "scrollYHandle") {
				handleTop = pos.y + this.contentScrollAttrs.y;
				if (handleTop < 0) handleTop = 0;
				if ((handleTop + this.contentScrollAttrs.handleHeight) > this.contentScrollAttrs.trackHeight) handleTop = this.contentScrollAttrs.trackHeight - this.contentScrollAttrs.handleHeight;
				axdom("#" + cfg.targetID + "_AX_" + handleName).css({ top: handleTop });
				this.contentScrollScrollSync({ top: handleTop });
			} else {
				handleLeft = pos.x + this.contentScrollAttrs.x;
				if (handleLeft < 0) handleLeft = 0;
				if ((handleLeft + this.contentScrollAttrs.handleWidth) > this.contentScrollAttrs.trackWidth) handleLeft = this.contentScrollAttrs.trackWidth - this.contentScrollAttrs.handleWidth;
				axdom("#" + cfg.targetID + "_AX_" + handleName).css({ left: handleLeft });
				this.contentScrollScrollSync({ left: handleLeft });
			}
		} catch (e) {
			this.contentScrollScrollEnd(event);
		}
	},
	contentScrollScrollEnd: function (event) {
		var cfg = this.config;
		axdom(document.body).unbind("mousemove.AXTree");
		axdom(document.body).unbind("mouseup.AXTree");
		axdom(document.body).unbind("mouseleave.AXTree");
		axdom("iframe").unbind("mouseover.AXTree");

		axdom(document.body).removeAttr("onselectstart");
		//axdom(document.body).removeClass("AXUserSelectNone");

		axdom("#" + cfg.targetID + "_AX_" + this.contentScrollAttrs.handleName).removeClass("hover");
	},
	contentScrollScrollWheel: function (e) {
		var cfg = this.config;
		if (cfg.height != "auto") {
			var cfg = this.config;

			var event = window.event || e;
			var delta = event.detail ? event.detail * (-20) : event.wheelDelta / 2 //check for detail first so Opera uses that instead of wheelDelta

			var scrollTop = axdom("#" + cfg.targetID + "_AX_scrollContent").position().top;
			var scrollHeight = axdom("#" + cfg.targetID + "_AX_scrollContent").height();
			var bodyHeight = this.body.height();
			//var handleTop = axdom("#"+cfg.targetID+"_AX_scrollYHandle").position().top; i want this value
			var handleHeight = axdom("#" + cfg.targetID + "_AX_scrollYHandle").outerHeight();
			var trackHeight = axdom("#" + cfg.targetID + "_AX_scrollTrackY").height();

			if (scrollHeight < bodyHeight) {
				return;
			}

			//trace({scrollTop:scrollTop, bodyHeight:bodyHeight, scrollHeight:scrollHeight});
			var eventCancle = false;
			scrollTop += delta;

			if (scrollTop > 0) {
				scrollTop = 0;
				eventCancle = true;
			} else if (scrollTop.abs() + bodyHeight > scrollHeight) {
				scrollTop = bodyHeight - scrollHeight;
				eventCancle = true;
			} else if (scrollTop == 0) {
				scrollTop = 0;
				eventCancle = true;
			}

			axdom("#" + cfg.targetID + "_AX_scrollContent").css({ top: scrollTop });
			this.contentScrollContentSync({ top: scrollTop });

			if (!eventCancle) {
				if (event.preventDefault) event.preventDefault();
				if (event.stopPropagation) event.stopPropagation();
				event.cancelBubble = true;
				return false;
			}
		}
	},
	contentScrollTouchstart: function (e) {
		var cfg = this.config;
		var event = window.event || e;
		this.contentScrollTouchMoved = true;
		this.contentScrollIDOffset = axdom("#" + cfg.targetID + "_AX_gridBody").offset();
		this.contentScrollXAttr = null;
		this.contentScrollYAttr = null;

		var pos = this.getTouchPositionToContentScroll(event);

		var YhandleTop = axdom("#" + cfg.targetID + "_AX_scrollYHandle").position().top;
		var YhandleHeight = axdom("#" + cfg.targetID + "_AX_scrollYHandle").outerHeight();
		var YtrackHeight = axdom("#" + cfg.targetID + "_AX_scrollTrackY").height();

		axdom("#" + cfg.targetID + "_AX_scrollYHandle").addClass("hover");

		var XhandleTop = axdom("#" + cfg.targetID + "_AX_scrollXHandle").position().left;
		var XhandleHeight = axdom("#" + cfg.targetID + "_AX_scrollXHandle").outerWidth();
		var XtrackHeight = axdom("#" + cfg.targetID + "_AX_scrollTrackX").width();

		axdom("#" + cfg.targetID + "_AX_scrollXHandle").addClass("hover");

		this.scrollTouchAttr = {
			y: (YhandleTop - pos.y).number(), h: YhandleHeight.number(), th: YtrackHeight,
			x: (XhandleTop - pos.x).number(), w: XhandleHeight.number(), tw: XtrackHeight
		};

		var contentScrollTouchEnd = this.contentScrollTouchEnd.bind(this);
		this.contentScrollTouchEndBind = function () {
			contentScrollTouchEnd(event);
		};

		var contentScrollTouchMove = this.contentScrollTouchMove.bind(this);
		this.contentScrollTouchMoveBind = function () {
			contentScrollTouchMove(event);
		};

		if (document.addEventListener) {
			document.addEventListener("touchend", this.contentScrollTouchEndBind, false);
			document.addEventListener("touchmove", this.contentScrollTouchMoveBind, false);
		}
	},
	contentScrollTouchMove: function (e) {
		var cfg = this.config;
		var event = window.event || e;
		if (this.contentScrollTouchMoved) {
			var pos = this.getTouchPositionToContentScroll(event);
			var scrollTouchAttr = this.scrollTouchAttr;

			var htop = axdom("#" + cfg.targetID + "_AX_scrollYHandle").position().top;
			var handleTop = pos.y + scrollTouchAttr.y;
			if (handleTop < 0) handleTop = 0;
			if ((handleTop + scrollTouchAttr.h) > scrollTouchAttr.th) handleTop = scrollTouchAttr.th - scrollTouchAttr.h;

			if ((htop - handleTop).abs() > 2) {
				axdom("#" + cfg.targetID + "_AX_scrollYHandle").css({ top: handleTop });
				this.contentScrollScrollSync({ top: handleTop });
			}

			if (this.show_scrollTrackX) {
				var hleft = axdom("#" + cfg.targetID + "_AX_scrollXHandle").position().left;
				var handleLeft = pos.x + this.scrollTouchAttr.x;
				if (handleLeft < 0) handleLeft = 0;
				if ((handleLeft + scrollTouchAttr.w) > scrollTouchAttr.tw) handleLeft = scrollTouchAttr.tw - scrollTouchAttr.w;

				if ((hleft - handleLeft).abs() > 2) {
					axdom("#" + cfg.targetID + "_AX_scrollXHandle").css({ left: handleLeft });
					this.contentScrollScrollSync({ left: handleLeft });
				}
			}

			if (event.preventDefault) event.preventDefault();
			else return false;
		}
	},
	contentScrollTouchEnd: function (e) {
		var cfg = this.config;
		var event = window.event || e;
		if (this.contentScrollTouchMoved) {

			axdom("#" + cfg.targetID + "_AX_scrollXHandle").removeClass("hover");
			axdom("#" + cfg.targetID + "_AX_scrollYHandle").removeClass("hover");

			if (document.removeEventListener) {
				document.removeEventListener("touchend", this.contentScrollTouchEndBind, false);
				document.removeEventListener("touchmove", this.contentScrollTouchMoveBind, false);
			}
			this.contentScrollTouchMoved = false;
		}
	},
	/**
	 * @method AXTree.clearFocus
	 * @description
	 * 선택된 상태를 해제합니다.
	 * @example
	 ```
	 myTree.clearFocus();
	 ```
	 */
	clearFocus: function () {
		var cfg = this.config;

		if (this.selectedCells.length > 0) {
			axf.each(this.selectedCells, function () {
				axdom("#" + this).removeClass("selected");
			});
			this.selectedCells.clear();
		}
		if (this.selectedRow.length > 0) {
			var body = this.body;
			axf.each(this.selectedRow, function () {
				body.find(".gridBodyTr_" + this).removeClass("selected");
			});
		}

		this.selectedRow.clear();
	},

	/**
	 * @method AXTree.setFocus
	 * @param {Number} itemIndex
	 * @description
	 * index 위치로 트리바디의 포커스를 이동하고 선택된 상태로 변경합니다.
	 * @example
	 * ```js
	 * myTree.setFocus(3);
	 * ```
	 */
	setFocus: function (itemIndex) {
		var cfg = this.config;

		if(itemIndex < 0 || itemIndex > this.list.length-1){
			return false;
		}
		if(!this.body.find(".gridBodyTr_" + itemIndex).get(0)) return;

		if (this.selectedCells.length > 0) {
			axf.each(this.selectedCells, function () {
				axdom("#" + this).removeClass("selected");
			});
			this.selectedCells.clear();
		}
		if (this.selectedRow.length > 0) {
			var body = this.body;
			axf.each(this.selectedRow, function () {
				body.find(".gridBodyTr_" + this).removeClass("selected");
			});
		}

		this.selectedRow.clear();

		this.body.find(".gridBodyTr_" + itemIndex).addClass("selected");
		this.selectedRow.push(itemIndex);

		if(cfg.height != "auto"){

			var trTop = this.body.find(".gridBodyTr_" + itemIndex).position().top;
			var trHeight = this.body.find(".gridBodyTr_" + itemIndex).height();

			var scrollHeight = axdom("#" + cfg.targetID + "_AX_scrollContent").height();
			var bodyHeight = this.body.height();
			var handleHeight = axdom("#" + cfg.targetID + "_AX_scrollYHandle").outerHeight();
			var trackHeight = axdom("#" + cfg.targetID + "_AX_scrollTrackY").height();

			if (trTop.number() + trHeight.number() > bodyHeight) {
				var scrollTop = bodyHeight - (trTop.number() + trHeight.number());
				axdom("#" + cfg.targetID + "_AX_scrollContent").css({ top: scrollTop });
				this.contentScrollContentSync({ top: scrollTop });
			} else {
				if (trTop.number() == 0) {
					var scrollTop = 0;
					axdom("#" + cfg.targetID + "_AX_scrollContent").css({ top: scrollTop });
					this.contentScrollContentSync({ top: scrollTop });
				}
			}
		}
	},
	/**
	 * @method AXTree.click
	 * @param {Number} itemIndex - index of Array
	 * @param {String} open||expand - "open"이면 아이템개체 확장 후 선택, "expand"이면 아이템개체 확장만
	 * @param {Boolean} [doNotCallBack] - 아이템 개체 확장 처리후 클릭이벤트 발생 방지
	 * @returns {JSObject} - {"focusedID": ID } 대상아이디가 오브젝트로 옵니다.
	 * @description
	 * 아이템인덱스의 아이템 선택, 확장, 클릭이벤트 발생 처리를 합니다.
	 * @example
	 * ```js
	 * var findIndex = null;
	 * $.each(List, function(jindex, J){
	 *    if(this.id == "findid"){
	 *        findIndex = jindex;
	 *        return false;
	 *    }
	 * });
	 *	 if(findIndex != null){
	 *    var focusItem = myTree.click(findIndex, "open", true); // 아이템 확장처리만 원함.
	 * }
	 * ```
	 */
	click: function (itemIndex, open, doNotCallBack) {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;

		var item = this.list[itemIndex];

		if(!item){
			return {focusedID:undefined};
		}

		var hashs = item[cfg.reserveKeys.hashKey].split(/_/g);
		var subTree = this.tree;

		var opendPath = [];
		axf.each(hashs, function (idx, arg) {
			if (idx == 1) {
				subTree = subTree[this.number()];
				opendPath.push(subTree[reserveKeys.hashKey]);
			} else if (idx > 1) {
				subTree = subTree[cfg.reserveKeys.subTree][this.number()];
				opendPath.push(subTree[reserveKeys.hashKey]);
			}
		});
        if (open !== "expand") {
            opendPath.pop();
        }

		if (cfg.body.onclick && !doNotCallBack) {
			var sendObj = {
				index: itemIndex,
				list: this.list,
				item: item,
				subTree: subTree,
				page: this.page
			};
			cfg.body.onclick.call(sendObj, itemIndex, item);
		}

		if(open == "open" || open == "expand"){
			var expandList = [];
			axf.each(this.list, function(lidx, L){
				axf.each(opendPath, function(pidx, P){
					if(L[reserveKeys.hashKey] == P){
						if(!L[reserveKeys.openKey]){
							expandList.push(lidx);
						}
					}
				});
			});
			//trace(expandList);
			for(var i=0;i<expandList.length;i++){
				this.expandToggleList(expandList[i], this.list[expandList[i]]);
			}
		}

        if (open !== "expand") {
            this.setFocus(itemIndex);
        }

        if (cfg.persistSelected && open !== "expand") { // printList에서 click 메서드를 호출시 "expand"를 사용한다.
            var persistKey = cfg.cookiePrefix + cfg.targetID + "-selected-index";
            axf.setCookie(persistKey, itemIndex, cfg.cookieExpiredays);
        }

		return {focusedID:this.body.find(".gridBodyTr_" + itemIndex).attr("id")};

		/*
         if (event.preventDefault) event.preventDefault();
         if (event.stopPropagation) event.stopPropagation();
         event.cancelBubble = true;
         return false;
         */
	},
	/* body 영역 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ head & foot 영역  */
	getDataSetFormatterValue: function (formatter, dataSet, value, key, CH) {
		var cfg = this.config;
		var result;
		if (formatter == "money") {
			if (value == "" || value == "null" || value == undefined) {
				result = "";
			} else {
				result = value.number().money();
			}
		} else if (formatter == "dec") {
			result = (value == undefined) ? "" : value.dec();
		} else if (formatter == "html") {
			result = value;
		} else if (formatter == "checkbox") {
			result = value;
		} else {
			var sendObj = {
				index: null,
				list: this.list,
				item: dataSet,
				dataSet: dataSet,
				page: this.page
			};
			result = formatter.call(sendObj);
		}
		return result;
	},
	getHeadDataSet: function (dataSet, isfix) {
		var cfg = this.config;
		var tpo = [];
		var getDataSetFormatterValue = this.getDataSetFormatterValue.bind(this);
		//dataSet 빈 Key 채우기
		axf.each(cfg.colGroup, function () {
			if (dataSet[this.key] == undefined) dataSet[this.key] = "";
		});
		//dataSet 빈 Key 채우기 ~~~~~~~~~~~~~~~~
		var hasFixed = this.hasFixed;

		for (var r = 0; r < cfg.head.rows.length; r++) {
			var isLastTR = (cfg.head.rows.length - 1 == r);
			tpo.push("<tr class=\"gridBodyTr gridBodyTr_foot\" id=\"" + cfg.targetID + "_AX_head_" + r + "_AX_" + (isfix || "n") + "\">");
			var colCount = 0;

			axf.each(cfg.head.rows[r], function (CHidx, CH) {
				if (CH.display && CH.colspan > 0) {

					if (isfix == undefined || (isfix != undefined && colCount < (cfg.fixedColSeq + 1))) {

						colCount += CH.colspan;

						//radio, check exception
						var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
						var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
						var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";
						var bottomClass = (CH.isLastCell) ? "" : " bodyBottomBorder";
						var fixedClass = (CH.isFixedEndCell) ? " fixedLine" : "";

						//trace({r:r, CHidx:CHifixedColSeq:cfg.fixedColSeq, colCount:colCount});

						var bodyNodeClass = "";
						if (CH.formatter == "checkbox") bodyNodeClass = " bodyTdCheckBox";
						else if (CH.formatter == "html") bodyNodeClass = " bodyTdHtml";

						tpo.push("<td" + valign + rowspan + colspan + " id=\"" + cfg.targetID + "_AX_" + (isfix || "n") + "head_AX_" + r + "_AX_" + CHidx + "\" class=\"bodyTd" + bottomClass + fixedClass + "\">");
						tpo.push("<div class=\"tdRelBlock\">");
						tpo.push("<div class=\"bodyNode bodyTdText" + bodyNodeClass + "\" align=\"" + CH.align + "\" id=\"" + cfg.targetID + "_AX_headText_AX_" + r + "_AX_" + CHidx + "\">");
						if ((hasFixed && !CH.isFixedCell) || !hasFixed || isfix != undefined) {
							if (CH.formatter) {
								tpo.push(getDataSetFormatterValue(CH.formatter, dataSet, dataSet[CH.key], CH.key, CH));
							} else {
								tpo.push(dataSet[CH.key]);
							}
						} else {
							tpo.push("&nbsp;");
						}
						tpo.push("</div>");
						tpo.push("</div>");
						tpo.push("</td>");
					}
				}
			});
			if (r == 0 && isfix == undefined) {
				tpo.push("<td class=\"bodyNullTd\" id=\"" + cfg.targetID + "_AX_headnull\" rowspan=\"" + cfg.body.rows.length + "\"><div class=\"tdRelBlock\">&nbsp;</div></td>");
			}
			tpo.push("</tr>");
		}
		return tpo.join('');
	},
	getFootDataSet: function (dataSet, isfix) {
		var cfg = this.config;
		var tpo = [];
		var getDataSetFormatterValue = this.getDataSetFormatterValue.bind(this);
		//dataSet 빈 Key 채우기
		axf.each(cfg.colGroup, function () {
			if (dataSet[this.key] == undefined) dataSet[this.key] = "";
		});
		//dataSet 빈 Key 채우기 ~~~~~~~~~~~~~~~~
		var hasFixed = this.hasFixed;

		for (var r = 0; r < cfg.foot.rows.length; r++) {
			var isLastTR = (cfg.foot.rows.length - 1 == r);
			tpo.push("<tr class=\"gridBodyTr gridBodyTr_foot\" id=\"" + cfg.targetID + "_AX_foot_" + r + "_AX_" + (isfix || "n") + "\">");
			var colCount = 0;

			axf.each(cfg.foot.rows[r], function (CHidx, CH) {
				if (CH.display && CH.colspan > 0) {

					if (isfix == undefined || (isfix != undefined && colCount < (cfg.fixedColSeq + 1))) {

						colCount += CH.colspan;

						//radio, check exception
						var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
						var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
						var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";
						var bottomClass = (CH.isLastCell) ? "" : " bodyBottomBorder";
						var fixedClass = (CH.isFixedEndCell) ? " fixedLine" : "";

						//trace({r:r, CHidx:CHifixedColSeq:cfg.fixedColSeq, colCount:colCount});

						var bodyNodeClass = "";
						if (CH.formatter == "checkbox") bodyNodeClass = " bodyTdCheckBox";
						else if (CH.formatter == "html") bodyNodeClass = " bodyTdHtml";

						tpo.push("<td" + valign + rowspan + colspan + " id=\"" + cfg.targetID + "_AX_" + (isfix || "n") + "foot_AX_" + r + "_AX_" + CHidx + "\" class=\"bodyTd" + bottomClass + fixedClass + "\">");
						tpo.push("<div class=\"tdRelBlock\">");
						tpo.push("<div class=\"bodyNode bodyTdText" + bodyNodeClass + "\" align=\"" + CH.align + "\" id=\"" + cfg.targetID + "_AX_footText_AX_" + r + "_AX_" + CHidx + "\">");
						if ((hasFixed && !CH.isFixedCell) || !hasFixed || isfix != undefined) {
							if (CH.formatter) {
								tpo.push(getDataSetFormatterValue(CH.formatter, dataSet, dataSet[CH.key], CH.key, CH));
							} else {
								tpo.push(dataSet[CH.key]);
							}
						} else {
							tpo.push("&nbsp;");
						}
						tpo.push("</div>");
						tpo.push("</div>");
						tpo.push("</td>");
					}
				}
			});
			if (r == 0 && isfix == undefined) {
				tpo.push("<td class=\"bodyNullTd\" id=\"" + cfg.targetID + "_AX_footnull\" rowspan=\"" + cfg.body.rows.length + "\"><div class=\"tdRelBlock\">&nbsp;</div></td>");
			}
			tpo.push("</tr>");
		}
		return tpo.join('');
	},
	setDataSet: function (obj) {
		var cfg = this.config;
		if (obj.ajaxUrl) {

		} else {
			if (axdom.isPlainObject(obj)) {
				this.dataSet = obj;
				if (cfg.head) this.printHead();
				if (cfg.foot) this.printFoot();
				this.contentScrollResize(false);
			}
		}
	},
	redrawDataSet: function () {
		var cfg = this.config;
		if (this.dataSet) {
			if (cfg.head) this.printHead();
			if (cfg.foot) this.printFoot();
		}
	},
	printHead: function () {
		var cfg = this.config;
		var getDataSet = this.getHeadDataSet.bind(this);
		var po = [];
		po.push(getDataSet(this.dataSet));
		axdom("#" + cfg.targetID + "_AX_thead").html(po.join(''));
		if (this.hasFixed) {
			po = [];
			po.push(getDataSet(this.dataSet, "fix"));
			axdom("#" + cfg.targetID + "_AX_fixedThead").html(po.join(''));
		}
	},
	printFoot: function () {
		var cfg = this.config;
		var getDataSet = this.getFootDataSet.bind(this);
		var po = [];
		po.push(getDataSet(this.dataSet));
		axdom("#" + cfg.targetID + "_AX_tfoot").html(po.join(''));
		if (this.hasFixed) {
			po = [];
			po.push(getDataSet(this.dataSet, "fix"));
			axdom("#" + cfg.targetID + "_AX_fixedTfoot").html(po.join(''));
		}
	},
	/* head & foot 영역 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ editor 영역  */

	/* editor 영역 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	/* tree 추가 메서드  */
	/**
	 * @method AXTree.setTree
	 * @param {Array | Object} obj - example code 참고
	 * @description
	 * 트리에 데이터를 전달합니다. 비동기 방식의 경우 직접데이터를 전달하지 않고 데이터의 전달자 정보를 정의하여 처리합니다.
	 * @example
     * ```js
     * //Array - JSObject(tree형)
     * var Tree = [
     *	 {no:"1", type:"WBS", activity:"WBS 이름", desc:"", charger:"", admin:"", docs:"", open:true, subTree:[
     *	    {no:"1.1", type:"phase", activity:"기획 및 설계", desc:"M", charger:"최인석", admin:"", docs:"", open:true, subTree:[
     *		    {no:"1.1.1", type:"process", activity:"기획단계", desc:"M", charger:"최인석", admin:"", docs:"", open:true, subTree:[
     *			    {no:"1.1.1.1", type:"activity", activity:"요구사항정의", desc:"M", charger:"최인석/PM", admin:"홍길동", docs:"[필수]요구사항정의서", open:false, subTree:[]},
     *                {no:"1.1.1.2", type:"activity", activity:"업무분할", desc:"M", charger:"한승욱/기획", admin:"", docs:"[권고]요구사항정의서", open:false, subTree:[]}
     *            ]}
     *        ]}
     *    ]},
     *	 {no:"9", type:"WBS", activity:"WBS 이름", desc:"", charger:"", admin:"", docs:"", open:true, subTree:[]}
     *	 ];
     *	 myTree.setTree(Tree);
     *
     *	 var AJAXconfigs = {
     *    ajaxUrl:"loadTree.php", //{String} - AJAX 호출 URL
     *    ajaxPars:"param1=1&param2=2",   //{String} - AJAX 호출 URL 파라미터 (전송은 post 방식으로 이루어집니다.)
     *    onLoad: function(){ //[Function] - AJAX 호출완료 이벤트 콜백함수
     *        ...
     *    }
     *};
     * myTree.setTree(AJAXconfigs);
     * ```
	 */
	setTree: function (obj, sortDisable) {
		var cfg = this.config;
		var nowSortHeadID = this.nowSortHeadID;
		var nowSortHeadObj = this.nowSortHeadObj;
		this.listLoadingDisplay();

		if (obj.ajaxUrl) {
			this.ajaxInfo = obj;
			this.ajax_sortDisable = sortDisable;
			this.pageActive = true;

			var url = obj.ajaxUrl;
			/*
             var appendPars = [
             "pageNo="+this.page.pageNo,
             "pageSize="+this.page.pageSize
             ];
             var pars = (obj.ajaxPars) ? obj.ajaxPars + "&" +  appendPars.join('&') : appendPars.join('&') ;
             */
			var pars = (obj.ajaxPars) ? obj.ajaxPars : "";

			var ajaxGetTree = this.ajaxGetTree.bind(this);
			new AXReq(url, {
				debug: false, pars: pars, onsucc: function (res) {
					if ((res.result && res.result == AXConfig.AXReq.okCode) || (res.result == undefined && !res.error)) {
						res._sortDisable = sortDisable;
						if (obj.response) {
							obj.response.call(res);
						} else {
							ajaxGetTree(res);
						}
						if (obj.onLoad) obj.onLoad.call(res);
					} else {
						//AXUtil.alert(res);
						AXUtil.alert(res.msg);
					}
				}
			});
		} else {
			this.ajaxInfo = null;
			if (axdom.isArray(obj)) {
				this.tree = obj;
				this.list = this.convertHashListToTree(obj);
				//trace(this.list);
				this.setList(this.list, false);
			}
		}

	},
	ajaxGetTree: function (res) {
		var cfg = this.config;
		var nowSortHeadID = this.nowSortHeadID;
		var nowSortHeadObj = this.nowSortHeadObj;
		this.tree = res[AXConfig.AXTree.keyTree];

		this.list = this.convertHashListToTree(res[AXConfig.AXTree.keyTree]);
		if (res._sortDisable || !cfg.sort) {

		} else {
			if (nowSortHeadID) {
				this.list = this.sortList(nowSortHeadObj.sort, nowSortHeadObj, this.list);
			}
		}
		//AXUtil.overwriteObject(this.page, res.page, true);
		this.setList(this.list, false);
		//this.setPaging(); tree 에선 페이징 보류
	},
	setLoading: function (itemIndex, item) {
		var cfg = this.config;
		for (var r = 0; r < cfg.body.rows.length; r++) {
			axdom("#" + cfg.targetID + "_AX_tr_" + r + "_AX_n_AX_" + itemIndex).find(".bodyNodeIndent").addClass("loading");
		}
	},
	endLoading: function (itemIndex, item) {
		var cfg = this.config;
		for (var r = 0; r < cfg.body.rows.length; r++) {
			axdom("#" + cfg.targetID + "_AX_tr_" + r + "_AX_n_AX_" + itemIndex).find(".bodyNodeIndent").removeClass("loading");
		}
	},
	/**
	 * @method AXTree.appendTree
	 * @param {Number} itemIndex - 부모아이템 인덱스
	 * @param {JSObject} item - 부모아이템
	 * @param {JSObject} subTree - 추가하려는 아이템
	 * @description
	 * 원하는 아이템 하위에 아이템을 추가합니다.
	 * @example
	 * ```js
	 * // 선택아이템의 자식 추가하기
	 * var obj = myTree.getSelectedList();
	 * myTree.appendTree(obj.index, obj.item, [{nodeID:"N", nodenm:frm.nodeName.value, writer:"mondo", type:"file", parentcd:obj.item.nodeID}]);
     *
	 * // 선택아이템의 형제 추가하기
	 * var obj = myTree.getSelectedListParent();
	 * myTree.appendTree(obj.index, obj.item, [{nodeID:"N", nodenm:frm.nodeName.value, writer:"mondo", type:"file", parentcd:(obj.item.nodeID|0)}]);
	 * ```
	 */

	appendTree: function (itemIndex, item, subTree) {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;

		//trace({itemIndex:itemIndex, item:item, subTree:subTree});

		if (itemIndex == null || itemIndex == undefined || item == null || item == undefined) {

			var tree = this.tree;
			axf.each(subTree, function () {
				this[cfg.reserveKeys.subTree] = [];
				this._CUD = "C";
				tree.push(this);
			});

			var pushedList = this.appendSubTree("0".setDigit(cfg.hashDigit), true, subTree, this.tree);
			this.printList();

		} else { // 부모 하위 개체로 추가할 때에.

			axf.each(subTree, function () {
				if (!this[cfg.reserveKeys.subTree]) this[cfg.reserveKeys.subTree] = [];
			});
			var hashs = item[cfg.reserveKeys.hashKey].split(/_/g);

			var tree = this.tree; // 추가될 트리 구하기
			axf.each(hashs, function (idx, T) {
				if (idx > 0) {
					if (idx == 1) tree = tree[T.number()];
					else tree = tree[cfg.reserveKeys.subTree][T.number()];
				}
			});

			//tree[cfg.reserveKeys.subTree] =
			//tree[reserveKeys.openKey] = true;
			axf.each(subTree, function () {
				this._CUD = "C";
				tree[reserveKeys.subTree].push(this);
			});

			this.list = this.convertHashListToTree(this.tree);
			this.printList();
		}

		this.contentScrollXAttr = null;
		this.contentScrollYAttr = null;
		/* */
	},
	appendSubTree: function (parentHash, parentOpened, arr, parentArr) {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var appendSubTree = this.appendSubTree.bind(this);
		var appendSubTree_pushList = this.appendSubTree_pushList.bind(this);

		var returnList = [];
		var appendIndex = this.list.length;
		var parentSubTreeLength = 0;
		if (parentHash != "0".setDigit(cfg.hashDigit)) parentSubTreeLength = parentArr[reserveKeys.subTree].length;
		else parentSubTreeLength = parentArr.length;

		axf.each(arr, function (idx, A) {
			var pushItem = {};
			var hasOpenKey = false, hasSubTree = false;
			axf.each(A, function (k, v) {
				if (k == reserveKeys.openKey) {
					hasOpenKey = true;
					pushItem[k] = v;
				} else if (k == reserveKeys.subTree) {
					if(v.length > 0){
						hasSubTree = true;
						pushItem.__subTreeLength = v.length;
					}
				} else if (k == "__subTree") {
					hasSubTree = v;
					pushItem.__subTreeLength = v ? 1 : 0;
				} else {
					pushItem[k] = v;
				}
			});

			pushItem[reserveKeys.parentHashKey] = parentHash;
			pushItem[reserveKeys.hashKey] = parentHash + cfg.hashSpliter + (idx + parentSubTreeLength - 1).setDigit(cfg.hashDigit);
			if (!hasOpenKey) pushItem[reserveKeys.openKey] = true;

			//trace(pushItem[reserveKeys.openKey]);

			if (!hasSubTree) pushItem.__subTreeLength = 0;
			if (!pushItem[reserveKeys.subTree]) pushItem[reserveKeys.subTree] = [];
			pushItem[reserveKeys.displayKey] = parentOpened;
			if (pushItem[reserveKeys.openKey] && !parentOpened) pushItem[reserveKeys.openKey] = false; //부보가 닫힌 개체 이면 자식 개체도 닫힘

			//trace(pushItem);


			appendSubTree_pushList(pushItem);
			returnList.push({ itemIndex: appendIndex, item: pushItem });
			appendIndex++;

			if (!A[reserveKeys.subTree]) A[reserveKeys.subTree] = [];

			if (hasSubTree && A[reserveKeys.subTree].length > 0) {
				appendSubTree(pushItem[reserveKeys.hashKey], pushItem[reserveKeys.openKey], A[reserveKeys.subTree]);
			}
		});
		return returnList;
	},
	appendSubTree_pushList: function (item) {
		this.list.push(item);
	},
	fetchTree: function(subTree, parentItem){
		// TODO : fetchTree 속도 개선을 위해 추가된 아이템만 추가 하도록 함수 변경 필요
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var tree = this.tree;

		if(parentItem){

			var hashs = parentItem[cfg.reserveKeys.hashKey].split(/_/g);
			axf.each(hashs, function (idx, T) {
				if (idx > 0) {
					if (idx == 1) tree = tree[T.number()];
					else tree = tree[cfg.reserveKeys.subTree][T.number()];
				}
			});
			axf.each(subTree, function () {
				this[cfg.reserveKeys.subTree] = [];
				tree[reserveKeys.subTree].push(this);
			});

			this.list = this.convertHashListToTree(this.tree);
		}else{
			axf.each(subTree, function () {
				this[cfg.reserveKeys.subTree] = [];
				tree.push(this);
			});

			var pushedList = this.appendSubTree("0".setDigit(cfg.hashDigit), true, subTree, this.tree);
		}

		this.printList();
	},
	/**
	 * @method AXTree.updateTree
	 * @param {Number} itemIndex - 아이템 인덱스
	 * @param {JSObject} item - 아이템
	 * @param {JSObject} obj - 수정하려는 아이템 내용
	 * @description
	 * 원하는 아이템의 데이터를 수정합니다.
	 * @example
	 * ```js
	 * var obj = myTree.getSelectedList();
	 * myTree.updateTree(obj.index, obj.item, {nodenm:frm.nodeName.value});
	 * // 수정하려는 아이템의 일부 키만 전달 해도 수정이 가능합니다.
	 * ```
	 */
	updateTree: function (itemIndex, item, obj) {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var relation = cfg.relation;
		AXUtil.overwriteObject(item, obj);

		if(item._CUD != "C") item._CUD = "U";

		//item[cfg.reserveKeys.subTree] = this.list[itemIndex][cfg.reserveKeys.subTree];
		this.list[itemIndex] = item;

		this.updateList(itemIndex, item);

		for(var idx=0;idx<this.list.length;idx++){
			this.list[idx][reserveKeys.parentHashKey] = undefined;
			this.list[idx][reserveKeys.hashKey] = undefined;
		}

		this.positioningHashList(this.list);
	},
	/**
	 * @method AXTree.removeTree
	 * @param {Number|null} itemIndex - 아이템 index, index는 항목은 null 로 정의해도 처리가 가능합니다.
	 * @param {JSObject} item - 아이템
	 * @description
	 * 원하는 아이템의 데이터를 수정합니다.
	 * @example
     * ```
     * var obj = myTree.getSelectedList();
     * if(obj.error){
     *     alert("개체를 선택해 주세요");
     *     return;
     * }
     * myTree.removeTree(obj.index, obj.item);
     * ```
	 */
	removeTree: function (itemIndex, item) {
		var cfg = this.config, _this = this;
		var reserveKeys = cfg.reserveKeys;
		var relation = cfg.relation;
		// this.list 와 this.tree 에서 해당 개체를 찾아 제거 한다.
		// tree 찾기
		var hashs = item[reserveKeys.hashKey].split(/_/g);
		var phash = item[reserveKeys.parentHashKey];
		var tree = this.tree;
		var ptree = this.tree;
		for (var idx = 1; idx < hashs.length; idx++) {
			var H = hashs[idx];
			if (idx == 1) tree = tree[H.number()];
			else tree = tree[cfg.reserveKeys.subTree][H.number()];
			if (idx == hashs.length - 2) {
				//부모 트리인 경우
				ptree = tree;
			}
		}

		tree._isDel = true;

		if(tree._CUD == "C"){
			tree._CUD = "";
		}else{
			tree._CUD = "D";
		}

		var applyDel = function (subTree) {
			for (var ti = 0; ti < subTree.length; ti++) {
				subTree[ti]._isDel = true;

				if(subTree[ti]._CUD == "C"){
					subTree[ti]._CUD = "";
				}else{
					subTree[ti]._CUD = "D";
				}

				if (subTree[ti][cfg.reserveKeys.subTree]) {
					applyDel(subTree[ti][cfg.reserveKeys.subTree]);
				}
			}
		};
		applyDel(tree[cfg.reserveKeys.subTree]);

		var __subTreeLength = 0;
		if (ptree[cfg.reserveKeys.subTree]) {
			axf.each(ptree[cfg.reserveKeys.subTree], function () {
				if (!this._isDel) __subTreeLength++;
			});
		}

		// 삭제할 item 에 종속된 itemIndex 구한다.
		var pItem = null;

		axf.each(this.list, function (idx, L) {

			if (L[reserveKeys.hashKey].left(item[reserveKeys.hashKey].length) == item[reserveKeys.hashKey]) {
				L._isDel = true;
				if(L._CUD == "C"){
					L._CUD = "";
				}else{
					L._CUD = "D";
				}
				_this.target.find(".gridBodyTr_" + idx).remove();
			}
			if (phash == L[reserveKeys.hashKey]) {
				pItem = { itemIndex: idx, item: L };
			}
		});

		//부모 ITEM 의 __subTreeLength 속성 변경하기
		if (pItem) {
			this.list[pItem.itemIndex].__subTreeLength = __subTreeLength;
			// appendList 구문 생성
			/*
             if (__subTreeLength == 0) {
             var lastR = cfg.body.rows.length - 1;
             axdom("#" + cfg.targetID + "_AX_tr_" + lastR + "_AX_n_AX_" + pItem.itemIndex).find(".bodyNodeIndent").hide();
             axdom("#" + cfg.targetID + "_AX_tr_" + lastR + "_AX_f_AX_" + pItem.itemIndex).find(".bodyNodeIndent").hide();
             axdom("#" + cfg.targetID + "_AX_tr_" + lastR + "_AX_n_AX_" + pItem.itemIndex).find(".bodyNodeIndent").removeClass("expand");
             axdom("#" + cfg.targetID + "_AX_tr_" + lastR + "_AX_f_AX_" + pItem.itemIndex).find(".bodyNodeIndent").removeClass("expand");
             }
             */

			// 부모 ITEM 의 update
			var getItem = this.getItem.bind(this);
			var npo = "", lastR = cfg.body.rows.length - 1;
			npo = getItem(pItem.itemIndex, this.list[pItem.itemIndex], "n", "notr");
			_this.target.find(".gridBodyTr_" + pItem.itemIndex).html(npo);
		}

		if (this.selectedRow.length > 0) {
			var body = this.body;
			axf.each(this.selectedRow, function () {
				body.find(".gridBodyTr_" + this).removeClass("selected");
			});
			this.selectedRow.clear();
			AXContextMenu.close({ id: cfg.targetID + "ContextMenu" }); // event 직접 연결 방식
		}
	},
	moveUpTree: function () {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var relation = cfg.relation;

		var selectedObject = this.getSelectedList();

		if (selectedObject.error) {
			toast.push(selectedObject.description);
			return;
		}

		var itemIndex = selectedObject.index;
		var item = this.list[selectedObject.index];

		var hashs = item[cfg.reserveKeys.hashKey].split(/_/g);
		var myTree = this.tree;
		var nowChildIndex, changeChildIndex;
		var parentHashs = [];

		for (var hidx = 1; hidx < hashs.length - 1; hidx++) {
			if (hidx == 1) {
				myTree = myTree[hashs[hidx].number()];
				parentHashs.push(hashs[hidx]);
			} else {
				myTree = myTree[cfg.reserveKeys.subTree][hashs[hidx].number()];
				parentHashs.push(hashs[hidx]);
			}
			nowChildIndex = hashs[hidx + 1].number();
		}

		var isRootControl = false;
		if (myTree == this.tree) {
			isRootControl = true;
			nowChildIndex = hashs.last().number();
		}

		if (nowChildIndex < 1) {
			//이동불가
			toast.push("순서의 처음입니다.");
		} else {
			changeChildIndex = nowChildIndex - 1;

			try {
				if (isRootControl) {
					while (myTree[changeChildIndex]._isDel) {
						changeChildIndex--;
						if (changeChildIndex == 0) break;
					}

					var newSelectedHash = "0".setDigit(cfg.hashDigit) + "_" + (changeChildIndex).setDigit(cfg.hashDigit);
					var tempObj = AXUtil.copyObject(myTree[nowChildIndex]);

					myTree[nowChildIndex] = AXUtil.copyObject(myTree[changeChildIndex]);
					myTree[changeChildIndex] = tempObj;
					if(typeof myTree[nowChildIndex]._CUD == "undefined") myTree[nowChildIndex]._CUD = "U";
					if(typeof myTree[changeChildIndex]._CUD == "undefined") myTree[changeChildIndex]._CUD = "U";
				} else {
					while (myTree[cfg.reserveKeys.subTree][changeChildIndex]._isDel) {
						changeChildIndex--;
						if (changeChildIndex == 0) break;
					}

					var newSelectedHash = "0".setDigit(cfg.hashDigit) + "_" + parentHashs.join("_") + "_" + (changeChildIndex).setDigit(cfg.hashDigit);
					var tempObj = AXUtil.copyObject(myTree[cfg.reserveKeys.subTree][nowChildIndex]);
					myTree[cfg.reserveKeys.subTree][nowChildIndex] = AXUtil.copyObject(myTree[cfg.reserveKeys.subTree][changeChildIndex]);
					myTree[cfg.reserveKeys.subTree][changeChildIndex] = tempObj;
					if(typeof myTree[cfg.reserveKeys.subTree][nowChildIndex]._CUD == "undefined") myTree[cfg.reserveKeys.subTree][nowChildIndex]._CUD = "U";
					if(typeof myTree[cfg.reserveKeys.subTree][changeChildIndex]._CUD == "undefined") myTree[cfg.reserveKeys.subTree][changeChildIndex]._CUD = "U";
				}
			} catch (e) {
				trace(e);
			}

			this.selectedCells.clear();
			this.selectedRow.clear();

			this.list = this.convertHashListToTree(this.tree);
			this.printList();

			var newSelecteIndex;
			for (var idx = 0; idx < this.list.length; idx++) {
				if (this.list[idx][reserveKeys.hashKey] == newSelectedHash) {
					newSelecteIndex = idx;
					this.body.find(".gridBodyTr_" + newSelecteIndex).addClass("selected");
					this.selectedRow.push(newSelecteIndex);
					break;
				}
			}

		}
	},
	moveDownTree: function () {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var relation = cfg.relation;

		var selectedObject = this.getSelectedList();

		if (selectedObject.error) {
			toast.push(selectedObject.description);
			return;
		}

		var itemIndex = selectedObject.index;
		var item = this.list[selectedObject.index];
		var hashs = item[cfg.reserveKeys.hashKey].split(/_/g);

		var myTree = this.tree;
		var nowChildIndex, changeChildIndex;
		var parentHashs = [];
		for (var hidx = 1; hidx < hashs.length - 1; hidx++) {
			if (hidx == 1) {
				myTree = myTree[hashs[hidx].number()];
				parentHashs.push(hashs[hidx]);
			} else {
				myTree = myTree[cfg.reserveKeys.subTree][hashs[hidx].number()];
				parentHashs.push(hashs[hidx]);
			}
			nowChildIndex = hashs[hidx + 1].number();
			//trace(myTree);
		}

		var isRootControl = false;
		var subTreeLength;
		if (myTree == this.tree) {
			isRootControl = true;
			//parentHashs.push(hashs.last();
			nowChildIndex = hashs.last().number();
			subTreeLength = myTree.length;
		} else {
			subTreeLength = myTree[cfg.reserveKeys.subTree].length;
		}

		if (nowChildIndex > subTreeLength - 2) {
			//이동불가
			toast.push("순서의 마지막입니다.");
		} else {
			changeChildIndex = nowChildIndex.number() + 1;

			try {
				if (isRootControl) {
					while(myTree[changeChildIndex]._isDel){
						changeChildIndex++;
						if(changeChildIndex == myTree.length-1) break;
					}

					var newSelectedHash = "0".setDigit(cfg.hashDigit) + "_" + (changeChildIndex).setDigit(cfg.hashDigit);
					var tempObj = AXUtil.copyObject(myTree[nowChildIndex]);
					myTree[nowChildIndex] = AXUtil.copyObject(myTree[changeChildIndex]);
					myTree[changeChildIndex] = tempObj;
					if(typeof myTree[nowChildIndex]._CUD == "undefined") myTree[nowChildIndex]._CUD = "U";
					if(typeof myTree[nowChildIndex + 1]._CUD == "undefined") myTree[nowChildIndex + 1]._CUD = "U";
				} else {
					while(myTree[cfg.reserveKeys.subTree][changeChildIndex]._isDel){
						changeChildIndex++;
						if(changeChildIndex == myTree[cfg.reserveKeys.subTree].length-1) break;
					}

					var newSelectedHash = "0".setDigit(cfg.hashDigit) + "_" + parentHashs.join("_") + "_" + (changeChildIndex).setDigit(cfg.hashDigit);
					var tempObj = AXUtil.copyObject(myTree[cfg.reserveKeys.subTree][nowChildIndex]);
					myTree[cfg.reserveKeys.subTree][nowChildIndex] = AXUtil.copyObject(myTree[cfg.reserveKeys.subTree][changeChildIndex]);
					myTree[cfg.reserveKeys.subTree][changeChildIndex] = tempObj;
					if(typeof myTree[cfg.reserveKeys.subTree][nowChildIndex]._CUD == "undefined") myTree[cfg.reserveKeys.subTree][nowChildIndex]._CUD = "U";
					if(typeof myTree[cfg.reserveKeys.subTree][nowChildIndex + 1]._CUD == "undefined") myTree[cfg.reserveKeys.subTree][nowChildIndex + 1]._CUD = "U";
				}
			} catch (e) {
				trace(e);
			}

			this.selectedCells.clear();
			this.selectedRow.clear();

			this.list = this.convertHashListToTree(this.tree);
			this.printList();

			var newSelecteIndex;
			for (var idx = 0; idx < this.list.length; idx++) {
				if (this.list[idx][reserveKeys.hashKey] == newSelectedHash) {
					newSelecteIndex = idx;

					this.body.find(".gridBodyTr_" + newSelecteIndex).addClass("selected");
					this.selectedRow.push(newSelecteIndex);

					break;
				}
			};

		}

	},
	/**
	 * @method AXTree.moveTree
	 * @param {JSObject} Option - startMove, validate, endMove, Option에 3가지 함수를 정의합니다. example code 참고
	 * @description
	 * 원하는 아이템의 위치를 수정합니다.
	 * @example
     * ```js
     * myTree.moveTree({
     *     startMove: function(){      //moveTree가 발동 되었을 때 발생되는 콜백함수
     *         myTree.addClassItem({
     *             className:"disable",
     *             addClass:function(){
     *                 return (this.nodeID == "N");
     *             }
     *         });
     *     },
     *     validate:function(){        //moveTree가 활성화 된 상태에서 사용자의 선택을 검증하는 콜백함수
     *         //this.moveObj
     *         //this.targetObj
     *         if(this.targetObj.nodeID == "N"){
     *             alert("이동할 수 없는 대상을 선택하셨습니다.");
     *             return false;
     *         }else{
     *             return true;
     *         }
     *     },
     *     endMove: function(){        //moveTree가 완료 되었을때 발생되는 콜백함수
     *         myTree.removeClassItem({
     *             className:"disable",
     *             removeClass:function(){
     *                 return (this.nodeID == "N");
     *             }
     *         });
     *     }
     * });
     * ```
	 */
	moveTree: function (Option) {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var relation = cfg.relation;
		var moveObj = Option.moveObj, targetObj = Option.targetObj;

		// TODO : MOVE Bug -----

		if (moveObj && targetObj) {
			//외부 이동 명령 처리
			//this.moveTreeExec(); 을 위한 필터링 
		} else {

			var selectedObject = this.getSelectedList();

			if (selectedObject.error) {
				toast.push(selectedObject.description);
				return;
			}

			var itemIndex = selectedObject.index;
			var item = this.list[selectedObject.index];
			var hashs = item[cfg.reserveKeys.hashKey].split(/_/g);

			this.body.find(".gridBodyTr_" + itemIndex).addClass("copied");
			toast.push({ type: "Warning", body: "선택하신 아이템을 이동시킬 부모 아이템을 선택하세요" });
			this.readyMoved = true;
			this.moveTarget = { itemIndex: itemIndex };
			this.moveValidate = Option.validate;
			this.moveEndFunction = Option.endMove;

			if (Option.startMove) {
				Option.startMove.call();
			}

			//직계 부모를 disable 처리 합니다.
			this.addClassItem({
				className: "disable",
				addClass: function () {
					return (item[reserveKeys.parentHashKey] == this[reserveKeys.hashKey] || item[reserveKeys.hashKey] == this[reserveKeys.hashKey].left(item[reserveKeys.hashKey].length));
				}
			});

			// key event ready
			var eventForDocument = this.onBodyKeydown.bind(this);
			this.eventForDocument = function (event) {
				eventForDocument(event);
			};
			axdom(document.body).bind("keydown", this.eventForDocument);

		}
	},
	moveTreeExec: function (moveIndex, targetIndex) {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var relation = cfg.relation;

		if (moveIndex == targetIndex) {
			alert("이동 위치와 이동대상이 같습니다. 이동 할 수 없습니다.");
			return;
		}

		var moveObj = this.list[moveIndex];
		var targetObj = this.list[targetIndex];

		if (moveObj[reserveKeys.parentHashKey] == targetObj[reserveKeys.hashKey]) {
			alert("이동 위치가 현재 위치와 다르지 않습니다. 이동 할 수 없습니다.");
			return;
		}
		if (moveObj[reserveKeys.hashKey] == targetObj[reserveKeys.hashKey].left(moveObj[reserveKeys.hashKey].length)) {
			alert("이동 위치가 자식위치입니다. 이동 할 수 없습니다.");
			return;
		}

		if (this.moveValidate) {
			var validateResult = this.moveValidate.call({ moveObj: moveObj, targetObj: targetObj }, moveObj, targetObj);
			if (!validateResult) {
				return;
			}
		}

		//trace(this.tree);

		//아이템 복사 ~~~~~~~~~~~~~~~~~~
		var move_hashs = moveObj[reserveKeys.hashKey].split(/_/g);
		var move_Tree_parent = this.tree;
		for (var hidx = 1; hidx < move_hashs.length - 1; hidx++) {
			if (hidx == 1) {
				move_Tree_parent = move_Tree_parent[move_hashs[hidx].number()];
			} else {
				move_Tree_parent = move_Tree_parent[cfg.reserveKeys.subTree][move_hashs[hidx].number()];
			}
		}
		var copyObject = {};
		//trace("moveObj");
		//trace(moveObj);

		var move_Tree_parent_subTree = [];
		if (move_hashs.length == 2) { // root level
			move_Tree_parent_subTree = this.tree;
		} else {
			move_Tree_parent_subTree = move_Tree_parent[cfg.reserveKeys.subTree];
		}

		axf.each(move_Tree_parent_subTree, function (subTreeIndex, ST) {
			if (ST[relation.childKey] == moveObj[relation.childKey]) {
				copyObject = AXUtil.copyObject(ST);
			} else {

			}
		});
		//~~~~~~~~~~~~~~~~~~ 아이템 복사

		//아이템 이동 ~~~~~~~~~~~~~~~~~~
		var target_hashs = targetObj[reserveKeys.hashKey].split(/_/g);
		var target_Tree_parent = this.tree;

		//trace(this.tree);

		var newSelectedHashs = [];
		newSelectedHashs.push(target_hashs[0]);
		for (var hidx = 1; hidx < target_hashs.length; hidx++) {
			newSelectedHashs.push(target_hashs[hidx]);
			if (hidx == 1) {
				target_Tree_parent = target_Tree_parent[target_hashs[hidx].number()];
			} else {
				target_Tree_parent = target_Tree_parent[cfg.reserveKeys.subTree][target_hashs[hidx].number()];
			}
		}
		newSelectedHashs.push((target_Tree_parent[cfg.reserveKeys.subTree].length).setDigit(cfg.hashDigit));

		copyObject[relation.parentKey] = target_Tree_parent[relation.childKey];
		try {
			copyObject[relation.parentName] = target_Tree_parent[relation.childName];
		} catch (e) {

		}

		function treeExtend( _treeItems ){
			for(var ti = 0 ; ti < _treeItems.length ; ti++){
				if(typeof _treeItems[ti]._CUD == "undefined") _treeItems[ti]._CUD = "U";
				if( _treeItems[ti][cfg.reserveKeys.subTree] ){
					treeExtend( _treeItems[ti][cfg.reserveKeys.subTree] );
				}
			}
		}
		if(typeof copyObject._CUD == "undefined") copyObject._CUD = "U";
		treeExtend( copyObject[cfg.reserveKeys.subTree] );

		target_Tree_parent[cfg.reserveKeys.subTree].push(copyObject);
		var newSelectedHash = newSelectedHashs.join("_");

		//~~~~~~~~~~~~~~~~~~ 아이템 이동

		//이동된 아이템 제거
		var new_subTree = [];
		axf.each(move_Tree_parent_subTree, function (subTreeIndex, ST) {
			if (ST[relation.childKey] == moveObj[relation.childKey]) {

			} else {
				new_subTree.push(ST);
			}
		});

		if (move_hashs.length == 2) { // root level
			this.tree = new_subTree;
		} else {
			move_Tree_parent[cfg.reserveKeys.subTree] = new_subTree;
		}

		this.selectedCells.clear();
		this.selectedRow.clear();

		this.list = this.convertHashListToTree(this.tree);
		this.printList();

		var newSelecteIndex;
		for (var idx = 0; idx < this.list.length; idx++) {
			if (this.list[idx][reserveKeys.hashKey] == newSelectedHash) {
				newSelecteIndex = idx;

				this.body.find(".gridBodyTr_" + newSelecteIndex).addClass("selected");
				this.selectedRow.push(newSelecteIndex);

				break;
			}
		};

		this.cancelMove();
	},
	cancelMove: function () {
		this.readyMoved = false;
		this.body.find(".gridBodyTr_" + this.moveTarget.itemIndex).removeClass("copied");
		if (this.moveEndFunction) {
			this.moveEndFunction.call();
		}

		this.body.find(".gridBodyTr.disable").removeClass("disable");

		this.moveTarget = null;
		axdom(document.body).unbind("keydown", this.eventForDocument);
	},
	addClassItem: function (Option) {
		var body = this.body;

		axf.each(this.list, function (listIndex, item) {
			if (Option.addClass) {
				if (Option.addClass.call(item)) {
					body.find(".gridBodyTr_" + listIndex).addClass(Option.className);
				}
			}
		});
	},
	removeClassItem: function (Option) {
		var body = this.body;

		axf.each(this.list, function (listIndex, item) {
			if (Option.removeClass) {
				if (Option.removeClass.call(item)) {
					//trace(listIndex);
					body.find(".gridBodyTr_" + listIndex).removeClass(Option.className);
				}
			}
		});
	},
	/* tree 추가 메서드  */

	/* tree = list convert  */
	convertHashListToTree: function (Tree) {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var relation = cfg.relation;

		this.hashList = [];
		var pushItem = { isRoot: true };
		pushItem[relation.childKey] = "0";
		pushItem[reserveKeys.hashKey] = "0".setDigit(cfg.hashDigit);
		pushItem[reserveKeys.parentHashKey] = "";
		pushItem[reserveKeys.openKey] = true;
		pushItem._subTreeLength = Tree.length;

		this.getSubTreeList(pushItem[reserveKeys.hashKey], pushItem[reserveKeys.openKey], pushItem, Tree);
		return this.hashList;
	},
	getSubTreeList: function (parentHash, parentOpened, parentItem, arr) {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var relation = cfg.relation;

		var getSubTreeList = this.getSubTreeList.bind(this);
		var pushHashList = this.pushHashList.bind(this);

		if (!arr[reserveKeys.subTree]) arr[reserveKeys.subTree] = [];

		axf.each(arr, function (idx, A) {
			var pushItem = {};
			var hasOpenKey = false, hasSubTree = false;

			delete A.__subTreeLength;
			axf.each(A, function (k, v) {
				if (k == reserveKeys.openKey) {
					hasOpenKey = true;
					pushItem[k] = v;
				} else if (k == reserveKeys.subTree) {
					if(v.length > 0){
						hasSubTree = true;
						pushItem.__subTreeLength = v.length;
					}
				} else if (k == "__subTree") {
					hasSubTree = v;
					pushItem.__subTreeLength = v ? 1 : 0;
				} else {
					pushItem[k] = v;
				}
			});
			pushItem[reserveKeys.parentHashKey] = parentHash;
			pushItem[reserveKeys.hashKey] = parentHash + cfg.hashSpliter + idx.setDigit(cfg.hashDigit);
			A[reserveKeys.hashKey] = parentHash + cfg.hashSpliter + idx.setDigit(cfg.hashDigit);
			if (!hasOpenKey) pushItem[reserveKeys.openKey] = false;
			if (!hasSubTree) pushItem.__subTreeLength = 0;
			pushItem[reserveKeys.displayKey] = parentOpened;
			if (pushItem[reserveKeys.openKey] && !parentOpened) pushItem[reserveKeys.openKey] = false; //부보가 닫힌 개체 이면 자식 개체도 닫힘

			if (pushItem[relation.parentKey] == undefined || pushItem[relation.parentKey] == relation.rootID) {
				pushItem[relation.parentKey] = parentItem[relation.childKey];
			}

			if(idx == (arr.length-1)){
				A.__isLastChild = true;
				pushItem.__isLastChild = true;
			}else{
				A.__isLastChild = false;
				pushItem.__isLastChild = false;
			}
			pushHashList(pushItem);

			if (!A[reserveKeys.subTree]) A[reserveKeys.subTree] = [];
			if (hasSubTree && A[reserveKeys.subTree].length > 0) {
				getSubTreeList(pushItem[reserveKeys.hashKey], pushItem[reserveKeys.openKey], pushItem, A[reserveKeys.subTree]);
			}
		});
	},
	pushHashList: function (item) {
		this.hashList.push(item);
	},
	convertTreeToHashList: function (List) {
		var cfg = this.config;
		reserveKeys = cfg.reserveKeys;
		//cfg.hashSpliter;
		var hashTree = [];

		for (var idx = 0; idx < List.length; idx++) {
			var item = List[idx];
			var re = new RegExp(cfg.hashSpliter, "g");
			var pHash = item[reserveKeys.parentHashKey];
			var hashs = item[reserveKeys.hashKey].split(re);
			var pushItem = {};
			axf.each(item, function (k, v) {
				var addOk = true;
				axf.each(reserveKeys, function (kk, vv) {
					if (k == vv) {
						addOk = false;
						return false;
					}
				});
				if (addOk) {
					pushItem[k] = v;
				}
			});
			pushItem[reserveKeys.hashKey] = item[reserveKeys.hashKey];
			pushItem[cfg.reserveKeys.subTree] = [];
			if (hashs.length == 2) {
				hashTree.push(pushItem);
			} else if (hashs.length > 2) {
				var pItem = hashTree.has(function () {
					return this.item[reserveKeys.hashKey] == pHash;
				});
				if (pItem) {
					pItem[cfg.reserveKeys.subTree].push(pushItem);
				}
			}
		}
	},
	positioningHashList: function (List) {
		var cfg = this.config;
		reserveKeys = cfg.reserveKeys;
		relation = cfg.relation;

		if (!relation) {
			toast.push("relation 속성이 지정되지 않아 요청을 수행 할 수 없습니다. relation:{parentKey:'', childKey:''}");
			return;
		}

		// make pointer;
		var tree = [];
		var pointer = {};
		var seq = 0, _parentCheckKey = 0;
		for (var idx = 0; idx < List.length; idx++) {
			var L = List[idx];
			if(idx == 0) _parentCheckKey =  L[relation.parentKey];
			if (!L.isRoot) {
				if(L.AXTreeSplit){

				}else{
                    L.__index = idx;
                    pointer[L[relation.childKey]] = idx;
                    if (L[reserveKeys.openKey] == undefined) L[reserveKeys.openKey] = false;
					if (L[relation.parentKey] == _parentCheckKey) {
						L[reserveKeys.subTree] = [];
						L.__subTreeLength = 0;
						L[reserveKeys.parentHashKey] = "0".setDigit(cfg.hashDigit);
						L[reserveKeys.hashKey] = "0".setDigit(cfg.hashDigit) + "_" + seq.setDigit(cfg.hashDigit);
						L[reserveKeys.displayKey] = true;
						tree.push(AXUtil.copyObject(L));
						seq++;
					} else {
						L.__subTreeLength = 0;
						L[reserveKeys.displayKey] = false;
					}
				}
			}
		}

		for (var idx = 0; idx < List.length; idx++) {
			var L = List[idx];
			if (L[reserveKeys.parentHashKey] == undefined && !L.isRoot) {

				if(L.AXTreeSplit) continue;

				var pItem = List[pointer[L[relation.parentKey]]];
				var pHash = pItem[reserveKeys.hashKey] || "";
				var pHashs = pHash.split(/_/g);
				var pTree = tree;
				axf.each(pHashs, function (idx, T) {
					if (idx > 0) pTree = pTree[T.number()][cfg.reserveKeys.subTree];
				});
				L[reserveKeys.subTree] = [];

				var __subTreeLength = pItem.__subTreeLength;
				var pOpend = pItem[reserveKeys.openKey];
				L[reserveKeys.parentHashKey] = pHash;
				L[reserveKeys.hashKey] = pHash + cfg.hashSpliter + __subTreeLength.setDigit(cfg.hashDigit);
				L[reserveKeys.displayKey] = pOpend;

				pTree.push(AXUtil.copyObject(L));
				pItem.__subTreeLength++;
			}
		}

		// hash 값대로 정렬을 합니다.
		List.sort(function(p, n){
			return (p[reserveKeys.hashKey] < n[reserveKeys.hashKey]) ? -1 : (p[reserveKeys.hashKey] > n[reserveKeys.hashKey]) ? 1 : 0;
		});

		if(cfg.showConnectionLine){
			this.tree = tree;
			List = this.convertHashListToTree(this.tree);
			//List = this.list;
		}else{
			this.tree = tree;
		}

		//trace(List);
		//trace(tree);

		return List;
	},

	/**
	 * @method AXTree.getSelectedList
	 * @returns {JSObject} - {index:1, item: {} }
	 * @description
	 * 현재 선택된 아이템을 반환합니다.
	 * (Number) index of Array 선택한 아이템들의 첫번째
	 *
	 * @example
	 * ```js
	 * var SL = AXTree.getSelectedList();
	 * trace(SL);
	 * ```
	 */
	getSelectedList: function () {
		if (this.selectedRow != undefined && this.selectedRow != null && this.selectedRow.length > 0) {
			return { index: this.selectedRow.first(), item: this.list[this.selectedRow.first()] };
		} else {
			return { error: "noselected", description: "선택된 item이 없습니다." };
		}
	},
	/**
	 * @method AXTree.getSelectedListParent
	 * @returns {JSObject} - {index:1, item: {} }
	 * @description
	 * 현재 선택된 아이템의 부모 아이템을 반환합니다.
	 * @example
	 * ```js
	 * var SL = AXTree.getSelectedListParent();
	 * trace(SL)
	 * ```
	 */
	getSelectedListParent: function () {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var relation = cfg.relation;

		if (this.selectedRow != undefined && this.selectedRow != null && this.selectedRow.length > 0) {

			var item = this.list[this.selectedRow.first()];
			var pno = item[relation.parentKey];

			var parentIndex = null;
			if (pno != "0") {
				axf.each(this.list, function (findIndex, findItem) {
					if (findItem[relation.childKey] == pno) {
						parentIndex = findIndex;
						return false;
					}
				});
			}

			if (parentIndex == null) {
				return { index: null, item: null };
			} else {
				return { index: parentIndex, item: this.list[parentIndex] };
			}
		} else {
			return { index: null, item: null };
		}
	},

	/**
	 * @method AXTree.relationFixedSync
	 * @param {JSObject} options  - 설명
	 * @returns changed item of list {Array}
	 * @description 자식 항목에 체크된 경우 부모 값을 체크된 상태로 변경 해주는 메서드 입니다.
	 * @example
	 * ```js
	 * myTree.relationFixedSync();
	 * myTree.relationFixedSync({expandItem:true}); // 체크된 아이템을 확장상태로 변경합니다.
	 * ```
	 */
	relationFixedSync: function(options){
		var cfg = this.config;
		var _body = this.body, _this = this;
		var returnObject = [];
		axf.each(this.list, function(lidx, L){
			axdom("#" + cfg.targetID + "_AX_treeBody").find(".gridBodyTr_"+lidx+" .treeCheckBox_body").each(function(){
				if(L.__checked && (options && options.expandItem)) _this.expandToggleList(lidx, L, true);
				this.checked = L.__checked;
				returnObject.push(this);
			});
		});
		return returnObject;
	},

	/**
	 * @method AXTree.expandAll
	 * @param {(String|Null|Number)} [depth="all"} - 확장할 뎁스, 값을 주지 않거나 "all" 을 주면 전체 확장이됩니다.
	 * @description 트리의 노드를 확장시켜 줍니다.
	 * @example
	 * ```js
	 * myTree.expandAll(); //모두확장
	 * myTree.expandAll(1); //1 뎁스까지만 확장
	 * ```
	 */
	expandAll: function(depth){
		var cfg = this.config;
		var _body = this.body;
		axf.each(this.list, function (itemIndex, item) {
			if (typeof depth == "undefined" || depth == "all") {
				item[cfg.reserveKeys.openKey] = true;
			} else {
				var hashLevel = item[cfg.reserveKeys.parentHashKey].split(/_/g).length;
				if (hashLevel < depth.number()+1) item[cfg.reserveKeys.openKey] = true;
				else item[cfg.reserveKeys.openKey] = false;
			}
			item[cfg.reserveKeys.displayKey] = true;
			item[cfg.reserveKeys.parentHashKey] = undefined;
			item[cfg.reserveKeys.hashKey] = undefined;
		});
		this.list = this.positioningHashList(this.list);
		this.printList();
		return this;
	},
	/**
	 * @method AXTree.collapseAll
	 * @description
	 * 트리의 모든 아이템을 축소상태로 변경합니다.
	 * @example
	 * ```js
	 * myTree.collapseAll();
	 * ```
	 */
	collapseAll: function(){
		var cfg = this.config;
		var _body = this.body;
		axf.each(this.list, function (itemIndex, item) {
			item[cfg.reserveKeys.openKey] = false;
			if(item[cfg.relation.parentKey] == 0){
				item[cfg.reserveKeys.displayKey] = true;
			}else{
				item[cfg.reserveKeys.displayKey] = false;
			}
			item[cfg.reserveKeys.parentHashKey] = undefined;
			item[cfg.reserveKeys.hashKey] = undefined;
		});
		this.list = this.positioningHashList(this.list);
		this.printList();
		return this;
	},
    /**
     * item의 부모 item들을 포함해서 차례대로 확장합니다.
     *
     * @param {(Object|String)} - item or key ex) myTree.list[5](item) or myTree.list[5][relation.childKey](key)
     * @returns {AXTree}
     */
    expand: function(key){
        var targetItem;
        if (Object.isObject(key)) {
            targetItem = key;
        } else {
            var cfg = this.config;
            axf.each(this.list, function(itemIndex, item){
                if (item[cfg.relation.childKey] == key) {
                    targetItem = item;
                    return false;
                }
            });
        }

        if (!targetItem) {
            return {focusedID:undefined};
        }

        return this.click(targetItem.__index, "open", true);
    }
});
/* ---------------------------- */
/* http://www.axisj.com, license : http://www.axisj.com/license */

/**
 * SWFUpload: http://www.swfupload.org, http://swfupload.googlecode.com
 *
 * mmSWFUpload 1.0: Flash upload dialog - http://profandesign.se/swfupload/,  http://www.vinterwebb.se/
 *
 * SWFUpload is (c) 2006-2007 Lars Huring, Olov Nilz? and Mammon Media and is released under the MIT License:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * SWFUpload 2 is (c) 2007-2008 Jake Roberts and is released under the MIT License:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * SWFObject v2.2 <http://code.google.com/p/swfobject/>
 *	is released under the MIT License <http://www.opensource.org/licenses/mit-license.php>
 */

/* ******************* */
/* Constructor & Init  */
/* ******************* */

var SWFUpload;
var swfobject;

(function(){
	if (SWFUpload == undefined) {
		SWFUpload = function (settings) {
			this.initSWFUpload(settings);
		};
	}

	SWFUpload.prototype.initSWFUpload = function (userSettings) {
		try {
			this.customSettings = {};	// A container where developers can place their own settings associated with this instance.
			this.settings = {};
			this.eventQueue = [];
			this.movieName = "SWFUpload_" + SWFUpload.movieCount++;
			this.movieElement = null;


			// Setup global control tracking
			SWFUpload.instances[this.movieName] = this;

			// Load the settings.  Load the Flash movie.
			this.initSettings(userSettings);
			this.loadSupport();
			if (this.swfuploadPreload()) {
				this.loadFlash();
			}

			this.displayDebugInfo();
		} catch (ex) {
			delete SWFUpload.instances[this.movieName];
			throw ex;
		}
	};

	/* *************** */
	/* Static Members  */
	/* *************** */
	SWFUpload.instances = {};
	SWFUpload.movieCount = 0;
	SWFUpload.version = "2.5.0 2010-01-15 Beta 2";
	SWFUpload.QUEUE_ERROR = {
		QUEUE_LIMIT_EXCEEDED            : -100,
		FILE_EXCEEDS_SIZE_LIMIT         : -110,
		ZERO_BYTE_FILE                  : -120,
		INVALID_FILETYPE                : -130
	};
	SWFUpload.UPLOAD_ERROR = {
		HTTP_ERROR                      : -200,
		MISSING_UPLOAD_URL              : -210,
		IO_ERROR                        : -220,
		SECURITY_ERROR                  : -230,
		UPLOAD_LIMIT_EXCEEDED           : -240,
		UPLOAD_FAILED                   : -250,
		SPECIFIED_FILE_ID_NOT_FOUND     : -260,
		FILE_VALIDATION_FAILED          : -270,
		FILE_CANCELLED                  : -280,
		UPLOAD_STOPPED                  : -290,
		RESIZE                          : -300
	};
	SWFUpload.FILE_STATUS = {
		QUEUED       : -1,
		IN_PROGRESS  : -2,
		ERROR        : -3,
		COMPLETE     : -4,
		CANCELLED    : -5
	};
	SWFUpload.UPLOAD_TYPE = {
		NORMAL       : -1,
		RESIZED      : -2
	};

	SWFUpload.BUTTON_ACTION = {
		SELECT_FILE             : -100,
		SELECT_FILES            : -110,
		START_UPLOAD            : -120,
		JAVASCRIPT              : -130,	// DEPRECATED
		NONE                    : -130
	};
	SWFUpload.CURSOR = {
		ARROW : -1,
		HAND  : -2
	};
	SWFUpload.WINDOW_MODE = {
		WINDOW       : "transparent",
		TRANSPARENT  : "transparent",
		OPAQUE       : "opaque"
	};

	SWFUpload.RESIZE_ENCODING = {
		JPEG  : -1,
		PNG   : -2
	};

	// Private: takes a URL, determines if it is relative and converts to an absolute URL
	// using the current site. Only processes the URL if it can, otherwise returns the URL untouched
	SWFUpload.completeURL = function (url) {
		try {
			var path = "", indexSlash = -1;
			if (typeof(url) !== "string" || url.match(/^https?:\/\//i) || url.match(/^\//) || url === "") {
				return url;
			}

			indexSlash = window.location.pathname.lastIndexOf("/");
			if (indexSlash <= 0) {
				path = "/";
			} else {
				path = window.location.pathname.substr(0, indexSlash) + "/";
			}

			return path + url;
		} catch (ex) {
			return url;
		}
	};

	// Public: assign a new function to onload to use swfobject's domLoad functionality
	SWFUpload.onload = function () {};


	/* ******************** */
	/* Instance Members  */
	/* ******************** */

	// Private: initSettings ensures that all the
	// settings are set, getting a default value if one was not assigned.
	SWFUpload.prototype.initSettings = function (userSettings) {

		this.ensureDefault = function (settingName, defaultValue) {
			var setting = userSettings[settingName];
			if (setting != undefined) {
				this.settings[settingName] = setting;
			} else {
				this.settings[settingName] = defaultValue;
			}
		};

		// Upload backend settings
		this.ensureDefault("upload_url", "");
		this.ensureDefault("preserve_relative_urls", false);
		this.ensureDefault("file_post_name", userSettings.uploadFileName);
		this.ensureDefault("post_params", {});
		this.ensureDefault("use_query_string", false);
		this.ensureDefault("requeue_on_error", false);
		this.ensureDefault("http_success", []);
		this.ensureDefault("assume_success_timeout", 0);

		// File Settings
		this.ensureDefault("file_types", userSettings.file_types);
		this.ensureDefault("file_types_description", "All Files");
		this.ensureDefault("file_size_limit", 0);	// Default zero means "unlimited"
		this.ensureDefault("file_upload_limit", 0);
		this.ensureDefault("file_queue_limit", 0);

		// Flash Settings
		this.ensureDefault("flash_url", "swfupload.swf");
		this.ensureDefault("flash9_url", "swfupload_fp9.swf");
		this.ensureDefault("prevent_swf_caching", true);

		// Button Settings
		this.ensureDefault("button_image_url", "");
		this.ensureDefault("button_width", 1);
		this.ensureDefault("button_height", 1);
		this.ensureDefault("button_text", "");
		this.ensureDefault("button_text_style", "color: #000000; font-size: 16pt;");
		this.ensureDefault("button_text_top_padding", 0);
		this.ensureDefault("button_text_left_padding", 0);
		this.ensureDefault("button_action", SWFUpload.BUTTON_ACTION.SELECT_FILES);
		this.ensureDefault("button_disabled", false);
		this.ensureDefault("button_placeholder_id", "");
		this.ensureDefault("button_placeholder", null);
		this.ensureDefault("button_cursor", SWFUpload.CURSOR.ARROW);
		this.ensureDefault("button_window_mode", SWFUpload.WINDOW_MODE.WINDOW);

		// Debug Settings
		this.ensureDefault("debug", false);
		this.settings.debug_enabled = this.settings.debug;	// Here to maintain v2 API

		// Option Setting
		this.ensureDefault("fileSelectAutoUpload", userSettings.fileSelectAutoUpload);

		// Event Handlers
		this.settings.return_upload_start_handler = this.returnUploadStart;
		this.ensureDefault("swfupload_preload_handler", null);
		this.ensureDefault("swfupload_load_failed_handler", null);
		this.ensureDefault("swfupload_loaded_handler", null);
		this.ensureDefault("file_dialog_start_handler", null);
		this.ensureDefault("file_queued_handler", null);
		this.ensureDefault("file_queue_error_handler", null);
		this.ensureDefault("file_dialog_complete_handler", null);

		this.ensureDefault("upload_resize_start_handler", null);
		this.ensureDefault("upload_start_handler", null);
		this.ensureDefault("upload_progress_handler", null);
		this.ensureDefault("upload_error_handler", null);
		this.ensureDefault("upload_success_handler", null);
		this.ensureDefault("upload_complete_handler", null);

		this.ensureDefault("mouse_click_handler", null);
		this.ensureDefault("mouse_out_handler", null);
		this.ensureDefault("mouse_over_handler", null);

		this.ensureDefault("debug_handler", this.debugMessage);

		this.ensureDefault("custom_settings", {});

		// Other settings
		this.customSettings = this.settings.custom_settings;

		// Update the flash url if needed
		if (!!this.settings.prevent_swf_caching) {
			this.settings.flash_url = this.settings.flash_url + (this.settings.flash_url.indexOf("?") < 0 ? "?" : "&") + "preventswfcaching=" + new Date().getTime();
			this.settings.flash9_url = this.settings.flash9_url + (this.settings.flash9_url.indexOf("?") < 0 ? "?" : "&") + "preventswfcaching=" + new Date().getTime();
		}

		if (!this.settings.preserve_relative_urls) {
			this.settings.upload_url = SWFUpload.completeURL(this.settings.upload_url);
			this.settings.button_image_url = SWFUpload.completeURL(this.settings.button_image_url);
		}

		delete this.ensureDefault;
	};

	// Initializes the supported functionality based the Flash Player version, state, and event that occur during initialization
	SWFUpload.prototype.loadSupport = function () {
		this.support = {
			loading : swfobject.hasFlashPlayerVersion("9.0.28"),
			imageResize : swfobject.hasFlashPlayerVersion("10.0.0")
		};

	};

	// Private: loadFlash replaces the button_placeholder element with the flash movie.
	SWFUpload.prototype.loadFlash = function () {
		var targetElement, tempParent, wrapperType, flashHTML, els;

		if (!this.support.loading) {
			this.queueEvent("swfupload_load_failed_handler", ["Flash Player doesn't support SWFUpload"]);
			return;
		}

		// Make sure an element with the ID we are going to use doesn't already exist
		if (document.getElementById(this.movieName) !== null) {
			this.support.loading = false;
			this.queueEvent("swfupload_load_failed_handler", ["Element ID already in use"]);
			return;
		}

		// Get the element where we will be placing the flash movie
		targetElement = document.getElementById(this.settings.button_placeholder_id) || this.settings.button_placeholder;

		if (targetElement == undefined) {
			this.support.loading = false;
			this.queueEvent("swfupload_load_failed_handler", ["button place holder not found"]);
			return;
		}

		wrapperType = (targetElement.currentStyle && targetElement.currentStyle["display"] || window.getComputedStyle && document.defaultView.getComputedStyle(targetElement, null).getPropertyValue("display")) !== "block" ? "span" : "div";

		// Append the container and load the flash
		tempParent = document.createElement(wrapperType);

		flashHTML = this.getFlashHTML();

		try {
			tempParent.innerHTML = flashHTML;	// Using innerHTML is non-standard but the only sensible way to dynamically add Flash in IE (and maybe other browsers)
		} catch (ex) {
			this.support.loading = false;
			this.queueEvent("swfupload_load_failed_handler", ["Exception loading Flash HTML into placeholder"]);
			return;
		}

		// Try to get the movie element immediately
		els = tempParent.getElementsByTagName("object");
		if (!els || els.length > 1 || els.length === 0) {
			this.support.loading = false;
			this.queueEvent("swfupload_load_failed_handler", ["Unable to find movie after adding to DOM"]);
			return;
		} else if (els.length === 1) {
			this.movieElement = els[0];
		}

		targetElement.parentNode.replaceChild(tempParent.firstChild, targetElement);

		// Fix IE Flash/Form bug
		if (window[this.movieName] == undefined) {
			window[this.movieName] = this.getMovieElement();
		}
	};

	// Private: getFlashHTML generates the object tag needed to embed the flash in to the document
	SWFUpload.prototype.getFlashHTML = function (flashVersion) {
		// Flash Satay object syntax: http://www.alistapart.com/articles/flashsatay
		return ['<object id="', this.movieName, '" type="application/x-shockwave-flash" data="', (this.support.imageResize ? this.settings.flash_url : this.settings.flash9_url), '" width="', this.settings.button_width, '" height="', this.settings.button_height, '" class="swfupload">',
			'<param name="wmode" value="', this.settings.button_window_mode, '" />',
			'<param name="movie" value="', (this.support.imageResize ? this.settings.flash_url : this.settings.flash9_url), '" />',
			'<param name="quality" value="high" />',
			'<param name="allowScriptAccess" value="always" />',
			'<param name="flashvars" value="' + this.getFlashVars() + '" />',
			'</object>'].join("");
	};

	// Private: getFlashVars builds the parameter string that will be passed
	// to flash in the flashvars param.
	SWFUpload.prototype.getFlashVars = function () {
		// Build a string from the post param object
		var httpSuccessString, paramString;

		paramString = this.buildParamString();
		httpSuccessString = this.settings.http_success.join(",");

		// Build the parameter string
		return ["movieName=", encodeURIComponent(this.movieName),
			"&amp;uploadURL=", encodeURIComponent(this.settings.upload_url),
			"&amp;useQueryString=", encodeURIComponent(this.settings.use_query_string),
			"&amp;requeueOnError=", encodeURIComponent(this.settings.requeue_on_error),
			"&amp;httpSuccess=", encodeURIComponent(httpSuccessString),
			"&amp;assumeSuccessTimeout=", encodeURIComponent(this.settings.assume_success_timeout),
			"&amp;params=", encodeURIComponent(paramString),
			"&amp;filePostName=", encodeURIComponent(this.settings.file_post_name),
			"&amp;fileTypes=", encodeURIComponent(this.settings.file_types),
			"&amp;fileTypesDescription=", encodeURIComponent(this.settings.file_types_description),
			"&amp;fileSizeLimit=", encodeURIComponent(this.settings.file_size_limit),
			"&amp;fileUploadLimit=", encodeURIComponent(this.settings.file_upload_limit),
			"&amp;fileQueueLimit=", encodeURIComponent(this.settings.file_queue_limit),
			"&amp;debugEnabled=", encodeURIComponent(this.settings.debug_enabled),
			"&amp;buttonImageURL=", encodeURIComponent(this.settings.button_image_url),
			"&amp;buttonWidth=", encodeURIComponent(this.settings.button_width),
			"&amp;buttonHeight=", encodeURIComponent(this.settings.button_height),
			"&amp;buttonText=", encodeURIComponent(this.settings.button_text),
			"&amp;buttonTextTopPadding=", encodeURIComponent(this.settings.button_text_top_padding),
			"&amp;buttonTextLeftPadding=", encodeURIComponent(this.settings.button_text_left_padding),
			"&amp;buttonTextStyle=", encodeURIComponent(this.settings.button_text_style),
			"&amp;buttonAction=", encodeURIComponent(this.settings.button_action),
			"&amp;buttonDisabled=", encodeURIComponent(this.settings.button_disabled),
			"&amp;buttonCursor=", encodeURIComponent(this.settings.button_cursor)
		].join("");
	};

	// Public: get retrieves the DOM reference to the Flash element added by SWFUpload
	// The element is cached after the first lookup
	SWFUpload.prototype.getMovieElement = function () {
		if (this.movieElement == undefined) {
			this.movieElement = document.getElementById(this.movieName);
		}

		if (this.movieElement === null) {
			throw "Could not find Flash element";
		}

		return this.movieElement;
	};

	// Private: buildParamString takes the name/value pairs in the post_params setting object
	// and joins them up in to a string formatted "name=value&amp;name=value"
	SWFUpload.prototype.buildParamString = function () {
		var name, postParams, paramStringPairs = [];

		postParams = this.settings.post_params;

		if (typeof(postParams) === "object") {
			for (name in postParams) {
				if (postParams.hasOwnProperty(name)) {
					paramStringPairs.push(encodeURIComponent(name.toString()) + "=" + encodeURIComponent(postParams[name].toString()));
				}
			}
		}

		return paramStringPairs.join("&amp;");
	};

	// Public: Used to remove a SWFUpload instance from the page. This method strives to remove
	// all references to the SWF, and other objects so memory is properly freed.
	// Returns true if everything was destroyed. Returns a false if a failure occurs leaving SWFUpload in an inconsistant state.
	// Credits: Major improvements provided by steffen
	SWFUpload.prototype.destroy = function () {
		var movieElement;

		try {
			// Make sure Flash is done before we try to remove it
			this.cancelUpload(null, false);

			movieElement = this.cleanUp();

			// Remove the SWFUpload DOM nodes
			if (movieElement) {
				// Remove the Movie Element from the page
				try {
					movieElement.parentNode.removeChild(movieElement);
				} catch (ex) {}
			}

			// Remove IE form fix reference
			window[this.movieName] = null;

			// Destroy other references
			SWFUpload.instances[this.movieName] = null;
			delete SWFUpload.instances[this.movieName];

			this.movieElement = null;
			this.settings = null;
			this.customSettings = null;
			this.eventQueue = null;
			this.movieName = null;


			return true;
		} catch (ex2) {
			return false;
		}
	};


	// Public: displayDebugInfo prints out settings and configuration
	// information about this SWFUpload instance.
	// This function (and any references to it) can be deleted when placing
	// SWFUpload in production.
	SWFUpload.prototype.displayDebugInfo = function () {
		this.debug(
			[
				"---SWFUpload Instance Info---\n",
				"Version: ", SWFUpload.version, "\n",
				"Movie Name: ", this.movieName, "\n",
				"Settings:\n",
				"\t", "upload_url:               ", this.settings.upload_url, "\n",
				"\t", "flash_url:                ", this.settings.flash_url, "\n",
				"\t", "flash9_url:                ", this.settings.flash9_url, "\n",
				"\t", "use_query_string:         ", this.settings.use_query_string.toString(), "\n",
				"\t", "requeue_on_error:         ", this.settings.requeue_on_error.toString(), "\n",
				"\t", "http_success:             ", this.settings.http_success.join(", "), "\n",
				"\t", "assume_success_timeout:   ", this.settings.assume_success_timeout, "\n",
				"\t", "file_post_name:           ", this.settings.file_post_name, "\n",
				"\t", "post_params:              ", this.settings.post_params.toString(), "\n",
				"\t", "file_types:               ", this.settings.file_types, "\n",
				"\t", "file_types_description:   ", this.settings.file_types_description, "\n",
				"\t", "file_size_limit:          ", this.settings.file_size_limit, "\n",
				"\t", "file_upload_limit:        ", this.settings.file_upload_limit, "\n",
				"\t", "file_queue_limit:         ", this.settings.file_queue_limit, "\n",
				"\t", "debug:                    ", this.settings.debug.toString(), "\n",

				"\t", "prevent_swf_caching:      ", this.settings.prevent_swf_caching.toString(), "\n",

				"\t", "button_placeholder_id:    ", this.settings.button_placeholder_id.toString(), "\n",
				"\t", "button_placeholder:       ", (this.settings.button_placeholder ? "Set" : "Not Set"), "\n",
				"\t", "button_image_url:         ", this.settings.button_image_url.toString(), "\n",
				"\t", "button_width:             ", this.settings.button_width.toString(), "\n",
				"\t", "button_height:            ", this.settings.button_height.toString(), "\n",
				"\t", "button_text:              ", this.settings.button_text.toString(), "\n",
				"\t", "button_text_style:        ", this.settings.button_text_style.toString(), "\n",
				"\t", "button_text_top_padding:  ", this.settings.button_text_top_padding.toString(), "\n",
				"\t", "button_text_left_padding: ", this.settings.button_text_left_padding.toString(), "\n",
				"\t", "button_action:            ", this.settings.button_action.toString(), "\n",
				"\t", "button_cursor:            ", this.settings.button_cursor.toString(), "\n",
				"\t", "button_disabled:          ", this.settings.button_disabled.toString(), "\n",

				"\t", "custom_settings:          ", this.settings.custom_settings.toString(), "\n",
				"Event Handlers:\n",
				"\t", "swfupload_preload_handler assigned:  ", (typeof this.settings.swfupload_preload_handler === "function").toString(), "\n",
				"\t", "swfupload_load_failed_handler assigned:  ", (typeof this.settings.swfupload_load_failed_handler === "function").toString(), "\n",
				"\t", "swfupload_loaded_handler assigned:  ", (typeof this.settings.swfupload_loaded_handler === "function").toString(), "\n",
				"\t", "mouse_click_handler assigned:       ", (typeof this.settings.mouse_click_handler === "function").toString(), "\n",
				"\t", "mouse_over_handler assigned:        ", (typeof this.settings.mouse_over_handler === "function").toString(), "\n",
				"\t", "mouse_out_handler assigned:         ", (typeof this.settings.mouse_out_handler === "function").toString(), "\n",
				"\t", "file_dialog_start_handler assigned: ", (typeof this.settings.file_dialog_start_handler === "function").toString(), "\n",
				"\t", "file_queued_handler assigned:       ", (typeof this.settings.file_queued_handler === "function").toString(), "\n",
				"\t", "file_queue_error_handler assigned:  ", (typeof this.settings.file_queue_error_handler === "function").toString(), "\n",
				"\t", "upload_resize_start_handler assigned:      ", (typeof this.settings.upload_resize_start_handler === "function").toString(), "\n",
				"\t", "upload_start_handler assigned:      ", (typeof this.settings.upload_start_handler === "function").toString(), "\n",
				"\t", "upload_progress_handler assigned:   ", (typeof this.settings.upload_progress_handler === "function").toString(), "\n",
				"\t", "upload_error_handler assigned:      ", (typeof this.settings.upload_error_handler === "function").toString(), "\n",
				"\t", "upload_success_handler assigned:    ", (typeof this.settings.upload_success_handler === "function").toString(), "\n",
				"\t", "upload_complete_handler assigned:   ", (typeof this.settings.upload_complete_handler === "function").toString(), "\n",
				"\t", "debug_handler assigned:             ", (typeof this.settings.debug_handler === "function").toString(), "\n",

				"Support:\n",
				"\t", "Load:                     ", (this.support.loading ? "Yes" : "No"), "\n",
				"\t", "Image Resize:             ", (this.support.imageResize ? "Yes" : "No"), "\n"

			].join("")
		);
	};

	/* Note: addSetting and getSetting are no longer used by SWFUpload but are included
	 the maintain v2 API compatibility
	 */
	// Public: (Deprecated) addSetting adds a setting value. If the value given is undefined or null then the default_value is used.
	SWFUpload.prototype.addSetting = function (name, value, default_value) {
		if (value == undefined) {
			return (this.settings[name] = default_value);
		} else {
			return (this.settings[name] = value);
		}
	};

	// Public: (Deprecated) getSetting gets a setting. Returns an empty string if the setting was not found.
	SWFUpload.prototype.getSetting = function (name) {
		if (this.settings[name] != undefined) {
			return this.settings[name];
		}

		return "";
	};



	// Private: callFlash handles function calls made to the Flash element.
	// Calls are made with a setTimeout for some functions to work around
	// bugs in the ExternalInterface library.
	SWFUpload.prototype.callFlash = function (functionName, argumentArray) {
		var movieElement, returnValue, returnString;

		argumentArray = argumentArray || [];
		movieElement = this.getMovieElement();

		// Flash's method if calling ExternalInterface methods (code adapted from MooTools).
		try {
			if (movieElement != undefined) {
				returnString = movieElement.CallFunction('<invoke name="' + functionName + '" returntype="javascript">' + __flash__argumentsToXML(argumentArray, 0) + '</invoke>');
				returnValue = eval(returnString);
			} else {
				this.debug("Can't call flash because the movie wasn't found.");
			}
		} catch (ex) {
			this.debug("Exception calling flash function '" + functionName + "': " + ex.message);
		}

		// Unescape file post param values
		if (returnValue != undefined && typeof returnValue.post === "object") {
			returnValue = this.unescapeFilePostParams(returnValue);
		}

		return returnValue;
	};

	/* *****************************
	 -- Flash control methods --
	 Your UI should use these
	 to operate SWFUpload
	 ***************************** */

	// WARNING: this function does not work in Flash Player 10
	// Public: selectFile causes a File Selection Dialog window to appear.  This
	// dialog only allows 1 file to be selected.
	SWFUpload.prototype.selectFile = function () {
		this.callFlash("SelectFile");
	};

	// WARNING: this function does not work in Flash Player 10
	// Public: selectFiles causes a File Selection Dialog window to appear/ This
	// dialog allows the user to select any number of files
	// Flash Bug Warning: Flash limits the number of selectable files based on the combined length of the file names.
	// If the selection name length is too long the dialog will fail in an unpredictable manner.  There is no work-around
	// for this bug.
	SWFUpload.prototype.selectFiles = function () {
		this.callFlash("SelectFiles");
	};


	// Public: startUpload starts uploading the first file in the queue unless
	// the optional parameter 'fileID' specifies the ID
	SWFUpload.prototype.startUpload = function (fileID) {
		//trace(this.settings.fileSelectAutoUpload);
		//trace(this.allowUpload);
		if(this.settings.fileSelectAutoUpload || this.settings.allowUpload == true) {
			this.callFlash("StartUpload", [fileID]);
		}
	};

	// Public: startUpload starts uploading the first file in the queue unless
	// the optional parameter 'fileID' specifies the ID
	SWFUpload.prototype.startResizedUpload = function (fileID, width, height, encoding, quality, allowEnlarging) {
		this.callFlash("StartUpload", [fileID, { "width": width, "height" : height, "encoding" : encoding, "quality" : quality, "allowEnlarging" : allowEnlarging }]);
	};

	// Public: cancelUpload cancels any queued file.  The fileID parameter may be the file ID or index.
	// If you do not specify a fileID the current uploading file or first file in the queue is cancelled.
	// If you do not want the uploadError event to trigger you can specify false for the triggerErrorEvent parameter.
	SWFUpload.prototype.cancelUpload = function (fileID, triggerErrorEvent) {
		if (triggerErrorEvent !== false) {
			triggerErrorEvent = true;
		}
		this.callFlash("CancelUpload", [fileID, triggerErrorEvent]);
	};

	// Public: stopUpload stops the current upload and requeues the file at the beginning of the queue.
	// If nothing is currently uploading then nothing happens.
	SWFUpload.prototype.stopUpload = function () {
		this.callFlash("StopUpload");
	};


	// Public: requeueUpload requeues any file. If the file is requeued or already queued true is returned.
	// If the file is not found or is currently uploading false is returned.  Requeuing a file bypasses the
	// file size, queue size, upload limit and other queue checks.  Certain files can't be requeued (e.g, invalid or zero bytes files).
	SWFUpload.prototype.requeueUpload = function (indexOrFileID) {
		return this.callFlash("RequeueUpload", [indexOrFileID]);
	};


	/* ************************
	 * Settings methods
	 *   These methods change the SWFUpload settings.
	 *   SWFUpload settings should not be changed directly on the settings object
	 *   since many of the settings need to be passed to Flash in order to take
	 *   effect.
	 * *********************** */

	// Public: getStats gets the file statistics object.
	SWFUpload.prototype.getStats = function () {
		return this.callFlash("GetStats");
	};

	// Public: setStats changes the SWFUpload statistics.  You shouldn't need to
	// change the statistics but you can.  Changing the statistics does not
	// affect SWFUpload accept for the successful_uploads count which is used
	// by the upload_limit setting to determine how many files the user may upload.
	SWFUpload.prototype.setStats = function (statsObject) {
		this.callFlash("SetStats", [statsObject]);
	};

	// Public: getFile retrieves a File object by ID or Index.  If the file is
	// not found then 'null' is returned.
	SWFUpload.prototype.getFile = function (fileID) {
		if (typeof(fileID) === "number") {
			return this.callFlash("GetFileByIndex", [fileID]);
		} else {
			return this.callFlash("GetFile", [fileID]);
		}
	};

	// Public: getFileFromQueue retrieves a File object by ID or Index.  If the file is
	// not found then 'null' is returned.
	SWFUpload.prototype.getQueueFile = function (fileID) {
		if (typeof(fileID) === "number") {
			return this.callFlash("GetFileByQueueIndex", [fileID]);
		} else {
			return this.callFlash("GetFile", [fileID]);
		}
	};


	// Public: addFileParam sets a name/value pair that will be posted with the
	// file specified by the Files ID.  If the name already exists then the
	// exiting value will be overwritten.
	SWFUpload.prototype.addFileParam = function (fileID, name, value) {
		return this.callFlash("AddFileParam", [fileID, name, value]);
	};

	// Public: removeFileParam removes a previously set (by addFileParam) name/value
	// pair from the specified file.
	SWFUpload.prototype.removeFileParam = function (fileID, name) {
		this.callFlash("RemoveFileParam", [fileID, name]);
	};

	// Public: setUploadUrl changes the upload_url setting.
	SWFUpload.prototype.setUploadURL = function (url) {
		this.settings.upload_url = url.toString();
		this.callFlash("SetUploadURL", [url]);
	};

	// Public: setPostParams changes the post_params setting
	SWFUpload.prototype.setPostParams = function (paramsObject) {
		this.settings.post_params = paramsObject;
		this.callFlash("SetPostParams", [paramsObject]);
	};

	// Public: addPostParam adds post name/value pair.  Each name can have only one value.
	SWFUpload.prototype.addPostParam = function (name, value) {
		this.settings.post_params[name] = value;
		this.callFlash("SetPostParams", [this.settings.post_params]);
	};

	// Public: removePostParam deletes post name/value pair.
	SWFUpload.prototype.removePostParam = function (name) {
		delete this.settings.post_params[name];
		this.callFlash("SetPostParams", [this.settings.post_params]);
	};

	// Public: setFileTypes changes the file_types setting and the file_types_description setting
	SWFUpload.prototype.setFileTypes = function (types, description) {
		this.settings.file_types = types;
		this.settings.file_types_description = description;
		this.callFlash("SetFileTypes", [types, description]);
	};

	// Public: setFileSizeLimit changes the file_size_limit setting
	SWFUpload.prototype.setFileSizeLimit = function (fileSizeLimit) {
		this.settings.file_size_limit = fileSizeLimit;
		this.callFlash("SetFileSizeLimit", [fileSizeLimit]);
	};

	// Public: setFileUploadLimit changes the file_upload_limit setting
	SWFUpload.prototype.setFileUploadLimit = function (fileUploadLimit) {
		this.settings.file_upload_limit = fileUploadLimit;
		this.callFlash("SetFileUploadLimit", [fileUploadLimit]);
	};

	// Public: setFileQueueLimit changes the file_queue_limit setting
	SWFUpload.prototype.setFileQueueLimit = function (fileQueueLimit) {
		this.settings.file_queue_limit = fileQueueLimit;
		this.callFlash("SetFileQueueLimit", [fileQueueLimit]);
	};

	// Public: setFilePostName changes the file_post_name setting
	SWFUpload.prototype.setFilePostName = function (filePostName) {
		this.settings.file_post_name = filePostName;
		this.callFlash("SetFilePostName", [filePostName]);
	};

	// Public: setUseQueryString changes the use_query_string setting
	SWFUpload.prototype.setUseQueryString = function (useQueryString) {
		this.settings.use_query_string = useQueryString;
		this.callFlash("SetUseQueryString", [useQueryString]);
	};

	// Public: setRequeueOnError changes the requeue_on_error setting
	SWFUpload.prototype.setRequeueOnError = function (requeueOnError) {
		this.settings.requeue_on_error = requeueOnError;
		this.callFlash("SetRequeueOnError", [requeueOnError]);
	};

	// Public: setHTTPSuccess changes the http_success setting
	SWFUpload.prototype.setHTTPSuccess = function (http_status_codes) {
		if (typeof http_status_codes === "string") {
			http_status_codes = http_status_codes.replace(" ", "").split(",");
		}

		this.settings.http_success = http_status_codes;
		this.callFlash("SetHTTPSuccess", [http_status_codes]);
	};

	// Public: setHTTPSuccess changes the http_success setting
	SWFUpload.prototype.setAssumeSuccessTimeout = function (timeout_seconds) {
		this.settings.assume_success_timeout = timeout_seconds;
		this.callFlash("SetAssumeSuccessTimeout", [timeout_seconds]);
	};

	// Public: setDebugEnabled changes the debug_enabled setting
	SWFUpload.prototype.setDebugEnabled = function (debugEnabled) {
		this.settings.debug_enabled = debugEnabled;
		this.callFlash("SetDebugEnabled", [debugEnabled]);
	};

	// Public: setButtonImageURL loads a button image sprite
	SWFUpload.prototype.setButtonImageURL = function (buttonImageURL) {
		if (buttonImageURL == undefined) {
			buttonImageURL = "";
		}

		this.settings.button_image_url = buttonImageURL;
		this.callFlash("SetButtonImageURL", [buttonImageURL]);
	};

	// Public: setButtonDimensions resizes the Flash Movie and button
	SWFUpload.prototype.setButtonDimensions = function (width, height) {
		this.settings.button_width = width;
		this.settings.button_height = height;

		var movie = this.getMovieElement();
		if (movie != undefined) {
			movie.style.width = width + "px";
			movie.style.height = height + "px";
		}

		this.callFlash("SetButtonDimensions", [width, height]);
	};
	// Public: setButtonText Changes the text overlaid on the button
	SWFUpload.prototype.setButtonText = function (html) {
		this.settings.button_text = html;
		this.callFlash("SetButtonText", [html]);
	};
	// Public: setButtonTextPadding changes the top and left padding of the text overlay
	SWFUpload.prototype.setButtonTextPadding = function (left, top) {
		this.settings.button_text_top_padding = top;
		this.settings.button_text_left_padding = left;
		this.callFlash("SetButtonTextPadding", [left, top]);
	};

	// Public: setButtonTextStyle changes the CSS used to style the HTML/Text overlaid on the button
	SWFUpload.prototype.setButtonTextStyle = function (css) {
		this.settings.button_text_style = css;
		this.callFlash("SetButtonTextStyle", [css]);
	};
	// Public: setButtonDisabled disables/enables the button
	SWFUpload.prototype.setButtonDisabled = function (isDisabled) {
		this.settings.button_disabled = isDisabled;
		this.callFlash("SetButtonDisabled", [isDisabled]);
	};
	// Public: setButtonAction sets the action that occurs when the button is clicked
	SWFUpload.prototype.setButtonAction = function (buttonAction) {
		this.settings.button_action = buttonAction;
		this.callFlash("SetButtonAction", [buttonAction]);
	};

	// Public: setButtonCursor changes the mouse cursor displayed when hovering over the button
	SWFUpload.prototype.setButtonCursor = function (cursor) {
		this.settings.button_cursor = cursor;
		this.callFlash("SetButtonCursor", [cursor]);
	};

	/* *******************************
	 Flash Event Interfaces
	 These functions are used by Flash to trigger the various
	 events.

	 All these functions a Private.

	 Because the ExternalInterface library is buggy the event calls
	 are added to a queue and the queue then executed by a setTimeout.
	 This ensures that events are executed in a determinate order and that
	 the ExternalInterface bugs are avoided.
	 ******************************* */

	SWFUpload.prototype.queueEvent = function (handlerName, argumentArray) {
		// Warning: Don't call this.debug inside here or you'll create an infinite loop
		var self = this;

		if (argumentArray == undefined) {
			argumentArray = [];
		} else if (!(argumentArray instanceof Array)) {
			argumentArray = [argumentArray];
		}

		if (typeof this.settings[handlerName] === "function") {
			// Queue the event
			this.eventQueue.push(function () {
				this.settings[handlerName].apply(this, argumentArray);
			});

			// Execute the next queued event
			setTimeout(function () {
				self.executeNextEvent();
			}, 0);

		} else if (this.settings[handlerName] !== null) {
			throw "Event handler " + handlerName + " is unknown or is not a function";
		}
	};

	// Private: Causes the next event in the queue to be executed.  Since events are queued using a setTimeout
	// we must queue them in order to garentee that they are executed in order.
	SWFUpload.prototype.executeNextEvent = function () {
		// Warning: Don't call this.debug inside here or you'll create an infinite loop

		var  f = this.eventQueue ? this.eventQueue.shift() : null;
		if (typeof(f) === "function") {
			f.apply(this);
		}

	};

	// Private: unescapeFileParams is part of a workaround for a flash bug where objects passed through ExternalInterface cannot have
	// properties that contain characters that are not valid for JavaScript identifiers. To work around this
	// the Flash Component escapes the parameter names and we must unescape again before passing them along.
	SWFUpload.prototype.unescapeFilePostParams = function (file) {
		var reg = /[$]([0-9a-f]{4})/i, unescapedPost = {}, uk, k, match;

		if (file != undefined) {
			for (k in file.post) {
				if (file.post.hasOwnProperty(k)) {
					uk = k;
					while ((match = reg.exec(uk)) !== null) {
						uk = uk.replace(match[0], String.fromCharCode(parseInt("0x" + match[1], 16)));
					}
					unescapedPost[uk] = file.post[k];
				}
			}

			file.post = unescapedPost;
		}

		return file;
	};

	// Private: This event is called by SWFUpload Init after we've determined what the user's Flash Player supports.
	// Use the swfupload_preload_handler event setting to execute custom code when SWFUpload has loaded.
	// Return false to prevent SWFUpload from loading and allow your script to do something else if your required feature is
	// not supported
	SWFUpload.prototype.swfuploadPreload = function () {
		var returnValue;
		if (typeof this.settings.swfupload_preload_handler === "function") {
			returnValue = this.settings.swfupload_preload_handler.call(this);
		} else if (this.settings.swfupload_preload_handler != undefined) {
			throw "upload_start_handler must be a function";
		}

		// Convert undefined to true so if nothing is returned from the upload_start_handler it is
		// interpretted as 'true'.
		if (returnValue === undefined) {
			returnValue = true;
		}

		return !!returnValue;
	}

	// Private: This event is called by Flash when it has finished loading. Don't modify this.
	// Use the swfupload_loaded_handler event setting to execute custom code when SWFUpload has loaded.
	SWFUpload.prototype.flashReady = function () {
		// Check that the movie element is loaded correctly with its ExternalInterface methods defined
		var movieElement = 	this.cleanUp();

		if (!movieElement) {
			this.debug("Flash called back ready but the flash movie can't be found.");
			return;
		}

		this.queueEvent("swfupload_loaded_handler");
	};

	// Private: removes Flash added fuctions to the DOM node to prevent memory leaks in IE.
	// This function is called by Flash each time the ExternalInterface functions are created.
	SWFUpload.prototype.cleanUp = function () {
		var key, movieElement = this.getMovieElement();

		// Pro-actively unhook all the Flash functions
		try {
			if (movieElement && typeof(movieElement.CallFunction) === "unknown") { // We only want to do this in IE
				this.debug("Removing Flash functions hooks (this should only run in IE and should prevent memory leaks)");
				for (key in movieElement) {
					try {
						if (typeof(movieElement[key]) === "function") {
							movieElement[key] = null;
						}
					} catch (ex) {
					}
				}
			}
		} catch (ex1) {

		}

		// Fix Flashes own cleanup code so if the SWF Movie was removed from the page
		// it doesn't display errors.
		window["__flash__removeCallback"] = function (instance, name) {
			try {
				if (instance) {
					instance[name] = null;
				}
			} catch (flashEx) {

			}
		};

		return movieElement;
	};

	/* When the button_action is set to None this event gets fired and executes the mouse_click_handler */
	SWFUpload.prototype.mouseClick = function () {
		this.queueEvent("mouse_click_handler");
	};
	SWFUpload.prototype.mouseOver = function () {
		this.queueEvent("mouse_over_handler");
	};
	SWFUpload.prototype.mouseOut = function () {
		this.queueEvent("mouse_out_handler");
	};

	/* This is a chance to do something before the browse window opens */
	SWFUpload.prototype.fileDialogStart = function () {
		this.queueEvent("file_dialog_start_handler");
	};


	/* Called when a file is successfully added to the queue. */
	SWFUpload.prototype.fileQueued = function (file) {
		file = this.unescapeFilePostParams(file);
		this.queueEvent("file_queued_handler", file);
	};


	/* Handle errors that occur when an attempt to queue a file fails. */
	SWFUpload.prototype.fileQueueError = function (file, errorCode, message) {
		file = this.unescapeFilePostParams(file);
		this.queueEvent("file_queue_error_handler", [file, errorCode, message]);
	};

	/* Called after the file dialog has closed and the selected files have been queued.
	 You could call startUpload here if you want the queued files to begin uploading immediately. */
	SWFUpload.prototype.fileDialogComplete = function (numFilesSelected, numFilesQueued, numFilesInQueue) {
		this.queueEvent("file_dialog_complete_handler", [numFilesSelected, numFilesQueued, numFilesInQueue]);
	};

	SWFUpload.prototype.uploadResizeStart = function (file, resizeSettings) {
		file = this.unescapeFilePostParams(file);
		this.queueEvent("upload_resize_start_handler", [file, resizeSettings.width, resizeSettings.height, resizeSettings.encoding, resizeSettings.quality]);
	};

	SWFUpload.prototype.uploadStart = function (file) {
		file = this.unescapeFilePostParams(file);
		this.queueEvent("return_upload_start_handler", file);
	};

	SWFUpload.prototype.returnUploadStart = function (file) {
		var returnValue;
		if (typeof this.settings.upload_start_handler === "function") {
			file = this.unescapeFilePostParams(file);
			returnValue = this.settings.upload_start_handler.call(this, file);
		} else if (this.settings.upload_start_handler != undefined) {
			throw "upload_start_handler must be a function";
		}

		// Convert undefined to true so if nothing is returned from the upload_start_handler it is
		// interpretted as 'true'.
		if (returnValue === undefined) {
			returnValue = true;
		}

		returnValue = !!returnValue;

		this.callFlash("ReturnUploadStart", [returnValue]);
	};



	SWFUpload.prototype.uploadProgress = function (file, bytesComplete, bytesTotal) {
		file = this.unescapeFilePostParams(file);
		this.queueEvent("upload_progress_handler", [file, bytesComplete, bytesTotal]);
	};

	SWFUpload.prototype.uploadError = function (file, errorCode, message) {
		file = this.unescapeFilePostParams(file);
		this.queueEvent("upload_error_handler", [file, errorCode, message]);
	};

	SWFUpload.prototype.uploadSuccess = function (file, serverData, responseReceived) {
		file = this.unescapeFilePostParams(file);
		this.queueEvent("upload_success_handler", [file, serverData, responseReceived]);
	};

	SWFUpload.prototype.uploadComplete = function (file) {
		file = this.unescapeFilePostParams(file);
		this.queueEvent("upload_complete_handler", file);
	};

	/* Called by SWFUpload JavaScript and Flash functions when debug is enabled. By default it writes messages to the
	 internal debug console.  You can override this event and have messages written where you want. */
	SWFUpload.prototype.debug = function (message) {
		this.queueEvent("debug_handler", message);
	};


	/* **********************************
	 Debug Console
	 The debug console is a self contained, in page location
	 for debug message to be sent.  The Debug Console adds
	 itself to the body if necessary.

	 The console is automatically scrolled as messages appear.

	 If you are using your own debug handler or when you deploy to production and
	 have debug disabled you can remove these functions to reduce the file size
	 and complexity.
	 ********************************** */

	// Private: debugMessage is the default debug_handler.  If you want to print debug messages
	// call the debug() function.  When overriding the function your own function should
	// check to see if the debug setting is true before outputting debug information.
	SWFUpload.prototype.debugMessage = function (message) {
		var exceptionMessage, exceptionValues, key;

		if (this.settings.debug) {
			exceptionValues = [];

			// Check for an exception object and print it nicely
			if (typeof message === "object" && typeof message.name === "string" && typeof message.message === "string") {
				for (key in message) {
					if (message.hasOwnProperty(key)) {
						exceptionValues.push(key + ": " + message[key]);
					}
				}
				exceptionMessage = exceptionValues.join("\n") || "";
				exceptionValues = exceptionMessage.split("\n");
				exceptionMessage = "EXCEPTION: " + exceptionValues.join("\nEXCEPTION: ");
				SWFUpload.Console.writeLine(exceptionMessage);
			} else {
				SWFUpload.Console.writeLine(message);
			}
		}
	};

	SWFUpload.Console = {};
	SWFUpload.Console.writeLine = function (message) {
		var console, documentForm;

		try {
			console = document.getElementById("SWFUpload_Console");

			if (!console) {
				documentForm = document.createElement("form");
				document.getElementsByTagName("body")[0].appendChild(documentForm);

				console = document.createElement("textarea");
				console.id = "SWFUpload_Console";
				console.style.fontFamily = "monospace";
				console.setAttribute("wrap", "off");
				console.wrap = "off";
				console.style.overflow = "auto";
				console.style.width = "700px";
				console.style.height = "350px";
				console.style.margin = "5px";
				documentForm.appendChild(console);
			}

			console.value += message + "\n";

			console.scrollTop = console.scrollHeight - console.clientHeight;
		} catch (ex) {
			alert("Exception: " + ex.name + " Message: " + ex.message);
		}
	};


	/*	SWFObject v2.2 <http://code.google.com/p/swfobject/>
	 is released under the MIT License <http://www.opensource.org/licenses/mit-license.php>
	 */
	swfobject = function(){var D="undefined",r="object",S="Shockwave Flash",W="ShockwaveFlash.ShockwaveFlash",q="application/x-shockwave-flash",R="SWFObjectExprInst",x="onreadystatechange",O=window,j=document,t=navigator,T=false,U=[h],o=[],N=[],I=[],l,Q,E,B,J=false,a=false,n,G,m=true,M=function(){var aa=typeof j.getElementById!=D&&typeof j.getElementsByTagName!=D&&typeof j.createElement!=D,ah=t.userAgent.toLowerCase(),Y=t.platform.toLowerCase(),ae=Y?/win/.test(Y):/win/.test(ah),ac=Y?/mac/.test(Y):/mac/.test(ah),af=/webkit/.test(ah)?parseFloat(ah.replace(/^.*webkit\/(\d+(\.\d+)?).*$/,"$1")):false,X=!+"\v1",ag=[0,0,0],ab=null;if(typeof t.plugins!=D&&typeof t.plugins[S]==r){ab=t.plugins[S].description;if(ab&&!(typeof t.mimeTypes!=D&&t.mimeTypes[q]&&!t.mimeTypes[q].enabledPlugin)){T=true;X=false;ab=ab.replace(/^.*\s+(\S+\s+\S+$)/,"$1");ag[0]=parseInt(ab.replace(/^(.*)\..*$/,"$1"),10);ag[1]=parseInt(ab.replace(/^.*\.(.*)\s.*$/,"$1"),10);ag[2]=/[a-zA-Z]/.test(ab)?parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/,"$1"),10):0}}else{if(typeof O.ActiveXObject!=D){try{var ad=new ActiveXObject(W);if(ad){ab=ad.GetVariable("$version");if(ab){X=true;ab=ab.split(" ")[1].split(",");ag=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}}catch(Z){}}}return{w3:aa,pv:ag,wk:af,ie:X,win:ae,mac:ac}}(),k=function(){if(!M.w3){return}if((typeof j.readyState!=D&&j.readyState=="complete")||(typeof j.readyState==D&&(j.getElementsByTagName("body")[0]||j.body))){f()}if(!J){if(typeof j.addEventListener!=D){j.addEventListener("DOMContentLoaded",f,false)}if(M.ie&&M.win){j.attachEvent(x,function(){if(j.readyState=="complete"){j.detachEvent(x,arguments.callee);f()}});if(O==top){(function(){if(J){return}try{j.documentElement.doScroll("left")}catch(X){setTimeout(arguments.callee,0);return}f()})()}}if(M.wk){(function(){if(J){return}if(!/loaded|complete/.test(j.readyState)){setTimeout(arguments.callee,0);return}f()})()}s(f)}}();function f(){if(J){return}try{var Z=j.getElementsByTagName("body")[0].appendChild(C("span"));Z.parentNode.removeChild(Z)}catch(aa){return}J=true;var X=U.length;for(var Y=0;Y<X;Y++){U[Y]()}}function K(X){if(J){X()}else{U[U.length]=X}}function s(Y){if(typeof O.addEventListener!=D){O.addEventListener("load",Y,false)}else{if(typeof j.addEventListener!=D){j.addEventListener("load",Y,false)}else{if(typeof O.attachEvent!=D){i(O,"onload",Y)}else{if(typeof O.onload=="function"){var X=O.onload;O.onload=function(){X();Y()}}else{O.onload=Y}}}}}function h(){if(T){V()}else{H()}}function V(){var X=j.getElementsByTagName("body")[0];var aa=C(r);aa.setAttribute("type",q);var Z=X.appendChild(aa);if(Z){var Y=0;(function(){if(typeof Z.GetVariable!=D){var ab=Z.GetVariable("$version");if(ab){ab=ab.split(" ")[1].split(",");M.pv=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}else{if(Y<10){Y++;setTimeout(arguments.callee,10);return}}X.removeChild(aa);Z=null;H()})()}else{H()}}function H(){var ag=o.length;if(ag>0){for(var af=0;af<ag;af++){var Y=o[af].id;var ab=o[af].callbackFn;var aa={success:false,id:Y};if(M.pv[0]>0){var ae=c(Y);if(ae){if(F(o[af].swfVersion)&&!(M.wk&&M.wk<312)){w(Y,true);if(ab){aa.success=true;aa.ref=z(Y);ab(aa)}}else{if(o[af].expressInstall&&A()){var ai={};ai.data=o[af].expressInstall;ai.width=ae.getAttribute("width")||"0";ai.height=ae.getAttribute("height")||"0";if(ae.getAttribute("class")){ai.styleclass=ae.getAttribute("class")}if(ae.getAttribute("align")){ai.align=ae.getAttribute("align")}var ah={};var X=ae.getElementsByTagName("param");var ac=X.length;for(var ad=0;ad<ac;ad++){if(X[ad].getAttribute("name").toLowerCase()!="movie"){ah[X[ad].getAttribute("name")]=X[ad].getAttribute("value")}}P(ai,ah,Y,ab)}else{p(ae);if(ab){ab(aa)}}}}}else{w(Y,true);if(ab){var Z=z(Y);if(Z&&typeof Z.SetVariable!=D){aa.success=true;aa.ref=Z}ab(aa)}}}}}function z(aa){var X=null;var Y=c(aa);if(Y&&Y.nodeName=="OBJECT"){if(typeof Y.SetVariable!=D){X=Y}else{var Z=Y.getElementsByTagName(r)[0];if(Z){X=Z}}}return X}function A(){return !a&&F("6.0.65")&&(M.win||M.mac)&&!(M.wk&&M.wk<312)}function P(aa,ab,X,Z){a=true;E=Z||null;B={success:false,id:X};var ae=c(X);if(ae){if(ae.nodeName=="OBJECT"){l=g(ae);Q=null}else{l=ae;Q=X}aa.id=R;if(typeof aa.width==D||(!/%$/.test(aa.width)&&parseInt(aa.width,10)<310)){aa.width="310"}if(typeof aa.height==D||(!/%$/.test(aa.height)&&parseInt(aa.height,10)<137)){aa.height="137"}j.title=j.title.slice(0,47)+" - Flash Player Installation";var ad=M.ie&&M.win?"ActiveX":"PlugIn",ac="MMredirectURL="+O.location.toString().replace(/&/g,"%26")+"&MMplayerType="+ad+"&MMdoctitle="+j.title;if(typeof ab.flashvars!=D){ab.flashvars+="&"+ac}else{ab.flashvars=ac}if(M.ie&&M.win&&ae.readyState!=4){var Y=C("div");X+="SWFObjectNew";Y.setAttribute("id",X);ae.parentNode.insertBefore(Y,ae);ae.style.display="none";(function(){if(ae.readyState==4){ae.parentNode.removeChild(ae)}else{setTimeout(arguments.callee,10)}})()}u(aa,ab,X)}}function p(Y){if(M.ie&&M.win&&Y.readyState!=4){var X=C("div");Y.parentNode.insertBefore(X,Y);X.parentNode.replaceChild(g(Y),X);Y.style.display="none";(function(){if(Y.readyState==4){Y.parentNode.removeChild(Y)}else{setTimeout(arguments.callee,10)}})()}else{Y.parentNode.replaceChild(g(Y),Y)}}function g(ab){var aa=C("div");if(M.win&&M.ie){aa.innerHTML=ab.innerHTML}else{var Y=ab.getElementsByTagName(r)[0];if(Y){var ad=Y.childNodes;if(ad){var X=ad.length;for(var Z=0;Z<X;Z++){if(!(ad[Z].nodeType==1&&ad[Z].nodeName=="PARAM")&&!(ad[Z].nodeType==8)){aa.appendChild(ad[Z].cloneNode(true))}}}}}return aa}function u(ai,ag,Y){var X,aa=c(Y);if(M.wk&&M.wk<312){return X}if(aa){if(typeof ai.id==D){ai.id=Y}if(M.ie&&M.win){var ah="";for(var ae in ai){if(ai[ae]!=Object.prototype[ae]){if(ae.toLowerCase()=="data"){ag.movie=ai[ae]}else{if(ae.toLowerCase()=="styleclass"){ah+=' class="'+ai[ae]+'"'}else{if(ae.toLowerCase()!="classid"){ah+=" "+ae+'="'+ai[ae]+'"'}}}}}var af="";for(var ad in ag){if(ag[ad]!=Object.prototype[ad]){af+='<param name="'+ad+'" value="'+ag[ad]+'" />'}}aa.outerHTML='<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"'+ah+">"+af+"</object>";N[N.length]=ai.id;X=c(ai.id)}else{var Z=C(r);Z.setAttribute("type",q);for(var ac in ai){if(ai[ac]!=Object.prototype[ac]){if(ac.toLowerCase()=="styleclass"){Z.setAttribute("class",ai[ac])}else{if(ac.toLowerCase()!="classid"){Z.setAttribute(ac,ai[ac])}}}}for(var ab in ag){if(ag[ab]!=Object.prototype[ab]&&ab.toLowerCase()!="movie"){e(Z,ab,ag[ab])}}aa.parentNode.replaceChild(Z,aa);X=Z}}return X}function e(Z,X,Y){var aa=C("param");aa.setAttribute("name",X);aa.setAttribute("value",Y);Z.appendChild(aa)}function y(Y){var X=c(Y);if(X&&X.nodeName=="OBJECT"){if(M.ie&&M.win){X.style.display="none";(function(){if(X.readyState==4){b(Y)}else{setTimeout(arguments.callee,10)}})()}else{X.parentNode.removeChild(X)}}}function b(Z){var Y=c(Z);if(Y){for(var X in Y){if(typeof Y[X]=="function"){Y[X]=null}}Y.parentNode.removeChild(Y)}}function c(Z){var X=null;try{X=j.getElementById(Z)}catch(Y){}return X}function C(X){return j.createElement(X)}function i(Z,X,Y){Z.attachEvent(X,Y);I[I.length]=[Z,X,Y]}function F(Z){var Y=M.pv,X=Z.split(".");X[0]=parseInt(X[0],10);X[1]=parseInt(X[1],10)||0;X[2]=parseInt(X[2],10)||0;return(Y[0]>X[0]||(Y[0]==X[0]&&Y[1]>X[1])||(Y[0]==X[0]&&Y[1]==X[1]&&Y[2]>=X[2]))?true:false}function v(ac,Y,ad,ab){if(M.ie&&M.mac){return}var aa=j.getElementsByTagName("head")[0];if(!aa){return}var X=(ad&&typeof ad=="string")?ad:"screen";if(ab){n=null;G=null}if(!n||G!=X){var Z=C("style");Z.setAttribute("type","text/css");Z.setAttribute("media",X);n=aa.appendChild(Z);if(M.ie&&M.win&&typeof j.styleSheets!=D&&j.styleSheets.length>0){n=j.styleSheets[j.styleSheets.length-1]}G=X}if(M.ie&&M.win){if(n&&typeof n.addRule==r){n.addRule(ac,Y)}}else{if(n&&typeof j.createTextNode!=D){n.appendChild(j.createTextNode(ac+" {"+Y+"}"))}}}function w(Z,X){if(!m){return}var Y=X?"visible":"hidden";if(J&&c(Z)){c(Z).style.visibility=Y}else{v("#"+Z,"visibility:"+Y)}}function L(Y){var Z=/[\\\"<>\.;]/;var X=Z.exec(Y)!=null;return X&&typeof encodeURIComponent!=D?encodeURIComponent(Y):Y}var d=function(){if(M.ie&&M.win){window.attachEvent("onunload",function(){var ac=I.length;for(var ab=0;ab<ac;ab++){I[ab][0].detachEvent(I[ab][1],I[ab][2])}var Z=N.length;for(var aa=0;aa<Z;aa++){y(N[aa])}for(var Y in M){M[Y]=null}M=null;for(var X in swfobject){swfobject[X]=null}swfobject=null})}}();return{registerObject:function(ab,X,aa,Z){if(M.w3&&ab&&X){var Y={};Y.id=ab;Y.swfVersion=X;Y.expressInstall=aa;Y.callbackFn=Z;o[o.length]=Y;w(ab,false)}else{if(Z){Z({success:false,id:ab})}}},getObjectById:function(X){if(M.w3){return z(X)}},embedSWF:function(ab,ah,ae,ag,Y,aa,Z,ad,af,ac){var X={success:false,id:ah};if(M.w3&&!(M.wk&&M.wk<312)&&ab&&ah&&ae&&ag&&Y){w(ah,false);K(function(){ae+="";ag+="";var aj={};if(af&&typeof af===r){for(var al in af){aj[al]=af[al]}}aj.data=ab;aj.width=ae;aj.height=ag;var am={};if(ad&&typeof ad===r){for(var ak in ad){am[ak]=ad[ak]}}if(Z&&typeof Z===r){for(var ai in Z){if(typeof am.flashvars!=D){am.flashvars+="&"+ai+"="+Z[ai]}else{am.flashvars=ai+"="+Z[ai]}}}if(F(Y)){var an=u(aj,am,ah);if(aj.id==ah){w(ah,true)}X.success=true;X.ref=an}else{if(aa&&A()){aj.data=aa;P(aj,am,ah,ac);return}else{w(ah,true)}}if(ac){ac(X)}})}else{if(ac){ac(X)}}},switchOffAutoHideShow:function(){m=false},ua:M,getFlashPlayerVersion:function(){return{major:M.pv[0],minor:M.pv[1],release:M.pv[2]}},hasFlashPlayerVersion:F,createSWF:function(Z,Y,X){if(M.w3){return u(Z,Y,X)}else{return undefined}},showExpressInstall:function(Z,aa,X,Y){if(M.w3&&A()){P(Z,aa,X,Y)}},removeSWF:function(X){if(M.w3){y(X)}},createCSS:function(aa,Z,Y,X){if(M.w3){v(aa,Z,Y,X)}},addDomLoadEvent:K,addLoadEvent:s,getQueryParamValue:function(aa){var Z=j.location.search||j.location.hash;if(Z){if(/\?/.test(Z)){Z=Z.split("?")[1]}if(aa==null){return L(Z)}var Y=Z.split("&");for(var X=0;X<Y.length;X++){if(Y[X].substring(0,Y[X].indexOf("="))==aa){return L(Y[X].substring((Y[X].indexOf("=")+1)))}}}return""},expressInstallCallback:function(){if(a){var X=c(R);if(X&&l){X.parentNode.replaceChild(l,X);if(Q){w(Q,true);if(M.ie&&M.win){l.style.display="block"}}if(E){E(B)}}a=false}}}}();
	swfobject.addDomLoadEvent(function () {
		if (typeof(SWFUpload.onload) === "function") {
			SWFUpload.onload.call(window);
		}
	});
})();

// ---------------------------------------------------------------------------------------- swfobject end

/**
 * AXUpload5
 * @class AXUpload5
 * @extends AXJ
 * @version v1.4.4
 * @author tom@axisj.com
 * @logs
 "2013-10-02 오후 2:19:36 - 시작 tom",
 "2013-10-12 오전 11:13:06 - 업로드 서버오류 예외 처리 tom",
 "2013-10-29 오후 3:26:33 - 최지연 : 기타 버그 패치",
 "2013-10-30 오후 3:38:05 - config.uploadPars, config.deletePars 초기 설정값 패치 by tom",
 "2013-12-11 오후 5:15:51 - tom&root setUploadedList, setUpoadeFile 버그패치",
 "2013-12-17 오전 11:24:38 - tom : AXUploadPreview css 적용",
 "2014-02-11 오후 3:29:51 - tom : deleteFile 개선, 서버 JSON에 error 가 없으면 정상 처리 되도록 변경",
 "2014-02-23 오후 7:39:11 - tom : this.uploadedList 초기화 버그 픽스",
 "2014-02-23 오후 8:44:07 - <base> attr 인식 처리 구문 추가",
 "2014-04-10 - tom : 설정에 선언된 파일타입 체크하여 파일 셀렉트와 드랍 방지 처리 구문 추가",
 "2014-04-10 - tom : fileSelectAutoUpload 옵션 flash 모드에서 작동 하도록 픽스",
 "2014-05-15 - tom : 파일선택 갯수 선택오류 버그 픽스 / fileSelectAutoUpload 버그 픽스",
 "2014-05-23 - tom : file mimeType 이 없는 경우 업로드 지원 구문 추가"
 "2014-06-04 tom : in single upload, reupload bugfix"
 "2014-06-14 tom : extend config option flash_file_types, flash_file_types_description"
 "2014-06-17 tom : [bugfix] file_types undefined"
 "2014-06-26 tom : [bugfix] http error exception when delete runs "
 "2014-12-22 tom : [bugfix] manual 업로드 갯수제한 버그 픽스 "
 "2015-01-04 tom : thumbUrl 값이 없을 때 썸네일 배경 예외 처리 "
 "2015-01-05 tom : queuebox class 가 listType일 때 progressbar 위치 조정"
 "2015-01-09 tom : onFileDrop uploadedCount 증가구문 수정 https://github.com/axisj-com/axisj/issues/385"
 "2015-01-16 tom : setUploadedList bug fix"
 "2015-02-06 John : getItemTag : openMode (view 모드 추가) list 모드 css 적용"
 "2015-02-07 tom : single 모드에서 fileDisplayHide: true 속성 추가"
 "2015-03-28 tom : https://github.com/axisj-com/axisj/issues/501 삭제후 리스트가 비었을 때 onDeleteAll 호출"
 "2015-04-01 tom : fileKeys 에 id 값 정의 기능 추가"
 "2015-04-06 tom : fileKeys 기본 맵핑방식 수정"
 "2015-05-14 HJ.Park : SWFUpload 모드에서 파일 사이즈 초과시 onError 메서드 호출하도록 수정 https://github.com/axisj-com/axisj/issues/559"
 "2015-05-21 tom : singleUpload setUploadedList 버그픽스 https://github.com/axisj-com/axisj/issues/580"
 "2015-08-02 tom : 업로드 버튼 태그 수정 / 업로드 완료시에 엘리먼트 초기화 기능 보류"
 "2015-08-03 tom : setUploadedList queue box clear"
 "2015-08-07 tom : 내부 키 id > _id_ 로 교체"
 "2015-11-24 tom : queueBoxAppendType:"prepend" 버그 픽스
 * @description
 *
 ```js
 var myUpload = new AXUpload5();
 myUpload.setConfig(classConfig:JSObject);
 ```
 *
 */

/**
 * @method initialize.setConig
 * @param {Object} config - gridConfig
 * @description
 * 선언된 클래스를 사용하기 위해 속성을 정의합니다.
 * @example
 ```js
 var myUpload = new AXUPload5();
 myUpload.setConfig({
	targetID:"AXUpload5",               //{String} - 업로드 버튼 엘리먼트 아이디
	openMode: "view",                   //{String} - 업로드된 파일 삭제 아이콘 숨김
	buttonTxt:"파일올리기",              //[String] - 업로드 버튼 문구. 사용자가 지정하지 않으면 AXConfig 에서 정의한 값을 사용합니다.
	targetButtonClass:"Green",          //[String] - 업로드 버튼에 추가될 CSS 클래스
	uploadFileName:"files[]",           //{String} - 서버에 전송될 파일 파라미터 키이름
	file_types:"*.*",                   //{String} - upload 할 파일타입( *.* | audio/* | video/* | image/* | MIME_type (accept) )
	dropBoxID:"uploadQueueBox",         //{String} - 드래그 드랍 타겟 엘리먼트 아이디
	queueBoxID:"uploadQueueBox",        //{String} - 업로드된 파일 목록을 보여주는 업로드 큐박스 엘리먼트 아이디
	flash_url : "../../_AXJ/lib/swfupload.swf",         //[String] - html 5를 지원하지 않는 브라우저를 위한 swf upload 설정 원치 않는 경우엔 선언 하지 않아도 됩니다.
	flash9_url : "../../_AXJ/lib/swfupload_fp9.swf",    //[String] - html 5를 지원하지 않는 브라우저를 위한 swf upload 설정 원치 않는 경우엔 선언 하지 않아도 됩니다.
	onClickUploadedItem: function(){    //[fn] 업로드된 목록을 클릭했을 때 이벤트 콜백함수
		window.open(this.uploadedPath.dec() + this.saveName.dec(), "_blank", "width=500,height=500");
	},
	uploadMaxFileSize:(10*1024*1024),   //{Number} - 업로드 될 개별 파일 사이즈(클라이언트에서 제한하는 사이즈이며, 서버에서 설정되는 값이 아닙니다.)
	uploadMaxFileCount:3,               //{Number} - 업로드될 파일갯수 제한 0 은 무제한
	uploadUrl:"uploadFile.asp",         //{String} - 서버전송 URL
	uploadPars:{userID:"tom", userName:"액시스"},  //[JSObject] - 서버전송 URL 파라미터
	deleteUrl:"deleteFile.asp",         //{String} - 서버전송 URL
	deletePars:{userID:"tom", userName:"액시스"},  //[JSObject] - 서버전송 URL 파라미터
	fileKeys:{                          //[JSObject] - 서버에서 리턴하는 json key 정의 (id는 예약어 사용할 수 없음)
		id:"id",
		name:"name",
		type:"type",
		saveName:"saveName",
		fileSize:"fileSize",
		uploadedPath:"uploadedPath",
		thumbPath:"thumbUrl"            // 서버에서 키값을 다르게 설정 할 수 있다는 것을 확인 하기 위해 이름을 다르게 처리한 예제 입니다.
	},
	onbeforeFileSelect: function(){     //[fn] - 드랍되거나 파일이 선택되기 전에 이벤트 return true; 리턴하지 않으면 진행을 중지 합니다.
		trace(this);
		return true;
	},
	onUpload: function(){               //[fn] - 업로드가 완료되는 이벤트 콜백함수
		trace(this);
		//trace("onUpload");
	},
	onComplete: function(){             //[fn] - 업로드가 모두 완료되는 이벤트 콜백함수
		//trace(this);
		//trace("onComplete");
		$("#uploadCancelBtn").get(0).disabled = true; // 전송중지 버튼 제어
	},
	onStart: function(){                //[fn] - 업로드가 시작되는 이벤트 콜백함수
		//trace(this);
		//trace("onStart");
		$("#uploadCancelBtn").get(0).disabled = false; // 전송중지 버튼 제어
	},
	onDelete: function(){               //[fn] - 파일 삭제 완료되는 이벤트 콜백함수
		//trace(this);
		//trace("onDelete");
	},
	onError: function(errorType, extData){  //[fn] - 에러가 발생되었을 때 이벤트 콜백함수 [errorType, extData] 인자 사용
		if(errorType == "html5Support"){
			//dialog.push("The File APIs are not fully supported in this browser.");
		}else if(errorType == "fileSize"){
			trace(extData);
			alert("파일사이즈가 초과된 파일을 업로드 할 수 없습니다. 업로드 목록에서 제외 합니다.("+extData.name+" : "+extData.size.byte()+")");
		}else if(errorType == "fileCount"){
			alert("업로드 갯수 초과 초과된 아이템은 업로드 되지 않습니다.");
		}
	}
});

 ```
 */

var AXUpload5 = Class.create(AXJ, {
	initialize: function(AXJ_super){
		AXJ_super();
		this.uploadedList = [];
		this.uploadingObj = null;
		this.queue = [];
		this.queueLive = false;
		this.isSingleUpload = false;
		this.config.uploadFileName = "fileData";
		this.config.file_types = "*.*";
		this.config.fileSelectAutoUpload = true;
		this.supportHtml5 = false;
		if (window.File && window.FileReader && window.FileList && window.Blob) this.supportHtml5 = true;
		if(!AXConfig.AXUpload5){
			AXConfig.AXUpload5 = {buttonTxt:"Upload files"};
		}
		this.config.buttonTxt = AXConfig.AXUpload5.buttonTxt;
		this.fileKeys = { // 서버에서 리턴하는 json key 정의 (id 는 예약어 입니다.)
			_id_:"_id_",
			name:"name",
			type:"type",
			saveName:"saveName",
			fileSize:"fileSize",
			uploadedPath:"uploadedPath",
			thumbPath:"thumbPath"
		};
		this.config.flash_url = "/_AXJ/lib/swfupload.swf";
		this.config.flash9_url = "/_AXJ/lib/swfupload_fp9.swf";
		this.config.uploadPars = {};
		this.config.deletePars = {};
		this.config.queueBoxAppendType = "append";
	},
	init: function(reset){
		var cfg = this.config;
		// 파일키 덮어쓰기 빠진 키 초기값으로 정의
		for(k in this.fileKeys){
			if(typeof this.config.fileKeys === "undefined" || typeof this.config.fileKeys[k] === "undefined") this.config.fileKeys[k] = this.fileKeys[k];
		}
		if(reset == undefined){
			if(!this.supportHtml5){
				if(cfg.onError) cfg.onError("html5Support");
				this.swfinit(reset);
				return;
			}
		}else{
			if(!this.supportHtml5){
				return;
			}
		}
		
		var baseUrl = axdom("base").attr("href");
		if(axf.isEmpty(baseUrl)) baseUrl = "";
		if(cfg.uploadUrl.left(1) == "/"){
			cfg.uploadUrl = baseUrl + cfg.uploadUrl;
		}
		if(cfg.deleteUrl.left(1) == "/"){
			cfg.deleteUrl = baseUrl + cfg.deleteUrl;
		}
		/* dropBoxID, queueBoxID 자동 생성 */
		if( cfg.dropBoxTarget ){
			if(cfg.dropBoxTarget.id === undefined || cfg.dropBoxTarget.id == ""){
				axdom(cfg.dropBoxTarget).attr("id", cfg.dropBoxTarget.id = cfg.dropBoxID = "AXJUnique_dropBox_"+axf.getUniqueId());
			}else if(axf.isEmpty(cfg.dropBoxID)){
				cfg.dropBoxID = cfg.dropBoxTarget.id;
			}
		}
		if( cfg.queueBoxTarget ){
			if( cfg.queueBoxTarget.id === undefined || cfg.queueBoxTarget.id == "" ){
				axdom(cfg.queueBoxTarget).attr("id", cfg.queueBoxTarget.id = cfg.queueBoxID = "AXJUnique_queueBox_"+axf.getUniqueId());
				alert(cfg.queueBoxID);
			}else if(axf.isEmpty(cfg.queueBoxID)){
				cfg.queueBoxID = cfg.queueBoxTarget.id;
			}
		}
		
		this.target = axdom("#"+cfg.targetID);
		if(reset == undefined){
			this.target.empty();
			this.uploadedList = [];
		}
		
		var inputFileMultiple = 'multiple="multiple"';
		var inputFileAccept = cfg.file_types;
		if(cfg.isSingleUpload){
			inputFileMultiple = '';
		}
		if(!this.supportHtml5){
			inputFileMultiple = '';
		}
		
		var po = [];
		/*
		 po.push('<div style="position:relative;">');
		 po.push('	<table style=""><tbody><tr><td id="'+cfg.targetID+'_AX_selectorTD">');
		 po.push('	<input type="file" id="'+cfg.targetID+'_AX_files" '+inputFileMultiple+' accept="'+inputFileAccept+'" style="position:absolute;left:0px;top:0px;margin:0px;padding:0px;-moz-opacity: 0.0;opacity:.00;filter: alpha(opacity=0);" />');
		 po.push('	<button type="button" class="AXButton '+cfg.targetButtonClass+'" id="'+cfg.targetID+'_AX_selector"><span class="AXFileSelector">'+(cfg.buttonTxt)+'</span></button>');
		 po.push('	</td>');

		 if(cfg.isSingleUpload && cfg.fileDisplayHide != true){
		 po.push('<td>');
		 po.push('<div class="AXFileDisplay" id="'+cfg.targetID+'_AX_display">'+AXConfig.AXUpload5.uploadSelectTxt+'</div>');
		 po.push('</td>');
		 }

		 po.push('	</tr></tbody></table>');
		 */

		po.push('<div style="position:relative;">');

		po.push('   <div style="float:left;">');
		po.push('	    <input type="file" id="'+cfg.targetID+'_AX_files" '+inputFileMultiple+' accept="'+inputFileAccept+'" style="position:absolute;left:0px;top:0px;margin:0px;padding:0px;-moz-opacity: 0.0;opacity:.00;filter: alpha(opacity=0);" />');
		po.push('	    <button type="button" class="AXButton '+cfg.targetButtonClass+'" id="'+cfg.targetID+'_AX_selector"><span class="AXFileSelector">'+(cfg.buttonTxt)+'</span></button>');
		po.push('   </div>');

		if(cfg.isSingleUpload && cfg.fileDisplayHide != true){
			po.push('   <div style="float:left;">');
			po.push('       <div class="AXFileDisplay" style="padding:3px; 5px;" id="'+cfg.targetID+'_AX_display">'+AXConfig.AXUpload5.uploadSelectTxt+'</div>');
			po.push('   </div>');
		}
		po.push('   <div style="clear:both;"></div>');

		po.push('</div>');
		this.target.empty();
		this.target.append(po.join(''));
		
		axdom('#'+cfg.targetID+'_AX_selectorTD').css({width:axdom('#'+cfg.targetID+'_AX_selector').outerWidth()+5});
		axdom('#'+cfg.targetID+'_AX_files').css({width:axdom('#'+cfg.targetID+'_AX_selector').outerWidth(),height:axdom('#'+cfg.targetID+'_AX_selector').outerHeight()});
		
		var pauseQueue = this.pauseQueue.bind(this);
		var _this = this;

		axdom('#'+cfg.targetID+'_AX_selector').click(function(event){

			if(cfg.onbeforeFileSelect){
				if(!cfg.onbeforeFileSelect.call({
						uploadedList:_this.uploadedList,
						uploadMaxFileSize:cfg.uploadMaxFileSize,
						uploadMaxFileCount:cfg.uploadMaxFileCount
					})){
					return false;
				}
			}
			
			if(!cfg.isSingleUpload && cfg.uploadMaxFileCount != 0){
				if(_this.uploadedList.length >= cfg.uploadMaxFileCount){
					cfg.onError("fileCount");
					return false;
				}
			}
			
			pauseQueue();
			axdom('#'+cfg.targetID+'_AX_files').click();
		});
		
		var onFileSelect = this.onFileSelect.bind(this);
		var fileSelector = document.getElementById(cfg.targetID+'_AX_files');
		if(axf.browser.name == "ie" && axf.browser.version < 9){
			
		}else{
			fileSelector.addEventListener('change', onFileSelect, false);
		}

		if(reset == undefined){
			if(cfg.dropBoxID && this.supportHtml5){
				
				// 드랍존 표현구문 ----------------- s
				/*
				 var dropZoneMsg = [];
				 dropZoneMsg.push("<span class=\"msgText\" id=\""+cfg.dropBoxID+"_msgText\">");
				 dropZoneMsg.push(AXConfig.AXUpload5.dropZoneTxt);
				 dropZoneMsg.push("</span>");
				 axdom("#"+cfg.dropBoxID).append(dropZoneMsg.join(''));
				 */
				axdom("#"+cfg.dropBoxID).addClass("allowDrop");
				//axdom("#"+cfg.dropBoxID).find(".msgText").css({"top":axdom("#"+cfg.dropBoxID).height()/2-50});
				// 드랍존 표현구문 ----------------- e
				
				var dropZoneBox = [];
				dropZoneBox.push("<div class=\"dropZoneBox\" id=\""+cfg.dropBoxID+"_dropZoneBox\" style=\"border:3px dashed #d7d7d7;display:none;\">");
				dropZoneBox.push("</div>");
				axdom("#"+cfg.dropBoxID).append(dropZoneBox.join(''));
				
				// ---------------- 옵션사항 s
				/*
				 axdom("#"+cfg.dropBoxID+"_dropZoneBox").show();
				 axdom("#"+cfg.dropBoxID+"_dropZoneBox").css({height:axdom("#"+cfg.dropBoxID).innerHeight()-6, width:axdom("#"+cfg.dropBoxID).innerWidth()-6});
				 setTimeout(function(){
				 axdom("#"+cfg.dropBoxID+"_dropZoneBox").fadeOut();
				 }, 2000);
				 */
				// ---------------- 옵션사항 e
				
				var onFileDragOver = this.onFileDragOver.bind(this);
				var onFileDrop = this.onFileDrop.bind(this);
				var dragZone = document.getElementById(cfg.dropBoxID);
				dragZone.addEventListener('dragover', function(evt){onFileDragOver(evt)}, false);
				
				var dropZone = document.getElementById(cfg.dropBoxID+"_dropZoneBox");
				dropZone.addEventListener('drop', function(evt){
					
					if(cfg.onbeforeFileSelect){
						if(!cfg.onbeforeFileSelect.call({
								uploadedList:_this.uploadedList,
								uploadMaxFileSize:cfg.uploadMaxFileSize,
								uploadMaxFileCount:cfg.uploadMaxFileCount
							})){
							evt.stopPropagation();
							evt.preventDefault();
							axdom("#"+cfg.dropBoxID).removeClass("onDrop");
							axdom("#"+cfg.dropBoxID+"_dropZoneBox").hide();
							return false;
						}
					}
					
					if(!cfg.isSingleUpload && cfg.uploadMaxFileCount != 0){
						if(_this.uploadedList.length >= cfg.uploadMaxFileCount){
							evt.stopPropagation();
							evt.preventDefault();
							axdom("#"+cfg.dropBoxID).removeClass("onDrop");
							axdom("#"+cfg.dropBoxID+"_dropZoneBox").hide();
							cfg.onError("fileCount");
							return false;
						}
					}

					onFileDrop(evt)
				}, false);
			}
			
			if(cfg.queueBoxID){
				this.multiSelector = new AXMultiSelect();
				this.multiSelector.setConfig({
					selectStage       : cfg.queueBoxID,
					selectClassName   : "readyselect",
					beselectClassName : "beSelected",
					selectingClassName: "AX_selecting"
				});
			}
		}
	},
	swfinit: function(reset){
		var cfg = this.config;
		this.target = axdom("#"+cfg.targetID);

		var po = [];
		po.push('<div style="position:relative;">');
		po.push('	<table style="table-layout:fixed;width:100%;"><tbody><tr><td id="'+cfg.targetID+'_AX_selectorTD">');
		po.push('	<button type="button" class="AXButton '+cfg.targetButtonClass+'" id="'+cfg.targetID+'_AX_selector"><span class="AXFileSelector">'+(cfg.buttonTxt)+'</span></button>');
		po.push('	<span id="spanButtonPlaceholder" class="AXUpload5flashUploadButton"></span>');
		po.push('	</td>');
		
		if(cfg.isSingleUpload){
			po.push('<td>');
			po.push('<div class="AXFileDisplay" id="'+cfg.targetID+'_AX_display">'+AXConfig.AXUpload5.uploadSelectTxt+'</div>');
			po.push('</td>');
		}
		
		po.push('	<tr></tbody></table>');
		po.push('</div>');
		this.target.empty();
		this.target.append(po.join(''));
		
		axdom('#'+cfg.targetID+'_AX_selectorTD').css({width:axdom('#'+cfg.targetID+'_AX_selector').outerWidth()+5});
		
		var btnW = axdom('#'+cfg.targetID+'_AX_selector').outerWidth();
		var btnH = axdom('#'+cfg.targetID+'_AX_selector').outerHeight();
		
		// functions --------------------------------------------------------------- s
		var uploadSuccess = this.uploadSuccess.bind(this);
		var onClickDeleteButton = this.onClickDeleteButton.bind(this);
		var onClickFileTitle = this.onClickFileTitle.bind(this);
		
		var file_dialog_complete_handler = function(numFilesSelected, numFilesQueued){
			if (numFilesSelected > 0) {
				if (this.swfu.getStats().files_queued > 0) {
					//if(this.settings.onStartUpload) this.settings.onStartUpload();
					if(cfg.onStart) cfg.onStart.call(this.queue);
				}
			}
			this.swfu.startUpload();
		};
		var file_dialog_complete_handler_bind = file_dialog_complete_handler.bind(this);
		//--
		var file_queued_handler = function(file){
			if(cfg.isSingleUpload){
				var myFile = this.uploadedList.first();
				if(myFile){
					if(!confirm(AXConfig.AXUpload5.deleteConfirm)){
						this.cancelUpload();
					};
					var uploadFn = function(){
						var itemID = 'AX_'+ file[cfg.fileKeys._id_];
						this.queue.push({_id_:itemID, file:file});
						axdom("#" + cfg.targetID+'_AX_display').empty();
						axdom("#" + cfg.targetID+'_AX_display').append(this.getItemTag(itemID, file));
					};
					this.deleteFile(myFile, uploadFn.bind(this));
					return;
				}else{
					var itemID = 'AX_'+ file[cfg.fileKeys._id_];
					this.queue.push({_id_:itemID, file:file});
					axdom("#" + cfg.targetID+'_AX_display').empty();
					axdom("#" + cfg.targetID+'_AX_display').append(this.getItemTag(itemID, file));
				}
			}else{
				//cfg.uploadMaxFileCount
				if(cfg.uploadMaxFileCount != 0){
					if(this.uploadedList.length >= cfg.uploadMaxFileCount){
						cfg.onError("fileCount");
						this.cancelUpload();
						return;
					}
				}
				
				//trace(file);
				//{"filestatus":-1, "name":"20130708175735_1.jpg", "type":".jpg", "id":"SWFUpload_0_0", "index":0, "modificationdate":"2013-10-04T08:51:27Z", "uploadtype":0, "post":{}, "size":891324, "creationdate":"2013-10-04T08:52:02Z"} 
				var itemID = 'AX_'+ file[cfg.fileKeys._id_];
				this.queue.push({_id_:itemID, file:file});
				//큐박스에 아이템 추가
				if(cfg.queueBoxAppendType == "prepend") axdom("#" + cfg.queueBoxID).prepend(this.getItemTag(itemID, file));
				else axdom("#" + cfg.queueBoxID).append(this.getItemTag(itemID, file));
				axdom("#" + cfg.queueBoxID).find("#"+itemID).fadeIn();
			}
		};
		var file_queued_handler_bind = file_queued_handler.bind(this);
		//--
		var file_queue_error_handler = function(file, errorCode, message){
			try {
				if (errorCode === SWFUpload.QUEUE_ERROR.QUEUE_LIMIT_EXCEEDED) {
					alert("You have attempted to queue too many files.\n" + (message === 0 ? "You have reached the upload limit." : "You may select " + (message > 1 ? "up to " + message + " files." : "one file.")));
					return;
				}
				this.cancelUpload();
				if(cfg.onComplete) cfg.onComplete.call(this.uploadedList, this.uploadedList);

				switch (errorCode) {
					case SWFUpload.QUEUE_ERROR.FILE_EXCEEDS_SIZE_LIMIT:
						this.showMSG("File is too big.");
						this.swfu.debug("Error Code: File too big, File name: " + file.name + ", File size: " + file.size + ", Message: " + message);
						break;
					case SWFUpload.QUEUE_ERROR.ZERO_BYTE_FILE:
						this.showMSG("Cannot upload Zero Byte files.");
						this.swfu.debug("Error Code: Zero byte file, File name: " + file.name + ", File size: " + file.size + ", Message: " + message);
						break;
					case SWFUpload.QUEUE_ERROR.INVALID_FILETYPE:
						this.showMSG("Invalid File Type.");
						this.swfu.debug("Error Code: Invalid File Type, File name: " + file.name + ", File size: " + file.size + ", Message: " + message);
						break;
					default:
						if (file !== null) {
							this.showMSG("Unhandled Error");
						}
						this.swfu.debug("Error Code: " + errorCode + ", File name: " + file.name + ", File size: " + file.size + ", Message: " + message);
						break;
				}
			} catch (ex) {
				this.debug(ex);
			}
		};
		var file_queue_error_handler_bind = file_queue_error_handler.bind(this);
		//--
		var upload_start_handler = function(){
			if(this.isSingleUpload){

			}else{
				if(cfg.uploadMaxFileCount != 0){
					if(cfg.uploadMaxFileCount <= this.uploadedList.length){
						this.cancelUpload();
					}
				}
			}
		};
		var upload_start_handler_bind = upload_start_handler.bind(this);
		//--
		var upload_progress_handler = function(file, bytesLoaded, bytesTotal){
			var itemID = 'AX_'+ file[cfg.fileKeys._id_];
			if(cfg.isSingleUpload){
				axdom("#"+itemID).find(".AXUploadProcessBar").width( ((bytesLoaded / bytesTotal) * 100).round(2)+"%" );
			}else{
				axdom("#" + cfg.queueBoxID).find("#"+itemID+" .AXUploadProcessBar").width( ((bytesLoaded / bytesTotal) * 100).round(2)+"%" );
			}
		};
		var upload_progress_handler_bind = upload_progress_handler.bind(this);
		//--
		var upload_error_handler = function(file, errorCode, message){
			if(cfg.onError) {
				if (errorCode == SWFUpload.UPLOAD_ERROR.HTTP_ERROR && message == 413) {
					errorCode = "fileSize";
				}

				cfg.onError(errorCode, file);
			}
		};
		var upload_error_handler_bind = upload_error_handler.bind(this);
		//--
		var upload_success_handler = function(file, res){
			var itemID = 'AX_'+ file[cfg.fileKeys._id_];
			
			try{if(typeof res == "string") res = res.object();}catch(e){trace(e);}
			if(cfg.isSingleUpload){
				
				axdom("#"+itemID+" .AXUploadBtns").show();
				axdom("#"+itemID+" .AXUploadLabel").show();
				axdom("#"+itemID+" .AXUploadTit").show();
				
				axdom("#"+itemID+" .AXUploadProcess").hide();

				uploadSuccess(file, itemID, res);
				// --------------------- s
				axdom("#"+itemID+" .AXUploadBtnsA").bind("click", function(){
					onClickDeleteButton(itemID);
				});
				if(cfg.onClickUploadedItem){
					axdom("#"+itemID+" .AXUploadDownload").bind("click", function(){
						onClickFileTitle(itemID);
					});
				}
				
			}else{
				
				axdom("#" + cfg.queueBoxID).find("#"+itemID+" .AXUploadBtns").show();
				axdom("#" + cfg.queueBoxID).find("#"+itemID+" .AXUploadLabel").show();
				axdom("#" + cfg.queueBoxID).find("#"+itemID+" .AXUploadProcess").hide();
				
				if(res[cfg.fileKeys.thumbPath]){
					axdom("#" + cfg.queueBoxID).find("#"+itemID+" .AXUploadIcon").css({
						"background-image":"url('"+(res[cfg.fileKeys.thumbPath]||"").dec()+"')"
					}).addClass("AXUploadPreview").find("img.preview").remove();
				}else{
					axdom("#" + cfg.queueBoxID).find("#"+itemID+" .AXUploadIcon").css({"background-image":"url()"});
					axdom("#" + cfg.queueBoxID).find("#"+itemID+" .AXUploadIcon").html((res[cfg.fileKeys.type]||"").dec().replace(".", ""));
				}
				
				uploadSuccess(file, itemID, res);
				// --------------------- s
				axdom("#" + cfg.queueBoxID).find("#"+itemID+" .AXUploadBtnsA").bind("click", function(){
					onClickDeleteButton(itemID);
				});
				if(cfg.onClickUploadedItem){
					axdom("#" + cfg.queueBoxID).find("#"+itemID+" .AXUploadDownload").bind("click", function(){
						onClickFileTitle(itemID);
					});
				}
			}
			
			//큐에서 제거
			var updateQueue = [];
			axdom.each(this.queue, function(){
				if(this.id != itemID) updateQueue.push(this);
			});
			this.queue = updateQueue;
		};
		var upload_success_handler_bind = upload_success_handler.bind(this);
		//--
		var upload_complete_handler = function(){
			if(this.isSingleUpload){
				this.uploadComplete();
			}else{
				if (this.swfu.getStats().files_queued === 0) {
					this.uploadComplete();
					this.swfu.settings.allowUpload = false;
				}else{
					this.swfu.startUpload();
				}
			}
		};
		var upload_complete_handler_bind = upload_complete_handler.bind(this);
		//--
		var queue_complete_handler = function(){
			//alert("end");
		};
		var queue_complete_handler_bind = queue_complete_handler.bind(this);
		// functions --------------------------------------------------------------- e

		var settings = {
			flash_url : cfg.flash_url,
			flash9_url : cfg.flash9_url,
			upload_url: cfg.uploadUrl,
			file_post_name: cfg.uploadFileName,
			post_params: cfg.uploadPars,
			file_size_limit : cfg.uploadMaxFileSize,
			fileSelectAutoUpload: cfg.fileSelectAutoUpload,
			file_types : cfg.flash_file_types||"*.*",
			file_types_description : cfg.flash_file_types_description||"all",
			file_upload_limit : 0, //cfg.uploadMaxFileCount,
			file_queue_limit : 0,
			debug: false,

			// Button Settings
			button_image_url : "null",
			button_placeholder_id : "spanButtonPlaceholder",
			button_width: btnW,
			button_height: btnH,

			// The event handler functions are defined in handlers.js
			swfupload_preload_handler : function(){},
			swfupload_load_failed_handler : function(){},
			swfupload_loaded_handler : function(){},
			file_queued_handler : file_queued_handler_bind,
			file_queue_error_handler : file_queue_error_handler_bind,
			file_dialog_complete_handler : file_dialog_complete_handler_bind,
			upload_start_handler : upload_start_handler_bind,
			upload_progress_handler : upload_progress_handler_bind,
			upload_error_handler : upload_error_handler_bind,
			upload_success_handler : upload_success_handler_bind,
			upload_complete_handler : upload_complete_handler_bind,
			queue_complete_handler : queue_complete_handler_bind	// Queue plugin event
		};
		this.swfu = new SWFUpload(settings);
		
		if(cfg.queueBoxID){
			this.multiSelector = new AXMultiSelect();
			this.multiSelector.setConfig({
				selectStage       : cfg.queueBoxID,
				selectClassName   : "readyselect",
				beselectClassName : "beSelected"
			});
		}
	},
	getItemTag: function(itemID, f){
		var cfg = this.config;
		var po = [];

		if(cfg.isSingleUpload){
			po.push('<div class="AXUploadItem ' + (cfg.openMode || "") +'" id="'+itemID+'">');
			po.push('	<div class="AXUploadBtns" style="display:none;">');
			po.push('		<a href="#AXExecption" class="AXUploadBtnsA" id="'+itemID+'_AXUploadBtns_deleteFile">del</a>');
			po.push('	</div>');
			po.push('	<div class="AXUploadLabel ' + (cfg.openMode || "") +'" style="display:none;">');
			if(cfg.openMode != "view") po.push('		<a href="#AXExecption" id="'+itemID+'_AXUploadLabel_download" class="AXUploadDownload">download</a>');
			po.push('	</div>');
			po.push('	<div class="AXUploadProcess">');
			po.push('		<div class="AXUploadProcessBar"></div>');
			po.push('	</div>');
			po.push('	<div class="AXUploadTit" title="'+f.name.dec()+'" style="display:none;">'+f.name.dec()+'</div>');
			po.push('</div>');
		}else{
			po.push('<div class="AXUploadItem ' + cfg.openMode +'" id="'+itemID+'" style=\"display:none;\">');
			po.push('	<div class="AXUploadIcon">');
			po.push('		<img id="' + itemID + '_preview" class="preview" src="" />');
			po.push('	</div>');
			po.push('	<div class="AXUploadType"><span class="AXUploadSize">'+f.size.number().byte()+'</span></div>');
			//view 모드인경우 파일명을 클릭하면 다운로드 이벤트를 발생시킨다
			if(cfg.openMode == "view") {
				po.push('    <a href="#AXExecption" id="' + itemID + '_AXUploadLabel_download" class="AXUploadDownload">');
				po.push('    <div class="AXUploadTit" title="' + f.name.dec() + '">' + f.name.dec());
				po.push('    </div>');
				po.push('    </a>');
			}
			else{
				po.push('	<div class="AXUploadTit" title="'+f.name.dec()+'">'+f.name.dec()+'</div>');
			}
			po.push('	<div class="AXUploadProcess">');
			po.push('		<div class="AXUploadProcessBar"></div>');
			po.push('	</div>');
			po.push('	<div class="AXUploadBtns" style="display:none;">');
			if(cfg.openMode != "view") po.push('		<a href="#AXExecption" class="AXUploadBtnsA" id="'+itemID+'_AXUploadBtns_deleteFile">del</a>');
			po.push('	</div>');
			po.push('	<div class="AXUploadLabel ' + cfg.openMode +'" style="display:none;">');
			
			if(cfg.formatter){
				var uf = {};
				//uf.id =  (f.id) ? f.id : itemID;
				uf.id =  itemID;
				uf.name = f.name;
				uf.type = f.type;
				uf.size = f.size;
				
				var returnStr = cfg.formatter.call(uf, uf);
				if (returnStr) po.push(returnStr);
			}
			po.push('		<a href="#AXExecption" id="'+itemID+'_AXUploadLabel_download" class="AXUploadDownload">download</a>');
			po.push('	</div>');
		}
		return po.join('');
	},
	onFileSelect: function(evt){
		var cfg = this.config, _this = this;
		if(this.supportHtml5){
			var files = evt.target.files; // FileList object
			if(cfg.isSingleUpload){
				
				var myFile = this.uploadedList.first();
				if(myFile){
					this.__tempFiles = files[0];
					if(!confirm(AXConfig.AXUpload5.deleteConfirm)) return;
					var uploadFn = function(){
						var itemID = 'AX'+AXUtil.timekey()+'_AX_0';
						this.queue.push({_id_:itemID, file:_this.__tempFiles});
						axdom("#" + cfg.targetID+'_AX_display').empty();
						axdom("#" + cfg.targetID+'_AX_display').append(_this.getItemTag(itemID, _this.__tempFiles));

						_this.queueLive = true;
						if(cfg.onStart) cfg.onStart.call(_this.queue, _this.queue);
						_this.uploadQueue();
						itemID = null;
						_this.__tempFiles = null;
					};
					this.deleteFile(myFile, uploadFn.bind(this));
					return;
				}else{
					var i = 0;
					var f = files[i];
					var itemID = 'AX'+AXUtil.timekey()+'_AX_'+i;
					this.queue.push({_id_:itemID, file:f});
					axdom("#" + cfg.targetID+'_AX_display').empty();
					axdom("#" + cfg.targetID+'_AX_display').append(this.getItemTag(itemID, f));
				}

			}
			else
			{
				var hasSizeOverFile = false;
				var sizeOverFile;
				if(!cfg.file_types) cfg.file_types = ".";
				if(cfg.file_types == "*.*") cfg.file_types = "*/*";

				for (var i = 0; i < files.length; i++) {
					var f = files[i];
					if(f.size > cfg.uploadMaxFileSize){
						hasSizeOverFile = true;
						sizeOverFile = f;
						break;
					}
				}
				if(hasSizeOverFile) cfg.onError("fileSize", {name:sizeOverFile.name, size:sizeOverFile.size});

				//todo : 업로드 갯수 제한 확인 1
				var uploadedCount = this.uploadedList.length;
				var queueCount = this.queue.length;
				//trace(uploadedCount, queueCount, (uploadedCount-1+queueCount));
				for (var i = 0; i < files.length; i++) {
					var f = files[i];
					if( f.size <= cfg.uploadMaxFileSize && ( (new RegExp(cfg.file_types.replace(/\*/g, "[a-z]"), "ig")).test(f.type.toString()) || (cfg.file_types == "*/*" && f.type == "") ) ){
						if((uploadedCount+queueCount) < cfg.uploadMaxFileCount || cfg.uploadMaxFileCount == 0){
							var itemID = 'AX'+AXUtil.timekey()+'_AX_'+i;
							this.queue.push({_id_:itemID, file:f});
							//큐박스에 아이템 추가

							if(cfg.queueBoxAppendType == "prepend") axdom("#" + cfg.queueBoxID).prepend(this.getItemTag(itemID, f));
							else axdom("#" + cfg.queueBoxID).append(this.getItemTag(itemID, f));

							this.setLocalPreview(itemID, f);

							axdom("#" + cfg.queueBoxID).find("#"+itemID).fadeIn();

							uploadedCount++;

							//trace(uploadedCount, this.queue.length);

						}else{
							cfg.onError("fileCount");
							break;
						}
					}
				};
			}
		}else{
			alert("not support HTML5");
		}
		this.queueLive = true;
		if(cfg.onStart) cfg.onStart.call(this.queue, this.queue);
		this.uploadQueue();
	},
	onFileDragOver: function(evt){
		var cfg = this.config;
		axdom("#"+cfg.dropBoxID).addClass("onDrop");
		axdom("#"+cfg.dropBoxID+"_dropZoneBox").show();
		/*axdom("#"+cfg.dropBoxID+"_dropZoneBox").css({height:axdom("#"+cfg.dropBoxID).innerHeight()-6, width:axdom("#"+cfg.dropBoxID).innerWidth()-6}); 라르게덴 2013-10-29 오후 3:21:45 */
		axdom("#"+cfg.dropBoxID+"_dropZoneBox").css({height:axdom("#"+cfg.dropBoxID).prop("scrollHeight")-6, width:axdom("#"+cfg.dropBoxID).innerWidth()-6});
		
		var dropZone = document.getElementById(cfg.dropBoxID+"_dropZoneBox");
		dropZone.addEventListener('dragleave', function(evt){
			axdom("#"+cfg.dropBoxID).removeClass("onDrop");
			axdom("#"+cfg.dropBoxID+"_dropZoneBox").hide();
		}, false);

		evt.stopPropagation();
		evt.preventDefault();
		evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
	},
	onFileDrop: function(evt){
		var cfg = this.config, quebox = axdom("#" + cfg.queueBoxID);
		evt.stopPropagation();
		evt.preventDefault();
		axdom("#"+cfg.dropBoxID).removeClass("onDrop");
		axdom("#"+cfg.dropBoxID+"_dropZoneBox").hide()
		
		var files = evt.dataTransfer.files; // FileList object.
		
		var hasSizeOverFile = false;
		var sizeOverFile;
		for (var i = 0, f; f = files[i]; i++) {
			if(f.size > cfg.uploadMaxFileSize){
				hasSizeOverFile = true;
				sizeOverFile = f;
				break;
			}
		}
		if(hasSizeOverFile) cfg.onError("fileSize", {name:sizeOverFile.name, size:sizeOverFile.size});
		if(!cfg.file_types) cfg.file_types = ".";
		if(cfg.file_types == "*.*") cfg.file_types = "*/*";
		var fileTypeRe = new RegExp(cfg.file_types.replace(/\*/g, "[a-z]"), "ig");
		// todo : 업로드 갯수 제한 확인
		var uploadedCount = this.uploadedList.length;
		var queueCount = this.queue.length;
		for (var i = 0, f; f = files[i]; i++) {
			if(f.size <= cfg.uploadMaxFileSize && ( (new RegExp(cfg.file_types.replace(/\*/g, "[a-z]"), "ig")).test(f.type.toString()) || (cfg.file_types == "*/*" && f.type == "") ) ){
				if((uploadedCount+queueCount) < cfg.uploadMaxFileCount || cfg.uploadMaxFileCount == 0){
					uploadedCount++;
					var itemID = 'AX'+AXUtil.timekey()+'_AX_'+i;
					this.queue.push({_id_:itemID, file:f});
					//큐박스에 아이템 추가
					if(cfg.queueBoxAppendType == "prepend") quebox.prepend(this.getItemTag(itemID, f));
					else quebox.append(this.getItemTag(itemID, f));

					this.setLocalPreview(itemID, f);

					quebox.find("#"+itemID).fadeIn();
				}else{
					cfg.onError("fileCount");
					break;
				}
			}
		};

		this.queueLive = true;
		if(cfg.onStart) cfg.onStart.call(this.queue);
		this.uploadQueue();
	},
	pauseQueue: function(){
		this.queueLive = false;
	},
	uploadQueue: function(fileUpload){
		var cfg = this.config;
		
		if(cfg.fileSelectAutoUpload == false && fileUpload == undefined){
			return;
		}

		if(cfg.fileSelectAutoUpload == false && fileUpload != undefined && this.swfu) {
			this.swfu.settings.allowUpload = true;
			this.swfu.startUpload();
		}

		if(!this.queueLive) return;
		if(this.queue.length == 0){
			//trace("uploadEnd");
			this.uploadComplete();
			return;
		}
		
		var uploadQueue = this.uploadQueue.bind(this);
		var cancelUpload = this.cancelUpload.bind(this);
		var uploadSuccess = this.uploadSuccess.bind(this);
		var onClickDeleteButton = this.onClickDeleteButton.bind(this);
		var onClickFileTitle = this.onClickFileTitle.bind(this);
		
		var obj = this.queue.shift();
		this.uploadingObj = obj;
		var formData = new FormData();
		//서버로 전송해야 할 추가 파라미터 정보 설정
		axdom.each(cfg.uploadPars, function(k, v){
			formData.append(k, v);
		});
		//formData.append(obj.file.name, obj.file);
		formData.append(cfg.uploadFileName, obj.file);
		
		//obj.id
		var itemID = obj._id_, quebox = axdom("#" + cfg.queueBoxID), itembox = axdom("#"+itemID);
		
		this.xhr = new XMLHttpRequest();
		this.xhr.open('POST', cfg.uploadUrl, true);
		this.xhr.onload = function(e) {
			var res = e.target.response;
			try { if (typeof res == "string") res = res.object(); } catch (e) {
				trace(e);
				cancelUpload();
				return;
			}

			if (res.result == "err" || res.error) {
				alert("파일전송에 실패 하였습니다. 서버에서 에러가 리턴되었습니다. 콘솔창을 확인 하세요.");
				trace(res);
				axdom("#" + itemID).fadeOut("slow");
				cancelUpload();
				return;
			}
			
			if(cfg.isSingleUpload)
			{

				itembox.find(".AXUploadBtns").show();
				itembox.find(".AXUploadLabel").show();
				itembox.find(".AXUploadTit").show();

				itembox.find(".AXUploadProcess").hide();

				uploadSuccess(obj.file, itemID, res);
				// --------------------- s
				itembox.find(".AXUploadBtnsA").bind("click", function(){
					onClickDeleteButton(itemID);
				});
				if(cfg.onClickUploadedItem){
					itembox.find(".AXUploadDownload").bind("click", function(){
						onClickFileTitle(itemID);
					});
				}
				
			}
			else
			{

				itembox.find(".AXUploadBtns").show();
				itembox.find(".AXUploadLabel").show();
				itembox.find(".AXUploadProcess").hide();
				
				var _res = (Object.isArray(res)) ? res[0] : res; /* Array 타입 예외처리 */

				if(_res[cfg.fileKeys.thumbPath]){
					itembox.find(".AXUploadIcon").css({
						"background-image":"url('"+(_res[cfg.fileKeys.thumbPath]||"").dec()+"')"
					}).addClass("AXUploadPreview").find("img.preview").remove();
				}else{
					itembox.find(".AXUploadIcon").css({"background-image":"url()"});
					itembox.find(".AXUploadIcon").html((_res[cfg.fileKeys.type]||"").dec().replace(".", ""));
				}
				
				uploadSuccess(obj.file, itemID, _res);
				
				// --------------------- s
				itembox.find(".AXUploadBtnsA").bind("click", function(){
					onClickDeleteButton(itemID);
				});
				if(cfg.onClickUploadedItem){
					itembox.find(".AXUploadDownload").bind("click", function(){
						onClickFileTitle(itemID);
					});
				}
			}

			// --------------------- e
			uploadQueue(fileUpload);
		};
		var setUploadingObj = function(){
			this.uploadingObj = null;
		};
		var setUploadingObjBind = setUploadingObj.bind(this);
		this.xhr.upload.onprogress = function(e) {
			if(cfg.isSingleUpload){
				if (e.lengthComputable) { itembox.find(".AXUploadProcessBar").width( ((e.loaded / e.total) * 100).round(2)+"%" ); }
			}else{
				if (e.lengthComputable) { itembox.find(".AXUploadProcessBar").width( ((e.loaded / e.total) * 100).round(2)+"%" ); }
			}
			if (e.lengthComputable) {
				if(	e.loaded > e.total*0.9 ){
					setUploadingObjBind();
				}
			}
		};
		this.xhr.send(formData);  // multipart/form-data
	},
	uploadSuccess: function(file, itemID, res){ // 업로드 아이템별 이벤트
		var cfg = this.config;
		var uploadedItem = {};
		uploadedItem[cfg.fileKeys._id_] = itemID;

		var _res = (Object.isArray(res)) ? res[0] : res; /* Array 타입 예외처리 */
		axdom.each(_res, function(k, v){
			uploadedItem[k] = v;
		});
		if(cfg.queueBoxAppendType == "prepend") {
			//this.uploadedList.push(uploadedItem);
			this.uploadedList.splice(0, 0, uploadedItem);
		}
		else{
			this.uploadedList.push(uploadedItem);
			/*
			 var uploadedList = [];
			 uploadedList.push(uploadedItem);
			 axdom.each(this.uploadedList, function(){
			 uploadedList.push(this);
			 });
			 */
			//this.uploadedList = this.uploadedList.concat(uploadedItem);
		}
		axdom("#"+itemID).addClass("readyselect");
		if(cfg.onUpload) cfg.onUpload.call(uploadedItem, uploadedItem);
	},
	clearQueue: function(){
		//큐제거
		axdom.each(this.queue, function(){
			axdom("#"+this.id).hide(function(){
				axdom(this).remove();
			});
		});
		this.queue = [];
	},
	uploadComplete: function(){
		var cfg = this.config;
		//trace("uploadComplete");
		if(AXgetId(cfg.targetID+'_AX_files')){ // 2015-08-02 업로드 완료 방식 변경 체크중
			/*
			 axdom('#'+cfg.targetID+'_AX_files').remove();

			 var inputFileMultiple = 'multiple="multiple"';
			 var inputFileAccept = cfg.file_types;
			 if(cfg.isSingleUpload){
			 inputFileMultiple = '';
			 }
			 if(!this.supportHtml5){
			 inputFileMultiple = '';
			 }

			 var  po = ['	<input type="file" id="'+cfg.targetID+'_AX_files" '+inputFileMultiple+' accept="'+inputFileAccept+'" style="position:absolute;left:0px;top:0px;margin:0px;padding:0px;-moz-opacity: 0.0;opacity:.00;filter: alpha(opacity=0);" />'];
			 axdom("#"+cfg.targetID+"_AX_selectorTD").prepend(po.join(''));
			 axdom('#'+cfg.targetID+'_AX_files').css({width:axdom('#'+cfg.targetID+'_AX_selector').outerWidth(),height:axdom('#'+cfg.targetID+'_AX_selector').outerHeight()});

			 var onFileSelect = this.onFileSelect.bind(this);

			 setTimeout(function(){
			 var fileSelector = document.getElementById(cfg.targetID+'_AX_files');
			 if(AXUtil.browser.name == "ie" && AXUtil.browser.version < 9){

			 }else{
			 fileSelector.addEventListener('change', onFileSelect, false);
			 }
			 }, 100);
			 */
		}
		if(cfg.queueBoxID){
			this.multiSelector.collect();
		}
		if(cfg.onComplete) cfg.onComplete.call(this.uploadedList, this.uploadedList);
	},
	cancelUpload: function(){
		var cfg = this.config;
		if(this.swfu){
			this.swfu.stopUpload();
			var stats = this.swfu.getStats();
			while (stats.files_queued > 0) {
				this.swfu.cancelUpload();
				stats = this.swfu.getStats();
			}
			stats = null;
			this.pauseQueue();
			this.clearQueue();
		}else{
			if(this.uploadingObj){
				this.xhr.abort();
				axdom("#"+this.uploadingObj.id).remove();
				this.uploadingObj = null;
			}
			this.pauseQueue();
			this.clearQueue();
		}
		if(cfg.onComplete) cfg.onComplete.call(this.uploadedList, this.uploadedList);
	},
	onClickDeleteButton: function(itemID){
		var cfg = this.config;
		if(cfg.isSingleUpload){
			var myFile;
			axdom.each(this.uploadedList, function(){
				if(this[cfg.fileKeys._id_] == itemID){
					myFile = this;
					return false;
				}
			});
			if(myFile){
				this.deleteFile(myFile);
			}
			myFile = null;
			//trace("a");
			this.init("reset");
		}else{
			var myFile;
			axdom.each(this.uploadedList, function(){
				if(this[cfg.fileKeys._id_] == itemID){
					myFile = this;
					return false;
				}
			});
			if(myFile){
				this.deleteFile(myFile);
				if(cfg.queueBoxID){
					this.multiSelector.clearSelects();
				}
			}
			myFile = null;
		}
		
	},
	onClickFileTitle: function(itemID){
		var cfg = this.config;
		//trace(itemID);
		if(cfg.onClickUploadedItem){
			var myFile;
			axdom.each(this.uploadedList, function(){
				if(this[cfg.fileKeys._id_] == itemID){
					myFile = this;
					return false;
				}
			});
			cfg.onClickUploadedItem.call(myFile, myFile);
		}
	},
	deleteFile: function(file, onEnd, withOutServer){
		var cfg = this.config;
		if(!onEnd) if(!confirm(AXConfig.AXUpload5.deleteConfirm)) return;
		var removeUploadedList = this.removeUploadedList.bind(this);
		
		//trace(file);
		//{"id":"AXA220125984_AX_0", "name":"38540011%2EJPG", "type":"%2EJPG", "saveName":"0DA0316011A0001%2EJPG", "fileSize":"3172720", "uploadedPath":"%2F%5Ffile%2F1%2F", "thumbPath":"%2F%5Ffile%2F1%2FT%5F0DA0316011A0001%2EJPG"}
		if (file != undefined){

			if(withOutServer == "withOutServer"){
				if(cfg.isSingleUpload){
					axdom('#'+cfg.targetID+'_AX_display').html(AXConfig.AXUpload5.uploadSelectTxt);
				}else{
					axdom("#"+file[cfg.fileKeys._id_]).hide(function(){
						axdom(this).remove();
					});
				}
				removeUploadedList(file[cfg.fileKeys._id_]);
				if(cfg.onDelete) cfg.onDelete.call({file:file, response:withOutServer}, file);
				if(onEnd) onEnd();
				return;
			}
			
			var pars = [];
			var sendPars = "";
			axdom.each(file, function(k, v){
				if(k != "downloadPath") pars.push( k + '=' + v );
			});
			
			if (typeof(cfg.deletePars) === "object") {
				axdom.each(cfg.deletePars, function(k, v){
					pars.push(k + '=' + v);
				});
				sendPars = pars.join("&");
			}else{
				sendPars = pars.join("&") + "&" + cfg.deletePars;
			}

			if(cfg.isSingleUpload){
				axdom("#"+file[cfg.fileKeys._id_]+" .AXUploadBtns").hide();
			}else{
				axdom("#" + cfg.queueBoxID).find("#"+file[cfg.fileKeys._id_]+" .AXUploadBtns").hide();
			}
			
			new AXReq(cfg.deleteUrl, {
				method:(cfg.deleteMethod||"POST"),
				debug:false,
				pars:sendPars,
				onsucc:function(res){
					if ((res.result && res.result == AXConfig.AXReq.okCode) || (res.result == undefined && !res.error)) {

						if(onEnd) setTimeout(onEnd, 1);
						if(cfg.isSingleUpload){
							axdom('#'+cfg.targetID+'_AX_display').html(AXConfig.AXUpload5.uploadSelectTxt);
						}else{
							axdom("#"+file[cfg.fileKeys._id_]).hide(function(){
								axdom(this).remove();
							});
						}
						if(cfg.onDelete) cfg.onDelete.call({file:file, response:res}, file);
						removeUploadedList(file[cfg.fileKeys._id_]);

					}else{
						if(cfg.isSingleUpload){
							axdom("#"+file[cfg.fileKeys._id_]+" .AXUploadBtns").show();
						}else{
							axdom("#" + cfg.queueBoxID).find("#"+file[cfg.fileKeys._id_]+" .AXUploadBtns").show();
						}
					}
				},
				onerr: function(){
					if(cfg.isSingleUpload){
						axdom("#"+file[cfg.fileKeys._id_]+" .AXUploadBtns").show();
					}else{
						axdom("#" + cfg.queueBoxID).find("#"+file[cfg.fileKeys._id_]+" .AXUploadBtns").show();
					}
				}
			});

		}else{
			trace("file undefined");
		}
	},
	deleteSelect: function(arg, withOutServer){
		var cfg = this.config;
		if(arg == "all"){
			var deleteQueue = [];
			axdom.each(this.uploadedList, function(){
				deleteQueue.push(this[cfg.fileKeys._id_]);
			});
			this.ccDelete(deleteQueue, 0, withOutServer);
			deleteQueue = null;
		}else{
			if(!this.multiSelector) return;
			var selectObj = this.multiSelector.getSelects();
			if (selectObj.length > 0){
				var deleteQueue = [];
				axdom.each(selectObj, function(){
					deleteQueue.push(this.id);
				});
				this.ccDelete(deleteQueue, 0, withOutServer);
				deleteQueue = null;
			}else{
				alert("삭제하실 파일을 선택해 주세요");
			}
		}
	},
	ccDelete: function(deleteQueue, index, withOutServer){
		var cfg = this.config;
		if(deleteQueue.length > index){
			var myFile;
			axdom.each(this.uploadedList, function(){
				if(this[cfg.fileKeys._id_] == deleteQueue[index]){
					myFile = this;
					return false;
				}
			});
			var ccDelete = this.ccDelete.bind(this);
			this.deleteFile(myFile, function(){
				ccDelete(deleteQueue, (index+1), withOutServer);
			}, withOutServer);
		}
	},
	removeUploadedList: function(fid){
		var cfg = this.config;
		var newUploadedList = [];
		axdom.each(this.uploadedList, function(){
			if(this[cfg.fileKeys._id_] != fid) newUploadedList.push(this);
		});
		this.uploadedList = newUploadedList;
		newUploadedList = null;
		if (this.config.onDeleteAll && this.uploadedList.length < 1)  this.config.onDeleteAll.call();
		
		this.multiSelector.collect();
	},
	showMSG: function(msg){
		dialog.push(msg);
	},

	/**
	 * @method AXUpload5.setUploadedList
	 * @param {Array} files - example code 참고
	 * @returns {type} name
	 * @description
	 * 업로드된 목록을 지정합니다.
	 * @example
	 ```
	 ex1)
	 var myFileList = [];
	 var fileItem = {
    name		: 'fileName', //{string} - setConfig.fileKeys 에서 정의한 json key
    type		: 'fileType', //{string} - setConfig.fileKeys 에서 정의한 json key
    saveName	: 'saveName', //{string} - setConfig.fileKeys 에서 정의한 json key
    fileSize	: 'fileSize', //{string} - setConfig.fileKeys 에서 정의한 json key
    uploadedPath: 'filePath', //{string} - setConfig.fileKeys 에서 정의한 json key
    thumbPath	: 'thumbPath' //{string} - setConfig.fileKeys 에서 정의한 json key
};
	 myFileList.push(fileItem);
	 myUpload.setUploadedList(myFileList);

	 ex2)
	 var url = "loadFileList";               //해당 url 에서 예제1의 myFileList 구조에 맞는 json을 내려 줍니다.
	 var pars = "dummy="+AXUtil.timekey();
	 new AXReq(url, {pars:pars, onsucc:function(res){
	if(res.result == "ok"){
		myUpload.setUploadedList(res.ds);
	}else{
		alert(res.msg.dec());
	}
}});
	 ```
	 */
	setUploadedList: function(files){
		var cfg = this.config;
		
		var getItemTag = this.getItemTag.bind(this);
		var onClickDeleteButton = this.onClickDeleteButton.bind(this);
		var onClickFileTitle = this.onClickFileTitle.bind(this);

		if(cfg.isSingleUpload){
			this.uploadedList = [];
			var f;
			if(axdom.isArray(files)){
				if (Object.isObject(files[0]) ){
					f = files[0];
				}
			}else{
				if (Object.isObject(files) ){
					f = files;
				}
			}
			if(!f) return;
			if(!f[cfg.fileKeys._id_]) {
				if(f["id"]) {
					f[cfg.fileKeys._id_] = f["id"];
				}else {
					return;
				}
			}
			
			this.uploadedList.push(f);
			
			var itemID = (f[cfg.fileKeys._id_]||f["id"]), itembox;
			
			var uf = {
				id:itemID,
				name:f[cfg.fileKeys.name],
				size:f[cfg.fileKeys.fileSize]
			};

			itembox = axdom("#" + cfg.targetID+'_AX_display');
			if(cfg.queueBoxAppendType == "prepend") itembox.empty().prepend(this.getItemTag(itemID, uf));
			else itembox.empty().append(this.getItemTag(itemID, uf));


			itembox.find(".AXUploadBtns").show();
			itembox.find(".AXUploadLabel").show();
			itembox.find(".AXUploadTit").show();
			itembox.find(".AXUploadProcess").hide();

			itembox.find(".AXUploadBtnsA").bind("click", function(){
				onClickDeleteButton(itemID);
			});
			if(cfg.onClickUploadedItem){
				itembox.find(".AXUploadDownload").bind("click", function(){
					onClickFileTitle(itemID);
				});
			}
			
		}
		else
		{

			//this.uploadedList = files;
			this.uploadedList = [];
			var uploadedList = [];

			axf.each(files, function(){
				if(this) uploadedList.push(this);
			});
			this.uploadedList = uploadedList;

			if(cfg.queueBoxID){
				var quebox = axdom("#" + cfg.queueBoxID);
				// quebox.empty();
				// @panic910
				quebox.remove('.AXUploadItem');
				axdom.each(this.uploadedList, function(fidx, f){
					if(f[cfg.fileKeys._id_] == undefined){
						if(f["id"]){
							f[cfg.fileKeys._id_] = f["id"];
						}else{
							trace([cfg.fileKeys._id_] + " key는 필수 항목 입니다.");
							return false;
						}
					}
					var itemID = f[cfg.fileKeys._id_], itembox;
					var uf = {
						id:itemID,
						name:f[cfg.fileKeys.name],
						size:f[cfg.fileKeys.fileSize]
					};

					if(cfg.queueBoxAppendType == "prepend") quebox.prepend(getItemTag(itemID, uf));
					else quebox.append(getItemTag(itemID, uf));


					itembox = axdom("#" + itemID);
					itembox.fadeIn();
					
					// --------------------- s
					itembox.find(".AXUploadBtns").show();
					itembox.find(".AXUploadLabel").show();
					itembox.find(".AXUploadProcess").hide();

					if(f[cfg.fileKeys.thumbPath]){
						itembox.find(".AXUploadIcon").css({
							"background-image":"url('"+(f[cfg.fileKeys.thumbPath]||"").dec()+"')"
						}).addClass("AXUploadPreview").find("img.preview").remove();
					}else{
						itembox.find(".AXUploadIcon").css({"background-image":"none"});
						itembox.find(".AXUploadIcon").html((f[cfg.fileKeys.type]||"").dec().replace(".", ""));
					}

					itembox.find(".AXUploadBtnsA").bind("click", function(){
						onClickDeleteButton(itemID);
					});
					if(cfg.onClickUploadedItem){
						itembox.find(".AXUploadDownload").bind("click", function(){
							onClickFileTitle(itemID);
						});
					}
					if(f['mainImage']){
						$("#"+f['id']+"_AXUploadLabel_mainImageFile").show();
					}
					// --------------------- e
					
					itembox.addClass("readyselect");
				});
				this.multiSelector.collect();
			}
		}
	},

	/**
	 * @method AXUpload5.getUploadedList
	 * @param {string} arg - ("param"|"json") 옵션에 따라 파라미터 타입 또는 JSObject 형태로 리턴 타입을 지정합니다.
	 * @returns {String | JSObject}
	 * @description
	 * 업로드된 파일목록을 반환합니다.
	 * @example
	 ```
	 var list = myUpload.getUploadedList("json");
	 trace(list);
	 toast.push(Object.toJSON(list));
	 ```
	 */
	getUploadedList: function(arg){
		var cfg = this.config;

		if(cfg.uploadedListSort){
			this.uploadedList = cfg.uploadedListSort.call(this, this.uploadedList);
		}

		if(arg == "param"){
			try{
				var pars = [];
				if(this.uploadedList){
					axdom.each(this.uploadedList, function(){
						if(this != "") pars.push(axdom.param(this));
					});
				}
				return pars.join("&");
				pars = null;
			}catch(e){
				trace(e);
			}
		}else{
			return this.uploadedList;
		}
	},

	/**
	 * @method AXUpload5.getSelectUploadedList
	 * @param {string} arg - ("param"|"json") 옵션에 따라 파라미터 타입 또는 JSObject 형태로 리턴 타입을 지정합니다.
	 * @returns {String | JSObject}
	 * @description
	 * 업로드된 파일 목록 중에서 선택된 아이템을 반환합니다.
	 * @example
	 ```
	 var list = myUpload.getSelectUploadedList("json");
	 trace(list);
	 toast.push(Object.toJSON(list));
	 ```
	 */
	getSelectUploadedList: function(arg){
		if(!this.multiSelector) return;
		var selectObj = this.multiSelector.getSelects();
		if(arg == "param"){
			var pars = [];
			axdom.each(this.uploadedList, function(){
				for(var a=0;a<selectObj.length;a++){
					if(this.id == selectObj[a].id) pars.push(axdom.param(this));
				}
			});
			return pars.join("&");
			pars = null;
		}else{
			var pars = [];
			axdom.each(this.uploadedList, function(){
				for(var a=0;a<selectObj.length;a++){
					if(this.id == selectObj[a].id) pars.push(this);
				}
			});
			return pars;
			pars = null;
		}
	},
	setUploadedFile: function(file){
		
		if(!file) return;
		if(!file[this.config.fileKeys.id]) return;
		
		this.uploadedList = [];
		this.uploadedList.push(file);
		fileNameMaxLen = this.settings.fileNameMaxLen;
		var po = [];
		
		var dfileicon = this.settings.dfileicon;

		var UploadDisplay_id = this.settings.UploadDisplay_id;
		var onClickButton = this.onClickButton.bind(this);
		var AXfile = this.uploadedList.first();
		
		var po = [];
		po.push("<div class='AXFileTitleBlock'>");
		po.push("<a href='#AXexec' class='AXFileTitle'>"+AXfile.ti.dec()+"</a>");
		po.push("<a href='#AXexec' class='AXFileDelete'>X</a>");
		po.push("</div>");
		axdom("#"+UploadDisplay_id).html(po.join(''));
		axdom("#"+UploadDisplay_id).find(".AXFileDelete").bind("click", onClickButton);

		if(this.settings.onclick){
			var onclick = this.settings.onclick.bind(this);
			axdom("#"+UploadDisplay_id).find(".AXFileTitle").bind("click", function(){
				onclick(AXfile);
			});
		}

		po = null;
		fileNameMaxLen = null;
	},
	getUploadedFile: function(){
		return this.uploadedList.first();
	},
	
	addKeyInUploadedListItem: function(objID, obj){
		var uploadedList = this.uploadedList;
		
		axdom.each(uploadedList, function(idx, o){
			if (o.id == objID){
				axdom.each(obj, function(k, v){
					o[k] = v;
				});
			}else{
				axdom.each(obj, function(k, v){
					o[k] = '';
				});
			}
		});
	},

	setLocalPreview: function(itemID, file){
		if (!this.supportHtml5 || this.config.isSingleUpload) { return; }
		if (!this.supportHtml5 || this.config.isSingleUpload) { return; }

		try {
			var previewId = itemID + "_preview";
			var preview   = axf.getId(previewId);
			var reader    = new FileReader(previewId);

			reader.onloadend = function () {
				try {
					preview.src = reader.result;
				} catch (ex) {
					trace(ex);
				}
			};

			if (file) {
				reader.readAsDataURL(file);
			}
		} catch (e) {
			trace(e);
		}
	},
	
	nothing: function(){

	}
});

// axdom extend
/* ---------------------------- */
var AXUserSelect = Class.create(AXJ, {
    initialize: function(AXJ_super) {
        AXJ_super();
        this.config.className = "";
        this.ds = [];
    },
    init: function() {
        var config = this.config;
        this.myDrag = new AXDrag();
        
        if (!config.containerID || !jQuery("#" + config.containerID).get(0)) {
            alert("컨테이너 아이디가 지정되지 않아 modsTab 초기화에 실패 하였습니다.");
            return;
        }
        this.CT = jQuery("#" + config.containerID);

        var po = [];
        po.push("<div class=\"" + config.className + " readyDrop\" id=\"" + config.containerID + "_AX_UserSelectBox\" style='height:100%;'>");
        po.push("</div>");
        this.CT.html(po.join(''));


        var onSort = this.onSort.bind(this);
        var onDrop = this.onDrop.bind(this);

        this.myDrag.setConfig({
            dragStage: config.containerID + "_AX_UserSelectBox",
            dragBoxClassName: "modsDragBox",
            bedragClassName: "bedraged",
            bedropClassName: "bedroped",
            dragClassName: "readyDrag",
            dropClassName: "readyDrop",
            //onDrag: fnObj.portlet.onDrag,
            onDrop: onDrop,
            onSort: onSort,
            multiSelector: {
                selectStage: config.containerID + "_AX_UserSelectBox",
                selectClassName: "readyDrag",
                beselectClassName: "beSelected"
            },
            sort: {
                sorter: "<div class=\"modsSortGhost\"></div>"
            }
        });
        // 3 : 활성화
        this.myDrag.active();

    },
/**
 * @method AXUserSelect.push
 * @param ds {Array} 추가할 아이템 배열
 * @returns null
 * @description UserSelect 개체에 아이템을 추가합니다.
 * @example
```
var ds = [];
ds.push({
	id:AXUtil.timekey(),
    nm:AXUtil.timekey(),
    desc:"AXISJ"
});
myUserBox.push(ds);
```
 */
    push: function(ds) {
        var config = this.config;
        var myds = this.ds;
        var po = [];
        jQuery.each(ds, function(i, D) {
            var addOk = 1;
            jQuery.each(myds, function() {
                if (this.id == D.id) {
                    addOk = 0;
                    return false;
                }
            });
            if (addOk == 1) {
                po.push("<div class=\"readyDrag\" id=\"" + config.containerID + "userSelectItem_AX_" + this.id + "\">");
                po.push("	<div class=\"userSelectItemBody\">");
                po.push("	<input type=\"hidden\" name=\"id\" id=\"" + config.containerID + "userSelectItemID_AX_" + this.id + "\" value=\"" + this.id + "\" /> ");
                po.push("	<input type=\"hidden\" name=\"nm\" id=\"" + config.containerID + "userSelectItemNM_AX_" + this.id + "\" value=\"" + this.nm + "\" /> ");
                po.push("	<input type=\"hidden\" name=\"desc\" id=\"" + config.containerID + "userSelectItemDESC_AX_" + this.id + "\" value=\"" + (this.desc||"") + "\" /> ");
                po.push("	" + this.nm.dec() + " ");
                po.push("	" + (this.desc||"").dec() + " ");
                //po.push("	<a href=\"#modsExec\" class=\"del\">삭제</a>");
                po.push("	</div>");
                po.push("</div>");
                myds.push(this);
            }
        });

        jQuery("#" + config.containerID + "_AX_UserSelectBox").append(po.join(''));


        this.dragCollect();
    },
    del: function(select) {
        var config = this.config;
        var myDS = [];
        jQuery.each(this.ds, function() {
            var delOK = 0;
            for (var a = 0; a < select.length; a++) {
                if (select[a].id.split(/_AX_/g).last() == this.id) {
                    delOK = 1;
                }
            }
            if (delOK == 1) {
                jQuery("#" + config.containerID + "userSelectItem_AX_" + this.id).remove();
            } else {
                myDS.push(this);
            }
        });
        this.ds = myDS;
        this.dragCollect();
    },
    _del: function(select) {
        var config = this.config;
        var myDS = [];
        axf.each(this.ds, function() {
            var delOK = 0;
            for (var a = 0; a < select.length; a++) {
                if (select[a] == this.id) {
                    delOK = 1;
                }
            }
            if (delOK == 1) {
                axdom("#" + config.containerID + "userSelectItem_AX_" + this.id).remove();
            } else {
                myDS.push(this);
            }
        });
        this.ds = myDS;
        this.dragCollect();
    },    
    dragCollect: function() {
        this.myDrag.collectItem();
    },
    onSort: function(res) {
	    var _this = this, that;
        var dragCollect = this.dragCollect.bind(this);
        if (axdom(res.dragItem).html() == axdom(res.sortItem).html()) return;
        if (res.dragItem == res.sortItem) return;
        axdom(res.dragItem).fadeOut("fast", function() {
            axdom(res.sortItem).before(this);
            axdom(this).show("fast");
            dragCollect();
	        if(_this.config.onchange){
		        that = {
			        containerID: _this.config.containerID,
			        list : _this.getDS()
		        };
		        _this.config.onchange.call(that);
	        }
        });
	    
	    return this;
    },
    onDrop: function(res) {
	    var _this = this, that;
        var dragCollect = this.dragCollect.bind(this);
        axdom(res.dragItem).fadeOut("fast", function() {
            jQuery("#" + _this.config.containerID + "_AX_UserSelectBox").append(this); //예외 경우
            jQuery(this).show("fast");
            dragCollect();
	        if(_this.config.onchange){
		        that = {
			        containerID: _this.config.containerID,
			        list : _this.getDS()
		        };
		        _this.config.onchange.call(that);
	        }
        });
	    return this;
    },
    moveup: function() {
	    var _this = this, that, select = this.getSelect();

        axf.each(select, function() {
            var prev = axdom(this).prev();
            prev.before(axdom(this));
        });

	    if(_this.config.onchange){
		    that = {
			    containerID: _this.config.containerID,
			    list : _this.getDS()
		    };
		    _this.config.onchange.call(that);
	    }
	    return this;
    },
    movedown: function() {
	    var _this = this, that, select = this.getSelect();

        axf.each(select, function() {
            var next = axdom(this).next();
            next.after(axdom(this));
        });

	    if(_this.config.onchange){
		    that = {
			    containerID: _this.config.containerID,
			    list : _this.getDS()
		    };
		    _this.config.onchange.call(that);
	    }
	    return this;
    },    
    getSelect: function() {
        return this.myDrag.mselector.getSelects();
    },
    empty: function() {
        var config = this.config;
        jQuery("#" + config.containerID + "_AX_UserSelectBox").empty();
        this.ds = [];
        this.dragCollect();
    },
    getDS: function() {
        var config = this.config;
        var myDS = [];
        jQuery("#" + config.containerID + "_AX_UserSelectBox").find(".readyDrag").each(function() {
            var id = this.id.split(/_AX_/g).last();
            var nm = jQuery("#" + config.containerID + "userSelectItemNM_AX_" + id).val();
            var desc = jQuery("#" + config.containerID + "userSelectItemDESC_AX_" + id).val();
            myDS.push({id:id, nm:nm, desc:desc});
        });
        return myDS;
    },
	getSelectDS: function() {
		var config = this.config;
		var myDS = [];
		var sls = this.myDrag.mselector.getSelects();
		if(sls.length > 0){
			for(var i=0;i<sls.length;i++){
				var id = sls[i].id.split(/_AX_/g).last();
				var nm = jQuery("#" + config.containerID + "userSelectItemNM_AX_" + id).val();
				var desc = jQuery("#" + config.containerID + "userSelectItemDESC_AX_" + id).val();
				myDS.push({id:id, nm:nm, desc:desc});
			}
		}
		return myDS;
	}
});
/* ---------------------------- */
var AXValidator = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();
        this.Observer = null;
        this.form = null;
        this.elements = [];
        this.errElements = [];
        this.errMessagePattern = "[{label}] {message}";
        this.config = {
            targetID: null,
            clazz: "av-"
        };

		if(AXConfig.AXValidator && AXConfig.AXValidator.validateErrMessage){
			this.config.validateErrMessage = AXConfig.AXValidator.validateErrMessage;
		}else{
			this.config.validateErrMessage = {
				/* for element */
				required: "[{label}](은)는 필수입력 사항입니다.",
				requiredstring: "반드시 {required}(으)로 입력하셔야 하는 사항입니다.",
				match: "[{label}](은)는 입력된 내용이 일치하지 않습니다.",
				invalid: "[{label}](은)는 입력된 내용이 올바르지 않습니다.",
				min: "[{label}](은)는 {min} 이상의 값을 입력해주세요.",
				max: "[{label}](은)는 {max} 이하의 값을 입력해주세요.",
				minbyte: "[{label}]의 입력된 내용의 길이가 {minbyte}Byte 이상이어야 합니다.",
				maxbyte: "[{label}]의 입력된 내용의 길이가 {maxbyte}Byte를 초과할 수 없습니다.",
				minlength: "[{label}]의 입력된 내용의 length가 {minlength} 이상이어야 합니다.",
				maxlength: "[{label}]의 입력된 내용의 length가 {maxlength}을 초과할 수 없습니다.",

				/* for format */
				number: "숫자로만 입력하셔야 합니다.",
				email: "이메일 형식이 올바르지 않습니다.",
				hangul: "한글로만 입력하셔야 합니다.",
				engonly: "영문으로만 입력하셔야 합니다.",
				residentno: "주민등록번호 형식이 올바르지 않습니다.",
				foreignerno: "외국인등록번호 형식이 올바르지 않습니다.",
				bizno: "사업자등록번호 형식이 올바르지 않습니다.",
				phone: "전화번호 형식이 올바르지 않습니다.",
				isdate: "날짜 형식이 올바르지 않습니다.",
				zip: "우편번호 형식이 올바르지 않습니다.",
				money: "화폐형식으로만 입력하셔야 합니다.",
				earlierThan: "[{label}] 보다 빠른 날짜를 입력해야 합니다.",
				laterThan: "[{label}] 보다 느린 날짜를 입력해야 합니다.",

				exception: "not found errmessage"
			};
		}

    },
    init: function () {
        var cfg = this.config;
        if (Object.isUndefined(cfg.targetFormName)) {
            trace("need targetID - setConfig({targetFormName:''})");
            return;
        }

        if (!document[cfg.targetFormName]) {
            // 엘리먼트가 존재 하지 않는 경우 예외 처리
            trace("not found form element");
            return;
        }

        this.form = $(document[cfg.targetFormName]);
        this.findElement();
    },
    findElement: function () {
        var cfg = this.config;
        var allElements = this.form.serializeObject();
        var _elements = this.elements;
        var checkClass = this.validateCheckClass;

        axdom.each(allElements, function (eidx, Elem) {
            try {
                var config = {};
                var isValidate = false;
                axdom.each(checkClass, function (k, v) {
                    if (Elem.id) {
                        if (axdom("#" + Elem.id).hasClass(cfg.clazz + k)) {
                            config[k] = v;
                            isValidate = true;
                        }
                    } else if (Elem.name) {
                        if ($(document[cfg.targetFormName][Elem.name]).hasClass(cfg.clazz + k)) {
                            config[k] = v;
                            isValidate = true;
                        }
                    }
                });
                if (isValidate) {
                    delete Elem.value;
                    Elem.config = config;
                    _elements.push(Elem);
                }
            } catch (e) {

            }
        });
	    // checkbox, radio 수집
	    var checkedItems = {};
	    axdom(this.form).find("input[type=checkbox], input[type=radio]").each(function(eidx, Elem){

		    var config = {};
		    var isValidate = false, label = "";
		    axdom.each(checkClass, function (k, v) {
				if (Elem.name) {
				    if ($(document[cfg.targetFormName][Elem.name]).hasClass(cfg.clazz + k)) {
					    config[k] = v;
					    isValidate = true;
					    if(label == "") label = (Elem.title || Elem.placeholder || "");
				    }
			    }
		    });

		    if (isValidate) {
			    if(checkedItems[this.name]){
				    checkedItems[this.name].push({index:0, type:this.type, value:this.value, id:this.id, checked:this.checked, label:label});
			    }else{
				    checkedItems[this.name] = [{index:0, type:this.type, value:this.value, id:this.id,  checked:this.checked, config:config, label:label}];
			    }
		    }
	    });

	    axf.each(checkedItems, function(k, v){
		    var item = {
			    "id":"",
			    "name":k,
			    "type":v[0].type,
			    "label":v[0].label,
			    "multi":true,
			    "config":v[0].config
		    };
		    /*
		    for(var aa=0;aa<v.length;aa++){
			    if(item.id == ""){
				    item.id = v[aa].id;
			    }else{
				    item.id += "," + v[aa].id;
			    }
		    }
		    */
		    _elements.push(item);
	    });
	    
	    //config에 checkCrlf 옵션이 있을 경우
	    if(cfg.checkCrlf){
	    	axdom(this.form).find("textarea[maxlength]").each(function(index, element){
	    		
	    		var item = {
	    			"id":element.id,
	    			"name":element.name,
	    			"type":"textarea",
	    			"value":"",
	    			"label":element.title||element.placeholder||"",
	    			"config":{"maxlength":element.maxLength}
	    		};
	    		
	    		_elements.push(item);
	    	});
	    }

        this.elements = _elements;
    },

/**
 * @method AXValidator.add
 * @param {JSObject} - example code 참고
 * @description
 * validate 대상 아이템을 추가합니다.
 * @example
 ```

var jsObjectSample = {
    id: "userID",           //{string} - 아이템식별자
    label: "아이디",        //{string} - 아이템라벨
    config: {               //필요한 조합을 object로 정의합니다.
        required: true,		//[boolean=true] - 필수입력 체크
        number: true, 		//[boolean=true] - 숫자입력 체크
        email: true, 		//[boolean=true] - 이메일형식 체크
        hangul: true, 		//[boolean=true] - 한글형식 체크
        engonly: true, 		//[boolean=true] - 영문형식 체크
        residentno: true, 	//[boolean=true] - 주민등록번호형식 체크
        foreignerno: true,	//[boolean=true] - 외국인번호형식 체크
        bizno: true, 		//[boolean=true] - 사업자등록번호형식 체크
        phone: true, 		//[boolean=true] - 전화번호형식 체크
        isdate: true, 		//[boolean=true] - 날짜형식 체크
        zip: true, 			//[boolean=true] - 우편번호형식 체크
        money: true, 		//[boolean=true] - 숫자에 , 포함 체크
        earlierThan:{
            id: "targetId",			//{string} - 대상의 아이디. 현재 아이템의 값이 대상보다 커야함
            label:	"targetLabel"	//{string} - 대상의 라벨
        },
        laterThan:{
            id: "targetId",			//{string} - 대상의 아이디. 현재 아이템의 값이 대상보다 작아야함
            label:	"targetLabel"	//{string} - 대상의 라벨
        },
        min: true, 			//[boolean=true] - 최소값
        max: true, 			//[boolean=true] - 최대값
        minbyte: true, 		//[boolean=true] - 최소바이트값
        maxbyte: true, 		//[boolean=true] - 최대바이트값
        minlength: true, 	//[boolean=true] - 최소길이
        maxlength: true 	//[boolean=true] - 최대길이
    },
    realtime:{			    //특정이벤트 발생시 액션정의
        event: "keydown",	//{String} - 발생하는 이벤트 종류
        response: function(){   //{fn} - 정의된 이벤트에 따른 실시간 이벤트 콜백함수
            //trace(this);
        }
    },
    onblur: function(){     //[fn] - 대상 아이템에 블러 이벤트 발생 콜백함수
        //trace(this);
    }
};

var myValidator = new AXValidator();
myValidator.add({
    id: "userID",           //{string} - 아이템식별자
    label: "아이디",        //{string} - 아이템라벨
    config: {
        required: true,     //[boolean=true] - 필수입력 체크
        minbyte:10,         //[boolean=true] - 최소바이트값
        maxbyte:20          //[boolean=true] - 최대바이트값
    },
    realtime: {
        event: "keydown",           //{String} - 발생하는 이벤트 종류
        response: function () {     //{fn} - 정의된 이벤트에 따른 실시간 이벤트 콜백함수
        	if(this.result){
        		$("#userID_realtime").html("OK");
        	}else{
            	$("#userID_realtime").html(this.message);
           }
			if (this.validateKey == "maxbyte" || this.validateKey == "maxlength") {
			    return false; //키 입력 중지
			} else {
			    return true; //키 입력 제어 안함
			}
        }
    },
	onblur: function(){ //[fn] - 대상 아이템에 블러 이벤트 발생 콜백함수
		trace(this);
	}
});

myValidator.add({
	id:"enddate",   //{string} - 아이템 식별자
	label:"종료일",  //{string} - 아이템 라벨
	config:{
	    isdate:true,    //[boolean=true] - 날짜형식 체크
	    laterThan:{
	        id:"regdate",   //{string} - 대상의 아이디. 현재 아이템의 값이 대상보다 작아야함
	        label:"등록일"  //{string} - 대상의 라벨
        }
    },
	onblur: function(){     //[fn] - 대상 아이템에 블러 이벤트 발생 콜백함수
        trace(this);
	}
});

 ```
 */
    add: function (addObj) {
        var cfg = this.config;
        var addedObject;
        var addElement = this.addElement.bind(this);
        var getElement = this.getElement.bind(this);
        var isActiveFormControl = this.isActiveFormControl.bind(this);
        var element = getElement(addObj);
        if (!isActiveFormControl(element)) return false;

        if (addObj.id) {
            var findIndex = null;
            axdom.each(this.elements, function (eidx, elem) {
                if (this.id == addObj.id) {
                    findIndex = eidx;
                    return false;
                }
            });
            if (findIndex != null) {
                addElement(addObj, findIndex);
                addedObject = this.elements[findIndex];
            } else {
                addObj.name = axdom("#" + addObj.id).attr("name");
                this.elements.push(addObj);
                addedObject = this.elements.last();
            }
        } else if (addObj.name) {
            var findIndex = null;
            axdom.each(this.elements, function (eidx, elem) {
                if (this.name == addObj.name) {
                    findIndex = eidx;
                    return false;
                }
            });
            if (findIndex != null) {
                addElement(addObj, findIndex);
                addedObject = this.elements[findIndex];
            } else {
                addObj.id = $(document[cfg.targetFormName][addObj.name]).attr("id");
                this.elements.push(addObj);
                addedObject = this.elements.last();
            }

        }

        var raiseError = this.raiseError.bind(this);
        var validateFormatter = this.validateFormatter.bind(this);
        var targetElem;
        var targetElemForSelect;

        if (addedObject.id) {
            targetElem = axdom("#" + addedObject.id);
            targetElemForSelect = AXgetId(addedObject.id);
        } else if (addedObject.name) {
            targetElem = $(document[cfg.targetFormName][addedObject.name]);
            targetElemForSelect = document[cfg.targetFormName][addedObject.name];
        }
        var Elem = addedObject;
        var displayFormatter = this.displayFormatter.bind(this);

        // realtime 지원 함수 구문 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if (addedObject.realtime) {
            //Elem.realtime.validate = Elem.config;

            Elem.needRealtimeCheck = false;
            Elem.realtimeCheck = {};

            axdom.each(Elem.config, function (k, v) {
                if (k == "maxlength" || k == "maxbyte") {
                    Elem.needRealtimeCheck = true;
                    Elem.realtimeCheck[k] = v;
                }
            });

            if (Elem.needRealtimeCheck) {
                targetElem.unbind("keydown.validate");
                targetElem.bind("keydown.validate", function (e) {
                    var event = window.event || e;
                    if (!event.keyCode || event.keyCode == 9 || event.keyCode == 16) return;
                    var _val = this.value;
                    var returnObject = null;
                    var eventBlock = true;

                    if (document.selection && document.selection.createRange) {
                        var range = document.selection.createRange();
                        if (range.text != "") eventBlock = false;
                    } else if (window.getSelection) {

                        if (AXUtil.browser.name == "mozilla") {
                            //trace({ maxlength: Elem.realtimeCheck.maxlength, selectionStart: targetElemForSelect.selectionStart });
                            if (Elem.realtimeCheck.maxlength > targetElemForSelect.selectionStart) {
                                eventBlock = false;
                            }
                        } else {
                            selectedText = window.getSelection().toString();
                            if (selectedText != "") eventBlock = false;
                        }
                    }


                    axdom.each(Elem.realtimeCheck, function (k, v) {
                        var val = targetElem.val() + "A";
                        if (!validateFormatter(Elem, val, k, v, "realtime")) { // 값 검증 처리
                            returnObject = raiseError(Elem, val, k, v);
                            return false;
                        }
                    });

                    var responseResult = true;
                    if (returnObject == null) {
                        Elem.realtime.response.call({ result: true });
                    } else {
                        returnObject.result = false;
                        responseResult = Elem.realtime.response.call(returnObject);
                    }

                    if (responseResult == false) {
                        if (eventBlock) {
                            if (event.keyCode != AXUtil.Event.KEY_DELETE
                                && event.keyCode != AXUtil.Event.KEY_BACKSPACE
                                && event.keyCode != AXUtil.Event.KEY_LEFT
                                && event.keyCode != AXUtil.Event.KEY_RIGHT) {

                                if (event.preventDefault) event.preventDefault();
                                if (event.stopPropagation) event.stopPropagation();
                                event.cancelBubble = true;
                                return false;
                            }
                        }
                    }

                });
            }



            //trace(Elem.config);

            targetElem.unbind("keyup.validate").bind("keyup.validate", function (e) {
                var event = window.event || e;
                // ignore tab & shift key 스킵
                if (!event.keyCode || event.keyCode == 9 || event.keyCode == 16) return;

                var _val = this.value;
                var returnObject = null;
                var vKey;
                axdom.each(Elem.config, function (k, v) {

                    //trace(k);

                    vKey = k;
                    var val = targetElem.val();
                    if (!validateFormatter(Elem, val, k, v, "realtime")) { // 값 검증 처리
                        returnObject = raiseError(Elem, val, k, v);
                        return false;
                    }
                });

                var responseResult = true;
                if (returnObject == null) {
                    Elem.__prevValue = _val;
                    Elem.realtime.response.call({ result: true });
                } else {
                    returnObject.result = false;
                    responseResult = Elem.realtime.response.call(returnObject);
                }



                if (responseResult == false) {
                    if (event.keyCode != AXUtil.Event.KEY_DELETE
                        && event.keyCode != AXUtil.Event.KEY_BACKSPACE
                        && event.keyCode != AXUtil.Event.KEY_LEFT
                        && event.keyCode != AXUtil.Event.KEY_RIGHT
                        ) {

                        if ((Elem.__prevValue || "").length > _val.length) {
                            this.value = "";
                        } else {
                            if (displayFormatter((Elem.__prevValue || ""), vKey) != "") this.value = displayFormatter((Elem.__prevValue || ""), vKey);
                        }

                        if (event.preventDefault) event.preventDefault();
                        if (event.stopPropagation) event.stopPropagation();
                        event.cancelBubble = true;
                        return false;
                    }
                } else {
                    //realtime에서 체크시 백시켜서 오류
                    if (displayFormatter(this.value, vKey) != "") this.value = displayFormatter(this.value, vKey);
                }

            });

        }
        // realtime 지원 함수 구문 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


        //trace(addedObject);

        // blur 지원
        if (addedObject.onblur) {
            targetElem.unbind("blur.validate").bind("blur.validate", function (e) {
                var returnObject = {result:true};
                axdom.each(Elem.config, function (k, v) {
                    var val = targetElem.val();
                    if (!validateFormatter(Elem, val, k, v, "")) {
                        returnObject = raiseError(Elem, val, k, v);
                        returnObject.config = Elem.config;
                        returnObject.result = false;
                        return false;
                    }
                });
                if(returnObject.result){
                    returnObject.element = Elem;
                    returnObject.value = targetElem.val();
                    returnObject.config = Elem.config;
                }
                var responseResult = Elem.onblur.call(returnObject);
            });
        }

    },

/**
 * @method AXValidator.del
 * @param {JSObject} - example code 참고
 * @description
 * validate 대상 아이템을 제거합니다.
 * @example
 ```
 myValidator.del( {id:"userID"});   //아이템식별자

 ```
 */
    del: function (delObj) {
        var cfg = this.config;
        var deledObject;

        var findIndex = null;
        if (delObj.id) {
            $.each(this.elements, function (eidx, elem) {
                if (this.id == delObj.id) {
                    findIndex = eidx;
                    return false;
                }
            });
        } else if (delObj.name) {
            $.each(this.elements, function (eidx, elem) {
                if (this.name == delObj.name) {
                    findIndex = eidx;
                    return false;
                }
            });
        }

        if (findIndex != null) {
            deledObject = this.elements[findIndex];
            $("#" + deledObject.id).unbind("keydown.validate");
            $("#" + deledObject.id).unbind("keyup.validate");
            $("#" + deledObject.id).unbind("blur.validate");
            this.elements.splice(findIndex, 1);
        }

        //trace(this.elements);
    },

    addElement: function (addObj, findIndex) {
        AXUtil.overwriteObject(this.elements[findIndex].config, addObj.config, true);
        if (addObj.onblur) this.elements[findIndex].onblur = addObj.onblur;
        if (addObj.realtime) this.elements[findIndex].realtime = addObj.realtime;
        if (addObj.message) this.elements[findIndex].message = addObj.message;
        if (addObj.label) this.elements[findIndex].label = addObj.label;
    },

/**
 * @method AXValidator.validate
 * @returns {boolean} - 정의된 규칙에 따라 (true|false) 로 결과를 리턴합니다.
 * @description
 * validate 처리결과를 리턴합니다.
 * @example
 ```
var validateResult = myValidator.validate();
 ```
 */
    validate: function (filterOption) {
        var cfg = this.config;
        var raiseError = this.raiseError.bind(this);
        var validateFormatter = this.validateFormatter.bind(this);

        var returnObject = null;
        for (var Elem, eidx= 0, __arr = this.elements; (eidx < __arr.length && (Elem = __arr[eidx])); eidx++) {
            var targetElem;
            if (Elem.id && !Elem.multi) {
                targetElem = axdom("#" + Elem.id);
            } else if (Elem.name) {
                targetElem = axdom( document[cfg.targetFormName][Elem.name] );
            }

	        if(Elem.name == "bizno") {
		        //alert(Elem.name);
		        //alert(document[cfg.targetFormName][Elem.name]);
	        }

            var isCheck = true;
            if(filterOption){
                if(filterOption.filterType == "include"){
                    isCheck = false;
                    for (var f, fidx= 0, __arr2 = filterOption.list; (fidx < __arr2.length && (f = __arr2[fidx])); fidx++) {
                        if(f.id && f.id == Elem.id){
                            isCheck = true;
                            break;
                        }else if(f.name && f.name == Elem.name){
                            isCheck = true;
                            break;
                        }
                    }
                }else{
                    isCheck = true;
                    for (var f, fidx= 0, __arr2 = filterOption.list; (fidx < __arr2.length && (f = __arr2[fidx])); fidx++) {
                        if(f.id && f.id == Elem.id){
                            isCheck = false;
                            break;
                        }else if(f.name && f.name == Elem.name){
                            isCheck = false;
                            break;
                        }
                    }
                }
            }

            if (targetElem && isCheck) {
	            var val = "";
	            if(Elem.type == "radio" || Elem.type == "checkbox"){
		            targetElem.each(function(){
			            if(this.checked){
				            if(val == "") val = this.value;
				            else val += "," + this.value;
			            }
		            });
	            }else{
		            val = targetElem.val();
	            }

                var _end = false;

                axdom.each(Elem.config, function (k, v) {
                    if (!validateFormatter(Elem, val, k, v, "")) { // 값 검증 처리
                        returnObject = raiseError(Elem, val, k, v);
                        _end = true;
                        return false;
                    }
                });
                if (_end) return false;
            }
        };

        if (returnObject == null) {
            this.errElements = [];
            return true;
        } else {
            return false;
        }

    },
    raiseError: function (elem, elemVal, validateKey, validateVal) {
        var messageConvert = this.messageConvert.bind(this);
        var message = messageConvert(elem, validateKey, validateVal);
        var returnObject = {
            element: elem,
            value: elemVal,
            validateKey: validateKey,
            validateVal: validateVal,
            message: message
        };
        this.errElements.push(returnObject);
        return returnObject;
    },
    messageConvert: function (elementObj, validateKey, validateVal) {
        var validateErrMessage = this.config.validateErrMessage;
        var vKey = "exception";
        var vVal = "";
        if (validateKey != undefined) vKey = validateKey;
        if (validateVal != undefined) vVal = validateVal;

        var element = elementObj;
        if (!element) {
            return null;
        }
        var label;
        if (element.label) {
            label = element.label.length > 0 ? element.label : (element.id || element.name);
        } else {
            label = (element.id || element.name);
        }

        if(vKey == "earlierThan" || vKey == "laterThan"){
            label = (validateVal.label||label);
        }

        var errMessage = validateErrMessage[vKey];
        if (element.message == undefined) {
            var typeMessage = errMessage;
        } else {
            var typeMessage = (element.message[vKey] || errMessage);
        }

        if (typeMessage != undefined) {
            var message = typeMessage.replace(/{label}/, label);
            message = message.replace("{" + vKey + "}", vVal);
        } else {
            message = "";
        }
        return message;
    },
    //-------------------- validate check - formatter - message Set [S] ----------------------
    validateCheckClass: {
        // element에서 클래스 검사 항목
        required: true,     //필수
        number: true,        //숫자 형식
        email: true,         //이메일 형식
        hangul: true,        //한글 형식
        engonly: true,       //영문 형식
        residentno: true,    //주민등록 번호 형식
        foreignerno: true,   //외국인 번호 형식
        bizno: true,         //사업자 등록 형식
        phone: true,         //전화번호 형식
        isdate: true,        //날짜 형식
        zip: true,           //우편번호 형식
        money: true          //',' 포함한 숫자
    },
    validateFormatter: function (Elem, ElemValue, validateKey, validateValue, realtime) {
        var cfg = this.config;
        var result = true;
        var lenMargin = 1; // 최소 최대 비교시 하나 커야 함.
        if (realtime == "realtime") lenMargin = 0; // realtime 실행 시는 마진 없음.
        try {

	        if (ElemValue != "" && validateKey == "residentno") {

	        }

            /* for element */
            if (validateKey == "required") {
                result = (ElemValue.trim() != "");
            } else if (ElemValue != "" && validateKey == "min") {
                result = (ElemValue.number() + lenMargin > validateValue);
            } else if (ElemValue != "" && validateKey == "max") {
                result = (ElemValue.number() - lenMargin <= validateValue);
            } else if (ElemValue != "" && validateKey == "minbyte") {
                result = (ElemValue.getByte().number() + lenMargin > validateValue);
            } else if (ElemValue != "" && validateKey == "maxbyte") {
                result = (ElemValue.getByte().number() - lenMargin <= validateValue);
            } else if (ElemValue != "" && validateKey == "minlength") {
                result = (ElemValue.length.number() >= validateValue);
            } else if (ElemValue != "" && validateKey == "maxlength") {
            	var crlfLength = 0;
            	if(cfg.checkCrlf){
            		var __matchedArr = ElemValue.match(/(\r\n|\n|\r)/g);
            		if(__matchedArr){
            			crlfLength = __matchedArr.length * 1;
            			trace(crlfLength);
            		}
            	}
                result = (ElemValue.length.number() + crlfLength <= validateValue);
                /* for format */
            } else if (ElemValue != "" && validateKey == "number") {
                //var pattern = /^[0-9]+$/;
                result = axdom.isNumeric(ElemValue.trim());
            } else if (ElemValue != "" && validateKey == "email") {
                var pattern = /^[_a-zA-Z0-9-\.]+@[\.a-zA-Z0-9-]+\.[a-zA-Z]+$/;
                result = pattern.test(ElemValue);
            } else if (ElemValue != "" && validateKey == "hangul") {
                var pattern = /^[가-힣0-9]+$/;
                result = pattern.test(ElemValue);
            } else if (ElemValue != "" && validateKey == "engonly") {
                var pattern = /^[a-zA-Z0-9_]+$/;
                result = pattern.test(ElemValue);
            } else if (ElemValue != "" && validateKey == "residentno") {


	            var pattern = /^(?:[0-9]{2}(?:0[1-9]|1[0-2])(?:0[1-9]|[1,2][0-9]|3[0,1]))-?[1-4][0-9]{6}$/;
	            var num = ElemValue;

	            //trace(pattern.test(num), "test");

	            if (!pattern.test(num)){
		            result = false;
	            }

	            function checkJumin(p_juminno) {
		            try {
			            // 파라미터로 전달받은 p_juminno가 공백이거나, 13자리를 넘어가거나, 숫자가 아닐경우 false 리턴
			            if(p_juminno == '' || p_juminno.length != 13 || typeof(Number(p_juminno)) != 'number') {
				            return false;
			            }

			            isKorean = true;
			            // 주민번호 뒷자리 첫번째 수가 4보다 크거나, 9보다 작으면 외국인
			            if(Number(p_juminno.charAt(6)) > 4 && Number(p_juminno.charAt(6)) < 9) {
				            isKorean = false;
			            }

			            // 아래부터는 검증 로직임.
			            var check = 0;
			            for(var i=0; i<12; i++) {
				            if(isKorean) {
					            check = check + ((i % 8 + 2) * Number(p_juminno.charAt(i)));
				            } else {
					            check = check + ((9 - i % 8) * Number(p_juminno.charAt(i)));
				            }
			            }
			            if(isKorean) {
				            check = 11 - (check % 11);
				            check = check % 10;
			            } else {
				            var remainder = check % 11;
				            if(remainder == 0) {
					            check = 1;
				            } else if(remainder==10) {
					            check = 0;
				            } else {
					            check = remainder;
				            }
				            var check2 = check + 2;
				            if(check2 > 9) {
					            check = check2 - 10;
				            } else {
					            check = check2;
				            }
			            }
			            if(check == Number(p_juminno.charAt(12))) {
				            return true;
			            } else {
				            return false;
			            }
		            } catch(e) {
			            alert(e.description);
		            }
	            }
	            if(result != false) {
		            result = checkJumin(num.replace(/\D/g, ""));
	            }
            } else if (ElemValue != "" && validateKey == "foreignerno") {
                var pattern = /^(\d{6})-?(\d{5}[7-9]\d{1})$/;
                var num = ElemValue;

	            if (!pattern.test(num)){
		            result = false;
	            }

	            if(result != false) {
		            num = RegExp.$1 + RegExp.$2;
		            //if ((num[7] * 10 + num[8]) % 2) return "foreignerno";

		            var sum = 0;
		            var last = num.charCodeAt(12) - 0x30;
		            var bases = "234567892345";
		            for (var i = 0; i < 12; i++) {
			            if (isNaN(num.substring(i, i + 1))) return "foreignerno";
			            sum += (num.charCodeAt(i) - 0x30) * (bases.charCodeAt(i) - 0x30);
		            }
		            var mod = sum % 11;
		            result = ((11 - mod + 2) % 10 == last);
	            }

            } else if (ElemValue != "" && validateKey == "bizno") {
                var pattern = /([0-9]{3})-?([0-9]{2})-?([0-9]{5})/;
                var num = ElemValue;
	            if(num.replace(/\D/g, "").length != 10){
		            result = false;
	            }
	            if (!pattern.test(num)){
		            result = false;
	            }

                num = RegExp.$1 + RegExp.$2 + RegExp.$3;
	            if(result != false) {
		            var vencod = num, sum = 0, getlist = new Array(10), chkvalue = new Array("1", "3", "7", "1", "3", "7", "1", "3", "5");
		            for (var i = 0; i < 10; i++) { getlist[i] = vencod.substring(i, i + 1); }
		            for (var i = 0; i < 9; i++) { sum += getlist[i] * chkvalue[i]; }
		            sum = sum + parseInt((getlist[8] * 5) / 10);
		            sidliy = sum % 10;
		            sidchk = (sidliy != 0) ? 10 - sidliy : 0;
		            result = (sidchk != getlist[9]) ? false : true;
		            /*
		            var cVal = 0;
		            for (var i = 0; i < 8; i++) {
			            var cKeyNum = parseInt(((_tmp = i % 3) == 0) ? 1 : (_tmp == 1) ? 3 : 7);
			            cVal += (parseFloat(num.substring(i, i + 1)) * cKeyNum) % 10;
		            }
		            ;
		            var li_temp = parseFloat(num.substring(i, i + 1)) * 5 + "0";
		            cVal += parseFloat(li_temp.substring(0, 1)) + parseFloat(li_temp.substring(1, 2));
		            result = (parseInt(num.substring(9, 10)) == 10 - (cVal % 10) % 10);
		            */
	            }

            } else if (ElemValue != "" && validateKey == "phone") {
                if (realtime == "realtime") {
                    var pattern = /[\D]+/;
                    var num = ElemValue.replace(/\-/g, "");
                    result = pattern.test(num) ? false : true;
                } else {
                    var pattern = /^(0[2-8][0-5]?|01[01346-9])-?([1-9]{1}[0-9]{2,3})-?([0-9]{4})$/;
                    var pattern15xx = /^(1544|1566|1577|1588|1644|1688)-?([0-9]{4})$/;
                    var patternHand = /^(01[01346-9])-?([1-9]{1}[0-9]{2,3})-?([0-9]{4})$/;
                    var num = ElemValue;
                    result = pattern.test(num) || pattern15xx.test(num) || patternHand.test(num) ? true : false;
                }
            } else if (ElemValue != "" && validateKey == "isdate") {
                result = true;

                var iDate = ElemValue.replace(/-/g, "");
                if (iDate.length != 8) {
                    return result = false;
                }

                var oDate = new Date(parseInt(iDate.substr(0, 4), 10), parseInt(iDate.substr(4, 2), 10) - 1, parseInt(iDate.substr(6, 2), 10));
                if (oDate.getFullYear() != parseInt(iDate.substr(0, 4), 10)
                    || oDate.getMonth() != parseInt(iDate.substr(4, 2), 10)-1
                    || oDate.getDate() != parseInt(iDate.substr(6, 2), 10)) {
                    return result = false;
                }else{
                    return result = true;
                }
            } else if (ElemValue != "" && validateKey == "zip") {
                var pattern = /^[0-9]{3}\-[0-9]{3}$/;
                result = pattern.test(ElemValue);
            } else if (ElemValue != "" && validateKey == "money") {
                var value = ElemValue.replace(",").replace(".");
                //실제 money형식
                var pattern = /^\$?[0-9]+(,[0-9]{3})*(\.[0-9]*)?$/;
                //var pattern = /^[1-9]\d*(((,\d{3}){1})?(\.\d{0,2})?)$/;
                result = pattern.test(ElemValue);
            } else if (validateKey == "earlierThan") {
                if(ElemValue == ""){
                    result = true;
                }else{
                    var st_date = ElemValue;
                    var ed_date = axdom("#" + validateValue.id).val().trim();
                    if(ed_date != ""){
                        if (st_date.date().diff(ed_date) < 0) {
                            result = false;
                        }else{
                            result = true;
                        }
                    }else{
                        result = false;
                    }
                }
            } else if (validateKey == "laterThan") {
                if(ElemValue == ""){
                    result = true;
                }else{
                    var ed_date = ElemValue;
                    var st_date = axdom("#" + validateValue.id).val().trim();
                    if(st_date != ""){
                        //trace(st_date, ed_date, st_date.date());
                        if (st_date.date().diff(ed_date) < 0) {
                            result = false;
                        }else{
                            result = true;
                        }
                    }else{
                        result = false;
                    }
                }
            } else {
                if (axdom.isFunction(validateValue)) {
                    result = validateValue.call({
                        Elem: Elem,
                        ElemValue: ElemValue,
                        validateKey: validateKey
                    });
                }
            }
        } catch (e) {
            trace("validateFormatter-catch:662", e);
            result = false;
        }

        return result;
    },
    //-------------------- validate check - formatter - message Set [E] ----------------------
    //-------------------- validate static 지원 함수 Set [S] ---------------------------------
/**
 * @method AXValidator.getErrorMessage
 * @returns {string} - 에러메세지
 * @description
 * 에러메세지를 리턴합니다.
 * @example
 ```
var validateResult = myValidator.validate();
if (!validateResult) {
	var msg = myValidator.getErrorMessage();    //에러메세지를 리턴합니다.
	alert(msg);
	myValidator.getErrorElement().focus();      //에러가 발생된 엘리먼트를 리턴합니다.
	return false;
}else{
	alert( validateResult );
}
 ```
 */
    getErrorMessage: function (errorMessagePattern) {
        if (!this.errElements) {
            return null;
        }
        if (this.errElements.length == 0) {
            return "Err 메세지가 없습니다.";
        }
        var errObj = this.errElements.last();
        var errElement = errObj.element;
        var messageConvert = this.messageConvert.bind(this);
        var message = messageConvert(errElement, errObj.validateKey, errObj.validateVal);

        return message;
    },

/**
 * @method AXValidator.getErrorElement
 * @returns {HTMLElement} - 에러가 발생된 엘리먼트
 * @description
 * 에러가 발생된 엘리먼트를 리텀합니다.
 * @example
 ```
var validateResult = myValidator.validate();
if (!validateResult) {
	var msg = myValidator.getErrorMessage();    //에러메세지를 리턴합니다.
	alert(msg);
	myValidator.getErrorElement().focus();      //에러가 발생된 엘리먼트를 리턴합니다.
	return false;
}else{
	alert( validateResult );
}
 ```
 */
    getErrorElement: function () {
        var cfg = this.config;
        if (!this.errElements) {
            return null;
        }
        if (this.errElements.length == 0) {
            return null;
        }
        var errObj = this.errElements.last();
        var errElement = errObj.element;
        return axdom("#" + errElement.id).length > 0 ? axdom("#" + errElement.id) : axdom(document[cfg.targetFormName][errElement.name]);
    },
    getElement: function (elementObj) {
        var cfg = this.config;
        var element;
        try {
            if (elementObj.id) {
                element = AXgetId(elementObj.id);
            } else {
                element = document[cfg.targetFormName][elementObj.name];
            }
        } catch (e) {
            return false;
        }
        if (element == null) {
            AXUtil.alert((elementObj.id || elementObj.name) + " not found");
            return null;
        } else {
            return element;
        }
    },
    isActiveFormControl: function (element) {
        if (!element) return false;
        if (!(__rinput.test(element.type) || __rselectTextarea.test(element.type)) || element.disabled) return false;
        return true;
    },
    displayFormatter: function (elemValue, validateKey) {
        if (elemValue == "" || elemValue == null) return "";

        var value = elemValue;
        var dataFormat = "";

        if (value != "") {
            if (validateKey == "phone") {
                var pattern = /[^0-9]/g;
                var parintPattern = "";
                value = value.replace(pattern, "");

                //문자열 길이에 따른 값 처리
                if (value.length < 4) return value;
                if (value.length > 3 && value.length < 7) {
                    dataFormat = "$1-$2";
                    parintPattern = /([0-9]{3})([0-9]+)/;
                } else if (value.length == 7) {
                    dataFormat = "$1-$2";
                    parintPattern = /([0-9]{3})([0-9]{4})/;
                } else if (value.length == 9) {
                    dataFormat = "$1-$2-$3";
                    parintPattern = /([0-9]{2})([0-9]{3})([0-9]+)/;
                }
                else if (value.length == 10) {
                    if (value.substring(0, 2) == "02") {
                        dataFormat = "$1-$2-$3";
                        parintPattern = /([0-9]{2})([0-9]{4})([0-9]+)/;
                    } else {
                        dataFormat = "$1-$2-$3";
                        parintPattern = /([0-9]{3})([0-9]{3})([0-9]+)/;
                    }
                } else if (value.length > 10) {
                    dataFormat = "$1-$2-$3";
                    parintPattern = /([0-9]{3})([0-9]{4})([0-9]+)/;
                }
                value = value.replace(parintPattern, dataFormat);

            } else if (validateKey == "isdate") {
                var pattern = /[^0-9]/g;
                var parintPattern = "";

                value = value.replace(pattern, "");
                if (value.length < 4) return value;
                if (value.length > 4 && value.length < 7) {
                    dataFormat = "$1-$2";
                    parintPattern = /([0-9]{4})([0-9]+)/;
                } else if (value.length < 10) {
                    dataFormat = "$1-$2-$3";
                    parintPattern = /([0-9]{4})([0-9]{2})([0-9]+)/;
                }
                value = value.replace(parintPattern, dataFormat);
            }
            else {
                return "";
            }
        }

        return value;
    }
    //-------------------- validate static 지원 함수 Set [E] ---------------------------------
});
/* ---------------------------- */
/* http://www.axisj.com, license : http://www.axisj.com/license */
 
var AXWaterfall = Class.create(AXJ, {
	version: "AXWaterfall v1.1",
	author: "tom@axisj.com",
	logs: [
		"2012-10-11 오후 1:40:26",
		"2013-11-07 오전 9:58:41 - tom : 최소사이즈 버그 픽스"
	],
	initialize: function(AXJ_super) {
		AXJ_super();
		this.CT_className = "AXWaterfall";
		this.I_className = "WaterBox";
		this.I_classNameMobile = "WaterBoxMobile";
		this.config.boxWidth = 224;
		this.config.boxMargin = 10;
		this.config.pageSize = 5;
		this.config.mobileSize = 300;
		this.config.autoResize = true;
		this.Observer = null;
		this.player = null;
		this.played = false;
		this.targetWidth = null;
	},
	init: function(){
		var config = this.config;
		if(Object.isUndefined(config.targetID)){
			trace("need targetID - setConfig({targetID:''})");
			return;
		}
		axdom("#"+config.targetID).addClass(this.CT_className);
		axdom("#"+config.targetID).find("."+config.fallClassName).addClass(this.I_className);
		
		var bodyWidth = (AXUtil.docTD == "Q") ? document.body.clientWidth : document.documentElement.clientWidth;
		this.targetWidth = bodyWidth;
		axdom("#"+config.targetID).css({width:"auto", minWidth:"auto", maxWidth:"auto"});
		
		axdom("#"+config.targetID).find("."+config.fallClassName).hide();
		
		this.waterFall();
		this.bindEvent();
	},
	onresize: function(){
		var config = this.config;
		var bodyWidth = (AXUtil.docTD == "Q") ? document.body.clientWidth : document.documentElement.clientWidth;
		if(this.targetWidth == bodyWidth) return;
		this.targetWidth = bodyWidth;
		
		axdom("#"+config.targetID).css({width:"auto", minWidth:"auto", maxWidth:"auto"});
		if (this.Observer) clearTimeout(this.Observer); //닫기 명령 제거
		var waterFall = this.waterFall.bind(this);
		this.Observer = setTimeout(function() {
			axdom("#"+config.targetID).find("."+config.fallClassName).hide();
		   waterFall();
		}, 100);
	},
	waterFall: function(){
		//if(this.played) return;
		
		var config = this.config;
		var CTw = axdom("#"+config.targetID).innerWidth() - config.boxMargin;
		var CW = config.boxWidth + config.boxMargin + 2;
		this.Clen = parseInt(CTw.div(CW));
		
		var targetWidth = (CW * this.Clen);
		if(targetWidth < CW){			
			axdom("#"+config.targetID).css({width:"auto"});
		}else{
			axdom("#"+config.targetID).css({width:targetWidth+"px"});
		}

		if(this.Clen == 1){
			axdom("#"+config.targetID).find("."+config.fallClassName).addClass(this.I_classNameMobile);	
		}else{
			axdom("#"+config.targetID).find("."+config.fallClassName).removeClass(this.I_classNameMobile);	
		}
		this.grid = [];
		this.colsGrid = [];
		for(var a=0;a<this.Clen;a++) this.colsGrid.push(0);
		this.itemLen = axdom("#"+config.targetID).find("."+config.fallClassName).length;
		
		axdom("#"+config.targetID).find("."+config.fallClassName).each(function(index, O){
			var boxID = config.targetID+"_AX_"+index;
			axdom(O).attr("id", boxID);
			//axdom(O).html(index);
		});
		
		if(this.player) clearTimeout(this.player); //실행 중지
		this.playWaterFall(0);
	},
	
	playWaterFall: function(pageNo){
		var config = this.config;
		var stIndex = pageNo * config.pageSize;
		var edIndex = (pageNo+1) * config.pageSize;
		var l = 0, t = 0, et = 0, c = 0;
		
		for(var a = stIndex;a < edIndex;a++){
			var boxID = config.targetID+"_AX_"+a;
			if(a < this.Clen){
				t = 0;
				l = (a * config.boxWidth) + (config.boxMargin * a);
				c = a;
			}else{
				var minH = null;
				var minC = null;
				axdom.each(this.colsGrid, function(index, O){
					if(minH == null || minH > O){
						minH = O;
						minC = index;	
						c = index;
						l = (index * config.boxWidth) + (config.boxMargin * index);
					}
				});
				t = minH + config.boxMargin;
			}
			if(AXgetId(boxID)){
				var myBox = axdom("#"+boxID);
				myBox.css({left:l, top:t});
				myBox.show();
				var et = t + myBox.outerHeight();
				this.grid.push({id:boxID, left:l, top:t, et:et, col:c});
				this.colsGrid[c] = et;
				//trace({id:boxID, left:l, top:t, et:et, col:c});
			}else{
				break;	
			}
		}
		
		//trace(pageNo+" == "+(this.itemLen / config.pageSize));
		
		if((pageNo+1) > this.itemLen / config.pageSize){
			//play end
			var maxH = null;
			axdom.each(this.colsGrid, function(index, O){
				if(maxH == null || maxH < O){
					maxH = O;
				}
			});
			var itemWidth = this.Clen * (config.boxWidth + config.boxMargin) - config.boxMargin;
			var leftPadding = (axdom("#"+config.targetID).innerWidth() - itemWidth) /2;
			axdom("#"+config.targetID).css({height:maxH+config.boxMargin});
			this.played = false;
		}else{
			var playWaterFall = this.playWaterFall.bind(this);
			this.player = setTimeout(function(){
				playWaterFall((pageNo+1));
			}, 10);
		}
	},
	
	bindEvent: function(){
		var config = this.config;
		if(this.config.autoResize)
			axdom(window).resize(this.onresize.bind(this));
	}
});